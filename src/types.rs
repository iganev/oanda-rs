pub mod error;

use serde::{Deserialize, Serialize};

///DateTime header
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "DateTime header",
///  "type": "string",
///  "enum": [
///    "UNIX",
///    "RFC3339"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AcceptDatetimeFormat {
    #[serde(rename = "UNIX")]
    Unix,
    #[serde(rename = "RFC3339")]
    Rfc3339,
}

impl From<&AcceptDatetimeFormat> for AcceptDatetimeFormat {
    fn from(value: &AcceptDatetimeFormat) -> Self {
        value.clone()
    }
}

impl ToString for AcceptDatetimeFormat {
    fn to_string(&self) -> String {
        match *self {
            Self::Unix => "UNIX".to_string(),
            Self::Rfc3339 => "RFC3339".to_string(),
        }
    }
}

impl std::str::FromStr for AcceptDatetimeFormat {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "UNIX" => Ok(Self::Unix),
            "RFC3339" => Ok(Self::Rfc3339),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for AcceptDatetimeFormat {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for AcceptDatetimeFormat {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for AcceptDatetimeFormat {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The full details of a client's Account. This includes full open Trade,
/// open Position and pending Order representation.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The full details of a client's Account. This includes
/// full open Trade, open Position and pending Order representation.",
///  "type": "object",
///  "properties": {
///    "NAV": {
///      "description": "The net asset value of the Account. Equal to
/// Account balance + unrealizedPL.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "alias": {
///      "description": "Client-assigned alias for the Account. Only
/// provided if the Account has an alias set",
///      "type": "string"
///    },
///    "balance": {
///      "description": "The current balance of the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "commission": {
///      "description": "The total amount of commission paid over the
/// lifetime of the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "createdByUserID": {
///      "description": "ID of the user that created the Account.",
///      "type": "integer"
///    },
///    "createdTime": {
///      "description": "The date/time when the Account was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "currency": {
///      "description": "The home currency of the Account",
///      "type": "string",
///      "format": "A string containing an ISO 4217 currency (http://en.wikipedia.org/wiki/ISO_4217)"
///    },
///    "financing": {
///      "description": "The total amount of financing paid/collected over
/// the lifetime of the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "guaranteedExecutionFees": {
///      "description": "The total amount of fees charged over the lifetime
/// of the Account for the execution of guaranteed Stop Loss Orders.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "guaranteedStopLossOrderMode": {
///      "description": "The current guaranteed Stop Loss Order mode of the
/// Account.",
///      "type": "string",
///      "enum": [
///        "DISABLED",
///        "ALLOWED",
///        "REQUIRED"
///      ]
///    },
///    "hedgingEnabled": {
///      "description": "Flag indicating that the Account has hedging
/// enabled.",
///      "type": "boolean"
///    },
///    "id": {
///      "description": "The Account's identifier",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "lastMarginCallExtensionTime": {
///      "description": "The date/time of the Account's last margin call
/// extension.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "lastOrderFillTimestamp": {
///      "description": "The date/time of the last order that was filled for
/// this account.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "lastTransactionID": {
///      "description": "The ID of the last Transaction created for the
/// Account.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "marginAvailable": {
///      "description": "Margin available for Account currency.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "marginCallEnterTime": {
///      "description": "The date/time when the Account entered a margin
/// call state. Only provided if the Account is in a margin call.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "marginCallExtensionCount": {
///      "description": "The number of times that the Account's current
/// margin call was extended.",
///      "type": "integer"
///    },
///    "marginCallMarginUsed": {
///      "description": "The Account's margin call margin used.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "marginCallPercent": {
///      "description": "The Account's margin call percentage. When this
/// value is 1.0 or above the Account is in a margin call situation.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "marginCloseoutMarginUsed": {
///      "description": "The Account's margin closeout margin used.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "marginCloseoutNAV": {
///      "description": "The Account's margin closeout NAV.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "marginCloseoutPercent": {
///      "description": "The Account's margin closeout percentage. When this value is 1.0 or above the Account is in a margin closeout situation.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "marginCloseoutPositionValue": {
///      "description": "The value of the Account's open positions as used
/// for margin closeout calculations represented in the Account's home
/// currency.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "marginCloseoutUnrealizedPL": {
///      "description": "The Account's margin closeout unrealized PL.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "marginRate": {
///      "description": "Client-provided margin rate override for the
/// Account. The effective margin rate of the Account is the lesser of this
/// value and the OANDA margin rate for the Account's division. This value
/// is only provided if a margin rate override exists for the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "marginUsed": {
///      "description": "Margin currently used for the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "openPositionCount": {
///      "description": "The number of Positions currently open in the
/// Account.",
///      "type": "integer"
///    },
///    "openTradeCount": {
///      "description": "The number of Trades currently open in the
/// Account.",
///      "type": "integer"
///    },
///    "orders": {
///      "description": "The details of the Orders currently pending in the
/// Account.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/Order"
///      }
///    },
///    "pendingOrderCount": {
///      "description": "The number of Orders currently pending in the
/// Account.",
///      "type": "integer"
///    },
///    "pl": {
///      "description": "The total profit/loss realized over the lifetime of
/// the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "positionValue": {
///      "description": "The value of the Account's open positions
/// represented in the Account's home currency.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "positions": {
///      "description": "The details all Account Positions.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/Position"
///      }
///    },
///    "resettablePL": {
///      "description": "The total realized profit/loss for the Account
/// since it was last reset by the client.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "resettablePLTime": {
///      "description": "The date/time that the Account's resettablePL was
/// last reset.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "trades": {
///      "description": "The details of the Trades currently open in the
/// Account.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/TradeSummary"
///      }
///    },
///    "unrealizedPL": {
///      "description": "The total unrealized profit/loss for all Trades
/// currently open in the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "withdrawalLimit": {
///      "description": "The current WithdrawalLimit for the account which
/// will be zero or a positive value indicating how much can be withdrawn
/// from the account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Account {
    ///Client-assigned alias for the Account. Only provided if the Account
    /// has an alias set
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub alias: Option<String>,
    ///The current balance of the Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub balance: Option<String>,
    ///The total amount of commission paid over the lifetime of the
    /// Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commission: Option<String>,
    ///ID of the user that created the Account.
    #[serde(
        rename = "createdByUserID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub created_by_user_id: Option<i64>,
    ///The date/time when the Account was created.
    #[serde(
        rename = "createdTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub created_time: Option<String>,
    ///The home currency of the Account
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub currency: Option<String>,
    ///The total amount of financing paid/collected over the lifetime of
    /// the Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub financing: Option<String>,
    ///The total amount of fees charged over the lifetime of the Account
    /// for the execution of guaranteed Stop Loss Orders.
    #[serde(
        rename = "guaranteedExecutionFees",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub guaranteed_execution_fees: Option<String>,
    ///The current guaranteed Stop Loss Order mode of the Account.
    #[serde(
        rename = "guaranteedStopLossOrderMode",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub guaranteed_stop_loss_order_mode: Option<AccountGuaranteedStopLossOrderMode>,
    ///Flag indicating that the Account has hedging enabled.
    #[serde(
        rename = "hedgingEnabled",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub hedging_enabled: Option<bool>,
    ///The Account's identifier
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The date/time of the Account's last margin call extension.
    #[serde(
        rename = "lastMarginCallExtensionTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_margin_call_extension_time: Option<String>,
    ///The date/time of the last order that was filled for this account.
    #[serde(
        rename = "lastOrderFillTimestamp",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_order_fill_timestamp: Option<String>,
    ///The ID of the last Transaction created for the Account.
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
    ///Margin available for Account currency.
    #[serde(
        rename = "marginAvailable",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_available: Option<String>,
    ///The date/time when the Account entered a margin call state. Only
    /// provided if the Account is in a margin call.
    #[serde(
        rename = "marginCallEnterTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_call_enter_time: Option<String>,
    ///The number of times that the Account's current margin call was
    /// extended.
    #[serde(
        rename = "marginCallExtensionCount",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_call_extension_count: Option<i64>,
    ///The Account's margin call margin used.
    #[serde(
        rename = "marginCallMarginUsed",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_call_margin_used: Option<String>,
    ///The Account's margin call percentage. When this value is 1.0 or
    /// above the Account is in a margin call situation.
    #[serde(
        rename = "marginCallPercent",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_call_percent: Option<String>,
    ///The Account's margin closeout margin used.
    #[serde(
        rename = "marginCloseoutMarginUsed",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_closeout_margin_used: Option<String>,
    ///The Account's margin closeout NAV.
    #[serde(
        rename = "marginCloseoutNAV",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_closeout_nav: Option<String>,
    ///The Account's margin closeout percentage. When this value is 1.0 or
    /// above the Account is in a margin closeout situation.
    #[serde(
        rename = "marginCloseoutPercent",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_closeout_percent: Option<String>,
    ///The value of the Account's open positions as used for margin
    /// closeout calculations represented in the Account's home currency.
    #[serde(
        rename = "marginCloseoutPositionValue",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_closeout_position_value: Option<String>,
    ///The Account's margin closeout unrealized PL.
    #[serde(
        rename = "marginCloseoutUnrealizedPL",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_closeout_unrealized_pl: Option<String>,
    ///Client-provided margin rate override for the Account. The effective
    /// margin rate of the Account is the lesser of this value and the OANDA
    /// margin rate for the Account's division. This value is only provided
    /// if a margin rate override exists for the Account.
    #[serde(
        rename = "marginRate",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_rate: Option<String>,
    ///Margin currently used for the Account.
    #[serde(
        rename = "marginUsed",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_used: Option<String>,
    ///The net asset value of the Account. Equal to Account balance +
    /// unrealizedPL.
    #[serde(rename = "NAV", default, skip_serializing_if = "Option::is_none")]
    pub nav: Option<String>,
    ///The number of Positions currently open in the Account.
    #[serde(
        rename = "openPositionCount",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub open_position_count: Option<i64>,
    ///The number of Trades currently open in the Account.
    #[serde(
        rename = "openTradeCount",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub open_trade_count: Option<i64>,
    ///The details of the Orders currently pending in the Account.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub orders: Vec<Order>,
    ///The number of Orders currently pending in the Account.
    #[serde(
        rename = "pendingOrderCount",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub pending_order_count: Option<i64>,
    ///The total profit/loss realized over the lifetime of the Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pl: Option<String>,
    ///The value of the Account's open positions represented in the
    /// Account's home currency.
    #[serde(
        rename = "positionValue",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub position_value: Option<String>,
    ///The details all Account Positions.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub positions: Vec<Position>,
    ///The total realized profit/loss for the Account since it was last
    /// reset by the client.
    #[serde(
        rename = "resettablePL",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub resettable_pl: Option<String>,
    ///The date/time that the Account's resettablePL was last reset.
    #[serde(
        rename = "resettablePLTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub resettable_pl_time: Option<String>,
    ///The details of the Trades currently open in the Account.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub trades: Vec<TradeSummary>,
    ///The total unrealized profit/loss for all Trades currently open in
    /// the Account.
    #[serde(
        rename = "unrealizedPL",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub unrealized_pl: Option<String>,
    ///The current WithdrawalLimit for the account which will be zero or a
    /// positive value indicating how much can be withdrawn from the
    /// account.
    #[serde(
        rename = "withdrawalLimit",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub withdrawal_limit: Option<String>,
}

impl From<&Account> for Account {
    fn from(value: &Account) -> Self {
        value.clone()
    }
}

impl Account {
    pub fn builder() -> builder::Account {
        Default::default()
    }
}

///An AccountChanges Object is used to represent the changes to an
/// Account's Orders, Trades and Positions since a specified Account
/// TransactionID in the past.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "An AccountChanges Object is used to represent the
/// changes to an Account's Orders, Trades and Positions since a specified
/// Account TransactionID in the past.",
///  "type": "object",
///  "properties": {
///    "ordersCancelled": {
///      "description": "The Orders cancelled.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/Order"
///      }
///    },
///    "ordersCreated": {
///      "description": "The Orders created. These Orders may have been
/// filled, cancelled or triggered in the same period.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/Order"
///      }
///    },
///    "ordersFilled": {
///      "description": "The Orders filled.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/Order"
///      }
///    },
///    "ordersTriggered": {
///      "description": "The Orders triggered.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/Order"
///      }
///    },
///    "positions": {
///      "description": "The Positions changed.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/Position"
///      }
///    },
///    "tradesClosed": {
///      "description": "The Trades closed.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/TradeSummary"
///      }
///    },
///    "tradesOpened": {
///      "description": "The Trades opened.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/TradeSummary"
///      }
///    },
///    "tradesReduced": {
///      "description": "The Trades reduced.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/TradeSummary"
///      }
///    },
///    "transactions": {
///      "description": "The Transactions that have been generated.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/Transaction"
///      }
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AccountChanges {
    ///The Orders cancelled.
    #[serde(
        rename = "ordersCancelled",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub orders_cancelled: Vec<Order>,
    ///The Orders created. These Orders may have been filled, cancelled or
    /// triggered in the same period.
    #[serde(
        rename = "ordersCreated",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub orders_created: Vec<Order>,
    ///The Orders filled.
    #[serde(
        rename = "ordersFilled",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub orders_filled: Vec<Order>,
    ///The Orders triggered.
    #[serde(
        rename = "ordersTriggered",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub orders_triggered: Vec<Order>,
    ///The Positions changed.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub positions: Vec<Position>,
    ///The Trades closed.
    #[serde(
        rename = "tradesClosed",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub trades_closed: Vec<TradeSummary>,
    ///The Trades opened.
    #[serde(
        rename = "tradesOpened",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub trades_opened: Vec<TradeSummary>,
    ///The Trades reduced.
    #[serde(
        rename = "tradesReduced",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub trades_reduced: Vec<TradeSummary>,
    ///The Transactions that have been generated.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub transactions: Vec<Transaction>,
}

impl From<&AccountChanges> for AccountChanges {
    fn from(value: &AccountChanges) -> Self {
        value.clone()
    }
}

impl AccountChanges {
    pub fn builder() -> builder::AccountChanges {
        Default::default()
    }
}

///An AccountState Object is used to represent an Account's current
/// price-dependent state. Price-dependent Account state is dependent on
/// OANDA's current Prices, and includes things like unrealized PL, NAV and
/// Trailing Stop Loss Order state.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "An AccountState Object is used to represent an
/// Account's current price-dependent state. Price-dependent Account state
/// is dependent on OANDA's current Prices, and includes things like
/// unrealized PL, NAV and Trailing Stop Loss Order state.",
///  "type": "object",
///  "properties": {
///    "NAV": {
///      "description": "The net asset value of the Account. Equal to
/// Account balance + unrealizedPL.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "marginAvailable": {
///      "description": "Margin available for Account currency.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "marginCallMarginUsed": {
///      "description": "The Account's margin call margin used.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "marginCallPercent": {
///      "description": "The Account's margin call percentage. When this
/// value is 1.0 or above the Account is in a margin call situation.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "marginCloseoutMarginUsed": {
///      "description": "The Account's margin closeout margin used.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "marginCloseoutNAV": {
///      "description": "The Account's margin closeout NAV.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "marginCloseoutPercent": {
///      "description": "The Account's margin closeout percentage. When this value is 1.0 or above the Account is in a margin closeout situation.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "marginCloseoutPositionValue": {
///      "description": "The value of the Account's open positions as used
/// for margin closeout calculations represented in the Account's home
/// currency.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "marginCloseoutUnrealizedPL": {
///      "description": "The Account's margin closeout unrealized PL.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "marginUsed": {
///      "description": "Margin currently used for the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "orders": {
///      "description": "The price-dependent state of each pending Order in
/// the Account.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/DynamicOrderState"
///      }
///    },
///    "positionValue": {
///      "description": "The value of the Account's open positions
/// represented in the Account's home currency.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "positions": {
///      "description": "The price-dependent state for each open Position in
/// the Account.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/CalculatedPositionState"
///      }
///    },
///    "trades": {
///      "description": "The price-dependent state for each open Trade in
/// the Account.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/CalculatedTradeState"
///      }
///    },
///    "unrealizedPL": {
///      "description": "The total unrealized profit/loss for all Trades
/// currently open in the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "withdrawalLimit": {
///      "description": "The current WithdrawalLimit for the account which
/// will be zero or a positive value indicating how much can be withdrawn
/// from the account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AccountChangesState {
    ///Margin available for Account currency.
    #[serde(
        rename = "marginAvailable",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_available: Option<String>,
    ///The Account's margin call margin used.
    #[serde(
        rename = "marginCallMarginUsed",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_call_margin_used: Option<String>,
    ///The Account's margin call percentage. When this value is 1.0 or
    /// above the Account is in a margin call situation.
    #[serde(
        rename = "marginCallPercent",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_call_percent: Option<String>,
    ///The Account's margin closeout margin used.
    #[serde(
        rename = "marginCloseoutMarginUsed",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_closeout_margin_used: Option<String>,
    ///The Account's margin closeout NAV.
    #[serde(
        rename = "marginCloseoutNAV",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_closeout_nav: Option<String>,
    ///The Account's margin closeout percentage. When this value is 1.0 or
    /// above the Account is in a margin closeout situation.
    #[serde(
        rename = "marginCloseoutPercent",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_closeout_percent: Option<String>,
    ///The value of the Account's open positions as used for margin
    /// closeout calculations represented in the Account's home currency.
    #[serde(
        rename = "marginCloseoutPositionValue",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_closeout_position_value: Option<String>,
    ///The Account's margin closeout unrealized PL.
    #[serde(
        rename = "marginCloseoutUnrealizedPL",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_closeout_unrealized_pl: Option<String>,
    ///Margin currently used for the Account.
    #[serde(
        rename = "marginUsed",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_used: Option<String>,
    ///The net asset value of the Account. Equal to Account balance +
    /// unrealizedPL.
    #[serde(rename = "NAV", default, skip_serializing_if = "Option::is_none")]
    pub nav: Option<String>,
    ///The price-dependent state of each pending Order in the Account.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub orders: Vec<DynamicOrderState>,
    ///The value of the Account's open positions represented in the
    /// Account's home currency.
    #[serde(
        rename = "positionValue",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub position_value: Option<String>,
    ///The price-dependent state for each open Position in the Account.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub positions: Vec<CalculatedPositionState>,
    ///The price-dependent state for each open Trade in the Account.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub trades: Vec<CalculatedTradeState>,
    ///The total unrealized profit/loss for all Trades currently open in
    /// the Account.
    #[serde(
        rename = "unrealizedPL",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub unrealized_pl: Option<String>,
    ///The current WithdrawalLimit for the account which will be zero or a
    /// positive value indicating how much can be withdrawn from the
    /// account.
    #[serde(
        rename = "withdrawalLimit",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub withdrawal_limit: Option<String>,
}

impl From<&AccountChangesState> for AccountChangesState {
    fn from(value: &AccountChangesState) -> Self {
        value.clone()
    }
}

impl AccountChangesState {
    pub fn builder() -> builder::AccountChangesState {
        Default::default()
    }
}

///The financing mode of an Account
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The financing mode of an Account",
///  "type": "string",
///  "enum": [
///    "NO_FINANCING",
///    "SECOND_BY_SECOND",
///    "DAILY"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AccountFinancingMode {
    #[serde(rename = "NO_FINANCING")]
    NoFinancing,
    #[serde(rename = "SECOND_BY_SECOND")]
    SecondBySecond,
    #[serde(rename = "DAILY")]
    Daily,
}

impl From<&AccountFinancingMode> for AccountFinancingMode {
    fn from(value: &AccountFinancingMode) -> Self {
        value.clone()
    }
}

impl ToString for AccountFinancingMode {
    fn to_string(&self) -> String {
        match *self {
            Self::NoFinancing => "NO_FINANCING".to_string(),
            Self::SecondBySecond => "SECOND_BY_SECOND".to_string(),
            Self::Daily => "DAILY".to_string(),
        }
    }
}

impl std::str::FromStr for AccountFinancingMode {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "NO_FINANCING" => Ok(Self::NoFinancing),
            "SECOND_BY_SECOND" => Ok(Self::SecondBySecond),
            "DAILY" => Ok(Self::Daily),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for AccountFinancingMode {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for AccountFinancingMode {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for AccountFinancingMode {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The current guaranteed Stop Loss Order mode of the Account.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The current guaranteed Stop Loss Order mode of the
/// Account.",
///  "type": "string",
///  "enum": [
///    "DISABLED",
///    "ALLOWED",
///    "REQUIRED"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AccountGuaranteedStopLossOrderMode {
    #[serde(rename = "DISABLED")]
    Disabled,
    #[serde(rename = "ALLOWED")]
    Allowed,
    #[serde(rename = "REQUIRED")]
    Required,
}

impl From<&AccountGuaranteedStopLossOrderMode> for AccountGuaranteedStopLossOrderMode {
    fn from(value: &AccountGuaranteedStopLossOrderMode) -> Self {
        value.clone()
    }
}

impl ToString for AccountGuaranteedStopLossOrderMode {
    fn to_string(&self) -> String {
        match *self {
            Self::Disabled => "DISABLED".to_string(),
            Self::Allowed => "ALLOWED".to_string(),
            Self::Required => "REQUIRED".to_string(),
        }
    }
}

impl std::str::FromStr for AccountGuaranteedStopLossOrderMode {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DISABLED" => Ok(Self::Disabled),
            "ALLOWED" => Ok(Self::Allowed),
            "REQUIRED" => Ok(Self::Required),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for AccountGuaranteedStopLossOrderMode {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for AccountGuaranteedStopLossOrderMode {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for AccountGuaranteedStopLossOrderMode {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The string representation of an Account Identifier.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The string representation of an Account Identifier.",
///  "type": "string",
///  "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct AccountId(pub String);
impl std::ops::Deref for AccountId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl From<AccountId> for String {
    fn from(value: AccountId) -> Self {
        value.0
    }
}

impl From<&AccountId> for AccountId {
    fn from(value: &AccountId) -> Self {
        value.clone()
    }
}

impl From<String> for AccountId {
    fn from(value: String) -> Self {
        Self(value)
    }
}

impl std::str::FromStr for AccountId {
    type Err = std::convert::Infallible;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}

impl ToString for AccountId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

///Properties related to an Account.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Properties related to an Account.",
///  "type": "object",
///  "properties": {
///    "id": {
///      "description": "The Account's identifier",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "mt4AccountID": {
///      "description": "The Account's associated MT4 Account ID. This field
/// will not be present if the Account is not an MT4 account.",
///      "type": "integer"
///    },
///    "tags": {
///      "description": "The Account's tags",
///      "type": "array",
///      "items": {
///        "type": "string"
///      }
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AccountProperties {
    ///The Account's identifier
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The Account's associated MT4 Account ID. This field will not be
    /// present if the Account is not an MT4 account.
    #[serde(
        rename = "mt4AccountID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub mt4_account_id: Option<i64>,
    ///The Account's tags
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub tags: Vec<String>,
}

impl From<&AccountProperties> for AccountProperties {
    fn from(value: &AccountProperties) -> Self {
        value.clone()
    }
}

impl AccountProperties {
    pub fn builder() -> builder::AccountProperties {
        Default::default()
    }
}

///A summary representation of a client's Account. The AccountSummary does
/// not provide to full specification of pending Orders, open Trades and
/// Positions.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A summary representation of a client's Account. The
/// AccountSummary does not provide to full specification of pending Orders,
/// open Trades and Positions.",
///  "type": "object",
///  "properties": {
///    "NAV": {
///      "description": "The net asset value of the Account. Equal to
/// Account balance + unrealizedPL.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "alias": {
///      "description": "Client-assigned alias for the Account. Only
/// provided if the Account has an alias set",
///      "type": "string"
///    },
///    "balance": {
///      "description": "The current balance of the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "commission": {
///      "description": "The total amount of commission paid over the
/// lifetime of the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "createdByUserID": {
///      "description": "ID of the user that created the Account.",
///      "type": "integer"
///    },
///    "createdTime": {
///      "description": "The date/time when the Account was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "currency": {
///      "description": "The home currency of the Account",
///      "type": "string",
///      "format": "A string containing an ISO 4217 currency (http://en.wikipedia.org/wiki/ISO_4217)"
///    },
///    "financing": {
///      "description": "The total amount of financing paid/collected over
/// the lifetime of the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "guaranteedExecutionFees": {
///      "description": "The total amount of fees charged over the lifetime
/// of the Account for the execution of guaranteed Stop Loss Orders.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "guaranteedStopLossOrderMode": {
///      "description": "The current guaranteed Stop Loss Order mode of the
/// Account.",
///      "type": "string",
///      "enum": [
///        "DISABLED",
///        "ALLOWED",
///        "REQUIRED"
///      ]
///    },
///    "hedgingEnabled": {
///      "description": "Flag indicating that the Account has hedging
/// enabled.",
///      "type": "boolean"
///    },
///    "id": {
///      "description": "The Account's identifier",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "lastMarginCallExtensionTime": {
///      "description": "The date/time of the Account's last margin call
/// extension.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "lastOrderFillTimestamp": {
///      "description": "The date/time of the last order that was filled for
/// this account.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "lastTransactionID": {
///      "description": "The ID of the last Transaction created for the
/// Account.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "marginAvailable": {
///      "description": "Margin available for Account currency.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "marginCallEnterTime": {
///      "description": "The date/time when the Account entered a margin
/// call state. Only provided if the Account is in a margin call.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "marginCallExtensionCount": {
///      "description": "The number of times that the Account's current
/// margin call was extended.",
///      "type": "integer"
///    },
///    "marginCallMarginUsed": {
///      "description": "The Account's margin call margin used.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "marginCallPercent": {
///      "description": "The Account's margin call percentage. When this
/// value is 1.0 or above the Account is in a margin call situation.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "marginCloseoutMarginUsed": {
///      "description": "The Account's margin closeout margin used.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "marginCloseoutNAV": {
///      "description": "The Account's margin closeout NAV.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "marginCloseoutPercent": {
///      "description": "The Account's margin closeout percentage. When this value is 1.0 or above the Account is in a margin closeout situation.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "marginCloseoutPositionValue": {
///      "description": "The value of the Account's open positions as used
/// for margin closeout calculations represented in the Account's home
/// currency.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "marginCloseoutUnrealizedPL": {
///      "description": "The Account's margin closeout unrealized PL.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "marginRate": {
///      "description": "Client-provided margin rate override for the
/// Account. The effective margin rate of the Account is the lesser of this
/// value and the OANDA margin rate for the Account's division. This value
/// is only provided if a margin rate override exists for the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "marginUsed": {
///      "description": "Margin currently used for the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "openPositionCount": {
///      "description": "The number of Positions currently open in the
/// Account.",
///      "type": "integer"
///    },
///    "openTradeCount": {
///      "description": "The number of Trades currently open in the
/// Account.",
///      "type": "integer"
///    },
///    "pendingOrderCount": {
///      "description": "The number of Orders currently pending in the
/// Account.",
///      "type": "integer"
///    },
///    "pl": {
///      "description": "The total profit/loss realized over the lifetime of
/// the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "positionValue": {
///      "description": "The value of the Account's open positions
/// represented in the Account's home currency.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "resettablePL": {
///      "description": "The total realized profit/loss for the Account
/// since it was last reset by the client.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "resettablePLTime": {
///      "description": "The date/time that the Account's resettablePL was
/// last reset.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "unrealizedPL": {
///      "description": "The total unrealized profit/loss for all Trades
/// currently open in the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "withdrawalLimit": {
///      "description": "The current WithdrawalLimit for the account which
/// will be zero or a positive value indicating how much can be withdrawn
/// from the account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AccountSummary {
    ///Client-assigned alias for the Account. Only provided if the Account
    /// has an alias set
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub alias: Option<String>,
    ///The current balance of the Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub balance: Option<String>,
    ///The total amount of commission paid over the lifetime of the
    /// Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commission: Option<String>,
    ///ID of the user that created the Account.
    #[serde(
        rename = "createdByUserID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub created_by_user_id: Option<i64>,
    ///The date/time when the Account was created.
    #[serde(
        rename = "createdTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub created_time: Option<String>,
    ///The home currency of the Account
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub currency: Option<String>,
    ///The total amount of financing paid/collected over the lifetime of
    /// the Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub financing: Option<String>,
    ///The total amount of fees charged over the lifetime of the Account
    /// for the execution of guaranteed Stop Loss Orders.
    #[serde(
        rename = "guaranteedExecutionFees",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub guaranteed_execution_fees: Option<String>,
    ///The current guaranteed Stop Loss Order mode of the Account.
    #[serde(
        rename = "guaranteedStopLossOrderMode",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub guaranteed_stop_loss_order_mode: Option<AccountSummaryGuaranteedStopLossOrderMode>,
    ///Flag indicating that the Account has hedging enabled.
    #[serde(
        rename = "hedgingEnabled",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub hedging_enabled: Option<bool>,
    ///The Account's identifier
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The date/time of the Account's last margin call extension.
    #[serde(
        rename = "lastMarginCallExtensionTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_margin_call_extension_time: Option<String>,
    ///The date/time of the last order that was filled for this account.
    #[serde(
        rename = "lastOrderFillTimestamp",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_order_fill_timestamp: Option<String>,
    ///The ID of the last Transaction created for the Account.
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
    ///Margin available for Account currency.
    #[serde(
        rename = "marginAvailable",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_available: Option<String>,
    ///The date/time when the Account entered a margin call state. Only
    /// provided if the Account is in a margin call.
    #[serde(
        rename = "marginCallEnterTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_call_enter_time: Option<String>,
    ///The number of times that the Account's current margin call was
    /// extended.
    #[serde(
        rename = "marginCallExtensionCount",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_call_extension_count: Option<i64>,
    ///The Account's margin call margin used.
    #[serde(
        rename = "marginCallMarginUsed",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_call_margin_used: Option<String>,
    ///The Account's margin call percentage. When this value is 1.0 or
    /// above the Account is in a margin call situation.
    #[serde(
        rename = "marginCallPercent",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_call_percent: Option<String>,
    ///The Account's margin closeout margin used.
    #[serde(
        rename = "marginCloseoutMarginUsed",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_closeout_margin_used: Option<String>,
    ///The Account's margin closeout NAV.
    #[serde(
        rename = "marginCloseoutNAV",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_closeout_nav: Option<String>,
    ///The Account's margin closeout percentage. When this value is 1.0 or
    /// above the Account is in a margin closeout situation.
    #[serde(
        rename = "marginCloseoutPercent",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_closeout_percent: Option<String>,
    ///The value of the Account's open positions as used for margin
    /// closeout calculations represented in the Account's home currency.
    #[serde(
        rename = "marginCloseoutPositionValue",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_closeout_position_value: Option<String>,
    ///The Account's margin closeout unrealized PL.
    #[serde(
        rename = "marginCloseoutUnrealizedPL",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_closeout_unrealized_pl: Option<String>,
    ///Client-provided margin rate override for the Account. The effective
    /// margin rate of the Account is the lesser of this value and the OANDA
    /// margin rate for the Account's division. This value is only provided
    /// if a margin rate override exists for the Account.
    #[serde(
        rename = "marginRate",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_rate: Option<String>,
    ///Margin currently used for the Account.
    #[serde(
        rename = "marginUsed",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_used: Option<String>,
    ///The net asset value of the Account. Equal to Account balance +
    /// unrealizedPL.
    #[serde(rename = "NAV", default, skip_serializing_if = "Option::is_none")]
    pub nav: Option<String>,
    ///The number of Positions currently open in the Account.
    #[serde(
        rename = "openPositionCount",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub open_position_count: Option<i64>,
    ///The number of Trades currently open in the Account.
    #[serde(
        rename = "openTradeCount",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub open_trade_count: Option<i64>,
    ///The number of Orders currently pending in the Account.
    #[serde(
        rename = "pendingOrderCount",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub pending_order_count: Option<i64>,
    ///The total profit/loss realized over the lifetime of the Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pl: Option<String>,
    ///The value of the Account's open positions represented in the
    /// Account's home currency.
    #[serde(
        rename = "positionValue",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub position_value: Option<String>,
    ///The total realized profit/loss for the Account since it was last
    /// reset by the client.
    #[serde(
        rename = "resettablePL",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub resettable_pl: Option<String>,
    ///The date/time that the Account's resettablePL was last reset.
    #[serde(
        rename = "resettablePLTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub resettable_pl_time: Option<String>,
    ///The total unrealized profit/loss for all Trades currently open in
    /// the Account.
    #[serde(
        rename = "unrealizedPL",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub unrealized_pl: Option<String>,
    ///The current WithdrawalLimit for the account which will be zero or a
    /// positive value indicating how much can be withdrawn from the
    /// account.
    #[serde(
        rename = "withdrawalLimit",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub withdrawal_limit: Option<String>,
}

impl From<&AccountSummary> for AccountSummary {
    fn from(value: &AccountSummary) -> Self {
        value.clone()
    }
}

impl AccountSummary {
    pub fn builder() -> builder::AccountSummary {
        Default::default()
    }
}

///The current guaranteed Stop Loss Order mode of the Account.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The current guaranteed Stop Loss Order mode of the
/// Account.",
///  "type": "string",
///  "enum": [
///    "DISABLED",
///    "ALLOWED",
///    "REQUIRED"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AccountSummaryGuaranteedStopLossOrderMode {
    #[serde(rename = "DISABLED")]
    Disabled,
    #[serde(rename = "ALLOWED")]
    Allowed,
    #[serde(rename = "REQUIRED")]
    Required,
}

impl From<&AccountSummaryGuaranteedStopLossOrderMode>
    for AccountSummaryGuaranteedStopLossOrderMode
{
    fn from(value: &AccountSummaryGuaranteedStopLossOrderMode) -> Self {
        value.clone()
    }
}

impl ToString for AccountSummaryGuaranteedStopLossOrderMode {
    fn to_string(&self) -> String {
        match *self {
            Self::Disabled => "DISABLED".to_string(),
            Self::Allowed => "ALLOWED".to_string(),
            Self::Required => "REQUIRED".to_string(),
        }
    }
}

impl std::str::FromStr for AccountSummaryGuaranteedStopLossOrderMode {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DISABLED" => Ok(Self::Disabled),
            "ALLOWED" => Ok(Self::Allowed),
            "REQUIRED" => Ok(Self::Required),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for AccountSummaryGuaranteedStopLossOrderMode {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for AccountSummaryGuaranteedStopLossOrderMode {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for AccountSummaryGuaranteedStopLossOrderMode {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The string representation of a quantity of an Account's home currency.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The string representation of a quantity of an Account's
/// home currency.",
///  "type": "string",
///  "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct AccountUnits(pub String);
impl std::ops::Deref for AccountUnits {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl From<AccountUnits> for String {
    fn from(value: AccountUnits) -> Self {
        value.0
    }
}

impl From<&AccountUnits> for AccountUnits {
    fn from(value: &AccountUnits) -> Self {
        value.clone()
    }
}

impl From<String> for AccountUnits {
    fn from(value: String) -> Self {
        Self(value)
    }
}

impl std::str::FromStr for AccountUnits {
    type Err = std::convert::Infallible;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}

impl ToString for AccountUnits {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

///The dynamically calculated state of a client's Account.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The dynamically calculated state of a client's
/// Account.",
///  "type": "object",
///  "properties": {
///    "NAV": {
///      "description": "The net asset value of the Account. Equal to
/// Account balance + unrealizedPL.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "marginAvailable": {
///      "description": "Margin available for Account currency.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "marginCallMarginUsed": {
///      "description": "The Account's margin call margin used.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "marginCallPercent": {
///      "description": "The Account's margin call percentage. When this
/// value is 1.0 or above the Account is in a margin call situation.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "marginCloseoutMarginUsed": {
///      "description": "The Account's margin closeout margin used.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "marginCloseoutNAV": {
///      "description": "The Account's margin closeout NAV.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "marginCloseoutPercent": {
///      "description": "The Account's margin closeout percentage. When this value is 1.0 or above the Account is in a margin closeout situation.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "marginCloseoutPositionValue": {
///      "description": "The value of the Account's open positions as used
/// for margin closeout calculations represented in the Account's home
/// currency.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "marginCloseoutUnrealizedPL": {
///      "description": "The Account's margin closeout unrealized PL.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "marginUsed": {
///      "description": "Margin currently used for the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "positionValue": {
///      "description": "The value of the Account's open positions
/// represented in the Account's home currency.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "unrealizedPL": {
///      "description": "The total unrealized profit/loss for all Trades
/// currently open in the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "withdrawalLimit": {
///      "description": "The current WithdrawalLimit for the account which
/// will be zero or a positive value indicating how much can be withdrawn
/// from the account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct CalculatedAccountState {
    ///Margin available for Account currency.
    #[serde(
        rename = "marginAvailable",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_available: Option<String>,
    ///The Account's margin call margin used.
    #[serde(
        rename = "marginCallMarginUsed",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_call_margin_used: Option<String>,
    ///The Account's margin call percentage. When this value is 1.0 or
    /// above the Account is in a margin call situation.
    #[serde(
        rename = "marginCallPercent",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_call_percent: Option<String>,
    ///The Account's margin closeout margin used.
    #[serde(
        rename = "marginCloseoutMarginUsed",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_closeout_margin_used: Option<String>,
    ///The Account's margin closeout NAV.
    #[serde(
        rename = "marginCloseoutNAV",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_closeout_nav: Option<String>,
    ///The Account's margin closeout percentage. When this value is 1.0 or
    /// above the Account is in a margin closeout situation.
    #[serde(
        rename = "marginCloseoutPercent",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_closeout_percent: Option<String>,
    ///The value of the Account's open positions as used for margin
    /// closeout calculations represented in the Account's home currency.
    #[serde(
        rename = "marginCloseoutPositionValue",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_closeout_position_value: Option<String>,
    ///The Account's margin closeout unrealized PL.
    #[serde(
        rename = "marginCloseoutUnrealizedPL",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_closeout_unrealized_pl: Option<String>,
    ///Margin currently used for the Account.
    #[serde(
        rename = "marginUsed",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_used: Option<String>,
    ///The net asset value of the Account. Equal to Account balance +
    /// unrealizedPL.
    #[serde(rename = "NAV", default, skip_serializing_if = "Option::is_none")]
    pub nav: Option<String>,
    ///The value of the Account's open positions represented in the
    /// Account's home currency.
    #[serde(
        rename = "positionValue",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub position_value: Option<String>,
    ///The total unrealized profit/loss for all Trades currently open in
    /// the Account.
    #[serde(
        rename = "unrealizedPL",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub unrealized_pl: Option<String>,
    ///The current WithdrawalLimit for the account which will be zero or a
    /// positive value indicating how much can be withdrawn from the
    /// account.
    #[serde(
        rename = "withdrawalLimit",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub withdrawal_limit: Option<String>,
}

impl From<&CalculatedAccountState> for CalculatedAccountState {
    fn from(value: &CalculatedAccountState) -> Self {
        value.clone()
    }
}

impl CalculatedAccountState {
    pub fn builder() -> builder::CalculatedAccountState {
        Default::default()
    }
}

///The dynamic (calculated) state of a Position
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The dynamic (calculated) state of a Position",
///  "type": "object",
///  "properties": {
///    "instrument": {
///      "description": "The Position's Instrument.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "longUnrealizedPL": {
///      "description": "The unrealized profit/loss of the Position's long
/// open Trades",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "marginUsed": {
///      "description": "Margin currently used by the Position.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "netUnrealizedPL": {
///      "description": "The Position's net unrealized profit/loss",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "shortUnrealizedPL": {
///      "description": "The unrealized profit/loss of the Position's short
/// open Trades",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct CalculatedPositionState {
    ///The Position's Instrument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    ///The unrealized profit/loss of the Position's long open Trades
    #[serde(
        rename = "longUnrealizedPL",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub long_unrealized_pl: Option<String>,
    ///Margin currently used by the Position.
    #[serde(
        rename = "marginUsed",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_used: Option<String>,
    ///The Position's net unrealized profit/loss
    #[serde(
        rename = "netUnrealizedPL",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub net_unrealized_pl: Option<String>,
    ///The unrealized profit/loss of the Position's short open Trades
    #[serde(
        rename = "shortUnrealizedPL",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub short_unrealized_pl: Option<String>,
}

impl From<&CalculatedPositionState> for CalculatedPositionState {
    fn from(value: &CalculatedPositionState) -> Self {
        value.clone()
    }
}

impl CalculatedPositionState {
    pub fn builder() -> builder::CalculatedPositionState {
        Default::default()
    }
}

///The dynamic (calculated) state of an open Trade
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The dynamic (calculated) state of an open Trade",
///  "type": "object",
///  "properties": {
///    "id": {
///      "description": "The Trade's ID.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "marginUsed": {
///      "description": "Margin currently used by the Trade.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "unrealizedPL": {
///      "description": "The Trade's unrealized profit/loss.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct CalculatedTradeState {
    ///The Trade's ID.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///Margin currently used by the Trade.
    #[serde(
        rename = "marginUsed",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_used: Option<String>,
    ///The Trade's unrealized profit/loss.
    #[serde(
        rename = "unrealizedPL",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub unrealized_pl: Option<String>,
}

impl From<&CalculatedTradeState> for CalculatedTradeState {
    fn from(value: &CalculatedTradeState) -> Self {
        value.clone()
    }
}

impl CalculatedTradeState {
    pub fn builder() -> builder::CalculatedTradeState {
        Default::default()
    }
}

///CancelOrderResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "lastTransactionID": {
///      "description": "The ID of the most recent Transaction created for
/// the Account",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "orderCancelTransaction": {
///      "$ref": "#/components/schemas/OrderCancelTransaction"
///    },
///    "relatedTransactionIDs": {
///      "description": "The IDs of all Transactions that were created while
/// satisfying the request.",
///      "type": "array",
///      "items": {
///        "description": "The unique Transaction identifier within each
/// Account.",
///        "type": "string",
///        "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///      }
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct CancelOrderResponse {
    ///The ID of the most recent Transaction created for the Account
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
    #[serde(
        rename = "orderCancelTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub order_cancel_transaction: Option<OrderCancelTransaction>,
    ///The IDs of all Transactions that were created while satisfying the
    /// request.
    #[serde(
        rename = "relatedTransactionIDs",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub related_transaction_i_ds: Vec<String>,
}

impl From<&CancelOrderResponse> for CancelOrderResponse {
    fn from(value: &CancelOrderResponse) -> Self {
        value.clone()
    }
}

impl CancelOrderResponse {
    pub fn builder() -> builder::CancelOrderResponse {
        Default::default()
    }
}

///The type of the Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The type of the Order.",
///  "type": "string",
///  "enum": [
///    "LIMIT",
///    "STOP",
///    "MARKET_IF_TOUCHED",
///    "TAKE_PROFIT",
///    "STOP_LOSS",
///    "TRAILING_STOP_LOSS"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CancellableOrderType {
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "STOP")]
    Stop,
    #[serde(rename = "MARKET_IF_TOUCHED")]
    MarketIfTouched,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "STOP_LOSS")]
    StopLoss,
    #[serde(rename = "TRAILING_STOP_LOSS")]
    TrailingStopLoss,
}

impl From<&CancellableOrderType> for CancellableOrderType {
    fn from(value: &CancellableOrderType) -> Self {
        value.clone()
    }
}

impl ToString for CancellableOrderType {
    fn to_string(&self) -> String {
        match *self {
            Self::Limit => "LIMIT".to_string(),
            Self::Stop => "STOP".to_string(),
            Self::MarketIfTouched => "MARKET_IF_TOUCHED".to_string(),
            Self::TakeProfit => "TAKE_PROFIT".to_string(),
            Self::StopLoss => "STOP_LOSS".to_string(),
            Self::TrailingStopLoss => "TRAILING_STOP_LOSS".to_string(),
        }
    }
}

impl std::str::FromStr for CancellableOrderType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "LIMIT" => Ok(Self::Limit),
            "STOP" => Ok(Self::Stop),
            "MARKET_IF_TOUCHED" => Ok(Self::MarketIfTouched),
            "TAKE_PROFIT" => Ok(Self::TakeProfit),
            "STOP_LOSS" => Ok(Self::StopLoss),
            "TRAILING_STOP_LOSS" => Ok(Self::TrailingStopLoss),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for CancellableOrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for CancellableOrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for CancellableOrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Candlestick representation
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Candlestick representation",
///  "type": "object",
///  "properties": {
///    "ask": {
///      "$ref": "#/components/schemas/CandlestickData"
///    },
///    "bid": {
///      "$ref": "#/components/schemas/CandlestickData"
///    },
///    "complete": {
///      "description": "A flag indicating if the candlestick is complete. A complete candlestick is one whose ending time is not in the future.",
///      "type": "boolean"
///    },
///    "mid": {
///      "$ref": "#/components/schemas/CandlestickData"
///    },
///    "time": {
///      "description": "The start time of the candlestick",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "volume": {
///      "description": "The number of prices created during the time-range
/// represented by the candlestick.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Candlestick {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ask: Option<CandlestickData>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bid: Option<CandlestickData>,
    ///A flag indicating if the candlestick is complete. A complete
    /// candlestick is one whose ending time is not in the future.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub complete: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mid: Option<CandlestickData>,
    ///The start time of the candlestick
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The number of prices created during the time-range represented by
    /// the candlestick.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub volume: Option<i64>,
}

impl From<&Candlestick> for Candlestick {
    fn from(value: &Candlestick) -> Self {
        value.clone()
    }
}

impl Candlestick {
    pub fn builder() -> builder::Candlestick {
        Default::default()
    }
}

///The price data (open, high, low, close) for the Candlestick
/// representation.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The price data (open, high, low, close) for the
/// Candlestick representation.",
///  "type": "object",
///  "properties": {
///    "c": {
///      "description": "The last (closing) price in the time-range
/// represented by the candlestick.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "h": {
///      "description": "The highest price in the time-range represented by
/// the candlestick.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "l": {
///      "description": "The lowest price in the time-range represented by
/// the candlestick.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "o": {
///      "description": "The first (open) price in the time-range
/// represented by the candlestick.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct CandlestickData {
    ///The last (closing) price in the time-range represented by the
    /// candlestick.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub c: Option<String>,
    ///The highest price in the time-range represented by the candlestick.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub h: Option<String>,
    ///The lowest price in the time-range represented by the candlestick.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub l: Option<String>,
    ///The first (open) price in the time-range represented by the
    /// candlestick.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub o: Option<String>,
}

impl From<&CandlestickData> for CandlestickData {
    fn from(value: &CandlestickData) -> Self {
        value.clone()
    }
}

impl CandlestickData {
    pub fn builder() -> builder::CandlestickData {
        Default::default()
    }
}

///The granularity of a candlestick
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The granularity of a candlestick",
///  "type": "string",
///  "enum": [
///    "S5",
///    "S10",
///    "S15",
///    "S30",
///    "M1",
///    "M2",
///    "M4",
///    "M5",
///    "M10",
///    "M15",
///    "M30",
///    "H1",
///    "H2",
///    "H3",
///    "H4",
///    "H6",
///    "H8",
///    "H12",
///    "D",
///    "W",
///    "M"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CandlestickGranularity {
    S5,
    S10,
    S15,
    S30,
    M1,
    M2,
    M4,
    M5,
    M10,
    M15,
    M30,
    H1,
    H2,
    H3,
    H4,
    H6,
    H8,
    H12,
    D,
    W,
    M,
}

impl From<&CandlestickGranularity> for CandlestickGranularity {
    fn from(value: &CandlestickGranularity) -> Self {
        value.clone()
    }
}

impl ToString for CandlestickGranularity {
    fn to_string(&self) -> String {
        match *self {
            Self::S5 => "S5".to_string(),
            Self::S10 => "S10".to_string(),
            Self::S15 => "S15".to_string(),
            Self::S30 => "S30".to_string(),
            Self::M1 => "M1".to_string(),
            Self::M2 => "M2".to_string(),
            Self::M4 => "M4".to_string(),
            Self::M5 => "M5".to_string(),
            Self::M10 => "M10".to_string(),
            Self::M15 => "M15".to_string(),
            Self::M30 => "M30".to_string(),
            Self::H1 => "H1".to_string(),
            Self::H2 => "H2".to_string(),
            Self::H3 => "H3".to_string(),
            Self::H4 => "H4".to_string(),
            Self::H6 => "H6".to_string(),
            Self::H8 => "H8".to_string(),
            Self::H12 => "H12".to_string(),
            Self::D => "D".to_string(),
            Self::W => "W".to_string(),
            Self::M => "M".to_string(),
        }
    }
}

impl std::str::FromStr for CandlestickGranularity {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "S5" => Ok(Self::S5),
            "S10" => Ok(Self::S10),
            "S15" => Ok(Self::S15),
            "S30" => Ok(Self::S30),
            "M1" => Ok(Self::M1),
            "M2" => Ok(Self::M2),
            "M4" => Ok(Self::M4),
            "M5" => Ok(Self::M5),
            "M10" => Ok(Self::M10),
            "M15" => Ok(Self::M15),
            "M30" => Ok(Self::M30),
            "H1" => Ok(Self::H1),
            "H2" => Ok(Self::H2),
            "H3" => Ok(Self::H3),
            "H4" => Ok(Self::H4),
            "H6" => Ok(Self::H6),
            "H8" => Ok(Self::H8),
            "H12" => Ok(Self::H12),
            "D" => Ok(Self::D),
            "W" => Ok(Self::W),
            "M" => Ok(Self::M),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for CandlestickGranularity {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for CandlestickGranularity {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for CandlestickGranularity {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A client-provided comment that can contain any data and may be assigned
/// to their Orders or Trades. Comments are typically used to provide extra
/// context or meaning to an Order or Trade.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A client-provided comment that can contain any data and
/// may be assigned to their Orders or Trades. Comments are typically used
/// to provide extra context or meaning to an Order or Trade.",
///  "type": "string"
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct ClientComment(pub String);
impl std::ops::Deref for ClientComment {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl From<ClientComment> for String {
    fn from(value: ClientComment) -> Self {
        value.0
    }
}

impl From<&ClientComment> for ClientComment {
    fn from(value: &ClientComment) -> Self {
        value.clone()
    }
}

impl From<String> for ClientComment {
    fn from(value: String) -> Self {
        Self(value)
    }
}

impl std::str::FromStr for ClientComment {
    type Err = std::convert::Infallible;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}

impl ToString for ClientComment {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

///A ClientConfigureRejectTransaction represents the reject of
/// configuration of an Account by a client.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A ClientConfigureRejectTransaction represents the
/// reject of configuration of an Account by a client.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "alias": {
///      "description": "The client-provided alias for the Account.",
///      "type": "string"
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "marginRate": {
///      "description": "The margin rate override for the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "rejectReason": {
///      "description": "The reason that the Reject Transaction was
/// created",
///      "type": "string",
///      "enum": [
///        "INTERNAL_SERVER_ERROR",
///        "INSTRUMENT_PRICE_UNKNOWN",
///        "ACCOUNT_NOT_ACTIVE",
///        "ACCOUNT_LOCKED",
///        "ACCOUNT_ORDER_CREATION_LOCKED",
///        "ACCOUNT_CONFIGURATION_LOCKED",
///        "ACCOUNT_DEPOSIT_LOCKED",
///        "ACCOUNT_WITHDRAWAL_LOCKED",
///        "ACCOUNT_ORDER_CANCEL_LOCKED",
///        "INSTRUMENT_NOT_TRADEABLE",
///        "PENDING_ORDERS_ALLOWED_EXCEEDED",
///        "ORDER_ID_UNSPECIFIED",
///        "ORDER_DOESNT_EXIST",
///        "ORDER_IDENTIFIER_INCONSISTENCY",
///        "TRADE_ID_UNSPECIFIED",
///        "TRADE_DOESNT_EXIST",
///        "TRADE_IDENTIFIER_INCONSISTENCY",
///        "INSUFFICIENT_MARGIN",
///        "INSTRUMENT_MISSING",
///        "INSTRUMENT_UNKNOWN",
///        "UNITS_MISSING",
///        "UNITS_INVALID",
///        "UNITS_PRECISION_EXCEEDED",
///        "UNITS_LIMIT_EXCEEDED",
///        "UNITS_MIMIMUM_NOT_MET",
///        "PRICE_MISSING",
///        "PRICE_INVALID",
///        "PRICE_PRECISION_EXCEEDED",
///        "PRICE_DISTANCE_MISSING",
///        "PRICE_DISTANCE_INVALID",
///        "PRICE_DISTANCE_PRECISION_EXCEEDED",
///        "PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "PRICE_DISTANCE_MINIMUM_NOT_MET",
///        "TIME_IN_FORCE_MISSING",
///        "TIME_IN_FORCE_INVALID",
///        "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING",
///        "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST",
///        "PRICE_BOUND_INVALID",
///        "PRICE_BOUND_PRECISION_EXCEEDED",
///        "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS",
///        "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED",
///        "CLIENT_ORDER_ID_INVALID",
///        "CLIENT_ORDER_ID_ALREADY_EXISTS",
///        "CLIENT_ORDER_TAG_INVALID",
///        "CLIENT_ORDER_COMMENT_INVALID",
///        "CLIENT_TRADE_ID_INVALID",
///        "CLIENT_TRADE_ID_ALREADY_EXISTS",
///        "CLIENT_TRADE_TAG_INVALID",
///        "CLIENT_TRADE_COMMENT_INVALID",
///        "ORDER_FILL_POSITION_ACTION_MISSING",
///        "ORDER_FILL_POSITION_ACTION_INVALID",
///        "TRIGGER_CONDITION_MISSING",
///        "TRIGGER_CONDITION_INVALID",
///        "ORDER_PARTIAL_FILL_OPTION_MISSING",
///        "ORDER_PARTIAL_FILL_OPTION_INVALID",
///        "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL",
///        "TAKE_PROFIT_ORDER_ALREADY_EXISTS",
///        "TAKE_PROFIT_ON_FILL_PRICE_MISSING",
///        "TAKE_PROFIT_ON_FILL_PRICE_INVALID",
///        "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED",
///        "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING",
///        "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID",
///        "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "STOP_LOSS_ORDER_ALREADY_EXISTS",
///        "STOP_LOSS_ORDER_GUARANTEED_REQUIRED",
///        "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD",
///        "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED",
///        "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION",
///        "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION",
///        "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED",
///        "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///        "STOP_LOSS_ORDER_NOT_CANCELABLE",
///        "STOP_LOSS_ORDER_NOT_REPLACEABLE",
///        "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///        "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///        "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING",
///        "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER",
///        "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///        "STOP_LOSS_ON_FILL_PRICE_MISSING",
///        "STOP_LOSS_ON_FILL_PRICE_INVALID",
///        "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///        "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_DISTANCE_INVALID",
///        "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///        "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING",
///        "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///        "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///        "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET",
///        "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED",
///        "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "CLOSE_TRADE_TYPE_MISSING",
///        "CLOSE_TRADE_PARTIAL_UNITS_MISSING",
///        "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE",
///        "CLOSEOUT_POSITION_DOESNT_EXIST",
///        "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION",
///        "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE",
///        "CLOSEOUT_POSITION_REJECT",
///        "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING",
///        "MARKUP_GROUP_ID_INVALID",
///        "POSITION_AGGREGATION_MODE_INVALID",
///        "ADMIN_CONFIGURE_DATA_MISSING",
///        "MARGIN_RATE_INVALID",
///        "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT",
///        "ALIAS_INVALID",
///        "CLIENT_CONFIGURE_DATA_MISSING",
///        "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL",
///        "AMOUNT_INVALID",
///        "INSUFFICIENT_FUNDS",
///        "AMOUNT_MISSING",
///        "FUNDING_REASON_MISSING",
///        "CLIENT_EXTENSIONS_DATA_MISSING",
///        "REPLACING_ORDER_INVALID",
///        "REPLACING_TRADE_ID_INVALID"
///      ]
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"CLIENT_CONFIGURE_REJECT\" in a ClientConfigureRejectTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ClientConfigureRejectTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The client-provided alias for the Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub alias: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The margin rate override for the Account.
    #[serde(
        rename = "marginRate",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_rate: Option<String>,
    ///The reason that the Reject Transaction was created
    #[serde(
        rename = "rejectReason",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub reject_reason: Option<ClientConfigureRejectTransactionRejectReason>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The Type of the Transaction. Always set to "CLIENT_CONFIGURE_REJECT"
    /// in a ClientConfigureRejectTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<ClientConfigureRejectTransactionType>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&ClientConfigureRejectTransaction> for ClientConfigureRejectTransaction {
    fn from(value: &ClientConfigureRejectTransaction) -> Self {
        value.clone()
    }
}

impl ClientConfigureRejectTransaction {
    pub fn builder() -> builder::ClientConfigureRejectTransaction {
        Default::default()
    }
}

///The reason that the Reject Transaction was created
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Reject Transaction was created",
///  "type": "string",
///  "enum": [
///    "INTERNAL_SERVER_ERROR",
///    "INSTRUMENT_PRICE_UNKNOWN",
///    "ACCOUNT_NOT_ACTIVE",
///    "ACCOUNT_LOCKED",
///    "ACCOUNT_ORDER_CREATION_LOCKED",
///    "ACCOUNT_CONFIGURATION_LOCKED",
///    "ACCOUNT_DEPOSIT_LOCKED",
///    "ACCOUNT_WITHDRAWAL_LOCKED",
///    "ACCOUNT_ORDER_CANCEL_LOCKED",
///    "INSTRUMENT_NOT_TRADEABLE",
///    "PENDING_ORDERS_ALLOWED_EXCEEDED",
///    "ORDER_ID_UNSPECIFIED",
///    "ORDER_DOESNT_EXIST",
///    "ORDER_IDENTIFIER_INCONSISTENCY",
///    "TRADE_ID_UNSPECIFIED",
///    "TRADE_DOESNT_EXIST",
///    "TRADE_IDENTIFIER_INCONSISTENCY",
///    "INSUFFICIENT_MARGIN",
///    "INSTRUMENT_MISSING",
///    "INSTRUMENT_UNKNOWN",
///    "UNITS_MISSING",
///    "UNITS_INVALID",
///    "UNITS_PRECISION_EXCEEDED",
///    "UNITS_LIMIT_EXCEEDED",
///    "UNITS_MIMIMUM_NOT_MET",
///    "PRICE_MISSING",
///    "PRICE_INVALID",
///    "PRICE_PRECISION_EXCEEDED",
///    "PRICE_DISTANCE_MISSING",
///    "PRICE_DISTANCE_INVALID",
///    "PRICE_DISTANCE_PRECISION_EXCEEDED",
///    "PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "PRICE_DISTANCE_MINIMUM_NOT_MET",
///    "TIME_IN_FORCE_MISSING",
///    "TIME_IN_FORCE_INVALID",
///    "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING",
///    "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST",
///    "PRICE_BOUND_INVALID",
///    "PRICE_BOUND_PRECISION_EXCEEDED",
///    "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS",
///    "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED",
///    "CLIENT_ORDER_ID_INVALID",
///    "CLIENT_ORDER_ID_ALREADY_EXISTS",
///    "CLIENT_ORDER_TAG_INVALID",
///    "CLIENT_ORDER_COMMENT_INVALID",
///    "CLIENT_TRADE_ID_INVALID",
///    "CLIENT_TRADE_ID_ALREADY_EXISTS",
///    "CLIENT_TRADE_TAG_INVALID",
///    "CLIENT_TRADE_COMMENT_INVALID",
///    "ORDER_FILL_POSITION_ACTION_MISSING",
///    "ORDER_FILL_POSITION_ACTION_INVALID",
///    "TRIGGER_CONDITION_MISSING",
///    "TRIGGER_CONDITION_INVALID",
///    "ORDER_PARTIAL_FILL_OPTION_MISSING",
///    "ORDER_PARTIAL_FILL_OPTION_INVALID",
///    "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL",
///    "TAKE_PROFIT_ORDER_ALREADY_EXISTS",
///    "TAKE_PROFIT_ON_FILL_PRICE_MISSING",
///    "TAKE_PROFIT_ON_FILL_PRICE_INVALID",
///    "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED",
///    "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING",
///    "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "STOP_LOSS_ORDER_ALREADY_EXISTS",
///    "STOP_LOSS_ORDER_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD",
///    "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION",
///    "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION",
///    "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED",
///    "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ORDER_NOT_CANCELABLE",
///    "STOP_LOSS_ORDER_NOT_REPLACEABLE",
///    "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///    "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING",
///    "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER",
///    "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ON_FILL_PRICE_MISSING",
///    "STOP_LOSS_ON_FILL_PRICE_INVALID",
///    "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_DISTANCE_INVALID",
///    "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///    "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET",
///    "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED",
///    "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "CLOSE_TRADE_TYPE_MISSING",
///    "CLOSE_TRADE_PARTIAL_UNITS_MISSING",
///    "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE",
///    "CLOSEOUT_POSITION_DOESNT_EXIST",
///    "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION",
///    "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE",
///    "CLOSEOUT_POSITION_REJECT",
///    "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING",
///    "MARKUP_GROUP_ID_INVALID",
///    "POSITION_AGGREGATION_MODE_INVALID",
///    "ADMIN_CONFIGURE_DATA_MISSING",
///    "MARGIN_RATE_INVALID",
///    "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT",
///    "ALIAS_INVALID",
///    "CLIENT_CONFIGURE_DATA_MISSING",
///    "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL",
///    "AMOUNT_INVALID",
///    "INSUFFICIENT_FUNDS",
///    "AMOUNT_MISSING",
///    "FUNDING_REASON_MISSING",
///    "CLIENT_EXTENSIONS_DATA_MISSING",
///    "REPLACING_ORDER_INVALID",
///    "REPLACING_TRADE_ID_INVALID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ClientConfigureRejectTransactionRejectReason {
    #[serde(rename = "INTERNAL_SERVER_ERROR")]
    InternalServerError,
    #[serde(rename = "INSTRUMENT_PRICE_UNKNOWN")]
    InstrumentPriceUnknown,
    #[serde(rename = "ACCOUNT_NOT_ACTIVE")]
    AccountNotActive,
    #[serde(rename = "ACCOUNT_LOCKED")]
    AccountLocked,
    #[serde(rename = "ACCOUNT_ORDER_CREATION_LOCKED")]
    AccountOrderCreationLocked,
    #[serde(rename = "ACCOUNT_CONFIGURATION_LOCKED")]
    AccountConfigurationLocked,
    #[serde(rename = "ACCOUNT_DEPOSIT_LOCKED")]
    AccountDepositLocked,
    #[serde(rename = "ACCOUNT_WITHDRAWAL_LOCKED")]
    AccountWithdrawalLocked,
    #[serde(rename = "ACCOUNT_ORDER_CANCEL_LOCKED")]
    AccountOrderCancelLocked,
    #[serde(rename = "INSTRUMENT_NOT_TRADEABLE")]
    InstrumentNotTradeable,
    #[serde(rename = "PENDING_ORDERS_ALLOWED_EXCEEDED")]
    PendingOrdersAllowedExceeded,
    #[serde(rename = "ORDER_ID_UNSPECIFIED")]
    OrderIdUnspecified,
    #[serde(rename = "ORDER_DOESNT_EXIST")]
    OrderDoesntExist,
    #[serde(rename = "ORDER_IDENTIFIER_INCONSISTENCY")]
    OrderIdentifierInconsistency,
    #[serde(rename = "TRADE_ID_UNSPECIFIED")]
    TradeIdUnspecified,
    #[serde(rename = "TRADE_DOESNT_EXIST")]
    TradeDoesntExist,
    #[serde(rename = "TRADE_IDENTIFIER_INCONSISTENCY")]
    TradeIdentifierInconsistency,
    #[serde(rename = "INSUFFICIENT_MARGIN")]
    InsufficientMargin,
    #[serde(rename = "INSTRUMENT_MISSING")]
    InstrumentMissing,
    #[serde(rename = "INSTRUMENT_UNKNOWN")]
    InstrumentUnknown,
    #[serde(rename = "UNITS_MISSING")]
    UnitsMissing,
    #[serde(rename = "UNITS_INVALID")]
    UnitsInvalid,
    #[serde(rename = "UNITS_PRECISION_EXCEEDED")]
    UnitsPrecisionExceeded,
    #[serde(rename = "UNITS_LIMIT_EXCEEDED")]
    UnitsLimitExceeded,
    #[serde(rename = "UNITS_MIMIMUM_NOT_MET")]
    UnitsMimimumNotMet,
    #[serde(rename = "PRICE_MISSING")]
    PriceMissing,
    #[serde(rename = "PRICE_INVALID")]
    PriceInvalid,
    #[serde(rename = "PRICE_PRECISION_EXCEEDED")]
    PricePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MISSING")]
    PriceDistanceMissing,
    #[serde(rename = "PRICE_DISTANCE_INVALID")]
    PriceDistanceInvalid,
    #[serde(rename = "PRICE_DISTANCE_PRECISION_EXCEEDED")]
    PriceDistancePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    PriceDistanceMaximumExceeded,
    #[serde(rename = "PRICE_DISTANCE_MINIMUM_NOT_MET")]
    PriceDistanceMinimumNotMet,
    #[serde(rename = "TIME_IN_FORCE_MISSING")]
    TimeInForceMissing,
    #[serde(rename = "TIME_IN_FORCE_INVALID")]
    TimeInForceInvalid,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING")]
    TimeInForceGtdTimestampMissing,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST")]
    TimeInForceGtdTimestampInPast,
    #[serde(rename = "PRICE_BOUND_INVALID")]
    PriceBoundInvalid,
    #[serde(rename = "PRICE_BOUND_PRECISION_EXCEEDED")]
    PriceBoundPrecisionExceeded,
    #[serde(rename = "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS")]
    OrdersOnFillDuplicateClientOrderIds,
    #[serde(rename = "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED")]
    TradeOnFillClientExtensionsNotSupported,
    #[serde(rename = "CLIENT_ORDER_ID_INVALID")]
    ClientOrderIdInvalid,
    #[serde(rename = "CLIENT_ORDER_ID_ALREADY_EXISTS")]
    ClientOrderIdAlreadyExists,
    #[serde(rename = "CLIENT_ORDER_TAG_INVALID")]
    ClientOrderTagInvalid,
    #[serde(rename = "CLIENT_ORDER_COMMENT_INVALID")]
    ClientOrderCommentInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_INVALID")]
    ClientTradeIdInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_ALREADY_EXISTS")]
    ClientTradeIdAlreadyExists,
    #[serde(rename = "CLIENT_TRADE_TAG_INVALID")]
    ClientTradeTagInvalid,
    #[serde(rename = "CLIENT_TRADE_COMMENT_INVALID")]
    ClientTradeCommentInvalid,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_MISSING")]
    OrderFillPositionActionMissing,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_INVALID")]
    OrderFillPositionActionInvalid,
    #[serde(rename = "TRIGGER_CONDITION_MISSING")]
    TriggerConditionMissing,
    #[serde(rename = "TRIGGER_CONDITION_INVALID")]
    TriggerConditionInvalid,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_MISSING")]
    OrderPartialFillOptionMissing,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_INVALID")]
    OrderPartialFillOptionInvalid,
    #[serde(rename = "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL")]
    InvalidReissueImmediatePartialFill,
    #[serde(rename = "TAKE_PROFIT_ORDER_ALREADY_EXISTS")]
    TakeProfitOrderAlreadyExists,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_MISSING")]
    TakeProfitOnFillPriceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_INVALID")]
    TakeProfitOnFillPriceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    TakeProfitOnFillPricePrecisionExceeded,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING")]
    TakeProfitOnFillTimeInForceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID")]
    TakeProfitOnFillTimeInForceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TakeProfitOnFillGtdTimestampMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TakeProfitOnFillGtdTimestampInPast,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TakeProfitOnFillClientOrderIdInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TakeProfitOnFillClientOrderTagInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TakeProfitOnFillClientOrderCommentInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TakeProfitOnFillTriggerConditionMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TakeProfitOnFillTriggerConditionInvalid,
    #[serde(rename = "STOP_LOSS_ORDER_ALREADY_EXISTS")]
    StopLossOrderAlreadyExists,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_REQUIRED")]
    StopLossOrderGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD")]
    StopLossOrderGuaranteedPriceWithinSpread,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED")]
    StopLossOrderGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION")]
    StopLossOrderGuaranteedHaltedCreateViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION")]
    StopLossOrderGuaranteedHaltedTightenViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED")]
    StopLossOrderGuaranteedHedgingNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOrderGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_CANCELABLE")]
    StopLossOrderNotCancelable,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_REPLACEABLE")]
    StopLossOrderNotReplaceable,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOrderGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOrderPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOrderPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER")]
    StopLossOnFillRequiredForPendingOrder,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED")]
    StopLossOnFillGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED")]
    StopLossOnFillGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_MISSING")]
    StopLossOnFillPriceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_INVALID")]
    StopLossOnFillPriceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    StopLossOnFillPricePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOnFillGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOnFillGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_INVALID")]
    StopLossOnFillDistanceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    StopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED")]
    StopLossOnFillDistancePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOnFillPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOnFillPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    StopLossOnFillTimeInForceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    StopLossOnFillTimeInForceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    StopLossOnFillGtdTimestampMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    StopLossOnFillGtdTimestampInPast,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    StopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    StopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    StopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    StopLossOnFillTriggerConditionMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    StopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS")]
    TrailingStopLossOrderAlreadyExists,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING")]
    TrailingStopLossOnFillPriceDistanceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID")]
    TrailingStopLossOnFillPriceDistanceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED")]
    TrailingStopLossOnFillPriceDistancePrecisionExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    TrailingStopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET")]
    TrailingStopLossOnFillPriceDistanceMinimumNotMet,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    TrailingStopLossOnFillTimeInForceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    TrailingStopLossOnFillTimeInForceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TrailingStopLossOnFillGtdTimestampMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TrailingStopLossOnFillGtdTimestampInPast,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TrailingStopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TrailingStopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TrailingStopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED")]
    TrailingStopLossOrdersNotSupported,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TrailingStopLossOnFillTriggerConditionMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TrailingStopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "CLOSE_TRADE_TYPE_MISSING")]
    CloseTradeTypeMissing,
    #[serde(rename = "CLOSE_TRADE_PARTIAL_UNITS_MISSING")]
    CloseTradePartialUnitsMissing,
    #[serde(rename = "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE")]
    CloseTradeUnitsExceedTradeSize,
    #[serde(rename = "CLOSEOUT_POSITION_DOESNT_EXIST")]
    CloseoutPositionDoesntExist,
    #[serde(rename = "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION")]
    CloseoutPositionIncompleteSpecification,
    #[serde(rename = "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE")]
    CloseoutPositionUnitsExceedPositionSize,
    #[serde(rename = "CLOSEOUT_POSITION_REJECT")]
    CloseoutPositionReject,
    #[serde(rename = "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING")]
    CloseoutPositionPartialUnitsMissing,
    #[serde(rename = "MARKUP_GROUP_ID_INVALID")]
    MarkupGroupIdInvalid,
    #[serde(rename = "POSITION_AGGREGATION_MODE_INVALID")]
    PositionAggregationModeInvalid,
    #[serde(rename = "ADMIN_CONFIGURE_DATA_MISSING")]
    AdminConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_INVALID")]
    MarginRateInvalid,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT")]
    MarginRateWouldTriggerCloseout,
    #[serde(rename = "ALIAS_INVALID")]
    AliasInvalid,
    #[serde(rename = "CLIENT_CONFIGURE_DATA_MISSING")]
    ClientConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL")]
    MarginRateWouldTriggerMarginCall,
    #[serde(rename = "AMOUNT_INVALID")]
    AmountInvalid,
    #[serde(rename = "INSUFFICIENT_FUNDS")]
    InsufficientFunds,
    #[serde(rename = "AMOUNT_MISSING")]
    AmountMissing,
    #[serde(rename = "FUNDING_REASON_MISSING")]
    FundingReasonMissing,
    #[serde(rename = "CLIENT_EXTENSIONS_DATA_MISSING")]
    ClientExtensionsDataMissing,
    #[serde(rename = "REPLACING_ORDER_INVALID")]
    ReplacingOrderInvalid,
    #[serde(rename = "REPLACING_TRADE_ID_INVALID")]
    ReplacingTradeIdInvalid,
}

impl From<&ClientConfigureRejectTransactionRejectReason>
    for ClientConfigureRejectTransactionRejectReason
{
    fn from(value: &ClientConfigureRejectTransactionRejectReason) -> Self {
        value.clone()
    }
}

impl ToString for ClientConfigureRejectTransactionRejectReason {
    fn to_string(&self) -> String {
        match *self {
            Self::InternalServerError => "INTERNAL_SERVER_ERROR".to_string(),
            Self::InstrumentPriceUnknown => "INSTRUMENT_PRICE_UNKNOWN".to_string(),
            Self::AccountNotActive => "ACCOUNT_NOT_ACTIVE".to_string(),
            Self::AccountLocked => "ACCOUNT_LOCKED".to_string(),
            Self::AccountOrderCreationLocked => "ACCOUNT_ORDER_CREATION_LOCKED".to_string(),
            Self::AccountConfigurationLocked => "ACCOUNT_CONFIGURATION_LOCKED".to_string(),
            Self::AccountDepositLocked => "ACCOUNT_DEPOSIT_LOCKED".to_string(),
            Self::AccountWithdrawalLocked => "ACCOUNT_WITHDRAWAL_LOCKED".to_string(),
            Self::AccountOrderCancelLocked => "ACCOUNT_ORDER_CANCEL_LOCKED".to_string(),
            Self::InstrumentNotTradeable => "INSTRUMENT_NOT_TRADEABLE".to_string(),
            Self::PendingOrdersAllowedExceeded => "PENDING_ORDERS_ALLOWED_EXCEEDED".to_string(),
            Self::OrderIdUnspecified => "ORDER_ID_UNSPECIFIED".to_string(),
            Self::OrderDoesntExist => "ORDER_DOESNT_EXIST".to_string(),
            Self::OrderIdentifierInconsistency => "ORDER_IDENTIFIER_INCONSISTENCY".to_string(),
            Self::TradeIdUnspecified => "TRADE_ID_UNSPECIFIED".to_string(),
            Self::TradeDoesntExist => "TRADE_DOESNT_EXIST".to_string(),
            Self::TradeIdentifierInconsistency => "TRADE_IDENTIFIER_INCONSISTENCY".to_string(),
            Self::InsufficientMargin => "INSUFFICIENT_MARGIN".to_string(),
            Self::InstrumentMissing => "INSTRUMENT_MISSING".to_string(),
            Self::InstrumentUnknown => "INSTRUMENT_UNKNOWN".to_string(),
            Self::UnitsMissing => "UNITS_MISSING".to_string(),
            Self::UnitsInvalid => "UNITS_INVALID".to_string(),
            Self::UnitsPrecisionExceeded => "UNITS_PRECISION_EXCEEDED".to_string(),
            Self::UnitsLimitExceeded => "UNITS_LIMIT_EXCEEDED".to_string(),
            Self::UnitsMimimumNotMet => "UNITS_MIMIMUM_NOT_MET".to_string(),
            Self::PriceMissing => "PRICE_MISSING".to_string(),
            Self::PriceInvalid => "PRICE_INVALID".to_string(),
            Self::PricePrecisionExceeded => "PRICE_PRECISION_EXCEEDED".to_string(),
            Self::PriceDistanceMissing => "PRICE_DISTANCE_MISSING".to_string(),
            Self::PriceDistanceInvalid => "PRICE_DISTANCE_INVALID".to_string(),
            Self::PriceDistancePrecisionExceeded => "PRICE_DISTANCE_PRECISION_EXCEEDED".to_string(),
            Self::PriceDistanceMaximumExceeded => "PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string(),
            Self::PriceDistanceMinimumNotMet => "PRICE_DISTANCE_MINIMUM_NOT_MET".to_string(),
            Self::TimeInForceMissing => "TIME_IN_FORCE_MISSING".to_string(),
            Self::TimeInForceInvalid => "TIME_IN_FORCE_INVALID".to_string(),
            Self::TimeInForceGtdTimestampMissing => {
                "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TimeInForceGtdTimestampInPast => {
                "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::PriceBoundInvalid => "PRICE_BOUND_INVALID".to_string(),
            Self::PriceBoundPrecisionExceeded => "PRICE_BOUND_PRECISION_EXCEEDED".to_string(),
            Self::OrdersOnFillDuplicateClientOrderIds => {
                "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS".to_string()
            }
            Self::TradeOnFillClientExtensionsNotSupported => {
                "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED".to_string()
            }
            Self::ClientOrderIdInvalid => "CLIENT_ORDER_ID_INVALID".to_string(),
            Self::ClientOrderIdAlreadyExists => "CLIENT_ORDER_ID_ALREADY_EXISTS".to_string(),
            Self::ClientOrderTagInvalid => "CLIENT_ORDER_TAG_INVALID".to_string(),
            Self::ClientOrderCommentInvalid => "CLIENT_ORDER_COMMENT_INVALID".to_string(),
            Self::ClientTradeIdInvalid => "CLIENT_TRADE_ID_INVALID".to_string(),
            Self::ClientTradeIdAlreadyExists => "CLIENT_TRADE_ID_ALREADY_EXISTS".to_string(),
            Self::ClientTradeTagInvalid => "CLIENT_TRADE_TAG_INVALID".to_string(),
            Self::ClientTradeCommentInvalid => "CLIENT_TRADE_COMMENT_INVALID".to_string(),
            Self::OrderFillPositionActionMissing => {
                "ORDER_FILL_POSITION_ACTION_MISSING".to_string()
            }
            Self::OrderFillPositionActionInvalid => {
                "ORDER_FILL_POSITION_ACTION_INVALID".to_string()
            }
            Self::TriggerConditionMissing => "TRIGGER_CONDITION_MISSING".to_string(),
            Self::TriggerConditionInvalid => "TRIGGER_CONDITION_INVALID".to_string(),
            Self::OrderPartialFillOptionMissing => "ORDER_PARTIAL_FILL_OPTION_MISSING".to_string(),
            Self::OrderPartialFillOptionInvalid => "ORDER_PARTIAL_FILL_OPTION_INVALID".to_string(),
            Self::InvalidReissueImmediatePartialFill => {
                "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL".to_string()
            }
            Self::TakeProfitOrderAlreadyExists => "TAKE_PROFIT_ORDER_ALREADY_EXISTS".to_string(),
            Self::TakeProfitOnFillPriceMissing => "TAKE_PROFIT_ON_FILL_PRICE_MISSING".to_string(),
            Self::TakeProfitOnFillPriceInvalid => "TAKE_PROFIT_ON_FILL_PRICE_INVALID".to_string(),
            Self::TakeProfitOnFillPricePrecisionExceeded => {
                "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED".to_string()
            }
            Self::TakeProfitOnFillTimeInForceMissing => {
                "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::TakeProfitOnFillTimeInForceInvalid => {
                "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::TakeProfitOnFillGtdTimestampMissing => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TakeProfitOnFillGtdTimestampInPast => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TakeProfitOnFillClientOrderIdInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::TakeProfitOnFillClientOrderTagInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::TakeProfitOnFillClientOrderCommentInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::TakeProfitOnFillTriggerConditionMissing => {
                "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::TakeProfitOnFillTriggerConditionInvalid => {
                "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::StopLossOrderAlreadyExists => "STOP_LOSS_ORDER_ALREADY_EXISTS".to_string(),
            Self::StopLossOrderGuaranteedRequired => {
                "STOP_LOSS_ORDER_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOrderGuaranteedPriceWithinSpread => {
                "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD".to_string()
            }
            Self::StopLossOrderGuaranteedNotAllowed => {
                "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOrderGuaranteedHaltedCreateViolation => {
                "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION".to_string()
            }
            Self::StopLossOrderGuaranteedHaltedTightenViolation => {
                "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION".to_string()
            }
            Self::StopLossOrderGuaranteedHedgingNotAllowed => {
                "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED".to_string()
            }
            Self::StopLossOrderGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOrderNotCancelable => "STOP_LOSS_ORDER_NOT_CANCELABLE".to_string(),
            Self::StopLossOrderNotReplaceable => "STOP_LOSS_ORDER_NOT_REPLACEABLE".to_string(),
            Self::StopLossOrderGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOrderPriceAndDistanceBothSpecified => {
                "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED".to_string()
            }
            Self::StopLossOrderPriceAndDistanceBothMissing => {
                "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING".to_string()
            }
            Self::StopLossOnFillRequiredForPendingOrder => {
                "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER".to_string()
            }
            Self::StopLossOnFillGuaranteedNotAllowed => {
                "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOnFillGuaranteedRequired => {
                "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOnFillPriceMissing => "STOP_LOSS_ON_FILL_PRICE_MISSING".to_string(),
            Self::StopLossOnFillPriceInvalid => "STOP_LOSS_ON_FILL_PRICE_INVALID".to_string(),
            Self::StopLossOnFillPricePrecisionExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOnFillGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillDistanceInvalid => "STOP_LOSS_ON_FILL_DISTANCE_INVALID".to_string(),
            Self::StopLossOnFillPriceDistanceMaximumExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::StopLossOnFillDistancePrecisionExceeded => {
                "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillPriceAndDistanceBothSpecified => {
                "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED".to_string()
            }
            Self::StopLossOnFillPriceAndDistanceBothMissing => {
                "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING".to_string()
            }
            Self::StopLossOnFillTimeInForceMissing => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::StopLossOnFillTimeInForceInvalid => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::StopLossOnFillGtdTimestampMissing => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::StopLossOnFillGtdTimestampInPast => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::StopLossOnFillClientOrderIdInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::StopLossOnFillClientOrderTagInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::StopLossOnFillClientOrderCommentInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::StopLossOnFillTriggerConditionMissing => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::StopLossOnFillTriggerConditionInvalid => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::TrailingStopLossOrderAlreadyExists => {
                "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistancePrecisionExceeded => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMaximumExceeded => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMinimumNotMet => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET".to_string()
            }
            Self::TrailingStopLossOnFillTimeInForceMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillTimeInForceInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampInPast => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderIdInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderTagInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderCommentInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::TrailingStopLossOrdersNotSupported => {
                "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED".to_string()
            }
            Self::TrailingStopLossOnFillTriggerConditionMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillTriggerConditionInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::CloseTradeTypeMissing => "CLOSE_TRADE_TYPE_MISSING".to_string(),
            Self::CloseTradePartialUnitsMissing => "CLOSE_TRADE_PARTIAL_UNITS_MISSING".to_string(),
            Self::CloseTradeUnitsExceedTradeSize => {
                "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE".to_string()
            }
            Self::CloseoutPositionDoesntExist => "CLOSEOUT_POSITION_DOESNT_EXIST".to_string(),
            Self::CloseoutPositionIncompleteSpecification => {
                "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION".to_string()
            }
            Self::CloseoutPositionUnitsExceedPositionSize => {
                "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE".to_string()
            }
            Self::CloseoutPositionReject => "CLOSEOUT_POSITION_REJECT".to_string(),
            Self::CloseoutPositionPartialUnitsMissing => {
                "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING".to_string()
            }
            Self::MarkupGroupIdInvalid => "MARKUP_GROUP_ID_INVALID".to_string(),
            Self::PositionAggregationModeInvalid => "POSITION_AGGREGATION_MODE_INVALID".to_string(),
            Self::AdminConfigureDataMissing => "ADMIN_CONFIGURE_DATA_MISSING".to_string(),
            Self::MarginRateInvalid => "MARGIN_RATE_INVALID".to_string(),
            Self::MarginRateWouldTriggerCloseout => {
                "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT".to_string()
            }
            Self::AliasInvalid => "ALIAS_INVALID".to_string(),
            Self::ClientConfigureDataMissing => "CLIENT_CONFIGURE_DATA_MISSING".to_string(),
            Self::MarginRateWouldTriggerMarginCall => {
                "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL".to_string()
            }
            Self::AmountInvalid => "AMOUNT_INVALID".to_string(),
            Self::InsufficientFunds => "INSUFFICIENT_FUNDS".to_string(),
            Self::AmountMissing => "AMOUNT_MISSING".to_string(),
            Self::FundingReasonMissing => "FUNDING_REASON_MISSING".to_string(),
            Self::ClientExtensionsDataMissing => "CLIENT_EXTENSIONS_DATA_MISSING".to_string(),
            Self::ReplacingOrderInvalid => "REPLACING_ORDER_INVALID".to_string(),
            Self::ReplacingTradeIdInvalid => "REPLACING_TRADE_ID_INVALID".to_string(),
        }
    }
}

impl std::str::FromStr for ClientConfigureRejectTransactionRejectReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "INTERNAL_SERVER_ERROR" => Ok(Self::InternalServerError),
            "INSTRUMENT_PRICE_UNKNOWN" => Ok(Self::InstrumentPriceUnknown),
            "ACCOUNT_NOT_ACTIVE" => Ok(Self::AccountNotActive),
            "ACCOUNT_LOCKED" => Ok(Self::AccountLocked),
            "ACCOUNT_ORDER_CREATION_LOCKED" => Ok(Self::AccountOrderCreationLocked),
            "ACCOUNT_CONFIGURATION_LOCKED" => Ok(Self::AccountConfigurationLocked),
            "ACCOUNT_DEPOSIT_LOCKED" => Ok(Self::AccountDepositLocked),
            "ACCOUNT_WITHDRAWAL_LOCKED" => Ok(Self::AccountWithdrawalLocked),
            "ACCOUNT_ORDER_CANCEL_LOCKED" => Ok(Self::AccountOrderCancelLocked),
            "INSTRUMENT_NOT_TRADEABLE" => Ok(Self::InstrumentNotTradeable),
            "PENDING_ORDERS_ALLOWED_EXCEEDED" => Ok(Self::PendingOrdersAllowedExceeded),
            "ORDER_ID_UNSPECIFIED" => Ok(Self::OrderIdUnspecified),
            "ORDER_DOESNT_EXIST" => Ok(Self::OrderDoesntExist),
            "ORDER_IDENTIFIER_INCONSISTENCY" => Ok(Self::OrderIdentifierInconsistency),
            "TRADE_ID_UNSPECIFIED" => Ok(Self::TradeIdUnspecified),
            "TRADE_DOESNT_EXIST" => Ok(Self::TradeDoesntExist),
            "TRADE_IDENTIFIER_INCONSISTENCY" => Ok(Self::TradeIdentifierInconsistency),
            "INSUFFICIENT_MARGIN" => Ok(Self::InsufficientMargin),
            "INSTRUMENT_MISSING" => Ok(Self::InstrumentMissing),
            "INSTRUMENT_UNKNOWN" => Ok(Self::InstrumentUnknown),
            "UNITS_MISSING" => Ok(Self::UnitsMissing),
            "UNITS_INVALID" => Ok(Self::UnitsInvalid),
            "UNITS_PRECISION_EXCEEDED" => Ok(Self::UnitsPrecisionExceeded),
            "UNITS_LIMIT_EXCEEDED" => Ok(Self::UnitsLimitExceeded),
            "UNITS_MIMIMUM_NOT_MET" => Ok(Self::UnitsMimimumNotMet),
            "PRICE_MISSING" => Ok(Self::PriceMissing),
            "PRICE_INVALID" => Ok(Self::PriceInvalid),
            "PRICE_PRECISION_EXCEEDED" => Ok(Self::PricePrecisionExceeded),
            "PRICE_DISTANCE_MISSING" => Ok(Self::PriceDistanceMissing),
            "PRICE_DISTANCE_INVALID" => Ok(Self::PriceDistanceInvalid),
            "PRICE_DISTANCE_PRECISION_EXCEEDED" => Ok(Self::PriceDistancePrecisionExceeded),
            "PRICE_DISTANCE_MAXIMUM_EXCEEDED" => Ok(Self::PriceDistanceMaximumExceeded),
            "PRICE_DISTANCE_MINIMUM_NOT_MET" => Ok(Self::PriceDistanceMinimumNotMet),
            "TIME_IN_FORCE_MISSING" => Ok(Self::TimeInForceMissing),
            "TIME_IN_FORCE_INVALID" => Ok(Self::TimeInForceInvalid),
            "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING" => Ok(Self::TimeInForceGtdTimestampMissing),
            "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST" => Ok(Self::TimeInForceGtdTimestampInPast),
            "PRICE_BOUND_INVALID" => Ok(Self::PriceBoundInvalid),
            "PRICE_BOUND_PRECISION_EXCEEDED" => Ok(Self::PriceBoundPrecisionExceeded),
            "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS" => {
                Ok(Self::OrdersOnFillDuplicateClientOrderIds)
            }
            "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED" => {
                Ok(Self::TradeOnFillClientExtensionsNotSupported)
            }
            "CLIENT_ORDER_ID_INVALID" => Ok(Self::ClientOrderIdInvalid),
            "CLIENT_ORDER_ID_ALREADY_EXISTS" => Ok(Self::ClientOrderIdAlreadyExists),
            "CLIENT_ORDER_TAG_INVALID" => Ok(Self::ClientOrderTagInvalid),
            "CLIENT_ORDER_COMMENT_INVALID" => Ok(Self::ClientOrderCommentInvalid),
            "CLIENT_TRADE_ID_INVALID" => Ok(Self::ClientTradeIdInvalid),
            "CLIENT_TRADE_ID_ALREADY_EXISTS" => Ok(Self::ClientTradeIdAlreadyExists),
            "CLIENT_TRADE_TAG_INVALID" => Ok(Self::ClientTradeTagInvalid),
            "CLIENT_TRADE_COMMENT_INVALID" => Ok(Self::ClientTradeCommentInvalid),
            "ORDER_FILL_POSITION_ACTION_MISSING" => Ok(Self::OrderFillPositionActionMissing),
            "ORDER_FILL_POSITION_ACTION_INVALID" => Ok(Self::OrderFillPositionActionInvalid),
            "TRIGGER_CONDITION_MISSING" => Ok(Self::TriggerConditionMissing),
            "TRIGGER_CONDITION_INVALID" => Ok(Self::TriggerConditionInvalid),
            "ORDER_PARTIAL_FILL_OPTION_MISSING" => Ok(Self::OrderPartialFillOptionMissing),
            "ORDER_PARTIAL_FILL_OPTION_INVALID" => Ok(Self::OrderPartialFillOptionInvalid),
            "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL" => {
                Ok(Self::InvalidReissueImmediatePartialFill)
            }
            "TAKE_PROFIT_ORDER_ALREADY_EXISTS" => Ok(Self::TakeProfitOrderAlreadyExists),
            "TAKE_PROFIT_ON_FILL_PRICE_MISSING" => Ok(Self::TakeProfitOnFillPriceMissing),
            "TAKE_PROFIT_ON_FILL_PRICE_INVALID" => Ok(Self::TakeProfitOnFillPriceInvalid),
            "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(Self::TakeProfitOnFillPricePrecisionExceeded)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(Self::TakeProfitOnFillTimeInForceMissing)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(Self::TakeProfitOnFillTimeInForceInvalid)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::TakeProfitOnFillGtdTimestampMissing)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TakeProfitOnFillGtdTimestampInPast)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderIdInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderTagInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderCommentInvalid)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::TakeProfitOnFillTriggerConditionMissing)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::TakeProfitOnFillTriggerConditionInvalid)
            }
            "STOP_LOSS_ORDER_ALREADY_EXISTS" => Ok(Self::StopLossOrderAlreadyExists),
            "STOP_LOSS_ORDER_GUARANTEED_REQUIRED" => Ok(Self::StopLossOrderGuaranteedRequired),
            "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD" => {
                Ok(Self::StopLossOrderGuaranteedPriceWithinSpread)
            }
            "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED" => Ok(Self::StopLossOrderGuaranteedNotAllowed),
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION" => {
                Ok(Self::StopLossOrderGuaranteedHaltedCreateViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION" => {
                Ok(Self::StopLossOrderGuaranteedHaltedTightenViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED" => {
                Ok(Self::StopLossOrderGuaranteedHedgingNotAllowed)
            }
            "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOrderGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ORDER_NOT_CANCELABLE" => Ok(Self::StopLossOrderNotCancelable),
            "STOP_LOSS_ORDER_NOT_REPLACEABLE" => Ok(Self::StopLossOrderNotReplaceable),
            "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOrderGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(Self::StopLossOrderPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(Self::StopLossOrderPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER" => {
                Ok(Self::StopLossOnFillRequiredForPendingOrder)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED" => {
                Ok(Self::StopLossOnFillGuaranteedNotAllowed)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED" => Ok(Self::StopLossOnFillGuaranteedRequired),
            "STOP_LOSS_ON_FILL_PRICE_MISSING" => Ok(Self::StopLossOnFillPriceMissing),
            "STOP_LOSS_ON_FILL_PRICE_INVALID" => Ok(Self::StopLossOnFillPriceInvalid),
            "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(Self::StopLossOnFillPricePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOnFillGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOnFillGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_INVALID" => Ok(Self::StopLossOnFillDistanceInvalid),
            "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::StopLossOnFillPriceDistanceMaximumExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(Self::StopLossOnFillDistancePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(Self::StopLossOnFillPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(Self::StopLossOnFillPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => Ok(Self::StopLossOnFillTimeInForceMissing),
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => Ok(Self::StopLossOnFillTimeInForceInvalid),
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::StopLossOnFillGtdTimestampMissing)
            }
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => Ok(Self::StopLossOnFillGtdTimestampInPast),
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderIdInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderTagInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderCommentInvalid)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::StopLossOnFillTriggerConditionMissing)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::StopLossOnFillTriggerConditionInvalid)
            }
            "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS" => {
                Ok(Self::TrailingStopLossOrderAlreadyExists)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(Self::TrailingStopLossOnFillPriceDistancePrecisionExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMaximumExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMinimumNotMet)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(Self::TrailingStopLossOnFillTimeInForceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(Self::TrailingStopLossOnFillTimeInForceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampInPast)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderIdInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderTagInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderCommentInvalid)
            }
            "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED" => {
                Ok(Self::TrailingStopLossOrdersNotSupported)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::TrailingStopLossOnFillTriggerConditionMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::TrailingStopLossOnFillTriggerConditionInvalid)
            }
            "CLOSE_TRADE_TYPE_MISSING" => Ok(Self::CloseTradeTypeMissing),
            "CLOSE_TRADE_PARTIAL_UNITS_MISSING" => Ok(Self::CloseTradePartialUnitsMissing),
            "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE" => Ok(Self::CloseTradeUnitsExceedTradeSize),
            "CLOSEOUT_POSITION_DOESNT_EXIST" => Ok(Self::CloseoutPositionDoesntExist),
            "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION" => {
                Ok(Self::CloseoutPositionIncompleteSpecification)
            }
            "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE" => {
                Ok(Self::CloseoutPositionUnitsExceedPositionSize)
            }
            "CLOSEOUT_POSITION_REJECT" => Ok(Self::CloseoutPositionReject),
            "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING" => {
                Ok(Self::CloseoutPositionPartialUnitsMissing)
            }
            "MARKUP_GROUP_ID_INVALID" => Ok(Self::MarkupGroupIdInvalid),
            "POSITION_AGGREGATION_MODE_INVALID" => Ok(Self::PositionAggregationModeInvalid),
            "ADMIN_CONFIGURE_DATA_MISSING" => Ok(Self::AdminConfigureDataMissing),
            "MARGIN_RATE_INVALID" => Ok(Self::MarginRateInvalid),
            "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT" => Ok(Self::MarginRateWouldTriggerCloseout),
            "ALIAS_INVALID" => Ok(Self::AliasInvalid),
            "CLIENT_CONFIGURE_DATA_MISSING" => Ok(Self::ClientConfigureDataMissing),
            "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL" => Ok(Self::MarginRateWouldTriggerMarginCall),
            "AMOUNT_INVALID" => Ok(Self::AmountInvalid),
            "INSUFFICIENT_FUNDS" => Ok(Self::InsufficientFunds),
            "AMOUNT_MISSING" => Ok(Self::AmountMissing),
            "FUNDING_REASON_MISSING" => Ok(Self::FundingReasonMissing),
            "CLIENT_EXTENSIONS_DATA_MISSING" => Ok(Self::ClientExtensionsDataMissing),
            "REPLACING_ORDER_INVALID" => Ok(Self::ReplacingOrderInvalid),
            "REPLACING_TRADE_ID_INVALID" => Ok(Self::ReplacingTradeIdInvalid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for ClientConfigureRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for ClientConfigureRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for ClientConfigureRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Type of the Transaction. Always set to "CLIENT_CONFIGURE_REJECT" in
/// a ClientConfigureRejectTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"CLIENT_CONFIGURE_REJECT\" in a ClientConfigureRejectTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ClientConfigureRejectTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&ClientConfigureRejectTransactionType> for ClientConfigureRejectTransactionType {
    fn from(value: &ClientConfigureRejectTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for ClientConfigureRejectTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for ClientConfigureRejectTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for ClientConfigureRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for ClientConfigureRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for ClientConfigureRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A ClientConfigureTransaction represents the configuration of an Account
/// by a client.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A ClientConfigureTransaction represents the
/// configuration of an Account by a client.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "alias": {
///      "description": "The client-provided alias for the Account.",
///      "type": "string"
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "marginRate": {
///      "description": "The margin rate override for the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"CLIENT_CONFIGURE\" in a ClientConfigureTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ClientConfigureTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The client-provided alias for the Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub alias: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The margin rate override for the Account.
    #[serde(
        rename = "marginRate",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_rate: Option<String>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The Type of the Transaction. Always set to "CLIENT_CONFIGURE" in a
    /// ClientConfigureTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<ClientConfigureTransactionType>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&ClientConfigureTransaction> for ClientConfigureTransaction {
    fn from(value: &ClientConfigureTransaction) -> Self {
        value.clone()
    }
}

impl ClientConfigureTransaction {
    pub fn builder() -> builder::ClientConfigureTransaction {
        Default::default()
    }
}

///The Type of the Transaction. Always set to "CLIENT_CONFIGURE" in a
/// ClientConfigureTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"CLIENT_CONFIGURE\" in a ClientConfigureTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ClientConfigureTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&ClientConfigureTransactionType> for ClientConfigureTransactionType {
    fn from(value: &ClientConfigureTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for ClientConfigureTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for ClientConfigureTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for ClientConfigureTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for ClientConfigureTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for ClientConfigureTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A ClientExtensions object allows a client to attach a clientID, tag and
/// comment to Orders and Trades in their Account.  Do not set, modify, or
/// delete this field if your account is associated with MT4.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A ClientExtensions object allows a client to attach a
/// clientID, tag and comment to Orders and Trades in their Account.  Do not
/// set, modify, or delete this field if your account is associated with
/// MT4.",
///  "type": "object",
///  "properties": {
///    "comment": {
///      "description": "A comment associated with the Order/Trade",
///      "type": "string"
///    },
///    "id": {
///      "description": "The Client ID of the Order/Trade",
///      "type": "string"
///    },
///    "tag": {
///      "description": "A tag associated with the Order/Trade",
///      "type": "string"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ClientExtensions {
    ///A comment associated with the Order/Trade
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    ///The Client ID of the Order/Trade
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///A tag associated with the Order/Trade
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tag: Option<String>,
}

impl From<&ClientExtensions> for ClientExtensions {
    fn from(value: &ClientExtensions) -> Self {
        value.clone()
    }
}

impl ClientExtensions {
    pub fn builder() -> builder::ClientExtensions {
        Default::default()
    }
}

///A client-provided identifier, used by clients to refer to their Orders
/// or Trades with an identifier that they have provided.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A client-provided identifier, used by clients to refer to their Orders or Trades with an identifier that they have provided.",
///  "type": "string"
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct ClientId(pub String);
impl std::ops::Deref for ClientId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl From<ClientId> for String {
    fn from(value: ClientId) -> Self {
        value.0
    }
}

impl From<&ClientId> for ClientId {
    fn from(value: &ClientId) -> Self {
        value.clone()
    }
}

impl From<String> for ClientId {
    fn from(value: String) -> Self {
        Self(value)
    }
}

impl std::str::FromStr for ClientId {
    type Err = std::convert::Infallible;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}

impl ToString for ClientId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

///The specification of an Account-specific Price.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The specification of an Account-specific Price.",
///  "type": "object",
///  "properties": {
///    "asks": {
///      "description": "The list of prices and liquidity available on the
/// Instrument's ask side. It is possible for this list to be empty if there
/// is no ask liquidity currently available for the Instrument in the
/// Account.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/PriceBucket"
///      }
///    },
///    "bids": {
///      "description": "The list of prices and liquidity available on the
/// Instrument's bid side. It is possible for this list to be empty if there
/// is no bid liquidity currently available for the Instrument in the
/// Account.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/PriceBucket"
///      }
///    },
///    "closeoutAsk": {
///      "description": "The closeout ask Price. This Price is used when a
/// ask is required to closeout a Position (margin closeout or manual) yet
/// there is no ask liquidity. The closeout ask is never used to open a new
/// position.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "closeoutBid": {
///      "description": "The closeout bid Price. This Price is used when a
/// bid is required to closeout a Position (margin closeout or manual) yet
/// there is no bid liquidity. The closeout bid is never used to open a new
/// position.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "instrument": {
///      "description": "The Price's Instrument.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "quoteHomeConversionFactors": {
///      "$ref": "#/components/schemas/QuoteHomeConversionFactors"
///    },
///    "status": {
///      "description": "The status of the Price.",
///      "type": "string",
///      "enum": [
///        "tradeable",
///        "non-tradeable",
///        "invalid"
///      ]
///    },
///    "time": {
///      "description": "The date/time when the Price was created",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "tradeable": {
///      "description": "Flag indicating if the Price is tradeable or not",
///      "type": "boolean"
///    },
///    "type": {
///      "description": "The string \"PRICE\". Used to identify the a Price
/// object when found in a stream.",
///      "type": "string"
///    },
///    "unitsAvailable": {
///      "$ref": "#/components/schemas/UnitsAvailable"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ClientPrice {
    ///The list of prices and liquidity available on the Instrument's ask
    /// side. It is possible for this list to be empty if there is no ask
    /// liquidity currently available for the Instrument in the Account.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub asks: Vec<PriceBucket>,
    ///The list of prices and liquidity available on the Instrument's bid
    /// side. It is possible for this list to be empty if there is no bid
    /// liquidity currently available for the Instrument in the Account.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub bids: Vec<PriceBucket>,
    ///The closeout ask Price. This Price is used when a ask is required to
    /// closeout a Position (margin closeout or manual) yet there is no ask
    /// liquidity. The closeout ask is never used to open a new position.
    #[serde(
        rename = "closeoutAsk",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub closeout_ask: Option<String>,
    ///The closeout bid Price. This Price is used when a bid is required to
    /// closeout a Position (margin closeout or manual) yet there is no bid
    /// liquidity. The closeout bid is never used to open a new position.
    #[serde(
        rename = "closeoutBid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub closeout_bid: Option<String>,
    ///The Price's Instrument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    #[serde(
        rename = "quoteHomeConversionFactors",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub quote_home_conversion_factors: Option<QuoteHomeConversionFactors>,
    ///The status of the Price.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<ClientPriceStatus>,
    ///The date/time when the Price was created
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///Flag indicating if the Price is tradeable or not
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tradeable: Option<bool>,
    ///The string "PRICE". Used to identify the a Price object when found
    /// in a stream.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
    #[serde(
        rename = "unitsAvailable",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub units_available: Option<UnitsAvailable>,
}

impl From<&ClientPrice> for ClientPrice {
    fn from(value: &ClientPrice) -> Self {
        value.clone()
    }
}

impl ClientPrice {
    pub fn builder() -> builder::ClientPrice {
        Default::default()
    }
}

///The status of the Price.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The status of the Price.",
///  "type": "string",
///  "enum": [
///    "tradeable",
///    "non-tradeable",
///    "invalid"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ClientPriceStatus {
    #[serde(rename = "tradeable")]
    Tradeable,
    #[serde(rename = "non-tradeable")]
    NonTradeable,
    #[serde(rename = "invalid")]
    Invalid,
}

impl From<&ClientPriceStatus> for ClientPriceStatus {
    fn from(value: &ClientPriceStatus) -> Self {
        value.clone()
    }
}

impl ToString for ClientPriceStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Tradeable => "tradeable".to_string(),
            Self::NonTradeable => "non-tradeable".to_string(),
            Self::Invalid => "invalid".to_string(),
        }
    }
}

impl std::str::FromStr for ClientPriceStatus {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "tradeable" => Ok(Self::Tradeable),
            "non-tradeable" => Ok(Self::NonTradeable),
            "invalid" => Ok(Self::Invalid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for ClientPriceStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for ClientPriceStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for ClientPriceStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A client provided request identifier.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A client provided request identifier.",
///  "type": "string"
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct ClientRequestId(pub String);
impl std::ops::Deref for ClientRequestId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl From<ClientRequestId> for String {
    fn from(value: ClientRequestId) -> Self {
        value.0
    }
}

impl From<&ClientRequestId> for ClientRequestId {
    fn from(value: &ClientRequestId) -> Self {
        value.clone()
    }
}

impl From<String> for ClientRequestId {
    fn from(value: String) -> Self {
        Self(value)
    }
}

impl std::str::FromStr for ClientRequestId {
    type Err = std::convert::Infallible;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}

impl ToString for ClientRequestId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

///A client-provided tag that can contain any data and may be assigned to
/// their Orders or Trades. Tags are typically used to associate groups of
/// Trades and/or Orders together.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A client-provided tag that can contain any data and may
/// be assigned to their Orders or Trades. Tags are typically used to
/// associate groups of Trades and/or Orders together.",
///  "type": "string"
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct ClientTag(pub String);
impl std::ops::Deref for ClientTag {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl From<ClientTag> for String {
    fn from(value: ClientTag) -> Self {
        value.0
    }
}

impl From<&ClientTag> for ClientTag {
    fn from(value: &ClientTag) -> Self {
        value.clone()
    }
}

impl From<String> for ClientTag {
    fn from(value: String) -> Self {
        Self(value)
    }
}

impl std::str::FromStr for ClientTag {
    type Err = std::convert::Infallible;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}

impl ToString for ClientTag {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

///ClosePositionBody
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "longClientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "longUnits": {
///      "description": "Indication of how much of the long Position to
/// closeout. Either the string \"ALL\", the string \"NONE\", or a
/// DecimalNumber representing how many units of the long position to close
/// using a PositionCloseout MarketOrder. The units specified must always be
/// positive.",
///      "type": "string"
///    },
///    "shortClientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "shortUnits": {
///      "description": "Indication of how much of the short Position to
/// closeout. Either the string \"ALL\", the string \"NONE\", or a
/// DecimalNumber representing how many units of the short position to close
/// using a PositionCloseout MarketOrder. The units specified must always be
/// positive.",
///      "type": "string"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ClosePositionBody {
    #[serde(
        rename = "longClientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub long_client_extensions: Option<ClientExtensions>,
    ///Indication of how much of the long Position to closeout. Either the
    /// string "ALL", the string "NONE", or a DecimalNumber representing how
    /// many units of the long position to close using a PositionCloseout
    /// MarketOrder. The units specified must always be positive.
    #[serde(rename = "longUnits", default, skip_serializing_if = "Option::is_none")]
    pub long_units: Option<String>,
    #[serde(
        rename = "shortClientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub short_client_extensions: Option<ClientExtensions>,
    ///Indication of how much of the short Position to closeout. Either the
    /// string "ALL", the string "NONE", or a DecimalNumber representing how
    /// many units of the short position to close using a PositionCloseout
    /// MarketOrder. The units specified must always be positive.
    #[serde(
        rename = "shortUnits",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub short_units: Option<String>,
}

impl From<&ClosePositionBody> for ClosePositionBody {
    fn from(value: &ClosePositionBody) -> Self {
        value.clone()
    }
}

impl ClosePositionBody {
    pub fn builder() -> builder::ClosePositionBody {
        Default::default()
    }
}

///ClosePositionResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "lastTransactionID": {
///      "description": "The ID of the most recent Transaction created for
/// the Account",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "longOrderCancelTransaction": {
///      "$ref": "#/components/schemas/OrderCancelTransaction"
///    },
///    "longOrderCreateTransaction": {
///      "$ref": "#/components/schemas/MarketOrderTransaction"
///    },
///    "longOrderFillTransaction": {
///      "$ref": "#/components/schemas/OrderFillTransaction"
///    },
///    "relatedTransactionIDs": {
///      "description": "The IDs of all Transactions that were created while
/// satisfying the request.",
///      "type": "array",
///      "items": {
///        "description": "The unique Transaction identifier within each
/// Account.",
///        "type": "string",
///        "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///      }
///    },
///    "shortOrderCancelTransaction": {
///      "$ref": "#/components/schemas/OrderCancelTransaction"
///    },
///    "shortOrderCreateTransaction": {
///      "$ref": "#/components/schemas/MarketOrderTransaction"
///    },
///    "shortOrderFillTransaction": {
///      "$ref": "#/components/schemas/OrderFillTransaction"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ClosePositionResponse {
    ///The ID of the most recent Transaction created for the Account
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
    #[serde(
        rename = "longOrderCancelTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub long_order_cancel_transaction: Option<OrderCancelTransaction>,
    #[serde(
        rename = "longOrderCreateTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub long_order_create_transaction: Option<MarketOrderTransaction>,
    #[serde(
        rename = "longOrderFillTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub long_order_fill_transaction: Option<OrderFillTransaction>,
    ///The IDs of all Transactions that were created while satisfying the
    /// request.
    #[serde(
        rename = "relatedTransactionIDs",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub related_transaction_i_ds: Vec<String>,
    #[serde(
        rename = "shortOrderCancelTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub short_order_cancel_transaction: Option<OrderCancelTransaction>,
    #[serde(
        rename = "shortOrderCreateTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub short_order_create_transaction: Option<MarketOrderTransaction>,
    #[serde(
        rename = "shortOrderFillTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub short_order_fill_transaction: Option<OrderFillTransaction>,
}

impl From<&ClosePositionResponse> for ClosePositionResponse {
    fn from(value: &ClosePositionResponse) -> Self {
        value.clone()
    }
}

impl ClosePositionResponse {
    pub fn builder() -> builder::ClosePositionResponse {
        Default::default()
    }
}

///CloseTradeBody
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "units": {
///      "description": "Indication of how much of the Trade to close.
/// Either the string \"ALL\" (indicating that all of the Trade should be
/// closed), or a DecimalNumber representing the number of units of the open
/// Trade to Close using a TradeClose MarketOrder. The units specified must
/// always be positive, and the magnitude of the value cannot exceed the
/// magnitude of the Trade's open units.",
///      "type": "string"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct CloseTradeBody {
    ///Indication of how much of the Trade to close. Either the string
    /// "ALL" (indicating that all of the Trade should be closed), or a
    /// DecimalNumber representing the number of units of the open Trade to
    /// Close using a TradeClose MarketOrder. The units specified must
    /// always be positive, and the magnitude of the value cannot exceed the
    /// magnitude of the Trade's open units.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<String>,
}

impl From<&CloseTradeBody> for CloseTradeBody {
    fn from(value: &CloseTradeBody) -> Self {
        value.clone()
    }
}

impl CloseTradeBody {
    pub fn builder() -> builder::CloseTradeBody {
        Default::default()
    }
}

///CloseTradeResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "lastTransactionID": {
///      "description": "The ID of the most recent Transaction created for
/// the Account",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "orderCancelTransaction": {
///      "$ref": "#/components/schemas/OrderCancelTransaction"
///    },
///    "orderCreateTransaction": {
///      "$ref": "#/components/schemas/MarketOrderTransaction"
///    },
///    "orderFillTransaction": {
///      "$ref": "#/components/schemas/OrderFillTransaction"
///    },
///    "relatedTransactionIDs": {
///      "description": "The IDs of all Transactions that were created while
/// satisfying the request.",
///      "type": "array",
///      "items": {
///        "description": "The unique Transaction identifier within each
/// Account.",
///        "type": "string",
///        "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///      }
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct CloseTradeResponse {
    ///The ID of the most recent Transaction created for the Account
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
    #[serde(
        rename = "orderCancelTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub order_cancel_transaction: Option<OrderCancelTransaction>,
    #[serde(
        rename = "orderCreateTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub order_create_transaction: Option<MarketOrderTransaction>,
    #[serde(
        rename = "orderFillTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub order_fill_transaction: Option<OrderFillTransaction>,
    ///The IDs of all Transactions that were created while satisfying the
    /// request.
    #[serde(
        rename = "relatedTransactionIDs",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub related_transaction_i_ds: Vec<String>,
}

impl From<&CloseTradeResponse> for CloseTradeResponse {
    fn from(value: &CloseTradeResponse) -> Self {
        value.clone()
    }
}

impl CloseTradeResponse {
    pub fn builder() -> builder::CloseTradeResponse {
        Default::default()
    }
}

///A CloseTransaction represents the closing of an Account.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A CloseTransaction represents the closing of an
/// Account.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"CLOSE\" in a CloseTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct CloseTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The Type of the Transaction. Always set to "CLOSE" in a
    /// CloseTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<CloseTransactionType>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&CloseTransaction> for CloseTransaction {
    fn from(value: &CloseTransaction) -> Self {
        value.clone()
    }
}

impl CloseTransaction {
    pub fn builder() -> builder::CloseTransaction {
        Default::default()
    }
}

///The Type of the Transaction. Always set to "CLOSE" in a
/// CloseTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to \"CLOSE\" in
/// a CloseTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CloseTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&CloseTransactionType> for CloseTransactionType {
    fn from(value: &CloseTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for CloseTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for CloseTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for CloseTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for CloseTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for CloseTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///ConfigureAccountBody
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "alias": {
///      "description": "Client-defined alias (name) for the Account",
///      "type": "string"
///    },
///    "marginRate": {
///      "description": "The string representation of a decimal number.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ConfigureAccountBody {
    ///Client-defined alias (name) for the Account
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub alias: Option<String>,
    ///The string representation of a decimal number.
    #[serde(
        rename = "marginRate",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_rate: Option<String>,
}

impl From<&ConfigureAccountBody> for ConfigureAccountBody {
    fn from(value: &ConfigureAccountBody) -> Self {
        value.clone()
    }
}

impl ConfigureAccountBody {
    pub fn builder() -> builder::ConfigureAccountBody {
        Default::default()
    }
}

///ConfigureAccountResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "clientConfigureTransaction": {
///      "$ref": "#/components/schemas/ClientConfigureTransaction"
///    },
///    "lastTransactionID": {
///      "description": "The ID of the last Transaction created for the
/// Account.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ConfigureAccountResponse {
    #[serde(
        rename = "clientConfigureTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_configure_transaction: Option<ClientConfigureTransaction>,
    ///The ID of the last Transaction created for the Account.
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
}

impl From<&ConfigureAccountResponse> for ConfigureAccountResponse {
    fn from(value: &ConfigureAccountResponse) -> Self {
        value.clone()
    }
}

impl ConfigureAccountResponse {
    pub fn builder() -> builder::ConfigureAccountResponse {
        Default::default()
    }
}

///CreateOrderBody
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "order": {
///      "$ref": "#/components/schemas/OrderRequest"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct CreateOrderBody {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub order: Option<OrderRequest>,
}

impl From<&CreateOrderBody> for CreateOrderBody {
    fn from(value: &CreateOrderBody) -> Self {
        value.clone()
    }
}

impl CreateOrderBody {
    pub fn builder() -> builder::CreateOrderBody {
        Default::default()
    }
}

///CreateOrderResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "lastTransactionID": {
///      "description": "The ID of the most recent Transaction created for
/// the Account",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "orderCancelTransaction": {
///      "$ref": "#/components/schemas/OrderCancelTransaction"
///    },
///    "orderCreateTransaction": {
///      "$ref": "#/components/schemas/Transaction"
///    },
///    "orderFillTransaction": {
///      "$ref": "#/components/schemas/OrderFillTransaction"
///    },
///    "orderReissueRejectTransaction": {
///      "$ref": "#/components/schemas/Transaction"
///    },
///    "orderReissueTransaction": {
///      "$ref": "#/components/schemas/Transaction"
///    },
///    "relatedTransactionIDs": {
///      "description": "The IDs of all Transactions that were created while
/// satisfying the request.",
///      "type": "array",
///      "items": {
///        "description": "The unique Transaction identifier within each
/// Account.",
///        "type": "string",
///        "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///      }
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct CreateOrderResponse {
    ///The ID of the most recent Transaction created for the Account
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
    #[serde(
        rename = "orderCancelTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub order_cancel_transaction: Option<OrderCancelTransaction>,
    #[serde(
        rename = "orderCreateTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub order_create_transaction: Option<Transaction>,
    #[serde(
        rename = "orderFillTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub order_fill_transaction: Option<OrderFillTransaction>,
    #[serde(
        rename = "orderReissueRejectTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub order_reissue_reject_transaction: Option<Transaction>,
    #[serde(
        rename = "orderReissueTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub order_reissue_transaction: Option<Transaction>,
    ///The IDs of all Transactions that were created while satisfying the
    /// request.
    #[serde(
        rename = "relatedTransactionIDs",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub related_transaction_i_ds: Vec<String>,
}

impl From<&CreateOrderResponse> for CreateOrderResponse {
    fn from(value: &CreateOrderResponse) -> Self {
        value.clone()
    }
}

impl CreateOrderResponse {
    pub fn builder() -> builder::CreateOrderResponse {
        Default::default()
    }
}

///A CreateTransaction represents the creation of an Account.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A CreateTransaction represents the creation of an
/// Account.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "accountNumber": {
///      "description": "The number of the Account within the
/// site/division/user",
///      "type": "integer"
///    },
///    "accountUserID": {
///      "description": "The ID of the user that the Account was created
/// for",
///      "type": "integer"
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "divisionID": {
///      "description": "The ID of the Division that the Account is in",
///      "type": "integer"
///    },
///    "homeCurrency": {
///      "description": "The home currency of the Account",
///      "type": "string",
///      "format": "A string containing an ISO 4217 currency (http://en.wikipedia.org/wiki/ISO_4217)"
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "siteID": {
///      "description": "The ID of the Site that the Account was created
/// at",
///      "type": "integer"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"CREATE\" in a CreateTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct CreateTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The number of the Account within the site/division/user
    #[serde(
        rename = "accountNumber",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub account_number: Option<i64>,
    ///The ID of the user that the Account was created for
    #[serde(
        rename = "accountUserID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub account_user_id: Option<i64>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    ///The ID of the Division that the Account is in
    #[serde(
        rename = "divisionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub division_id: Option<i64>,
    ///The home currency of the Account
    #[serde(
        rename = "homeCurrency",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub home_currency: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    ///The ID of the Site that the Account was created at
    #[serde(rename = "siteID", default, skip_serializing_if = "Option::is_none")]
    pub site_id: Option<i64>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The Type of the Transaction. Always set to "CREATE" in a
    /// CreateTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<CreateTransactionType>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&CreateTransaction> for CreateTransaction {
    fn from(value: &CreateTransaction) -> Self {
        value.clone()
    }
}

impl CreateTransaction {
    pub fn builder() -> builder::CreateTransaction {
        Default::default()
    }
}

///The Type of the Transaction. Always set to "CREATE" in a
/// CreateTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to \"CREATE\"
/// in a CreateTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CreateTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&CreateTransactionType> for CreateTransactionType {
    fn from(value: &CreateTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for CreateTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for CreateTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for CreateTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for CreateTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for CreateTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///Currency name identifier. Used by clients to refer to currencies.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Currency name identifier. Used by clients to refer to
/// currencies.",
///  "type": "string",
///  "format": "A string containing an ISO 4217 currency (http://en.wikipedia.org/wiki/ISO_4217)"
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct Currency(pub String);
impl std::ops::Deref for Currency {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl From<Currency> for String {
    fn from(value: Currency) -> Self {
        value.0
    }
}

impl From<&Currency> for Currency {
    fn from(value: &Currency) -> Self {
        value.clone()
    }
}

impl From<String> for Currency {
    fn from(value: String) -> Self {
        Self(value)
    }
}

impl std::str::FromStr for Currency {
    type Err = std::convert::Infallible;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}

impl ToString for Currency {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

///A DailyFinancingTransaction represents the daily payment/collection of
/// financing for an Account.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A DailyFinancingTransaction represents the daily
/// payment/collection of financing for an Account.",
///  "type": "object",
///  "properties": {
///    "accountBalance": {
///      "description": "The Account's balance after daily financing.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "accountFinancingMode": {
///      "description": "The account financing mode at the time of the daily
/// financing.",
///      "type": "string",
///      "enum": [
///        "NO_FINANCING",
///        "SECOND_BY_SECOND",
///        "DAILY"
///      ]
///    },
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "financing": {
///      "description": "The amount of financing paid/collected for the
/// Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "positionFinancings": {
///      "description": "The financing paid/collected for each Position in
/// the Account.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/PositionFinancing"
///      }
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"DAILY_FINANCING\" for a DailyFinancingTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct DailyFinancingTransaction {
    ///The Account's balance after daily financing.
    #[serde(
        rename = "accountBalance",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub account_balance: Option<String>,
    ///The account financing mode at the time of the daily financing.
    #[serde(
        rename = "accountFinancingMode",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub account_financing_mode: Option<DailyFinancingTransactionAccountFinancingMode>,
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    ///The amount of financing paid/collected for the Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub financing: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The financing paid/collected for each Position in the Account.
    #[serde(
        rename = "positionFinancings",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub position_financings: Vec<PositionFinancing>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The Type of the Transaction. Always set to "DAILY_FINANCING" for a
    /// DailyFinancingTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<DailyFinancingTransactionType>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&DailyFinancingTransaction> for DailyFinancingTransaction {
    fn from(value: &DailyFinancingTransaction) -> Self {
        value.clone()
    }
}

impl DailyFinancingTransaction {
    pub fn builder() -> builder::DailyFinancingTransaction {
        Default::default()
    }
}

///The account financing mode at the time of the daily financing.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The account financing mode at the time of the daily
/// financing.",
///  "type": "string",
///  "enum": [
///    "NO_FINANCING",
///    "SECOND_BY_SECOND",
///    "DAILY"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DailyFinancingTransactionAccountFinancingMode {
    #[serde(rename = "NO_FINANCING")]
    NoFinancing,
    #[serde(rename = "SECOND_BY_SECOND")]
    SecondBySecond,
    #[serde(rename = "DAILY")]
    Daily,
}

impl From<&DailyFinancingTransactionAccountFinancingMode>
    for DailyFinancingTransactionAccountFinancingMode
{
    fn from(value: &DailyFinancingTransactionAccountFinancingMode) -> Self {
        value.clone()
    }
}

impl ToString for DailyFinancingTransactionAccountFinancingMode {
    fn to_string(&self) -> String {
        match *self {
            Self::NoFinancing => "NO_FINANCING".to_string(),
            Self::SecondBySecond => "SECOND_BY_SECOND".to_string(),
            Self::Daily => "DAILY".to_string(),
        }
    }
}

impl std::str::FromStr for DailyFinancingTransactionAccountFinancingMode {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "NO_FINANCING" => Ok(Self::NoFinancing),
            "SECOND_BY_SECOND" => Ok(Self::SecondBySecond),
            "DAILY" => Ok(Self::Daily),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for DailyFinancingTransactionAccountFinancingMode {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for DailyFinancingTransactionAccountFinancingMode {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for DailyFinancingTransactionAccountFinancingMode {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Type of the Transaction. Always set to "DAILY_FINANCING" for a
/// DailyFinancingTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"DAILY_FINANCING\" for a DailyFinancingTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DailyFinancingTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&DailyFinancingTransactionType> for DailyFinancingTransactionType {
    fn from(value: &DailyFinancingTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for DailyFinancingTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for DailyFinancingTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for DailyFinancingTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for DailyFinancingTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for DailyFinancingTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A date and time value using either RFC3339 or UNIX time representation.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A date and time value using either RFC3339 or UNIX time
/// representation.",
///  "type": "string",
///  "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct DateTime(pub String);
impl std::ops::Deref for DateTime {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl From<DateTime> for String {
    fn from(value: DateTime) -> Self {
        value.0
    }
}

impl From<&DateTime> for DateTime {
    fn from(value: &DateTime) -> Self {
        value.clone()
    }
}

impl From<String> for DateTime {
    fn from(value: String) -> Self {
        Self(value)
    }
}

impl std::str::FromStr for DateTime {
    type Err = std::convert::Infallible;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}

impl ToString for DateTime {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

///The string representation of a decimal number.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The string representation of a decimal number.",
///  "type": "string",
///  "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct DecimalNumber(pub String);
impl std::ops::Deref for DecimalNumber {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl From<DecimalNumber> for String {
    fn from(value: DecimalNumber) -> Self {
        value.0
    }
}

impl From<&DecimalNumber> for DecimalNumber {
    fn from(value: &DecimalNumber) -> Self {
        value.clone()
    }
}

impl From<String> for DecimalNumber {
    fn from(value: String) -> Self {
        Self(value)
    }
}

impl std::str::FromStr for DecimalNumber {
    type Err = std::convert::Infallible;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}

impl ToString for DecimalNumber {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

///A DelayedTradeClosure Transaction is created administratively to
/// indicate open trades that should have been closed but weren't because
/// the open trades' instruments were untradeable at the time. Open trades
/// listed in this transaction will be closed once their respective
/// instruments become tradeable.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A DelayedTradeClosure Transaction is created
/// administratively to indicate open trades that should have been closed
/// but weren't because the open trades' instruments were untradeable at the
/// time. Open trades listed in this transaction will be closed once their
/// respective instruments become tradeable.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "reason": {
///      "description": "The reason for the delayed trade closure",
///      "type": "string",
///      "enum": [
///        "CLIENT_ORDER",
///        "TRADE_CLOSE",
///        "POSITION_CLOSEOUT",
///        "MARGIN_CLOSEOUT",
///        "DELAYED_TRADE_CLOSE"
///      ]
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "tradeIDs": {
///      "description": "List of Trade ID's identifying the open trades that
/// will be closed when their respective instruments become tradeable",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"DELAYED_TRADE_CLOSURE\" for an DelayedTradeClosureTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct DelayedTradeClosureTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The reason for the delayed trade closure
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<DelayedTradeClosureTransactionReason>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///List of Trade ID's identifying the open trades that will be closed
    /// when their respective instruments become tradeable
    #[serde(rename = "tradeIDs", default, skip_serializing_if = "Option::is_none")]
    pub trade_i_ds: Option<String>,
    ///The Type of the Transaction. Always set to "DELAYED_TRADE_CLOSURE"
    /// for an DelayedTradeClosureTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<DelayedTradeClosureTransactionType>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&DelayedTradeClosureTransaction> for DelayedTradeClosureTransaction {
    fn from(value: &DelayedTradeClosureTransaction) -> Self {
        value.clone()
    }
}

impl DelayedTradeClosureTransaction {
    pub fn builder() -> builder::DelayedTradeClosureTransaction {
        Default::default()
    }
}

///The reason for the delayed trade closure
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason for the delayed trade closure",
///  "type": "string",
///  "enum": [
///    "CLIENT_ORDER",
///    "TRADE_CLOSE",
///    "POSITION_CLOSEOUT",
///    "MARGIN_CLOSEOUT",
///    "DELAYED_TRADE_CLOSE"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DelayedTradeClosureTransactionReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "TRADE_CLOSE")]
    TradeClose,
    #[serde(rename = "POSITION_CLOSEOUT")]
    PositionCloseout,
    #[serde(rename = "MARGIN_CLOSEOUT")]
    MarginCloseout,
    #[serde(rename = "DELAYED_TRADE_CLOSE")]
    DelayedTradeClose,
}

impl From<&DelayedTradeClosureTransactionReason> for DelayedTradeClosureTransactionReason {
    fn from(value: &DelayedTradeClosureTransactionReason) -> Self {
        value.clone()
    }
}

impl ToString for DelayedTradeClosureTransactionReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ClientOrder => "CLIENT_ORDER".to_string(),
            Self::TradeClose => "TRADE_CLOSE".to_string(),
            Self::PositionCloseout => "POSITION_CLOSEOUT".to_string(),
            Self::MarginCloseout => "MARGIN_CLOSEOUT".to_string(),
            Self::DelayedTradeClose => "DELAYED_TRADE_CLOSE".to_string(),
        }
    }
}

impl std::str::FromStr for DelayedTradeClosureTransactionReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CLIENT_ORDER" => Ok(Self::ClientOrder),
            "TRADE_CLOSE" => Ok(Self::TradeClose),
            "POSITION_CLOSEOUT" => Ok(Self::PositionCloseout),
            "MARGIN_CLOSEOUT" => Ok(Self::MarginCloseout),
            "DELAYED_TRADE_CLOSE" => Ok(Self::DelayedTradeClose),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for DelayedTradeClosureTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for DelayedTradeClosureTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for DelayedTradeClosureTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Type of the Transaction. Always set to "DELAYED_TRADE_CLOSURE" for
/// an DelayedTradeClosureTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"DELAYED_TRADE_CLOSURE\" for an DelayedTradeClosureTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DelayedTradeClosureTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&DelayedTradeClosureTransactionType> for DelayedTradeClosureTransactionType {
    fn from(value: &DelayedTradeClosureTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for DelayedTradeClosureTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for DelayedTradeClosureTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for DelayedTradeClosureTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for DelayedTradeClosureTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for DelayedTradeClosureTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///In the context of an Order or a Trade, defines whether the units are
/// positive or negative.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "In the context of an Order or a Trade, defines whether
/// the units are positive or negative.",
///  "type": "string",
///  "enum": [
///    "LONG",
///    "SHORT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum Direction {
    #[serde(rename = "LONG")]
    Long,
    #[serde(rename = "SHORT")]
    Short,
}

impl From<&Direction> for Direction {
    fn from(value: &Direction) -> Self {
        value.clone()
    }
}

impl ToString for Direction {
    fn to_string(&self) -> String {
        match *self {
            Self::Long => "LONG".to_string(),
            Self::Short => "SHORT".to_string(),
        }
    }
}

impl std::str::FromStr for Direction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "LONG" => Ok(Self::Long),
            "SHORT" => Ok(Self::Short),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The dynamic state of an Order. This is only relevant to TrailingStopLoss
/// Orders, as no other Order type has dynamic state.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The dynamic state of an Order. This is only relevant to
/// TrailingStopLoss Orders, as no other Order type has dynamic state.",
///  "type": "object",
///  "properties": {
///    "id": {
///      "description": "The Order's ID.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "isTriggerDistanceExact": {
///      "description": "True if an exact trigger distance could be
/// calculated. If false, it means the provided trigger distance is a best
/// estimate. If the distance could not be determined, this value will not
/// be set.",
///      "type": "boolean"
///    },
///    "trailingStopValue": {
///      "description": "The Order's calculated trailing stop value.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "triggerDistance": {
///      "description": "The distance between the Trailing Stop Loss Order's
/// trailingStopValue and the current Market Price. This represents the
/// distance (in price units) of the Order from a triggering price. If the
/// distance could not be determined, this value will not be set.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct DynamicOrderState {
    ///The Order's ID.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///True if an exact trigger distance could be calculated. If false, it
    /// means the provided trigger distance is a best estimate. If the
    /// distance could not be determined, this value will not be set.
    #[serde(
        rename = "isTriggerDistanceExact",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub is_trigger_distance_exact: Option<bool>,
    ///The Order's calculated trailing stop value.
    #[serde(
        rename = "trailingStopValue",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_value: Option<String>,
    ///The distance between the Trailing Stop Loss Order's
    /// trailingStopValue and the current Market Price. This represents the
    /// distance (in price units) of the Order from a triggering price. If
    /// the distance could not be determined, this value will not be set.
    #[serde(
        rename = "triggerDistance",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trigger_distance: Option<String>,
}

impl From<&DynamicOrderState> for DynamicOrderState {
    fn from(value: &DynamicOrderState) -> Self {
        value.clone()
    }
}

impl DynamicOrderState {
    pub fn builder() -> builder::DynamicOrderState {
        Default::default()
    }
}

///A FixedPriceOrder is an order that is filled immediately upon creation
/// using a fixed price.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A FixedPriceOrder is an order that is filled
/// immediately upon creation using a fixed price.",
///  "type": "object",
///  "properties": {
///    "cancelledTime": {
///      "description": "Date/time when the Order was cancelled (only
/// provided when the state of the Order is CANCELLED)",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "cancellingTransactionID": {
///      "description": "ID of the Transaction that cancelled the Order
/// (only provided when the Order's state is CANCELLED)",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "createTime": {
///      "description": "The time when the Order was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "filledTime": {
///      "description": "Date/time when the Order was filled (only provided
/// when the Order's state is FILLED)",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "fillingTransactionID": {
///      "description": "ID of the Transaction that filled this Order (only
/// provided when the Order's state is FILLED)",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "id": {
///      "description": "The Order's identifier, unique within the Order's
/// Account.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "instrument": {
///      "description": "The Fixed Price Order's Instrument.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "positionFill": {
///      "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///      "type": "string",
///      "enum": [
///        "OPEN_ONLY",
///        "REDUCE_FIRST",
///        "REDUCE_ONLY",
///        "DEFAULT"
///      ]
///    },
///    "price": {
///      "description": "The price specified for the Fixed Price Order. This price is the exact price that the Fixed Price Order will be filled at.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "state": {
///      "description": "The current state of the Order.",
///      "type": "string",
///      "enum": [
///        "PENDING",
///        "FILLED",
///        "TRIGGERED",
///        "CANCELLED"
///      ]
///    },
///    "stopLossOnFill": {
///      "$ref": "#/components/schemas/StopLossDetails"
///    },
///    "takeProfitOnFill": {
///      "$ref": "#/components/schemas/TakeProfitDetails"
///    },
///    "tradeClientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "tradeClosedIDs": {
///      "description": "Trade IDs of Trades closed when the Order was
/// filled (only provided when the Order's state is FILLED and one or more
/// Trades were closed as a result of the fill)",
///      "type": "array",
///      "items": {
///        "description": "The Trade's identifier, unique within the Trade's
/// Account.",
///        "type": "string",
///        "format": "The string representation of the OANDA-assigned
/// TradeID. OANDA-assigned TradeIDs are positive integers, and are derived
/// from the TransactionID of the Transaction that opened the Trade."
///      }
///    },
///    "tradeOpenedID": {
///      "description": "Trade ID of Trade opened when the Order was filled
/// (only provided when the Order's state is FILLED and a Trade was opened
/// as a result of the fill)",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "tradeReducedID": {
///      "description": "Trade ID of Trade reduced when the Order was filled
/// (only provided when the Order's state is FILLED and a Trade was reduced
/// as a result of the fill)",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "tradeState": {
///      "description": "The state that the trade resulting from the Fixed
/// Price Order should be set to.",
///      "type": "string"
///    },
///    "trailingStopLossOnFill": {
///      "$ref": "#/components/schemas/TrailingStopLossDetails"
///    },
///    "type": {
///      "description": "The type of the Order. Always set to
/// \"FIXED_PRICE\" for Fixed Price Orders.",
///      "type": "string",
///      "enum": [
///        "MARKET",
///        "LIMIT",
///        "STOP",
///        "MARKET_IF_TOUCHED",
///        "TAKE_PROFIT",
///        "STOP_LOSS",
///        "TRAILING_STOP_LOSS",
///        "FIXED_PRICE"
///      ]
///    },
///    "units": {
///      "description": "The quantity requested to be filled by the Fixed
/// Price Order. A posititive number of units results in a long Order, and a
/// negative number of units results in a short Order.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct FixedPriceOrder {
    ///Date/time when the Order was cancelled (only provided when the state
    /// of the Order is CANCELLED)
    #[serde(
        rename = "cancelledTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelled_time: Option<String>,
    ///ID of the Transaction that cancelled the Order (only provided when
    /// the Order's state is CANCELLED)
    #[serde(
        rename = "cancellingTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The time when the Order was created.
    #[serde(
        rename = "createTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub create_time: Option<String>,
    ///Date/time when the Order was filled (only provided when the Order's
    /// state is FILLED)
    #[serde(
        rename = "filledTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub filled_time: Option<String>,
    ///ID of the Transaction that filled this Order (only provided when the
    /// Order's state is FILLED)
    #[serde(
        rename = "fillingTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub filling_transaction_id: Option<String>,
    ///The Order's identifier, unique within the Order's Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The Fixed Price Order's Instrument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    ///Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(
        rename = "positionFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub position_fill: Option<FixedPriceOrderPositionFill>,
    ///The price specified for the Fixed Price Order. This price is the
    /// exact price that the Fixed Price Order will be filled at.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The current state of the Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<FixedPriceOrderState>,
    #[serde(
        rename = "stopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stop_loss_on_fill: Option<StopLossDetails>,
    #[serde(
        rename = "takeProfitOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub take_profit_on_fill: Option<TakeProfitDetails>,
    #[serde(
        rename = "tradeClientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,
    ///Trade IDs of Trades closed when the Order was filled (only provided
    /// when the Order's state is FILLED and one or more Trades were closed
    /// as a result of the fill)
    #[serde(
        rename = "tradeClosedIDs",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub trade_closed_i_ds: Vec<String>,
    ///Trade ID of Trade opened when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was opened as a result
    /// of the fill)
    #[serde(
        rename = "tradeOpenedID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_opened_id: Option<String>,
    ///Trade ID of Trade reduced when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was reduced as a result
    /// of the fill)
    #[serde(
        rename = "tradeReducedID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_reduced_id: Option<String>,
    ///The state that the trade resulting from the Fixed Price Order should
    /// be set to.
    #[serde(
        rename = "tradeState",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_state: Option<String>,
    #[serde(
        rename = "trailingStopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,
    ///The type of the Order. Always set to "FIXED_PRICE" for Fixed Price
    /// Orders.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<FixedPriceOrderType>,
    ///The quantity requested to be filled by the Fixed Price Order. A
    /// posititive number of units results in a long Order, and a negative
    /// number of units results in a short Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<String>,
}

impl From<&FixedPriceOrder> for FixedPriceOrder {
    fn from(value: &FixedPriceOrder) -> Self {
        value.clone()
    }
}

impl FixedPriceOrder {
    pub fn builder() -> builder::FixedPriceOrder {
        Default::default()
    }
}

///Specification of how Positions in the Account are modified when the
/// Order is filled.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///  "type": "string",
///  "enum": [
///    "OPEN_ONLY",
///    "REDUCE_FIRST",
///    "REDUCE_ONLY",
///    "DEFAULT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum FixedPriceOrderPositionFill {
    #[serde(rename = "OPEN_ONLY")]
    OpenOnly,
    #[serde(rename = "REDUCE_FIRST")]
    ReduceFirst,
    #[serde(rename = "REDUCE_ONLY")]
    ReduceOnly,
    #[serde(rename = "DEFAULT")]
    Default,
}

impl From<&FixedPriceOrderPositionFill> for FixedPriceOrderPositionFill {
    fn from(value: &FixedPriceOrderPositionFill) -> Self {
        value.clone()
    }
}

impl ToString for FixedPriceOrderPositionFill {
    fn to_string(&self) -> String {
        match *self {
            Self::OpenOnly => "OPEN_ONLY".to_string(),
            Self::ReduceFirst => "REDUCE_FIRST".to_string(),
            Self::ReduceOnly => "REDUCE_ONLY".to_string(),
            Self::Default => "DEFAULT".to_string(),
        }
    }
}

impl std::str::FromStr for FixedPriceOrderPositionFill {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "OPEN_ONLY" => Ok(Self::OpenOnly),
            "REDUCE_FIRST" => Ok(Self::ReduceFirst),
            "REDUCE_ONLY" => Ok(Self::ReduceOnly),
            "DEFAULT" => Ok(Self::Default),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for FixedPriceOrderPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for FixedPriceOrderPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for FixedPriceOrderPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The reason that the Fixed Price Order was created
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Fixed Price Order was created",
///  "type": "string",
///  "enum": [
///    "PLATFORM_ACCOUNT_MIGRATION"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum FixedPriceOrderReason {
    #[serde(rename = "PLATFORM_ACCOUNT_MIGRATION")]
    PlatformAccountMigration,
}

impl From<&FixedPriceOrderReason> for FixedPriceOrderReason {
    fn from(value: &FixedPriceOrderReason) -> Self {
        value.clone()
    }
}

impl ToString for FixedPriceOrderReason {
    fn to_string(&self) -> String {
        match *self {
            Self::PlatformAccountMigration => "PLATFORM_ACCOUNT_MIGRATION".to_string(),
        }
    }
}

impl std::str::FromStr for FixedPriceOrderReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "PLATFORM_ACCOUNT_MIGRATION" => Ok(Self::PlatformAccountMigration),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for FixedPriceOrderReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for FixedPriceOrderReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for FixedPriceOrderReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The current state of the Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The current state of the Order.",
///  "type": "string",
///  "enum": [
///    "PENDING",
///    "FILLED",
///    "TRIGGERED",
///    "CANCELLED"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum FixedPriceOrderState {
    #[serde(rename = "PENDING")]
    Pending,
    #[serde(rename = "FILLED")]
    Filled,
    #[serde(rename = "TRIGGERED")]
    Triggered,
    #[serde(rename = "CANCELLED")]
    Cancelled,
}

impl From<&FixedPriceOrderState> for FixedPriceOrderState {
    fn from(value: &FixedPriceOrderState) -> Self {
        value.clone()
    }
}

impl ToString for FixedPriceOrderState {
    fn to_string(&self) -> String {
        match *self {
            Self::Pending => "PENDING".to_string(),
            Self::Filled => "FILLED".to_string(),
            Self::Triggered => "TRIGGERED".to_string(),
            Self::Cancelled => "CANCELLED".to_string(),
        }
    }
}

impl std::str::FromStr for FixedPriceOrderState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "PENDING" => Ok(Self::Pending),
            "FILLED" => Ok(Self::Filled),
            "TRIGGERED" => Ok(Self::Triggered),
            "CANCELLED" => Ok(Self::Cancelled),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for FixedPriceOrderState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for FixedPriceOrderState {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for FixedPriceOrderState {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A FixedPriceOrderTransaction represents the creation of a Fixed Price
/// Order in the user's account. A Fixed Price Order is an Order that is
/// filled immediately at a specified price.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A FixedPriceOrderTransaction represents the creation of
/// a Fixed Price Order in the user's account. A Fixed Price Order is an
/// Order that is filled immediately at a specified price.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "instrument": {
///      "description": "The Fixed Price Order's Instrument.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "positionFill": {
///      "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///      "type": "string",
///      "enum": [
///        "OPEN_ONLY",
///        "REDUCE_FIRST",
///        "REDUCE_ONLY",
///        "DEFAULT"
///      ]
///    },
///    "price": {
///      "description": "The price specified for the Fixed Price Order. This price is the exact price that the Fixed Price Order will be filled at.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "reason": {
///      "description": "The reason that the Fixed Price Order was created",
///      "type": "string",
///      "enum": [
///        "PLATFORM_ACCOUNT_MIGRATION"
///      ]
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "stopLossOnFill": {
///      "$ref": "#/components/schemas/StopLossDetails"
///    },
///    "takeProfitOnFill": {
///      "$ref": "#/components/schemas/TakeProfitDetails"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "tradeClientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "tradeState": {
///      "description": "The state that the trade resulting from the Fixed
/// Price Order should be set to.",
///      "type": "string"
///    },
///    "trailingStopLossOnFill": {
///      "$ref": "#/components/schemas/TrailingStopLossDetails"
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"FIXED_PRICE_ORDER\" in a FixedPriceOrderTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "units": {
///      "description": "The quantity requested to be filled by the Fixed
/// Price Order. A posititive number of units results in a long Order, and a
/// negative number of units results in a short Order.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct FixedPriceOrderTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The Fixed Price Order's Instrument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    ///Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(
        rename = "positionFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub position_fill: Option<FixedPriceOrderTransactionPositionFill>,
    ///The price specified for the Fixed Price Order. This price is the
    /// exact price that the Fixed Price Order will be filled at.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The reason that the Fixed Price Order was created
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<FixedPriceOrderTransactionReason>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    #[serde(
        rename = "stopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stop_loss_on_fill: Option<StopLossDetails>,
    #[serde(
        rename = "takeProfitOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub take_profit_on_fill: Option<TakeProfitDetails>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    #[serde(
        rename = "tradeClientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,
    ///The state that the trade resulting from the Fixed Price Order should
    /// be set to.
    #[serde(
        rename = "tradeState",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_state: Option<String>,
    #[serde(
        rename = "trailingStopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,
    ///The Type of the Transaction. Always set to "FIXED_PRICE_ORDER" in a
    /// FixedPriceOrderTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<FixedPriceOrderTransactionType>,
    ///The quantity requested to be filled by the Fixed Price Order. A
    /// posititive number of units results in a long Order, and a negative
    /// number of units results in a short Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<String>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&FixedPriceOrderTransaction> for FixedPriceOrderTransaction {
    fn from(value: &FixedPriceOrderTransaction) -> Self {
        value.clone()
    }
}

impl FixedPriceOrderTransaction {
    pub fn builder() -> builder::FixedPriceOrderTransaction {
        Default::default()
    }
}

///Specification of how Positions in the Account are modified when the
/// Order is filled.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///  "type": "string",
///  "enum": [
///    "OPEN_ONLY",
///    "REDUCE_FIRST",
///    "REDUCE_ONLY",
///    "DEFAULT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum FixedPriceOrderTransactionPositionFill {
    #[serde(rename = "OPEN_ONLY")]
    OpenOnly,
    #[serde(rename = "REDUCE_FIRST")]
    ReduceFirst,
    #[serde(rename = "REDUCE_ONLY")]
    ReduceOnly,
    #[serde(rename = "DEFAULT")]
    Default,
}

impl From<&FixedPriceOrderTransactionPositionFill> for FixedPriceOrderTransactionPositionFill {
    fn from(value: &FixedPriceOrderTransactionPositionFill) -> Self {
        value.clone()
    }
}

impl ToString for FixedPriceOrderTransactionPositionFill {
    fn to_string(&self) -> String {
        match *self {
            Self::OpenOnly => "OPEN_ONLY".to_string(),
            Self::ReduceFirst => "REDUCE_FIRST".to_string(),
            Self::ReduceOnly => "REDUCE_ONLY".to_string(),
            Self::Default => "DEFAULT".to_string(),
        }
    }
}

impl std::str::FromStr for FixedPriceOrderTransactionPositionFill {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "OPEN_ONLY" => Ok(Self::OpenOnly),
            "REDUCE_FIRST" => Ok(Self::ReduceFirst),
            "REDUCE_ONLY" => Ok(Self::ReduceOnly),
            "DEFAULT" => Ok(Self::Default),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for FixedPriceOrderTransactionPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for FixedPriceOrderTransactionPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for FixedPriceOrderTransactionPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The reason that the Fixed Price Order was created
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Fixed Price Order was created",
///  "type": "string",
///  "enum": [
///    "PLATFORM_ACCOUNT_MIGRATION"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum FixedPriceOrderTransactionReason {
    #[serde(rename = "PLATFORM_ACCOUNT_MIGRATION")]
    PlatformAccountMigration,
}

impl From<&FixedPriceOrderTransactionReason> for FixedPriceOrderTransactionReason {
    fn from(value: &FixedPriceOrderTransactionReason) -> Self {
        value.clone()
    }
}

impl ToString for FixedPriceOrderTransactionReason {
    fn to_string(&self) -> String {
        match *self {
            Self::PlatformAccountMigration => "PLATFORM_ACCOUNT_MIGRATION".to_string(),
        }
    }
}

impl std::str::FromStr for FixedPriceOrderTransactionReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "PLATFORM_ACCOUNT_MIGRATION" => Ok(Self::PlatformAccountMigration),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for FixedPriceOrderTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for FixedPriceOrderTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for FixedPriceOrderTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Type of the Transaction. Always set to "FIXED_PRICE_ORDER" in a
/// FixedPriceOrderTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"FIXED_PRICE_ORDER\" in a FixedPriceOrderTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum FixedPriceOrderTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&FixedPriceOrderTransactionType> for FixedPriceOrderTransactionType {
    fn from(value: &FixedPriceOrderTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for FixedPriceOrderTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for FixedPriceOrderTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for FixedPriceOrderTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for FixedPriceOrderTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for FixedPriceOrderTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The type of the Order. Always set to "FIXED_PRICE" for Fixed Price
/// Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The type of the Order. Always set to \"FIXED_PRICE\"
/// for Fixed Price Orders.",
///  "type": "string",
///  "enum": [
///    "MARKET",
///    "LIMIT",
///    "STOP",
///    "MARKET_IF_TOUCHED",
///    "TAKE_PROFIT",
///    "STOP_LOSS",
///    "TRAILING_STOP_LOSS",
///    "FIXED_PRICE"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum FixedPriceOrderType {
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "STOP")]
    Stop,
    #[serde(rename = "MARKET_IF_TOUCHED")]
    MarketIfTouched,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "STOP_LOSS")]
    StopLoss,
    #[serde(rename = "TRAILING_STOP_LOSS")]
    TrailingStopLoss,
    #[serde(rename = "FIXED_PRICE")]
    FixedPrice,
}

impl From<&FixedPriceOrderType> for FixedPriceOrderType {
    fn from(value: &FixedPriceOrderType) -> Self {
        value.clone()
    }
}

impl ToString for FixedPriceOrderType {
    fn to_string(&self) -> String {
        match *self {
            Self::Market => "MARKET".to_string(),
            Self::Limit => "LIMIT".to_string(),
            Self::Stop => "STOP".to_string(),
            Self::MarketIfTouched => "MARKET_IF_TOUCHED".to_string(),
            Self::TakeProfit => "TAKE_PROFIT".to_string(),
            Self::StopLoss => "STOP_LOSS".to_string(),
            Self::TrailingStopLoss => "TRAILING_STOP_LOSS".to_string(),
            Self::FixedPrice => "FIXED_PRICE".to_string(),
        }
    }
}

impl std::str::FromStr for FixedPriceOrderType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "MARKET" => Ok(Self::Market),
            "LIMIT" => Ok(Self::Limit),
            "STOP" => Ok(Self::Stop),
            "MARKET_IF_TOUCHED" => Ok(Self::MarketIfTouched),
            "TAKE_PROFIT" => Ok(Self::TakeProfit),
            "STOP_LOSS" => Ok(Self::StopLoss),
            "TRAILING_STOP_LOSS" => Ok(Self::TrailingStopLoss),
            "FIXED_PRICE" => Ok(Self::FixedPrice),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for FixedPriceOrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for FixedPriceOrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for FixedPriceOrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The reason that an Account is being funded.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that an Account is being funded.",
///  "type": "string",
///  "enum": [
///    "CLIENT_FUNDING",
///    "ACCOUNT_TRANSFER",
///    "DIVISION_MIGRATION",
///    "SITE_MIGRATION",
///    "ADJUSTMENT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum FundingReason {
    #[serde(rename = "CLIENT_FUNDING")]
    ClientFunding,
    #[serde(rename = "ACCOUNT_TRANSFER")]
    AccountTransfer,
    #[serde(rename = "DIVISION_MIGRATION")]
    DivisionMigration,
    #[serde(rename = "SITE_MIGRATION")]
    SiteMigration,
    #[serde(rename = "ADJUSTMENT")]
    Adjustment,
}

impl From<&FundingReason> for FundingReason {
    fn from(value: &FundingReason) -> Self {
        value.clone()
    }
}

impl ToString for FundingReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ClientFunding => "CLIENT_FUNDING".to_string(),
            Self::AccountTransfer => "ACCOUNT_TRANSFER".to_string(),
            Self::DivisionMigration => "DIVISION_MIGRATION".to_string(),
            Self::SiteMigration => "SITE_MIGRATION".to_string(),
            Self::Adjustment => "ADJUSTMENT".to_string(),
        }
    }
}

impl std::str::FromStr for FundingReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CLIENT_FUNDING" => Ok(Self::ClientFunding),
            "ACCOUNT_TRANSFER" => Ok(Self::AccountTransfer),
            "DIVISION_MIGRATION" => Ok(Self::DivisionMigration),
            "SITE_MIGRATION" => Ok(Self::SiteMigration),
            "ADJUSTMENT" => Ok(Self::Adjustment),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for FundingReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for FundingReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for FundingReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///GetAccountChangesResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "changes": {
///      "$ref": "#/components/schemas/AccountChanges"
///    },
///    "lastTransactionID": {
///      "description": "The ID of the last Transaction created for the Account.  This Transaction ID should be used for future poll requests, as the client has already observed all changes up to and including it.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "state": {
///      "$ref": "#/components/schemas/AccountChangesState"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GetAccountChangesResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub changes: Option<AccountChanges>,
    ///The ID of the last Transaction created for the Account.  This
    /// Transaction ID should be used for future poll requests, as the
    /// client has already observed all changes up to and including it.
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<AccountChangesState>,
}

impl From<&GetAccountChangesResponse> for GetAccountChangesResponse {
    fn from(value: &GetAccountChangesResponse) -> Self {
        value.clone()
    }
}

impl GetAccountChangesResponse {
    pub fn builder() -> builder::GetAccountChangesResponse {
        Default::default()
    }
}

///GetAccountInstrumentCandlesResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "candles": {
///      "description": "The list of candlesticks that satisfy the
/// request.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/Candlestick"
///      }
///    },
///    "granularity": {
///      "description": "The granularity of the candlesticks provided.",
///      "type": "string",
///      "enum": [
///        "S5",
///        "S10",
///        "S15",
///        "S30",
///        "M1",
///        "M2",
///        "M4",
///        "M5",
///        "M10",
///        "M15",
///        "M30",
///        "H1",
///        "H2",
///        "H3",
///        "H4",
///        "H6",
///        "H8",
///        "H12",
///        "D",
///        "W",
///        "M"
///      ]
///    },
///    "instrument": {
///      "description": "The instrument whose Prices are represented by the
/// candlesticks.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GetAccountInstrumentCandlesResponse {
    ///The list of candlesticks that satisfy the request.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub candles: Vec<Candlestick>,
    ///The granularity of the candlesticks provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub granularity: Option<GetAccountInstrumentCandlesResponseGranularity>,
    ///The instrument whose Prices are represented by the candlesticks.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
}

impl From<&GetAccountInstrumentCandlesResponse> for GetAccountInstrumentCandlesResponse {
    fn from(value: &GetAccountInstrumentCandlesResponse) -> Self {
        value.clone()
    }
}

impl GetAccountInstrumentCandlesResponse {
    pub fn builder() -> builder::GetAccountInstrumentCandlesResponse {
        Default::default()
    }
}

///The granularity of the candlesticks provided.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The granularity of the candlesticks provided.",
///  "type": "string",
///  "enum": [
///    "S5",
///    "S10",
///    "S15",
///    "S30",
///    "M1",
///    "M2",
///    "M4",
///    "M5",
///    "M10",
///    "M15",
///    "M30",
///    "H1",
///    "H2",
///    "H3",
///    "H4",
///    "H6",
///    "H8",
///    "H12",
///    "D",
///    "W",
///    "M"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum GetAccountInstrumentCandlesResponseGranularity {
    S5,
    S10,
    S15,
    S30,
    M1,
    M2,
    M4,
    M5,
    M10,
    M15,
    M30,
    H1,
    H2,
    H3,
    H4,
    H6,
    H8,
    H12,
    D,
    W,
    M,
}

impl From<&GetAccountInstrumentCandlesResponseGranularity>
    for GetAccountInstrumentCandlesResponseGranularity
{
    fn from(value: &GetAccountInstrumentCandlesResponseGranularity) -> Self {
        value.clone()
    }
}

impl ToString for GetAccountInstrumentCandlesResponseGranularity {
    fn to_string(&self) -> String {
        match *self {
            Self::S5 => "S5".to_string(),
            Self::S10 => "S10".to_string(),
            Self::S15 => "S15".to_string(),
            Self::S30 => "S30".to_string(),
            Self::M1 => "M1".to_string(),
            Self::M2 => "M2".to_string(),
            Self::M4 => "M4".to_string(),
            Self::M5 => "M5".to_string(),
            Self::M10 => "M10".to_string(),
            Self::M15 => "M15".to_string(),
            Self::M30 => "M30".to_string(),
            Self::H1 => "H1".to_string(),
            Self::H2 => "H2".to_string(),
            Self::H3 => "H3".to_string(),
            Self::H4 => "H4".to_string(),
            Self::H6 => "H6".to_string(),
            Self::H8 => "H8".to_string(),
            Self::H12 => "H12".to_string(),
            Self::D => "D".to_string(),
            Self::W => "W".to_string(),
            Self::M => "M".to_string(),
        }
    }
}

impl std::str::FromStr for GetAccountInstrumentCandlesResponseGranularity {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "S5" => Ok(Self::S5),
            "S10" => Ok(Self::S10),
            "S15" => Ok(Self::S15),
            "S30" => Ok(Self::S30),
            "M1" => Ok(Self::M1),
            "M2" => Ok(Self::M2),
            "M4" => Ok(Self::M4),
            "M5" => Ok(Self::M5),
            "M10" => Ok(Self::M10),
            "M15" => Ok(Self::M15),
            "M30" => Ok(Self::M30),
            "H1" => Ok(Self::H1),
            "H2" => Ok(Self::H2),
            "H3" => Ok(Self::H3),
            "H4" => Ok(Self::H4),
            "H6" => Ok(Self::H6),
            "H8" => Ok(Self::H8),
            "H12" => Ok(Self::H12),
            "D" => Ok(Self::D),
            "W" => Ok(Self::W),
            "M" => Ok(Self::M),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for GetAccountInstrumentCandlesResponseGranularity {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for GetAccountInstrumentCandlesResponseGranularity {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for GetAccountInstrumentCandlesResponseGranularity {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///GetAccountInstrumentsResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "instruments": {
///      "description": "The requested list of instruments.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/Instrument"
///      }
///    },
///    "lastTransactionID": {
///      "description": "The ID of the most recent Transaction created for
/// the Account.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GetAccountInstrumentsResponse {
    ///The requested list of instruments.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub instruments: Vec<Instrument>,
    ///The ID of the most recent Transaction created for the Account.
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
}

impl From<&GetAccountInstrumentsResponse> for GetAccountInstrumentsResponse {
    fn from(value: &GetAccountInstrumentsResponse) -> Self {
        value.clone()
    }
}

impl GetAccountInstrumentsResponse {
    pub fn builder() -> builder::GetAccountInstrumentsResponse {
        Default::default()
    }
}

///GetAccountResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "account": {
///      "$ref": "#/components/schemas/Account"
///    },
///    "lastTransactionID": {
///      "description": "The ID of the most recent Transaction created for
/// the Account.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GetAccountResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account: Option<Account>,
    ///The ID of the most recent Transaction created for the Account.
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
}

impl From<&GetAccountResponse> for GetAccountResponse {
    fn from(value: &GetAccountResponse) -> Self {
        value.clone()
    }
}

impl GetAccountResponse {
    pub fn builder() -> builder::GetAccountResponse {
        Default::default()
    }
}

///GetAccountSummaryResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "account": {
///      "$ref": "#/components/schemas/AccountSummary"
///    },
///    "lastTransactionID": {
///      "description": "The ID of the most recent Transaction created for
/// the Account.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GetAccountSummaryResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub account: Option<AccountSummary>,
    ///The ID of the most recent Transaction created for the Account.
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
}

impl From<&GetAccountSummaryResponse> for GetAccountSummaryResponse {
    fn from(value: &GetAccountSummaryResponse) -> Self {
        value.clone()
    }
}

impl GetAccountSummaryResponse {
    pub fn builder() -> builder::GetAccountSummaryResponse {
        Default::default()
    }
}

///GetInstrumentCandlesResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "candles": {
///      "description": "The list of candlesticks that satisfy the
/// request.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/Candlestick"
///      }
///    },
///    "granularity": {
///      "description": "The granularity of the candlesticks provided.",
///      "type": "string",
///      "enum": [
///        "S5",
///        "S10",
///        "S15",
///        "S30",
///        "M1",
///        "M2",
///        "M4",
///        "M5",
///        "M10",
///        "M15",
///        "M30",
///        "H1",
///        "H2",
///        "H3",
///        "H4",
///        "H6",
///        "H8",
///        "H12",
///        "D",
///        "W",
///        "M"
///      ]
///    },
///    "instrument": {
///      "description": "The instrument whose Prices are represented by the
/// candlesticks.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GetInstrumentCandlesResponse {
    ///The list of candlesticks that satisfy the request.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub candles: Vec<Candlestick>,
    ///The granularity of the candlesticks provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub granularity: Option<GetInstrumentCandlesResponseGranularity>,
    ///The instrument whose Prices are represented by the candlesticks.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
}

impl From<&GetInstrumentCandlesResponse> for GetInstrumentCandlesResponse {
    fn from(value: &GetInstrumentCandlesResponse) -> Self {
        value.clone()
    }
}

impl GetInstrumentCandlesResponse {
    pub fn builder() -> builder::GetInstrumentCandlesResponse {
        Default::default()
    }
}

///The granularity of the candlesticks provided.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The granularity of the candlesticks provided.",
///  "type": "string",
///  "enum": [
///    "S5",
///    "S10",
///    "S15",
///    "S30",
///    "M1",
///    "M2",
///    "M4",
///    "M5",
///    "M10",
///    "M15",
///    "M30",
///    "H1",
///    "H2",
///    "H3",
///    "H4",
///    "H6",
///    "H8",
///    "H12",
///    "D",
///    "W",
///    "M"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum GetInstrumentCandlesResponseGranularity {
    S5,
    S10,
    S15,
    S30,
    M1,
    M2,
    M4,
    M5,
    M10,
    M15,
    M30,
    H1,
    H2,
    H3,
    H4,
    H6,
    H8,
    H12,
    D,
    W,
    M,
}

impl From<&GetInstrumentCandlesResponseGranularity> for GetInstrumentCandlesResponseGranularity {
    fn from(value: &GetInstrumentCandlesResponseGranularity) -> Self {
        value.clone()
    }
}

impl ToString for GetInstrumentCandlesResponseGranularity {
    fn to_string(&self) -> String {
        match *self {
            Self::S5 => "S5".to_string(),
            Self::S10 => "S10".to_string(),
            Self::S15 => "S15".to_string(),
            Self::S30 => "S30".to_string(),
            Self::M1 => "M1".to_string(),
            Self::M2 => "M2".to_string(),
            Self::M4 => "M4".to_string(),
            Self::M5 => "M5".to_string(),
            Self::M10 => "M10".to_string(),
            Self::M15 => "M15".to_string(),
            Self::M30 => "M30".to_string(),
            Self::H1 => "H1".to_string(),
            Self::H2 => "H2".to_string(),
            Self::H3 => "H3".to_string(),
            Self::H4 => "H4".to_string(),
            Self::H6 => "H6".to_string(),
            Self::H8 => "H8".to_string(),
            Self::H12 => "H12".to_string(),
            Self::D => "D".to_string(),
            Self::W => "W".to_string(),
            Self::M => "M".to_string(),
        }
    }
}

impl std::str::FromStr for GetInstrumentCandlesResponseGranularity {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "S5" => Ok(Self::S5),
            "S10" => Ok(Self::S10),
            "S15" => Ok(Self::S15),
            "S30" => Ok(Self::S30),
            "M1" => Ok(Self::M1),
            "M2" => Ok(Self::M2),
            "M4" => Ok(Self::M4),
            "M5" => Ok(Self::M5),
            "M10" => Ok(Self::M10),
            "M15" => Ok(Self::M15),
            "M30" => Ok(Self::M30),
            "H1" => Ok(Self::H1),
            "H2" => Ok(Self::H2),
            "H3" => Ok(Self::H3),
            "H4" => Ok(Self::H4),
            "H6" => Ok(Self::H6),
            "H8" => Ok(Self::H8),
            "H12" => Ok(Self::H12),
            "D" => Ok(Self::D),
            "W" => Ok(Self::W),
            "M" => Ok(Self::M),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for GetInstrumentCandlesResponseGranularity {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for GetInstrumentCandlesResponseGranularity {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for GetInstrumentCandlesResponseGranularity {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///GetInstrumentOrderBookResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "orderBook": {
///      "$ref": "#/components/schemas/OrderBook"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GetInstrumentOrderBookResponse {
    #[serde(rename = "orderBook", default, skip_serializing_if = "Option::is_none")]
    pub order_book: Option<OrderBook>,
}

impl From<&GetInstrumentOrderBookResponse> for GetInstrumentOrderBookResponse {
    fn from(value: &GetInstrumentOrderBookResponse) -> Self {
        value.clone()
    }
}

impl GetInstrumentOrderBookResponse {
    pub fn builder() -> builder::GetInstrumentOrderBookResponse {
        Default::default()
    }
}

///GetInstrumentPositionBookResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "positionBook": {
///      "$ref": "#/components/schemas/PositionBook"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GetInstrumentPositionBookResponse {
    #[serde(
        rename = "positionBook",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub position_book: Option<PositionBook>,
}

impl From<&GetInstrumentPositionBookResponse> for GetInstrumentPositionBookResponse {
    fn from(value: &GetInstrumentPositionBookResponse) -> Self {
        value.clone()
    }
}

impl GetInstrumentPositionBookResponse {
    pub fn builder() -> builder::GetInstrumentPositionBookResponse {
        Default::default()
    }
}

///GetLatestCandlesResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "latestCandles": {
///      "description": "The latest candle sticks.",
///      "type": "array",
///      "items": {
///        "type": "object",
///        "properties": {
///          "candles": {
///            "description": "The list of candlesticks that satisfy the
/// request.",
///            "type": "array",
///            "items": {
///              "$ref": "#/components/schemas/Candlestick"
///            }
///          },
///          "granularity": {
///            "description": "The granularity of the candlesticks
/// provided.",
///            "type": "string",
///            "enum": [
///              "S5",
///              "S10",
///              "S15",
///              "S30",
///              "M1",
///              "M2",
///              "M4",
///              "M5",
///              "M10",
///              "M15",
///              "M30",
///              "H1",
///              "H2",
///              "H3",
///              "H4",
///              "H6",
///              "H8",
///              "H12",
///              "D",
///              "W",
///              "M"
///            ]
///          },
///          "instrument": {
///            "description": "The instrument whose Prices are represented
/// by the candlesticks.",
///            "type": "string",
///            "format": "A string containing the base currency and quote
/// currency delimited by a \"_\"."
///          }
///        }
///      }
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GetLatestCandlesResponse {
    ///The latest candle sticks.
    #[serde(
        rename = "latestCandles",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub latest_candles: Vec<GetLatestCandlesResponseLatestCandlesItem>,
}

impl From<&GetLatestCandlesResponse> for GetLatestCandlesResponse {
    fn from(value: &GetLatestCandlesResponse) -> Self {
        value.clone()
    }
}

impl GetLatestCandlesResponse {
    pub fn builder() -> builder::GetLatestCandlesResponse {
        Default::default()
    }
}

///GetLatestCandlesResponseLatestCandlesItem
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "candles": {
///      "description": "The list of candlesticks that satisfy the
/// request.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/Candlestick"
///      }
///    },
///    "granularity": {
///      "description": "The granularity of the candlesticks provided.",
///      "type": "string",
///      "enum": [
///        "S5",
///        "S10",
///        "S15",
///        "S30",
///        "M1",
///        "M2",
///        "M4",
///        "M5",
///        "M10",
///        "M15",
///        "M30",
///        "H1",
///        "H2",
///        "H3",
///        "H4",
///        "H6",
///        "H8",
///        "H12",
///        "D",
///        "W",
///        "M"
///      ]
///    },
///    "instrument": {
///      "description": "The instrument whose Prices are represented by the
/// candlesticks.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GetLatestCandlesResponseLatestCandlesItem {
    ///The list of candlesticks that satisfy the request.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub candles: Vec<Candlestick>,
    ///The granularity of the candlesticks provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub granularity: Option<GetLatestCandlesResponseLatestCandlesItemGranularity>,
    ///The instrument whose Prices are represented by the candlesticks.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
}

impl From<&GetLatestCandlesResponseLatestCandlesItem>
    for GetLatestCandlesResponseLatestCandlesItem
{
    fn from(value: &GetLatestCandlesResponseLatestCandlesItem) -> Self {
        value.clone()
    }
}

impl GetLatestCandlesResponseLatestCandlesItem {
    pub fn builder() -> builder::GetLatestCandlesResponseLatestCandlesItem {
        Default::default()
    }
}

///The granularity of the candlesticks provided.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The granularity of the candlesticks provided.",
///  "type": "string",
///  "enum": [
///    "S5",
///    "S10",
///    "S15",
///    "S30",
///    "M1",
///    "M2",
///    "M4",
///    "M5",
///    "M10",
///    "M15",
///    "M30",
///    "H1",
///    "H2",
///    "H3",
///    "H4",
///    "H6",
///    "H8",
///    "H12",
///    "D",
///    "W",
///    "M"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum GetLatestCandlesResponseLatestCandlesItemGranularity {
    S5,
    S10,
    S15,
    S30,
    M1,
    M2,
    M4,
    M5,
    M10,
    M15,
    M30,
    H1,
    H2,
    H3,
    H4,
    H6,
    H8,
    H12,
    D,
    W,
    M,
}

impl From<&GetLatestCandlesResponseLatestCandlesItemGranularity>
    for GetLatestCandlesResponseLatestCandlesItemGranularity
{
    fn from(value: &GetLatestCandlesResponseLatestCandlesItemGranularity) -> Self {
        value.clone()
    }
}

impl ToString for GetLatestCandlesResponseLatestCandlesItemGranularity {
    fn to_string(&self) -> String {
        match *self {
            Self::S5 => "S5".to_string(),
            Self::S10 => "S10".to_string(),
            Self::S15 => "S15".to_string(),
            Self::S30 => "S30".to_string(),
            Self::M1 => "M1".to_string(),
            Self::M2 => "M2".to_string(),
            Self::M4 => "M4".to_string(),
            Self::M5 => "M5".to_string(),
            Self::M10 => "M10".to_string(),
            Self::M15 => "M15".to_string(),
            Self::M30 => "M30".to_string(),
            Self::H1 => "H1".to_string(),
            Self::H2 => "H2".to_string(),
            Self::H3 => "H3".to_string(),
            Self::H4 => "H4".to_string(),
            Self::H6 => "H6".to_string(),
            Self::H8 => "H8".to_string(),
            Self::H12 => "H12".to_string(),
            Self::D => "D".to_string(),
            Self::W => "W".to_string(),
            Self::M => "M".to_string(),
        }
    }
}

impl std::str::FromStr for GetLatestCandlesResponseLatestCandlesItemGranularity {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "S5" => Ok(Self::S5),
            "S10" => Ok(Self::S10),
            "S15" => Ok(Self::S15),
            "S30" => Ok(Self::S30),
            "M1" => Ok(Self::M1),
            "M2" => Ok(Self::M2),
            "M4" => Ok(Self::M4),
            "M5" => Ok(Self::M5),
            "M10" => Ok(Self::M10),
            "M15" => Ok(Self::M15),
            "M30" => Ok(Self::M30),
            "H1" => Ok(Self::H1),
            "H2" => Ok(Self::H2),
            "H3" => Ok(Self::H3),
            "H4" => Ok(Self::H4),
            "H6" => Ok(Self::H6),
            "H8" => Ok(Self::H8),
            "H12" => Ok(Self::H12),
            "D" => Ok(Self::D),
            "W" => Ok(Self::W),
            "M" => Ok(Self::M),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for GetLatestCandlesResponseLatestCandlesItemGranularity {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for GetLatestCandlesResponseLatestCandlesItemGranularity {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for GetLatestCandlesResponseLatestCandlesItemGranularity {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///GetOrderResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "lastTransactionID": {
///      "description": "The ID of the most recent Transaction created for
/// the Account",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "order": {
///      "$ref": "#/components/schemas/Order"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GetOrderResponse {
    ///The ID of the most recent Transaction created for the Account
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub order: Option<Order>,
}

impl From<&GetOrderResponse> for GetOrderResponse {
    fn from(value: &GetOrderResponse) -> Self {
        value.clone()
    }
}

impl GetOrderResponse {
    pub fn builder() -> builder::GetOrderResponse {
        Default::default()
    }
}

///GetPositionResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "lastTransactionID": {
///      "description": "The ID of the most recent Transaction created for
/// the Account",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "position": {
///      "$ref": "#/components/schemas/Position"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GetPositionResponse {
    ///The ID of the most recent Transaction created for the Account
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub position: Option<Position>,
}

impl From<&GetPositionResponse> for GetPositionResponse {
    fn from(value: &GetPositionResponse) -> Self {
        value.clone()
    }
}

impl GetPositionResponse {
    pub fn builder() -> builder::GetPositionResponse {
        Default::default()
    }
}

///GetPricesResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "homeConversions": {
///      "description": "The list of home currency conversion factors
/// requested. This field will only be present if includeHomeConversions was
/// set to true in the request.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/HomeConversions"
///      }
///    },
///    "prices": {
///      "description": "The list of Price objects requested.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/ClientPrice"
///      }
///    },
///    "time": {
///      "description": "The DateTime value to use for the \"since\"
/// parameter in the next poll request.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GetPricesResponse {
    ///The list of home currency conversion factors requested. This field
    /// will only be present if includeHomeConversions was set to true in
    /// the request.
    #[serde(
        rename = "homeConversions",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub home_conversions: Vec<HomeConversions>,
    ///The list of Price objects requested.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub prices: Vec<ClientPrice>,
    ///The DateTime value to use for the "since" parameter in the next poll
    /// request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
}

impl From<&GetPricesResponse> for GetPricesResponse {
    fn from(value: &GetPricesResponse) -> Self {
        value.clone()
    }
}

impl GetPricesResponse {
    pub fn builder() -> builder::GetPricesResponse {
        Default::default()
    }
}

///GetTradeResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "lastTransactionID": {
///      "description": "The ID of the most recent Transaction created for
/// the Account",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "trade": {
///      "$ref": "#/components/schemas/Trade"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GetTradeResponse {
    ///The ID of the most recent Transaction created for the Account
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub trade: Option<Trade>,
}

impl From<&GetTradeResponse> for GetTradeResponse {
    fn from(value: &GetTradeResponse) -> Self {
        value.clone()
    }
}

impl GetTradeResponse {
    pub fn builder() -> builder::GetTradeResponse {
        Default::default()
    }
}

///GetTransactionRangeResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "lastTransactionID": {
///      "description": "The ID of the most recent Transaction created for
/// the Account",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "transactions": {
///      "description": "The list of Transactions that satisfy the
/// request.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/Transaction"
///      }
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GetTransactionRangeResponse {
    ///The ID of the most recent Transaction created for the Account
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
    ///The list of Transactions that satisfy the request.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub transactions: Vec<Transaction>,
}

impl From<&GetTransactionRangeResponse> for GetTransactionRangeResponse {
    fn from(value: &GetTransactionRangeResponse) -> Self {
        value.clone()
    }
}

impl GetTransactionRangeResponse {
    pub fn builder() -> builder::GetTransactionRangeResponse {
        Default::default()
    }
}

///GetTransactionResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "lastTransactionID": {
///      "description": "The ID of the most recent Transaction created for
/// the Account",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "transaction": {
///      "$ref": "#/components/schemas/Transaction"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GetTransactionResponse {
    ///The ID of the most recent Transaction created for the Account
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub transaction: Option<Transaction>,
}

impl From<&GetTransactionResponse> for GetTransactionResponse {
    fn from(value: &GetTransactionResponse) -> Self {
        value.clone()
    }
}

impl GetTransactionResponse {
    pub fn builder() -> builder::GetTransactionResponse {
        Default::default()
    }
}

///GetTransactionsSinceIdResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "lastTransactionID": {
///      "description": "The ID of the most recent Transaction created for
/// the Account",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "transactions": {
///      "description": "The list of Transactions that satisfy the
/// request.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/Transaction"
///      }
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GetTransactionsSinceIdResponse {
    ///The ID of the most recent Transaction created for the Account
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
    ///The list of Transactions that satisfy the request.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub transactions: Vec<Transaction>,
}

impl From<&GetTransactionsSinceIdResponse> for GetTransactionsSinceIdResponse {
    fn from(value: &GetTransactionsSinceIdResponse) -> Self {
        value.clone()
    }
}

impl GetTransactionsSinceIdResponse {
    pub fn builder() -> builder::GetTransactionsSinceIdResponse {
        Default::default()
    }
}

///Details required by clients creating a Guaranteed Stop Loss Order
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Details required by clients creating a Guaranteed Stop
/// Loss Order",
///  "type": "object",
///  "properties": {
///    "levelRestriction": {
///      "$ref":
/// "#/components/schemas/GuaranteedStopLossOrderLevelRestriction"
///    },
///    "minimumDistance": {
///      "description": "The minimum distance allowed between the Trade's
/// fill price and the configured price for guaranteed Stop Loss Orders
/// created for this instrument. Specified in price units.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "premium": {
///      "description": "The amount that is charged to the account if a
/// guaranteed Stop Loss Order is triggered and filled. The value is in
/// price units and is charged for each unit of the Trade.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GuaranteedStopLossOrderEntryData {
    #[serde(
        rename = "levelRestriction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub level_restriction: Option<GuaranteedStopLossOrderLevelRestriction>,
    ///The minimum distance allowed between the Trade's fill price and the
    /// configured price for guaranteed Stop Loss Orders created for this
    /// instrument. Specified in price units.
    #[serde(
        rename = "minimumDistance",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub minimum_distance: Option<String>,
    ///The amount that is charged to the account if a guaranteed Stop Loss
    /// Order is triggered and filled. The value is in price units and is
    /// charged for each unit of the Trade.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub premium: Option<String>,
}

impl From<&GuaranteedStopLossOrderEntryData> for GuaranteedStopLossOrderEntryData {
    fn from(value: &GuaranteedStopLossOrderEntryData) -> Self {
        value.clone()
    }
}

impl GuaranteedStopLossOrderEntryData {
    pub fn builder() -> builder::GuaranteedStopLossOrderEntryData {
        Default::default()
    }
}

///A GuaranteedStopLossOrderLevelRestriction represents the total position
/// size that can exist within a given price window for Trades with
/// guaranteed Stop Loss Orders attached for a specific Instrument.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A GuaranteedStopLossOrderLevelRestriction represents
/// the total position size that can exist within a given price window for
/// Trades with guaranteed Stop Loss Orders attached for a specific
/// Instrument.",
///  "type": "object",
///  "properties": {
///    "priceRange": {
///      "description": "The price range the volume applies to. This value
/// is in price units.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "volume": {
///      "description": "Applies to Trades with a guaranteed Stop Loss Order
/// attached for the specified Instrument. This is the total allowed Trade
/// volume that can exist within the priceRange based on the trigger prices
/// of the guaranteed Stop Loss Orders.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GuaranteedStopLossOrderLevelRestriction {
    ///The price range the volume applies to. This value is in price units.
    #[serde(
        rename = "priceRange",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub price_range: Option<String>,
    ///Applies to Trades with a guaranteed Stop Loss Order attached for the
    /// specified Instrument. This is the total allowed Trade volume that
    /// can exist within the priceRange based on the trigger prices of the
    /// guaranteed Stop Loss Orders.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub volume: Option<String>,
}

impl From<&GuaranteedStopLossOrderLevelRestriction> for GuaranteedStopLossOrderLevelRestriction {
    fn from(value: &GuaranteedStopLossOrderLevelRestriction) -> Self {
        value.clone()
    }
}

impl GuaranteedStopLossOrderLevelRestriction {
    pub fn builder() -> builder::GuaranteedStopLossOrderLevelRestriction {
        Default::default()
    }
}

///The overall behaviour of the Account regarding guaranteed Stop Loss
/// Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The overall behaviour of the Account regarding
/// guaranteed Stop Loss Orders.",
///  "type": "string",
///  "enum": [
///    "DISABLED",
///    "ALLOWED",
///    "REQUIRED"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum GuaranteedStopLossOrderMode {
    #[serde(rename = "DISABLED")]
    Disabled,
    #[serde(rename = "ALLOWED")]
    Allowed,
    #[serde(rename = "REQUIRED")]
    Required,
}

impl From<&GuaranteedStopLossOrderMode> for GuaranteedStopLossOrderMode {
    fn from(value: &GuaranteedStopLossOrderMode) -> Self {
        value.clone()
    }
}

impl ToString for GuaranteedStopLossOrderMode {
    fn to_string(&self) -> String {
        match *self {
            Self::Disabled => "DISABLED".to_string(),
            Self::Allowed => "ALLOWED".to_string(),
            Self::Required => "REQUIRED".to_string(),
        }
    }
}

impl std::str::FromStr for GuaranteedStopLossOrderMode {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DISABLED" => Ok(Self::Disabled),
            "ALLOWED" => Ok(Self::Allowed),
            "REQUIRED" => Ok(Self::Required),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for GuaranteedStopLossOrderMode {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for GuaranteedStopLossOrderMode {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for GuaranteedStopLossOrderMode {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///HomeConversions represents the factors to use to convert quantities of a
/// given currency into the Account's home currency. The conversion factor
/// depends on the scenario the conversion is required for.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "HomeConversions represents the factors to use to
/// convert quantities of a given currency into the Account's home currency.
/// The conversion factor depends on the scenario the conversion is required
/// for.",
///  "type": "object",
///  "properties": {
///    "accountGain": {
///      "description": "The factor used to convert any gains for an Account in the specified currency into the Account's home currency. This would include positive realized P/L and positive financing amounts. Conversion is performed by multiplying the positive P/L by the conversion factor.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "accountLoss": {
///      "description": "The string representation of a decimal number.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "currency": {
///      "description": "The currency to be converted into the home
/// currency.",
///      "type": "string",
///      "format": "A string containing an ISO 4217 currency (http://en.wikipedia.org/wiki/ISO_4217)"
///    },
///    "positionValue": {
///      "description": "The factor used to convert a Position or Trade
/// Value in the specified currency into the Account's home currency.
/// Conversion is performed by multiplying the Position or Trade Value by
/// the conversion factor.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct HomeConversions {
    ///The factor used to convert any gains for an Account in the specified
    /// currency into the Account's home currency. This would include
    /// positive realized P/L and positive financing amounts. Conversion is
    /// performed by multiplying the positive P/L by the conversion factor.
    #[serde(
        rename = "accountGain",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub account_gain: Option<String>,
    ///The string representation of a decimal number.
    #[serde(
        rename = "accountLoss",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub account_loss: Option<String>,
    ///The currency to be converted into the home currency.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub currency: Option<String>,
    ///The factor used to convert a Position or Trade Value in the
    /// specified currency into the Account's home currency. Conversion is
    /// performed by multiplying the Position or Trade Value by the
    /// conversion factor.
    #[serde(
        rename = "positionValue",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub position_value: Option<String>,
}

impl From<&HomeConversions> for HomeConversions {
    fn from(value: &HomeConversions) -> Self {
        value.clone()
    }
}

impl HomeConversions {
    pub fn builder() -> builder::HomeConversions {
        Default::default()
    }
}

///Full specification of an Instrument.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Full specification of an Instrument.",
///  "type": "object",
///  "properties": {
///    "commission": {
///      "$ref": "#/components/schemas/InstrumentCommission"
///    },
///    "displayName": {
///      "description": "The display name of the Instrument",
///      "type": "string"
///    },
///    "displayPrecision": {
///      "description": "The number of decimal places that should be used to
/// display prices for this instrument. (e.g. a displayPrecision of 5 would
/// result in a price of \"1\" being displayed as \"1.00000\")",
///      "type": "integer"
///    },
///    "marginRate": {
///      "description": "The margin rate for this instrument.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "maximumOrderUnits": {
///      "description": "The maximum units allowed for an Order placed for
/// this instrument. Specified in units.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "maximumPositionSize": {
///      "description": "The maximum position size allowed for this
/// instrument. Specified in units.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "maximumTrailingStopDistance": {
///      "description": "The maximum trailing stop distance allowed for a
/// trailing stop loss created for this instrument. Specified in price
/// units.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "minimumTradeSize": {
///      "description": "The smallest number of units allowed to be traded
/// for this instrument.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "minimumTrailingStopDistance": {
///      "description": "The minimum trailing stop distance allowed for a
/// trailing stop loss created for this instrument. Specified in price
/// units.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "name": {
///      "description": "The name of the Instrument",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "pipLocation": {
///      "description": "The location of the \"pip\" for this instrument.
/// The decimal position of the pip in this Instrument's price can be found
/// at 10 ^ pipLocation (e.g. -4 pipLocation results in a decimal pip
/// position of 10 ^ -4 = 0.0001).",
///      "type": "integer"
///    },
///    "tradeUnitsPrecision": {
///      "description": "The amount of decimal places that may be provided
/// when specifying the number of units traded for this instrument.",
///      "type": "integer"
///    },
///    "type": {
///      "description": "The type of the Instrument",
///      "type": "string",
///      "enum": [
///        "CURRENCY",
///        "CFD",
///        "METAL"
///      ]
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Instrument {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commission: Option<InstrumentCommission>,
    ///The display name of the Instrument
    #[serde(
        rename = "displayName",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub display_name: Option<String>,
    ///The number of decimal places that should be used to display prices
    /// for this instrument. (e.g. a displayPrecision of 5 would result in a
    /// price of "1" being displayed as "1.00000")
    #[serde(
        rename = "displayPrecision",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub display_precision: Option<i64>,
    ///The margin rate for this instrument.
    #[serde(
        rename = "marginRate",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_rate: Option<String>,
    ///The maximum units allowed for an Order placed for this instrument.
    /// Specified in units.
    #[serde(
        rename = "maximumOrderUnits",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub maximum_order_units: Option<String>,
    ///The maximum position size allowed for this instrument. Specified in
    /// units.
    #[serde(
        rename = "maximumPositionSize",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub maximum_position_size: Option<String>,
    ///The maximum trailing stop distance allowed for a trailing stop loss
    /// created for this instrument. Specified in price units.
    #[serde(
        rename = "maximumTrailingStopDistance",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub maximum_trailing_stop_distance: Option<String>,
    ///The smallest number of units allowed to be traded for this
    /// instrument.
    #[serde(
        rename = "minimumTradeSize",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub minimum_trade_size: Option<String>,
    ///The minimum trailing stop distance allowed for a trailing stop loss
    /// created for this instrument. Specified in price units.
    #[serde(
        rename = "minimumTrailingStopDistance",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub minimum_trailing_stop_distance: Option<String>,
    ///The name of the Instrument
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    ///The location of the "pip" for this instrument. The decimal position
    /// of the pip in this Instrument's price can be found at 10 ^
    /// pipLocation (e.g. -4 pipLocation results in a decimal pip position
    /// of 10 ^ -4 = 0.0001).
    #[serde(
        rename = "pipLocation",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub pip_location: Option<i64>,
    ///The amount of decimal places that may be provided when specifying
    /// the number of units traded for this instrument.
    #[serde(
        rename = "tradeUnitsPrecision",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_units_precision: Option<i64>,
    ///The type of the Instrument
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<InstrumentType>,
}

impl From<&Instrument> for Instrument {
    fn from(value: &Instrument) -> Self {
        value.clone()
    }
}

impl Instrument {
    pub fn builder() -> builder::Instrument {
        Default::default()
    }
}

///An InstrumentCommission represents an instrument-specific commission
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "An InstrumentCommission represents an
/// instrument-specific commission",
///  "type": "object",
///  "properties": {
///    "commission": {
///      "description": "The commission amount (in the Account's home
/// currency) charged per unitsTraded of the instrument",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "minimumCommission": {
///      "description": "The minimum commission amount (in the Account's
/// home currency) that is charged when an Order is filled for this
/// instrument.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "unitsTraded": {
///      "description": "The number of units traded that the commission
/// amount is based on.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct InstrumentCommission {
    ///The commission amount (in the Account's home currency) charged per
    /// unitsTraded of the instrument
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commission: Option<String>,
    ///The minimum commission amount (in the Account's home currency) that
    /// is charged when an Order is filled for this instrument.
    #[serde(
        rename = "minimumCommission",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub minimum_commission: Option<String>,
    ///The number of units traded that the commission amount is based on.
    #[serde(
        rename = "unitsTraded",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub units_traded: Option<String>,
}

impl From<&InstrumentCommission> for InstrumentCommission {
    fn from(value: &InstrumentCommission) -> Self {
        value.clone()
    }
}

impl InstrumentCommission {
    pub fn builder() -> builder::InstrumentCommission {
        Default::default()
    }
}

///Instrument name identifier. Used by clients to refer to an Instrument.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Instrument name identifier. Used by clients to refer to
/// an Instrument.",
///  "type": "string",
///  "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct InstrumentName(pub String);
impl std::ops::Deref for InstrumentName {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl From<InstrumentName> for String {
    fn from(value: InstrumentName) -> Self {
        value.0
    }
}

impl From<&InstrumentName> for InstrumentName {
    fn from(value: &InstrumentName) -> Self {
        value.clone()
    }
}

impl From<String> for InstrumentName {
    fn from(value: String) -> Self {
        Self(value)
    }
}

impl std::str::FromStr for InstrumentName {
    type Err = std::convert::Infallible;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}

impl ToString for InstrumentName {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

///The type of an Instrument.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The type of an Instrument.",
///  "type": "string",
///  "enum": [
///    "CURRENCY",
///    "CFD",
///    "METAL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum InstrumentType {
    #[serde(rename = "CURRENCY")]
    Currency,
    #[serde(rename = "CFD")]
    Cfd,
    #[serde(rename = "METAL")]
    Metal,
}

impl From<&InstrumentType> for InstrumentType {
    fn from(value: &InstrumentType) -> Self {
        value.clone()
    }
}

impl ToString for InstrumentType {
    fn to_string(&self) -> String {
        match *self {
            Self::Currency => "CURRENCY".to_string(),
            Self::Cfd => "CFD".to_string(),
            Self::Metal => "METAL".to_string(),
        }
    }
}

impl std::str::FromStr for InstrumentType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CURRENCY" => Ok(Self::Currency),
            "CFD" => Ok(Self::Cfd),
            "METAL" => Ok(Self::Metal),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for InstrumentType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for InstrumentType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for InstrumentType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A LimitOrder is an order that is created with a price threshold, and
/// will only be filled by a price that is equal to or better than the
/// threshold.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A LimitOrder is an order that is created with a price
/// threshold, and will only be filled by a price that is equal to or better
/// than the threshold.",
///  "type": "object",
///  "properties": {
///    "cancelledTime": {
///      "description": "Date/time when the Order was cancelled (only
/// provided when the state of the Order is CANCELLED)",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "cancellingTransactionID": {
///      "description": "ID of the Transaction that cancelled the Order
/// (only provided when the Order's state is CANCELLED)",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "createTime": {
///      "description": "The time when the Order was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "filledTime": {
///      "description": "Date/time when the Order was filled (only provided
/// when the Order's state is FILLED)",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "fillingTransactionID": {
///      "description": "ID of the Transaction that filled this Order (only
/// provided when the Order's state is FILLED)",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "gtdTime": {
///      "description": "The date/time when the Limit Order will be
/// cancelled if its timeInForce is \"GTD\".",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "id": {
///      "description": "The Order's identifier, unique within the Order's
/// Account.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "instrument": {
///      "description": "The Limit Order's Instrument.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "positionFill": {
///      "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///      "type": "string",
///      "enum": [
///        "OPEN_ONLY",
///        "REDUCE_FIRST",
///        "REDUCE_ONLY",
///        "DEFAULT"
///      ]
///    },
///    "price": {
///      "description": "The price threshold specified for the Limit Order.
/// The Limit Order will only be filled by a market price that is equal to
/// or better than this price.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "replacedByOrderID": {
///      "description": "The ID of the Order that replaced this Order (only
/// provided if this Order was cancelled as part of a cancel/replace).",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "replacesOrderID": {
///      "description": "The ID of the Order that was replaced by this Order (only provided if this Order was created as part of a cancel/replace).",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "state": {
///      "description": "The current state of the Order.",
///      "type": "string",
///      "enum": [
///        "PENDING",
///        "FILLED",
///        "TRIGGERED",
///        "CANCELLED"
///      ]
///    },
///    "stopLossOnFill": {
///      "$ref": "#/components/schemas/StopLossDetails"
///    },
///    "takeProfitOnFill": {
///      "$ref": "#/components/schemas/TakeProfitDetails"
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the Limit Order.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeClientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "tradeClosedIDs": {
///      "description": "Trade IDs of Trades closed when the Order was
/// filled (only provided when the Order's state is FILLED and one or more
/// Trades were closed as a result of the fill)",
///      "type": "array",
///      "items": {
///        "description": "The Trade's identifier, unique within the Trade's
/// Account.",
///        "type": "string",
///        "format": "The string representation of the OANDA-assigned
/// TradeID. OANDA-assigned TradeIDs are positive integers, and are derived
/// from the TransactionID of the Transaction that opened the Trade."
///      }
///    },
///    "tradeOpenedID": {
///      "description": "Trade ID of Trade opened when the Order was filled
/// (only provided when the Order's state is FILLED and a Trade was opened
/// as a result of the fill)",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "tradeReducedID": {
///      "description": "Trade ID of Trade reduced when the Order was filled
/// (only provided when the Order's state is FILLED and a Trade was reduced
/// as a result of the fill)",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "trailingStopLossOnFill": {
///      "$ref": "#/components/schemas/TrailingStopLossDetails"
///    },
///    "triggerCondition": {
///      "description": "Specification of which price component should be
/// used when determining if an Order should be triggered and filled. This
/// allows Orders to be triggered based on the bid, ask, mid, default (ask
/// for buy, bid for sell) or inverse (ask for sell, bid for buy) price
/// depending on the desired behaviour. Orders are always filled using their
/// default price component.\nThis feature is only provided through the REST
/// API. Clients who choose to specify a non-default trigger condition will
/// not see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///      "type": "string",
///      "enum": [
///        "DEFAULT",
///        "INVERSE",
///        "BID",
///        "ASK",
///        "MID"
///      ]
///    },
///    "type": {
///      "description": "The type of the Order. Always set to \"LIMIT\" for
/// Limit Orders.",
///      "type": "string",
///      "enum": [
///        "MARKET",
///        "LIMIT",
///        "STOP",
///        "MARKET_IF_TOUCHED",
///        "TAKE_PROFIT",
///        "STOP_LOSS",
///        "TRAILING_STOP_LOSS",
///        "FIXED_PRICE"
///      ]
///    },
///    "units": {
///      "description": "The quantity requested to be filled by the Limit
/// Order. A posititive number of units results in a long Order, and a
/// negative number of units results in a short Order.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct LimitOrder {
    ///Date/time when the Order was cancelled (only provided when the state
    /// of the Order is CANCELLED)
    #[serde(
        rename = "cancelledTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelled_time: Option<String>,
    ///ID of the Transaction that cancelled the Order (only provided when
    /// the Order's state is CANCELLED)
    #[serde(
        rename = "cancellingTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The time when the Order was created.
    #[serde(
        rename = "createTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub create_time: Option<String>,
    ///Date/time when the Order was filled (only provided when the Order's
    /// state is FILLED)
    #[serde(
        rename = "filledTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub filled_time: Option<String>,
    ///ID of the Transaction that filled this Order (only provided when the
    /// Order's state is FILLED)
    #[serde(
        rename = "fillingTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub filling_transaction_id: Option<String>,
    ///The date/time when the Limit Order will be cancelled if its
    /// timeInForce is "GTD".
    #[serde(rename = "gtdTime", default, skip_serializing_if = "Option::is_none")]
    pub gtd_time: Option<String>,
    ///The Order's identifier, unique within the Order's Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The Limit Order's Instrument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    ///Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(
        rename = "positionFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub position_fill: Option<LimitOrderPositionFill>,
    ///The price threshold specified for the Limit Order. The Limit Order
    /// will only be filled by a market price that is equal to or better
    /// than this price.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The ID of the Order that replaced this Order (only provided if this
    /// Order was cancelled as part of a cancel/replace).
    #[serde(
        rename = "replacedByOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub replaced_by_order_id: Option<String>,
    ///The ID of the Order that was replaced by this Order (only provided
    /// if this Order was created as part of a cancel/replace).
    #[serde(
        rename = "replacesOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub replaces_order_id: Option<String>,
    ///The current state of the Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<LimitOrderState>,
    #[serde(
        rename = "stopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stop_loss_on_fill: Option<StopLossDetails>,
    #[serde(
        rename = "takeProfitOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub take_profit_on_fill: Option<TakeProfitDetails>,
    ///The time-in-force requested for the Limit Order.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<LimitOrderTimeInForce>,
    #[serde(
        rename = "tradeClientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,
    ///Trade IDs of Trades closed when the Order was filled (only provided
    /// when the Order's state is FILLED and one or more Trades were closed
    /// as a result of the fill)
    #[serde(
        rename = "tradeClosedIDs",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub trade_closed_i_ds: Vec<String>,
    ///Trade ID of Trade opened when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was opened as a result
    /// of the fill)
    #[serde(
        rename = "tradeOpenedID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_opened_id: Option<String>,
    ///Trade ID of Trade reduced when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was reduced as a result
    /// of the fill)
    #[serde(
        rename = "tradeReducedID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_reduced_id: Option<String>,
    #[serde(
        rename = "trailingStopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,
    ///Specification of which price component should be used when
    /// determining if an Order should be triggered and filled. This allows
    /// Orders to be triggered based on the bid, ask, mid, default (ask for
    /// buy, bid for sell) or inverse (ask for sell, bid for buy) price
    /// depending on the desired behaviour. Orders are always filled using
    /// their default price component. This feature is only provided
    /// through the REST API. Clients who choose to specify a non-default
    /// trigger condition will not see it reflected in any of OANDA's
    /// proprietary or partner trading platforms, their transaction history
    /// or their account statements. OANDA platforms always assume that an
    /// Order's trigger condition is set to the default value when
    /// indicating the distance from an Order's trigger price, and will
    /// always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when
    /// creating a guaranteed Stop Loss Order. In this case the
    /// TriggerCondition value must either be "DEFAULT", or the "natural"
    /// trigger side "DEFAULT" results in. So for a Stop Loss Order for a
    /// long trade valid values are "DEFAULT" and "BID", and for short
    /// trades "DEFAULT" and "ASK" are valid.
    #[serde(
        rename = "triggerCondition",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trigger_condition: Option<LimitOrderTriggerCondition>,
    ///The type of the Order. Always set to "LIMIT" for Limit Orders.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<LimitOrderType>,
    ///The quantity requested to be filled by the Limit Order. A posititive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<String>,
}

impl From<&LimitOrder> for LimitOrder {
    fn from(value: &LimitOrder) -> Self {
        value.clone()
    }
}

impl LimitOrder {
    pub fn builder() -> builder::LimitOrder {
        Default::default()
    }
}

///Specification of how Positions in the Account are modified when the
/// Order is filled.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///  "type": "string",
///  "enum": [
///    "OPEN_ONLY",
///    "REDUCE_FIRST",
///    "REDUCE_ONLY",
///    "DEFAULT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LimitOrderPositionFill {
    #[serde(rename = "OPEN_ONLY")]
    OpenOnly,
    #[serde(rename = "REDUCE_FIRST")]
    ReduceFirst,
    #[serde(rename = "REDUCE_ONLY")]
    ReduceOnly,
    #[serde(rename = "DEFAULT")]
    Default,
}

impl From<&LimitOrderPositionFill> for LimitOrderPositionFill {
    fn from(value: &LimitOrderPositionFill) -> Self {
        value.clone()
    }
}

impl ToString for LimitOrderPositionFill {
    fn to_string(&self) -> String {
        match *self {
            Self::OpenOnly => "OPEN_ONLY".to_string(),
            Self::ReduceFirst => "REDUCE_FIRST".to_string(),
            Self::ReduceOnly => "REDUCE_ONLY".to_string(),
            Self::Default => "DEFAULT".to_string(),
        }
    }
}

impl std::str::FromStr for LimitOrderPositionFill {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "OPEN_ONLY" => Ok(Self::OpenOnly),
            "REDUCE_FIRST" => Ok(Self::ReduceFirst),
            "REDUCE_ONLY" => Ok(Self::ReduceOnly),
            "DEFAULT" => Ok(Self::Default),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for LimitOrderPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for LimitOrderPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for LimitOrderPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The reason that the Limit Order was initiated
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Limit Order was initiated",
///  "type": "string",
///  "enum": [
///    "CLIENT_ORDER",
///    "REPLACEMENT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LimitOrderReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "REPLACEMENT")]
    Replacement,
}

impl From<&LimitOrderReason> for LimitOrderReason {
    fn from(value: &LimitOrderReason) -> Self {
        value.clone()
    }
}

impl ToString for LimitOrderReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ClientOrder => "CLIENT_ORDER".to_string(),
            Self::Replacement => "REPLACEMENT".to_string(),
        }
    }
}

impl std::str::FromStr for LimitOrderReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CLIENT_ORDER" => Ok(Self::ClientOrder),
            "REPLACEMENT" => Ok(Self::Replacement),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for LimitOrderReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for LimitOrderReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for LimitOrderReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A LimitOrderRejectTransaction represents the rejection of the creation
/// of a Limit Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A LimitOrderRejectTransaction represents the rejection
/// of the creation of a Limit Order.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "gtdTime": {
///      "description": "The date/time when the Limit Order will be
/// cancelled if its timeInForce is \"GTD\".",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "instrument": {
///      "description": "The Limit Order's Instrument.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "intendedReplacesOrderID": {
///      "description": "The ID of the Order that this Order was intended to
/// replace (only provided if this Order was intended to replace an existing
/// Order).",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "positionFill": {
///      "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///      "type": "string",
///      "enum": [
///        "OPEN_ONLY",
///        "REDUCE_FIRST",
///        "REDUCE_ONLY",
///        "DEFAULT"
///      ]
///    },
///    "price": {
///      "description": "The price threshold specified for the Limit Order.
/// The Limit Order will only be filled by a market price that is equal to
/// or better than this price.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "reason": {
///      "description": "The reason that the Limit Order was initiated",
///      "type": "string",
///      "enum": [
///        "CLIENT_ORDER",
///        "REPLACEMENT"
///      ]
///    },
///    "rejectReason": {
///      "description": "The reason that the Reject Transaction was
/// created",
///      "type": "string",
///      "enum": [
///        "INTERNAL_SERVER_ERROR",
///        "INSTRUMENT_PRICE_UNKNOWN",
///        "ACCOUNT_NOT_ACTIVE",
///        "ACCOUNT_LOCKED",
///        "ACCOUNT_ORDER_CREATION_LOCKED",
///        "ACCOUNT_CONFIGURATION_LOCKED",
///        "ACCOUNT_DEPOSIT_LOCKED",
///        "ACCOUNT_WITHDRAWAL_LOCKED",
///        "ACCOUNT_ORDER_CANCEL_LOCKED",
///        "INSTRUMENT_NOT_TRADEABLE",
///        "PENDING_ORDERS_ALLOWED_EXCEEDED",
///        "ORDER_ID_UNSPECIFIED",
///        "ORDER_DOESNT_EXIST",
///        "ORDER_IDENTIFIER_INCONSISTENCY",
///        "TRADE_ID_UNSPECIFIED",
///        "TRADE_DOESNT_EXIST",
///        "TRADE_IDENTIFIER_INCONSISTENCY",
///        "INSUFFICIENT_MARGIN",
///        "INSTRUMENT_MISSING",
///        "INSTRUMENT_UNKNOWN",
///        "UNITS_MISSING",
///        "UNITS_INVALID",
///        "UNITS_PRECISION_EXCEEDED",
///        "UNITS_LIMIT_EXCEEDED",
///        "UNITS_MIMIMUM_NOT_MET",
///        "PRICE_MISSING",
///        "PRICE_INVALID",
///        "PRICE_PRECISION_EXCEEDED",
///        "PRICE_DISTANCE_MISSING",
///        "PRICE_DISTANCE_INVALID",
///        "PRICE_DISTANCE_PRECISION_EXCEEDED",
///        "PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "PRICE_DISTANCE_MINIMUM_NOT_MET",
///        "TIME_IN_FORCE_MISSING",
///        "TIME_IN_FORCE_INVALID",
///        "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING",
///        "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST",
///        "PRICE_BOUND_INVALID",
///        "PRICE_BOUND_PRECISION_EXCEEDED",
///        "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS",
///        "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED",
///        "CLIENT_ORDER_ID_INVALID",
///        "CLIENT_ORDER_ID_ALREADY_EXISTS",
///        "CLIENT_ORDER_TAG_INVALID",
///        "CLIENT_ORDER_COMMENT_INVALID",
///        "CLIENT_TRADE_ID_INVALID",
///        "CLIENT_TRADE_ID_ALREADY_EXISTS",
///        "CLIENT_TRADE_TAG_INVALID",
///        "CLIENT_TRADE_COMMENT_INVALID",
///        "ORDER_FILL_POSITION_ACTION_MISSING",
///        "ORDER_FILL_POSITION_ACTION_INVALID",
///        "TRIGGER_CONDITION_MISSING",
///        "TRIGGER_CONDITION_INVALID",
///        "ORDER_PARTIAL_FILL_OPTION_MISSING",
///        "ORDER_PARTIAL_FILL_OPTION_INVALID",
///        "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL",
///        "TAKE_PROFIT_ORDER_ALREADY_EXISTS",
///        "TAKE_PROFIT_ON_FILL_PRICE_MISSING",
///        "TAKE_PROFIT_ON_FILL_PRICE_INVALID",
///        "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED",
///        "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING",
///        "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID",
///        "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "STOP_LOSS_ORDER_ALREADY_EXISTS",
///        "STOP_LOSS_ORDER_GUARANTEED_REQUIRED",
///        "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD",
///        "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED",
///        "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION",
///        "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION",
///        "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED",
///        "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///        "STOP_LOSS_ORDER_NOT_CANCELABLE",
///        "STOP_LOSS_ORDER_NOT_REPLACEABLE",
///        "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///        "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///        "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING",
///        "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER",
///        "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///        "STOP_LOSS_ON_FILL_PRICE_MISSING",
///        "STOP_LOSS_ON_FILL_PRICE_INVALID",
///        "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///        "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_DISTANCE_INVALID",
///        "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///        "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING",
///        "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///        "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///        "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET",
///        "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED",
///        "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "CLOSE_TRADE_TYPE_MISSING",
///        "CLOSE_TRADE_PARTIAL_UNITS_MISSING",
///        "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE",
///        "CLOSEOUT_POSITION_DOESNT_EXIST",
///        "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION",
///        "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE",
///        "CLOSEOUT_POSITION_REJECT",
///        "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING",
///        "MARKUP_GROUP_ID_INVALID",
///        "POSITION_AGGREGATION_MODE_INVALID",
///        "ADMIN_CONFIGURE_DATA_MISSING",
///        "MARGIN_RATE_INVALID",
///        "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT",
///        "ALIAS_INVALID",
///        "CLIENT_CONFIGURE_DATA_MISSING",
///        "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL",
///        "AMOUNT_INVALID",
///        "INSUFFICIENT_FUNDS",
///        "AMOUNT_MISSING",
///        "FUNDING_REASON_MISSING",
///        "CLIENT_EXTENSIONS_DATA_MISSING",
///        "REPLACING_ORDER_INVALID",
///        "REPLACING_TRADE_ID_INVALID"
///      ]
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "stopLossOnFill": {
///      "$ref": "#/components/schemas/StopLossDetails"
///    },
///    "takeProfitOnFill": {
///      "$ref": "#/components/schemas/TakeProfitDetails"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the Limit Order.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeClientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "trailingStopLossOnFill": {
///      "$ref": "#/components/schemas/TrailingStopLossDetails"
///    },
///    "triggerCondition": {
///      "description": "Specification of which price component should be
/// used when determining if an Order should be triggered and filled. This
/// allows Orders to be triggered based on the bid, ask, mid, default (ask
/// for buy, bid for sell) or inverse (ask for sell, bid for buy) price
/// depending on the desired behaviour. Orders are always filled using their
/// default price component.\nThis feature is only provided through the REST
/// API. Clients who choose to specify a non-default trigger condition will
/// not see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///      "type": "string",
///      "enum": [
///        "DEFAULT",
///        "INVERSE",
///        "BID",
///        "ASK",
///        "MID"
///      ]
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"LIMIT_ORDER_REJECT\" in a LimitOrderRejectTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "units": {
///      "description": "The quantity requested to be filled by the Limit
/// Order. A posititive number of units results in a long Order, and a
/// negative number of units results in a short Order.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct LimitOrderRejectTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The date/time when the Limit Order will be cancelled if its
    /// timeInForce is "GTD".
    #[serde(rename = "gtdTime", default, skip_serializing_if = "Option::is_none")]
    pub gtd_time: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The Limit Order's Instrument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    ///The ID of the Order that this Order was intended to replace (only
    /// provided if this Order was intended to replace an existing Order).
    #[serde(
        rename = "intendedReplacesOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub intended_replaces_order_id: Option<String>,
    ///Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(
        rename = "positionFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub position_fill: Option<LimitOrderRejectTransactionPositionFill>,
    ///The price threshold specified for the Limit Order. The Limit Order
    /// will only be filled by a market price that is equal to or better
    /// than this price.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The reason that the Limit Order was initiated
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<LimitOrderRejectTransactionReason>,
    ///The reason that the Reject Transaction was created
    #[serde(
        rename = "rejectReason",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub reject_reason: Option<LimitOrderRejectTransactionRejectReason>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    #[serde(
        rename = "stopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stop_loss_on_fill: Option<StopLossDetails>,
    #[serde(
        rename = "takeProfitOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub take_profit_on_fill: Option<TakeProfitDetails>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The time-in-force requested for the Limit Order.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<LimitOrderRejectTransactionTimeInForce>,
    #[serde(
        rename = "tradeClientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,
    #[serde(
        rename = "trailingStopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,
    ///Specification of which price component should be used when
    /// determining if an Order should be triggered and filled. This allows
    /// Orders to be triggered based on the bid, ask, mid, default (ask for
    /// buy, bid for sell) or inverse (ask for sell, bid for buy) price
    /// depending on the desired behaviour. Orders are always filled using
    /// their default price component. This feature is only provided
    /// through the REST API. Clients who choose to specify a non-default
    /// trigger condition will not see it reflected in any of OANDA's
    /// proprietary or partner trading platforms, their transaction history
    /// or their account statements. OANDA platforms always assume that an
    /// Order's trigger condition is set to the default value when
    /// indicating the distance from an Order's trigger price, and will
    /// always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when
    /// creating a guaranteed Stop Loss Order. In this case the
    /// TriggerCondition value must either be "DEFAULT", or the "natural"
    /// trigger side "DEFAULT" results in. So for a Stop Loss Order for a
    /// long trade valid values are "DEFAULT" and "BID", and for short
    /// trades "DEFAULT" and "ASK" are valid.
    #[serde(
        rename = "triggerCondition",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trigger_condition: Option<LimitOrderRejectTransactionTriggerCondition>,
    ///The Type of the Transaction. Always set to "LIMIT_ORDER_REJECT" in a
    /// LimitOrderRejectTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<LimitOrderRejectTransactionType>,
    ///The quantity requested to be filled by the Limit Order. A posititive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<String>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&LimitOrderRejectTransaction> for LimitOrderRejectTransaction {
    fn from(value: &LimitOrderRejectTransaction) -> Self {
        value.clone()
    }
}

impl LimitOrderRejectTransaction {
    pub fn builder() -> builder::LimitOrderRejectTransaction {
        Default::default()
    }
}

///Specification of how Positions in the Account are modified when the
/// Order is filled.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///  "type": "string",
///  "enum": [
///    "OPEN_ONLY",
///    "REDUCE_FIRST",
///    "REDUCE_ONLY",
///    "DEFAULT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LimitOrderRejectTransactionPositionFill {
    #[serde(rename = "OPEN_ONLY")]
    OpenOnly,
    #[serde(rename = "REDUCE_FIRST")]
    ReduceFirst,
    #[serde(rename = "REDUCE_ONLY")]
    ReduceOnly,
    #[serde(rename = "DEFAULT")]
    Default,
}

impl From<&LimitOrderRejectTransactionPositionFill> for LimitOrderRejectTransactionPositionFill {
    fn from(value: &LimitOrderRejectTransactionPositionFill) -> Self {
        value.clone()
    }
}

impl ToString for LimitOrderRejectTransactionPositionFill {
    fn to_string(&self) -> String {
        match *self {
            Self::OpenOnly => "OPEN_ONLY".to_string(),
            Self::ReduceFirst => "REDUCE_FIRST".to_string(),
            Self::ReduceOnly => "REDUCE_ONLY".to_string(),
            Self::Default => "DEFAULT".to_string(),
        }
    }
}

impl std::str::FromStr for LimitOrderRejectTransactionPositionFill {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "OPEN_ONLY" => Ok(Self::OpenOnly),
            "REDUCE_FIRST" => Ok(Self::ReduceFirst),
            "REDUCE_ONLY" => Ok(Self::ReduceOnly),
            "DEFAULT" => Ok(Self::Default),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for LimitOrderRejectTransactionPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for LimitOrderRejectTransactionPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for LimitOrderRejectTransactionPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The reason that the Limit Order was initiated
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Limit Order was initiated",
///  "type": "string",
///  "enum": [
///    "CLIENT_ORDER",
///    "REPLACEMENT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LimitOrderRejectTransactionReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "REPLACEMENT")]
    Replacement,
}

impl From<&LimitOrderRejectTransactionReason> for LimitOrderRejectTransactionReason {
    fn from(value: &LimitOrderRejectTransactionReason) -> Self {
        value.clone()
    }
}

impl ToString for LimitOrderRejectTransactionReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ClientOrder => "CLIENT_ORDER".to_string(),
            Self::Replacement => "REPLACEMENT".to_string(),
        }
    }
}

impl std::str::FromStr for LimitOrderRejectTransactionReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CLIENT_ORDER" => Ok(Self::ClientOrder),
            "REPLACEMENT" => Ok(Self::Replacement),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for LimitOrderRejectTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for LimitOrderRejectTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for LimitOrderRejectTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The reason that the Reject Transaction was created
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Reject Transaction was created",
///  "type": "string",
///  "enum": [
///    "INTERNAL_SERVER_ERROR",
///    "INSTRUMENT_PRICE_UNKNOWN",
///    "ACCOUNT_NOT_ACTIVE",
///    "ACCOUNT_LOCKED",
///    "ACCOUNT_ORDER_CREATION_LOCKED",
///    "ACCOUNT_CONFIGURATION_LOCKED",
///    "ACCOUNT_DEPOSIT_LOCKED",
///    "ACCOUNT_WITHDRAWAL_LOCKED",
///    "ACCOUNT_ORDER_CANCEL_LOCKED",
///    "INSTRUMENT_NOT_TRADEABLE",
///    "PENDING_ORDERS_ALLOWED_EXCEEDED",
///    "ORDER_ID_UNSPECIFIED",
///    "ORDER_DOESNT_EXIST",
///    "ORDER_IDENTIFIER_INCONSISTENCY",
///    "TRADE_ID_UNSPECIFIED",
///    "TRADE_DOESNT_EXIST",
///    "TRADE_IDENTIFIER_INCONSISTENCY",
///    "INSUFFICIENT_MARGIN",
///    "INSTRUMENT_MISSING",
///    "INSTRUMENT_UNKNOWN",
///    "UNITS_MISSING",
///    "UNITS_INVALID",
///    "UNITS_PRECISION_EXCEEDED",
///    "UNITS_LIMIT_EXCEEDED",
///    "UNITS_MIMIMUM_NOT_MET",
///    "PRICE_MISSING",
///    "PRICE_INVALID",
///    "PRICE_PRECISION_EXCEEDED",
///    "PRICE_DISTANCE_MISSING",
///    "PRICE_DISTANCE_INVALID",
///    "PRICE_DISTANCE_PRECISION_EXCEEDED",
///    "PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "PRICE_DISTANCE_MINIMUM_NOT_MET",
///    "TIME_IN_FORCE_MISSING",
///    "TIME_IN_FORCE_INVALID",
///    "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING",
///    "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST",
///    "PRICE_BOUND_INVALID",
///    "PRICE_BOUND_PRECISION_EXCEEDED",
///    "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS",
///    "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED",
///    "CLIENT_ORDER_ID_INVALID",
///    "CLIENT_ORDER_ID_ALREADY_EXISTS",
///    "CLIENT_ORDER_TAG_INVALID",
///    "CLIENT_ORDER_COMMENT_INVALID",
///    "CLIENT_TRADE_ID_INVALID",
///    "CLIENT_TRADE_ID_ALREADY_EXISTS",
///    "CLIENT_TRADE_TAG_INVALID",
///    "CLIENT_TRADE_COMMENT_INVALID",
///    "ORDER_FILL_POSITION_ACTION_MISSING",
///    "ORDER_FILL_POSITION_ACTION_INVALID",
///    "TRIGGER_CONDITION_MISSING",
///    "TRIGGER_CONDITION_INVALID",
///    "ORDER_PARTIAL_FILL_OPTION_MISSING",
///    "ORDER_PARTIAL_FILL_OPTION_INVALID",
///    "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL",
///    "TAKE_PROFIT_ORDER_ALREADY_EXISTS",
///    "TAKE_PROFIT_ON_FILL_PRICE_MISSING",
///    "TAKE_PROFIT_ON_FILL_PRICE_INVALID",
///    "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED",
///    "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING",
///    "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "STOP_LOSS_ORDER_ALREADY_EXISTS",
///    "STOP_LOSS_ORDER_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD",
///    "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION",
///    "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION",
///    "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED",
///    "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ORDER_NOT_CANCELABLE",
///    "STOP_LOSS_ORDER_NOT_REPLACEABLE",
///    "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///    "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING",
///    "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER",
///    "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ON_FILL_PRICE_MISSING",
///    "STOP_LOSS_ON_FILL_PRICE_INVALID",
///    "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_DISTANCE_INVALID",
///    "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///    "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET",
///    "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED",
///    "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "CLOSE_TRADE_TYPE_MISSING",
///    "CLOSE_TRADE_PARTIAL_UNITS_MISSING",
///    "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE",
///    "CLOSEOUT_POSITION_DOESNT_EXIST",
///    "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION",
///    "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE",
///    "CLOSEOUT_POSITION_REJECT",
///    "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING",
///    "MARKUP_GROUP_ID_INVALID",
///    "POSITION_AGGREGATION_MODE_INVALID",
///    "ADMIN_CONFIGURE_DATA_MISSING",
///    "MARGIN_RATE_INVALID",
///    "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT",
///    "ALIAS_INVALID",
///    "CLIENT_CONFIGURE_DATA_MISSING",
///    "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL",
///    "AMOUNT_INVALID",
///    "INSUFFICIENT_FUNDS",
///    "AMOUNT_MISSING",
///    "FUNDING_REASON_MISSING",
///    "CLIENT_EXTENSIONS_DATA_MISSING",
///    "REPLACING_ORDER_INVALID",
///    "REPLACING_TRADE_ID_INVALID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LimitOrderRejectTransactionRejectReason {
    #[serde(rename = "INTERNAL_SERVER_ERROR")]
    InternalServerError,
    #[serde(rename = "INSTRUMENT_PRICE_UNKNOWN")]
    InstrumentPriceUnknown,
    #[serde(rename = "ACCOUNT_NOT_ACTIVE")]
    AccountNotActive,
    #[serde(rename = "ACCOUNT_LOCKED")]
    AccountLocked,
    #[serde(rename = "ACCOUNT_ORDER_CREATION_LOCKED")]
    AccountOrderCreationLocked,
    #[serde(rename = "ACCOUNT_CONFIGURATION_LOCKED")]
    AccountConfigurationLocked,
    #[serde(rename = "ACCOUNT_DEPOSIT_LOCKED")]
    AccountDepositLocked,
    #[serde(rename = "ACCOUNT_WITHDRAWAL_LOCKED")]
    AccountWithdrawalLocked,
    #[serde(rename = "ACCOUNT_ORDER_CANCEL_LOCKED")]
    AccountOrderCancelLocked,
    #[serde(rename = "INSTRUMENT_NOT_TRADEABLE")]
    InstrumentNotTradeable,
    #[serde(rename = "PENDING_ORDERS_ALLOWED_EXCEEDED")]
    PendingOrdersAllowedExceeded,
    #[serde(rename = "ORDER_ID_UNSPECIFIED")]
    OrderIdUnspecified,
    #[serde(rename = "ORDER_DOESNT_EXIST")]
    OrderDoesntExist,
    #[serde(rename = "ORDER_IDENTIFIER_INCONSISTENCY")]
    OrderIdentifierInconsistency,
    #[serde(rename = "TRADE_ID_UNSPECIFIED")]
    TradeIdUnspecified,
    #[serde(rename = "TRADE_DOESNT_EXIST")]
    TradeDoesntExist,
    #[serde(rename = "TRADE_IDENTIFIER_INCONSISTENCY")]
    TradeIdentifierInconsistency,
    #[serde(rename = "INSUFFICIENT_MARGIN")]
    InsufficientMargin,
    #[serde(rename = "INSTRUMENT_MISSING")]
    InstrumentMissing,
    #[serde(rename = "INSTRUMENT_UNKNOWN")]
    InstrumentUnknown,
    #[serde(rename = "UNITS_MISSING")]
    UnitsMissing,
    #[serde(rename = "UNITS_INVALID")]
    UnitsInvalid,
    #[serde(rename = "UNITS_PRECISION_EXCEEDED")]
    UnitsPrecisionExceeded,
    #[serde(rename = "UNITS_LIMIT_EXCEEDED")]
    UnitsLimitExceeded,
    #[serde(rename = "UNITS_MIMIMUM_NOT_MET")]
    UnitsMimimumNotMet,
    #[serde(rename = "PRICE_MISSING")]
    PriceMissing,
    #[serde(rename = "PRICE_INVALID")]
    PriceInvalid,
    #[serde(rename = "PRICE_PRECISION_EXCEEDED")]
    PricePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MISSING")]
    PriceDistanceMissing,
    #[serde(rename = "PRICE_DISTANCE_INVALID")]
    PriceDistanceInvalid,
    #[serde(rename = "PRICE_DISTANCE_PRECISION_EXCEEDED")]
    PriceDistancePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    PriceDistanceMaximumExceeded,
    #[serde(rename = "PRICE_DISTANCE_MINIMUM_NOT_MET")]
    PriceDistanceMinimumNotMet,
    #[serde(rename = "TIME_IN_FORCE_MISSING")]
    TimeInForceMissing,
    #[serde(rename = "TIME_IN_FORCE_INVALID")]
    TimeInForceInvalid,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING")]
    TimeInForceGtdTimestampMissing,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST")]
    TimeInForceGtdTimestampInPast,
    #[serde(rename = "PRICE_BOUND_INVALID")]
    PriceBoundInvalid,
    #[serde(rename = "PRICE_BOUND_PRECISION_EXCEEDED")]
    PriceBoundPrecisionExceeded,
    #[serde(rename = "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS")]
    OrdersOnFillDuplicateClientOrderIds,
    #[serde(rename = "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED")]
    TradeOnFillClientExtensionsNotSupported,
    #[serde(rename = "CLIENT_ORDER_ID_INVALID")]
    ClientOrderIdInvalid,
    #[serde(rename = "CLIENT_ORDER_ID_ALREADY_EXISTS")]
    ClientOrderIdAlreadyExists,
    #[serde(rename = "CLIENT_ORDER_TAG_INVALID")]
    ClientOrderTagInvalid,
    #[serde(rename = "CLIENT_ORDER_COMMENT_INVALID")]
    ClientOrderCommentInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_INVALID")]
    ClientTradeIdInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_ALREADY_EXISTS")]
    ClientTradeIdAlreadyExists,
    #[serde(rename = "CLIENT_TRADE_TAG_INVALID")]
    ClientTradeTagInvalid,
    #[serde(rename = "CLIENT_TRADE_COMMENT_INVALID")]
    ClientTradeCommentInvalid,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_MISSING")]
    OrderFillPositionActionMissing,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_INVALID")]
    OrderFillPositionActionInvalid,
    #[serde(rename = "TRIGGER_CONDITION_MISSING")]
    TriggerConditionMissing,
    #[serde(rename = "TRIGGER_CONDITION_INVALID")]
    TriggerConditionInvalid,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_MISSING")]
    OrderPartialFillOptionMissing,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_INVALID")]
    OrderPartialFillOptionInvalid,
    #[serde(rename = "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL")]
    InvalidReissueImmediatePartialFill,
    #[serde(rename = "TAKE_PROFIT_ORDER_ALREADY_EXISTS")]
    TakeProfitOrderAlreadyExists,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_MISSING")]
    TakeProfitOnFillPriceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_INVALID")]
    TakeProfitOnFillPriceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    TakeProfitOnFillPricePrecisionExceeded,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING")]
    TakeProfitOnFillTimeInForceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID")]
    TakeProfitOnFillTimeInForceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TakeProfitOnFillGtdTimestampMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TakeProfitOnFillGtdTimestampInPast,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TakeProfitOnFillClientOrderIdInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TakeProfitOnFillClientOrderTagInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TakeProfitOnFillClientOrderCommentInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TakeProfitOnFillTriggerConditionMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TakeProfitOnFillTriggerConditionInvalid,
    #[serde(rename = "STOP_LOSS_ORDER_ALREADY_EXISTS")]
    StopLossOrderAlreadyExists,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_REQUIRED")]
    StopLossOrderGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD")]
    StopLossOrderGuaranteedPriceWithinSpread,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED")]
    StopLossOrderGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION")]
    StopLossOrderGuaranteedHaltedCreateViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION")]
    StopLossOrderGuaranteedHaltedTightenViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED")]
    StopLossOrderGuaranteedHedgingNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOrderGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_CANCELABLE")]
    StopLossOrderNotCancelable,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_REPLACEABLE")]
    StopLossOrderNotReplaceable,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOrderGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOrderPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOrderPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER")]
    StopLossOnFillRequiredForPendingOrder,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED")]
    StopLossOnFillGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED")]
    StopLossOnFillGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_MISSING")]
    StopLossOnFillPriceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_INVALID")]
    StopLossOnFillPriceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    StopLossOnFillPricePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOnFillGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOnFillGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_INVALID")]
    StopLossOnFillDistanceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    StopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED")]
    StopLossOnFillDistancePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOnFillPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOnFillPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    StopLossOnFillTimeInForceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    StopLossOnFillTimeInForceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    StopLossOnFillGtdTimestampMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    StopLossOnFillGtdTimestampInPast,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    StopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    StopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    StopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    StopLossOnFillTriggerConditionMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    StopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS")]
    TrailingStopLossOrderAlreadyExists,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING")]
    TrailingStopLossOnFillPriceDistanceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID")]
    TrailingStopLossOnFillPriceDistanceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED")]
    TrailingStopLossOnFillPriceDistancePrecisionExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    TrailingStopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET")]
    TrailingStopLossOnFillPriceDistanceMinimumNotMet,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    TrailingStopLossOnFillTimeInForceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    TrailingStopLossOnFillTimeInForceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TrailingStopLossOnFillGtdTimestampMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TrailingStopLossOnFillGtdTimestampInPast,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TrailingStopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TrailingStopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TrailingStopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED")]
    TrailingStopLossOrdersNotSupported,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TrailingStopLossOnFillTriggerConditionMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TrailingStopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "CLOSE_TRADE_TYPE_MISSING")]
    CloseTradeTypeMissing,
    #[serde(rename = "CLOSE_TRADE_PARTIAL_UNITS_MISSING")]
    CloseTradePartialUnitsMissing,
    #[serde(rename = "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE")]
    CloseTradeUnitsExceedTradeSize,
    #[serde(rename = "CLOSEOUT_POSITION_DOESNT_EXIST")]
    CloseoutPositionDoesntExist,
    #[serde(rename = "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION")]
    CloseoutPositionIncompleteSpecification,
    #[serde(rename = "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE")]
    CloseoutPositionUnitsExceedPositionSize,
    #[serde(rename = "CLOSEOUT_POSITION_REJECT")]
    CloseoutPositionReject,
    #[serde(rename = "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING")]
    CloseoutPositionPartialUnitsMissing,
    #[serde(rename = "MARKUP_GROUP_ID_INVALID")]
    MarkupGroupIdInvalid,
    #[serde(rename = "POSITION_AGGREGATION_MODE_INVALID")]
    PositionAggregationModeInvalid,
    #[serde(rename = "ADMIN_CONFIGURE_DATA_MISSING")]
    AdminConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_INVALID")]
    MarginRateInvalid,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT")]
    MarginRateWouldTriggerCloseout,
    #[serde(rename = "ALIAS_INVALID")]
    AliasInvalid,
    #[serde(rename = "CLIENT_CONFIGURE_DATA_MISSING")]
    ClientConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL")]
    MarginRateWouldTriggerMarginCall,
    #[serde(rename = "AMOUNT_INVALID")]
    AmountInvalid,
    #[serde(rename = "INSUFFICIENT_FUNDS")]
    InsufficientFunds,
    #[serde(rename = "AMOUNT_MISSING")]
    AmountMissing,
    #[serde(rename = "FUNDING_REASON_MISSING")]
    FundingReasonMissing,
    #[serde(rename = "CLIENT_EXTENSIONS_DATA_MISSING")]
    ClientExtensionsDataMissing,
    #[serde(rename = "REPLACING_ORDER_INVALID")]
    ReplacingOrderInvalid,
    #[serde(rename = "REPLACING_TRADE_ID_INVALID")]
    ReplacingTradeIdInvalid,
}

impl From<&LimitOrderRejectTransactionRejectReason> for LimitOrderRejectTransactionRejectReason {
    fn from(value: &LimitOrderRejectTransactionRejectReason) -> Self {
        value.clone()
    }
}

impl ToString for LimitOrderRejectTransactionRejectReason {
    fn to_string(&self) -> String {
        match *self {
            Self::InternalServerError => "INTERNAL_SERVER_ERROR".to_string(),
            Self::InstrumentPriceUnknown => "INSTRUMENT_PRICE_UNKNOWN".to_string(),
            Self::AccountNotActive => "ACCOUNT_NOT_ACTIVE".to_string(),
            Self::AccountLocked => "ACCOUNT_LOCKED".to_string(),
            Self::AccountOrderCreationLocked => "ACCOUNT_ORDER_CREATION_LOCKED".to_string(),
            Self::AccountConfigurationLocked => "ACCOUNT_CONFIGURATION_LOCKED".to_string(),
            Self::AccountDepositLocked => "ACCOUNT_DEPOSIT_LOCKED".to_string(),
            Self::AccountWithdrawalLocked => "ACCOUNT_WITHDRAWAL_LOCKED".to_string(),
            Self::AccountOrderCancelLocked => "ACCOUNT_ORDER_CANCEL_LOCKED".to_string(),
            Self::InstrumentNotTradeable => "INSTRUMENT_NOT_TRADEABLE".to_string(),
            Self::PendingOrdersAllowedExceeded => "PENDING_ORDERS_ALLOWED_EXCEEDED".to_string(),
            Self::OrderIdUnspecified => "ORDER_ID_UNSPECIFIED".to_string(),
            Self::OrderDoesntExist => "ORDER_DOESNT_EXIST".to_string(),
            Self::OrderIdentifierInconsistency => "ORDER_IDENTIFIER_INCONSISTENCY".to_string(),
            Self::TradeIdUnspecified => "TRADE_ID_UNSPECIFIED".to_string(),
            Self::TradeDoesntExist => "TRADE_DOESNT_EXIST".to_string(),
            Self::TradeIdentifierInconsistency => "TRADE_IDENTIFIER_INCONSISTENCY".to_string(),
            Self::InsufficientMargin => "INSUFFICIENT_MARGIN".to_string(),
            Self::InstrumentMissing => "INSTRUMENT_MISSING".to_string(),
            Self::InstrumentUnknown => "INSTRUMENT_UNKNOWN".to_string(),
            Self::UnitsMissing => "UNITS_MISSING".to_string(),
            Self::UnitsInvalid => "UNITS_INVALID".to_string(),
            Self::UnitsPrecisionExceeded => "UNITS_PRECISION_EXCEEDED".to_string(),
            Self::UnitsLimitExceeded => "UNITS_LIMIT_EXCEEDED".to_string(),
            Self::UnitsMimimumNotMet => "UNITS_MIMIMUM_NOT_MET".to_string(),
            Self::PriceMissing => "PRICE_MISSING".to_string(),
            Self::PriceInvalid => "PRICE_INVALID".to_string(),
            Self::PricePrecisionExceeded => "PRICE_PRECISION_EXCEEDED".to_string(),
            Self::PriceDistanceMissing => "PRICE_DISTANCE_MISSING".to_string(),
            Self::PriceDistanceInvalid => "PRICE_DISTANCE_INVALID".to_string(),
            Self::PriceDistancePrecisionExceeded => "PRICE_DISTANCE_PRECISION_EXCEEDED".to_string(),
            Self::PriceDistanceMaximumExceeded => "PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string(),
            Self::PriceDistanceMinimumNotMet => "PRICE_DISTANCE_MINIMUM_NOT_MET".to_string(),
            Self::TimeInForceMissing => "TIME_IN_FORCE_MISSING".to_string(),
            Self::TimeInForceInvalid => "TIME_IN_FORCE_INVALID".to_string(),
            Self::TimeInForceGtdTimestampMissing => {
                "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TimeInForceGtdTimestampInPast => {
                "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::PriceBoundInvalid => "PRICE_BOUND_INVALID".to_string(),
            Self::PriceBoundPrecisionExceeded => "PRICE_BOUND_PRECISION_EXCEEDED".to_string(),
            Self::OrdersOnFillDuplicateClientOrderIds => {
                "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS".to_string()
            }
            Self::TradeOnFillClientExtensionsNotSupported => {
                "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED".to_string()
            }
            Self::ClientOrderIdInvalid => "CLIENT_ORDER_ID_INVALID".to_string(),
            Self::ClientOrderIdAlreadyExists => "CLIENT_ORDER_ID_ALREADY_EXISTS".to_string(),
            Self::ClientOrderTagInvalid => "CLIENT_ORDER_TAG_INVALID".to_string(),
            Self::ClientOrderCommentInvalid => "CLIENT_ORDER_COMMENT_INVALID".to_string(),
            Self::ClientTradeIdInvalid => "CLIENT_TRADE_ID_INVALID".to_string(),
            Self::ClientTradeIdAlreadyExists => "CLIENT_TRADE_ID_ALREADY_EXISTS".to_string(),
            Self::ClientTradeTagInvalid => "CLIENT_TRADE_TAG_INVALID".to_string(),
            Self::ClientTradeCommentInvalid => "CLIENT_TRADE_COMMENT_INVALID".to_string(),
            Self::OrderFillPositionActionMissing => {
                "ORDER_FILL_POSITION_ACTION_MISSING".to_string()
            }
            Self::OrderFillPositionActionInvalid => {
                "ORDER_FILL_POSITION_ACTION_INVALID".to_string()
            }
            Self::TriggerConditionMissing => "TRIGGER_CONDITION_MISSING".to_string(),
            Self::TriggerConditionInvalid => "TRIGGER_CONDITION_INVALID".to_string(),
            Self::OrderPartialFillOptionMissing => "ORDER_PARTIAL_FILL_OPTION_MISSING".to_string(),
            Self::OrderPartialFillOptionInvalid => "ORDER_PARTIAL_FILL_OPTION_INVALID".to_string(),
            Self::InvalidReissueImmediatePartialFill => {
                "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL".to_string()
            }
            Self::TakeProfitOrderAlreadyExists => "TAKE_PROFIT_ORDER_ALREADY_EXISTS".to_string(),
            Self::TakeProfitOnFillPriceMissing => "TAKE_PROFIT_ON_FILL_PRICE_MISSING".to_string(),
            Self::TakeProfitOnFillPriceInvalid => "TAKE_PROFIT_ON_FILL_PRICE_INVALID".to_string(),
            Self::TakeProfitOnFillPricePrecisionExceeded => {
                "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED".to_string()
            }
            Self::TakeProfitOnFillTimeInForceMissing => {
                "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::TakeProfitOnFillTimeInForceInvalid => {
                "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::TakeProfitOnFillGtdTimestampMissing => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TakeProfitOnFillGtdTimestampInPast => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TakeProfitOnFillClientOrderIdInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::TakeProfitOnFillClientOrderTagInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::TakeProfitOnFillClientOrderCommentInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::TakeProfitOnFillTriggerConditionMissing => {
                "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::TakeProfitOnFillTriggerConditionInvalid => {
                "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::StopLossOrderAlreadyExists => "STOP_LOSS_ORDER_ALREADY_EXISTS".to_string(),
            Self::StopLossOrderGuaranteedRequired => {
                "STOP_LOSS_ORDER_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOrderGuaranteedPriceWithinSpread => {
                "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD".to_string()
            }
            Self::StopLossOrderGuaranteedNotAllowed => {
                "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOrderGuaranteedHaltedCreateViolation => {
                "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION".to_string()
            }
            Self::StopLossOrderGuaranteedHaltedTightenViolation => {
                "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION".to_string()
            }
            Self::StopLossOrderGuaranteedHedgingNotAllowed => {
                "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED".to_string()
            }
            Self::StopLossOrderGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOrderNotCancelable => "STOP_LOSS_ORDER_NOT_CANCELABLE".to_string(),
            Self::StopLossOrderNotReplaceable => "STOP_LOSS_ORDER_NOT_REPLACEABLE".to_string(),
            Self::StopLossOrderGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOrderPriceAndDistanceBothSpecified => {
                "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED".to_string()
            }
            Self::StopLossOrderPriceAndDistanceBothMissing => {
                "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING".to_string()
            }
            Self::StopLossOnFillRequiredForPendingOrder => {
                "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER".to_string()
            }
            Self::StopLossOnFillGuaranteedNotAllowed => {
                "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOnFillGuaranteedRequired => {
                "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOnFillPriceMissing => "STOP_LOSS_ON_FILL_PRICE_MISSING".to_string(),
            Self::StopLossOnFillPriceInvalid => "STOP_LOSS_ON_FILL_PRICE_INVALID".to_string(),
            Self::StopLossOnFillPricePrecisionExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOnFillGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillDistanceInvalid => "STOP_LOSS_ON_FILL_DISTANCE_INVALID".to_string(),
            Self::StopLossOnFillPriceDistanceMaximumExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::StopLossOnFillDistancePrecisionExceeded => {
                "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillPriceAndDistanceBothSpecified => {
                "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED".to_string()
            }
            Self::StopLossOnFillPriceAndDistanceBothMissing => {
                "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING".to_string()
            }
            Self::StopLossOnFillTimeInForceMissing => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::StopLossOnFillTimeInForceInvalid => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::StopLossOnFillGtdTimestampMissing => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::StopLossOnFillGtdTimestampInPast => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::StopLossOnFillClientOrderIdInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::StopLossOnFillClientOrderTagInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::StopLossOnFillClientOrderCommentInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::StopLossOnFillTriggerConditionMissing => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::StopLossOnFillTriggerConditionInvalid => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::TrailingStopLossOrderAlreadyExists => {
                "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistancePrecisionExceeded => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMaximumExceeded => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMinimumNotMet => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET".to_string()
            }
            Self::TrailingStopLossOnFillTimeInForceMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillTimeInForceInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampInPast => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderIdInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderTagInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderCommentInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::TrailingStopLossOrdersNotSupported => {
                "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED".to_string()
            }
            Self::TrailingStopLossOnFillTriggerConditionMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillTriggerConditionInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::CloseTradeTypeMissing => "CLOSE_TRADE_TYPE_MISSING".to_string(),
            Self::CloseTradePartialUnitsMissing => "CLOSE_TRADE_PARTIAL_UNITS_MISSING".to_string(),
            Self::CloseTradeUnitsExceedTradeSize => {
                "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE".to_string()
            }
            Self::CloseoutPositionDoesntExist => "CLOSEOUT_POSITION_DOESNT_EXIST".to_string(),
            Self::CloseoutPositionIncompleteSpecification => {
                "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION".to_string()
            }
            Self::CloseoutPositionUnitsExceedPositionSize => {
                "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE".to_string()
            }
            Self::CloseoutPositionReject => "CLOSEOUT_POSITION_REJECT".to_string(),
            Self::CloseoutPositionPartialUnitsMissing => {
                "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING".to_string()
            }
            Self::MarkupGroupIdInvalid => "MARKUP_GROUP_ID_INVALID".to_string(),
            Self::PositionAggregationModeInvalid => "POSITION_AGGREGATION_MODE_INVALID".to_string(),
            Self::AdminConfigureDataMissing => "ADMIN_CONFIGURE_DATA_MISSING".to_string(),
            Self::MarginRateInvalid => "MARGIN_RATE_INVALID".to_string(),
            Self::MarginRateWouldTriggerCloseout => {
                "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT".to_string()
            }
            Self::AliasInvalid => "ALIAS_INVALID".to_string(),
            Self::ClientConfigureDataMissing => "CLIENT_CONFIGURE_DATA_MISSING".to_string(),
            Self::MarginRateWouldTriggerMarginCall => {
                "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL".to_string()
            }
            Self::AmountInvalid => "AMOUNT_INVALID".to_string(),
            Self::InsufficientFunds => "INSUFFICIENT_FUNDS".to_string(),
            Self::AmountMissing => "AMOUNT_MISSING".to_string(),
            Self::FundingReasonMissing => "FUNDING_REASON_MISSING".to_string(),
            Self::ClientExtensionsDataMissing => "CLIENT_EXTENSIONS_DATA_MISSING".to_string(),
            Self::ReplacingOrderInvalid => "REPLACING_ORDER_INVALID".to_string(),
            Self::ReplacingTradeIdInvalid => "REPLACING_TRADE_ID_INVALID".to_string(),
        }
    }
}

impl std::str::FromStr for LimitOrderRejectTransactionRejectReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "INTERNAL_SERVER_ERROR" => Ok(Self::InternalServerError),
            "INSTRUMENT_PRICE_UNKNOWN" => Ok(Self::InstrumentPriceUnknown),
            "ACCOUNT_NOT_ACTIVE" => Ok(Self::AccountNotActive),
            "ACCOUNT_LOCKED" => Ok(Self::AccountLocked),
            "ACCOUNT_ORDER_CREATION_LOCKED" => Ok(Self::AccountOrderCreationLocked),
            "ACCOUNT_CONFIGURATION_LOCKED" => Ok(Self::AccountConfigurationLocked),
            "ACCOUNT_DEPOSIT_LOCKED" => Ok(Self::AccountDepositLocked),
            "ACCOUNT_WITHDRAWAL_LOCKED" => Ok(Self::AccountWithdrawalLocked),
            "ACCOUNT_ORDER_CANCEL_LOCKED" => Ok(Self::AccountOrderCancelLocked),
            "INSTRUMENT_NOT_TRADEABLE" => Ok(Self::InstrumentNotTradeable),
            "PENDING_ORDERS_ALLOWED_EXCEEDED" => Ok(Self::PendingOrdersAllowedExceeded),
            "ORDER_ID_UNSPECIFIED" => Ok(Self::OrderIdUnspecified),
            "ORDER_DOESNT_EXIST" => Ok(Self::OrderDoesntExist),
            "ORDER_IDENTIFIER_INCONSISTENCY" => Ok(Self::OrderIdentifierInconsistency),
            "TRADE_ID_UNSPECIFIED" => Ok(Self::TradeIdUnspecified),
            "TRADE_DOESNT_EXIST" => Ok(Self::TradeDoesntExist),
            "TRADE_IDENTIFIER_INCONSISTENCY" => Ok(Self::TradeIdentifierInconsistency),
            "INSUFFICIENT_MARGIN" => Ok(Self::InsufficientMargin),
            "INSTRUMENT_MISSING" => Ok(Self::InstrumentMissing),
            "INSTRUMENT_UNKNOWN" => Ok(Self::InstrumentUnknown),
            "UNITS_MISSING" => Ok(Self::UnitsMissing),
            "UNITS_INVALID" => Ok(Self::UnitsInvalid),
            "UNITS_PRECISION_EXCEEDED" => Ok(Self::UnitsPrecisionExceeded),
            "UNITS_LIMIT_EXCEEDED" => Ok(Self::UnitsLimitExceeded),
            "UNITS_MIMIMUM_NOT_MET" => Ok(Self::UnitsMimimumNotMet),
            "PRICE_MISSING" => Ok(Self::PriceMissing),
            "PRICE_INVALID" => Ok(Self::PriceInvalid),
            "PRICE_PRECISION_EXCEEDED" => Ok(Self::PricePrecisionExceeded),
            "PRICE_DISTANCE_MISSING" => Ok(Self::PriceDistanceMissing),
            "PRICE_DISTANCE_INVALID" => Ok(Self::PriceDistanceInvalid),
            "PRICE_DISTANCE_PRECISION_EXCEEDED" => Ok(Self::PriceDistancePrecisionExceeded),
            "PRICE_DISTANCE_MAXIMUM_EXCEEDED" => Ok(Self::PriceDistanceMaximumExceeded),
            "PRICE_DISTANCE_MINIMUM_NOT_MET" => Ok(Self::PriceDistanceMinimumNotMet),
            "TIME_IN_FORCE_MISSING" => Ok(Self::TimeInForceMissing),
            "TIME_IN_FORCE_INVALID" => Ok(Self::TimeInForceInvalid),
            "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING" => Ok(Self::TimeInForceGtdTimestampMissing),
            "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST" => Ok(Self::TimeInForceGtdTimestampInPast),
            "PRICE_BOUND_INVALID" => Ok(Self::PriceBoundInvalid),
            "PRICE_BOUND_PRECISION_EXCEEDED" => Ok(Self::PriceBoundPrecisionExceeded),
            "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS" => {
                Ok(Self::OrdersOnFillDuplicateClientOrderIds)
            }
            "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED" => {
                Ok(Self::TradeOnFillClientExtensionsNotSupported)
            }
            "CLIENT_ORDER_ID_INVALID" => Ok(Self::ClientOrderIdInvalid),
            "CLIENT_ORDER_ID_ALREADY_EXISTS" => Ok(Self::ClientOrderIdAlreadyExists),
            "CLIENT_ORDER_TAG_INVALID" => Ok(Self::ClientOrderTagInvalid),
            "CLIENT_ORDER_COMMENT_INVALID" => Ok(Self::ClientOrderCommentInvalid),
            "CLIENT_TRADE_ID_INVALID" => Ok(Self::ClientTradeIdInvalid),
            "CLIENT_TRADE_ID_ALREADY_EXISTS" => Ok(Self::ClientTradeIdAlreadyExists),
            "CLIENT_TRADE_TAG_INVALID" => Ok(Self::ClientTradeTagInvalid),
            "CLIENT_TRADE_COMMENT_INVALID" => Ok(Self::ClientTradeCommentInvalid),
            "ORDER_FILL_POSITION_ACTION_MISSING" => Ok(Self::OrderFillPositionActionMissing),
            "ORDER_FILL_POSITION_ACTION_INVALID" => Ok(Self::OrderFillPositionActionInvalid),
            "TRIGGER_CONDITION_MISSING" => Ok(Self::TriggerConditionMissing),
            "TRIGGER_CONDITION_INVALID" => Ok(Self::TriggerConditionInvalid),
            "ORDER_PARTIAL_FILL_OPTION_MISSING" => Ok(Self::OrderPartialFillOptionMissing),
            "ORDER_PARTIAL_FILL_OPTION_INVALID" => Ok(Self::OrderPartialFillOptionInvalid),
            "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL" => {
                Ok(Self::InvalidReissueImmediatePartialFill)
            }
            "TAKE_PROFIT_ORDER_ALREADY_EXISTS" => Ok(Self::TakeProfitOrderAlreadyExists),
            "TAKE_PROFIT_ON_FILL_PRICE_MISSING" => Ok(Self::TakeProfitOnFillPriceMissing),
            "TAKE_PROFIT_ON_FILL_PRICE_INVALID" => Ok(Self::TakeProfitOnFillPriceInvalid),
            "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(Self::TakeProfitOnFillPricePrecisionExceeded)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(Self::TakeProfitOnFillTimeInForceMissing)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(Self::TakeProfitOnFillTimeInForceInvalid)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::TakeProfitOnFillGtdTimestampMissing)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TakeProfitOnFillGtdTimestampInPast)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderIdInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderTagInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderCommentInvalid)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::TakeProfitOnFillTriggerConditionMissing)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::TakeProfitOnFillTriggerConditionInvalid)
            }
            "STOP_LOSS_ORDER_ALREADY_EXISTS" => Ok(Self::StopLossOrderAlreadyExists),
            "STOP_LOSS_ORDER_GUARANTEED_REQUIRED" => Ok(Self::StopLossOrderGuaranteedRequired),
            "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD" => {
                Ok(Self::StopLossOrderGuaranteedPriceWithinSpread)
            }
            "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED" => Ok(Self::StopLossOrderGuaranteedNotAllowed),
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION" => {
                Ok(Self::StopLossOrderGuaranteedHaltedCreateViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION" => {
                Ok(Self::StopLossOrderGuaranteedHaltedTightenViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED" => {
                Ok(Self::StopLossOrderGuaranteedHedgingNotAllowed)
            }
            "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOrderGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ORDER_NOT_CANCELABLE" => Ok(Self::StopLossOrderNotCancelable),
            "STOP_LOSS_ORDER_NOT_REPLACEABLE" => Ok(Self::StopLossOrderNotReplaceable),
            "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOrderGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(Self::StopLossOrderPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(Self::StopLossOrderPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER" => {
                Ok(Self::StopLossOnFillRequiredForPendingOrder)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED" => {
                Ok(Self::StopLossOnFillGuaranteedNotAllowed)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED" => Ok(Self::StopLossOnFillGuaranteedRequired),
            "STOP_LOSS_ON_FILL_PRICE_MISSING" => Ok(Self::StopLossOnFillPriceMissing),
            "STOP_LOSS_ON_FILL_PRICE_INVALID" => Ok(Self::StopLossOnFillPriceInvalid),
            "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(Self::StopLossOnFillPricePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOnFillGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOnFillGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_INVALID" => Ok(Self::StopLossOnFillDistanceInvalid),
            "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::StopLossOnFillPriceDistanceMaximumExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(Self::StopLossOnFillDistancePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(Self::StopLossOnFillPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(Self::StopLossOnFillPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => Ok(Self::StopLossOnFillTimeInForceMissing),
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => Ok(Self::StopLossOnFillTimeInForceInvalid),
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::StopLossOnFillGtdTimestampMissing)
            }
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => Ok(Self::StopLossOnFillGtdTimestampInPast),
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderIdInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderTagInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderCommentInvalid)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::StopLossOnFillTriggerConditionMissing)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::StopLossOnFillTriggerConditionInvalid)
            }
            "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS" => {
                Ok(Self::TrailingStopLossOrderAlreadyExists)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(Self::TrailingStopLossOnFillPriceDistancePrecisionExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMaximumExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMinimumNotMet)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(Self::TrailingStopLossOnFillTimeInForceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(Self::TrailingStopLossOnFillTimeInForceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampInPast)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderIdInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderTagInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderCommentInvalid)
            }
            "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED" => {
                Ok(Self::TrailingStopLossOrdersNotSupported)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::TrailingStopLossOnFillTriggerConditionMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::TrailingStopLossOnFillTriggerConditionInvalid)
            }
            "CLOSE_TRADE_TYPE_MISSING" => Ok(Self::CloseTradeTypeMissing),
            "CLOSE_TRADE_PARTIAL_UNITS_MISSING" => Ok(Self::CloseTradePartialUnitsMissing),
            "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE" => Ok(Self::CloseTradeUnitsExceedTradeSize),
            "CLOSEOUT_POSITION_DOESNT_EXIST" => Ok(Self::CloseoutPositionDoesntExist),
            "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION" => {
                Ok(Self::CloseoutPositionIncompleteSpecification)
            }
            "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE" => {
                Ok(Self::CloseoutPositionUnitsExceedPositionSize)
            }
            "CLOSEOUT_POSITION_REJECT" => Ok(Self::CloseoutPositionReject),
            "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING" => {
                Ok(Self::CloseoutPositionPartialUnitsMissing)
            }
            "MARKUP_GROUP_ID_INVALID" => Ok(Self::MarkupGroupIdInvalid),
            "POSITION_AGGREGATION_MODE_INVALID" => Ok(Self::PositionAggregationModeInvalid),
            "ADMIN_CONFIGURE_DATA_MISSING" => Ok(Self::AdminConfigureDataMissing),
            "MARGIN_RATE_INVALID" => Ok(Self::MarginRateInvalid),
            "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT" => Ok(Self::MarginRateWouldTriggerCloseout),
            "ALIAS_INVALID" => Ok(Self::AliasInvalid),
            "CLIENT_CONFIGURE_DATA_MISSING" => Ok(Self::ClientConfigureDataMissing),
            "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL" => Ok(Self::MarginRateWouldTriggerMarginCall),
            "AMOUNT_INVALID" => Ok(Self::AmountInvalid),
            "INSUFFICIENT_FUNDS" => Ok(Self::InsufficientFunds),
            "AMOUNT_MISSING" => Ok(Self::AmountMissing),
            "FUNDING_REASON_MISSING" => Ok(Self::FundingReasonMissing),
            "CLIENT_EXTENSIONS_DATA_MISSING" => Ok(Self::ClientExtensionsDataMissing),
            "REPLACING_ORDER_INVALID" => Ok(Self::ReplacingOrderInvalid),
            "REPLACING_TRADE_ID_INVALID" => Ok(Self::ReplacingTradeIdInvalid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for LimitOrderRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for LimitOrderRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for LimitOrderRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The time-in-force requested for the Limit Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the Limit Order.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LimitOrderRejectTransactionTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&LimitOrderRejectTransactionTimeInForce> for LimitOrderRejectTransactionTimeInForce {
    fn from(value: &LimitOrderRejectTransactionTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for LimitOrderRejectTransactionTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for LimitOrderRejectTransactionTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for LimitOrderRejectTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for LimitOrderRejectTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for LimitOrderRejectTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///Specification of which price component should be used when determining
/// if an Order should be triggered and filled. This allows Orders to be
/// triggered based on the bid, ask, mid, default (ask for buy, bid for
/// sell) or inverse (ask for sell, bid for buy) price depending on the
/// desired behaviour. Orders are always filled using their default price
/// component. This feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order. A special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
/// results in. So for a Stop Loss Order for a long trade valid values are
/// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are valid.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of which price component should be used
/// when determining if an Order should be triggered and filled. This allows
/// Orders to be triggered based on the bid, ask, mid, default (ask for buy,
/// bid for sell) or inverse (ask for sell, bid for buy) price depending on
/// the desired behaviour. Orders are always filled using their default
/// price component.\nThis feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///  "type": "string",
///  "enum": [
///    "DEFAULT",
///    "INVERSE",
///    "BID",
///    "ASK",
///    "MID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LimitOrderRejectTransactionTriggerCondition {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "INVERSE")]
    Inverse,
    #[serde(rename = "BID")]
    Bid,
    #[serde(rename = "ASK")]
    Ask,
    #[serde(rename = "MID")]
    Mid,
}

impl From<&LimitOrderRejectTransactionTriggerCondition>
    for LimitOrderRejectTransactionTriggerCondition
{
    fn from(value: &LimitOrderRejectTransactionTriggerCondition) -> Self {
        value.clone()
    }
}

impl ToString for LimitOrderRejectTransactionTriggerCondition {
    fn to_string(&self) -> String {
        match *self {
            Self::Default => "DEFAULT".to_string(),
            Self::Inverse => "INVERSE".to_string(),
            Self::Bid => "BID".to_string(),
            Self::Ask => "ASK".to_string(),
            Self::Mid => "MID".to_string(),
        }
    }
}

impl std::str::FromStr for LimitOrderRejectTransactionTriggerCondition {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DEFAULT" => Ok(Self::Default),
            "INVERSE" => Ok(Self::Inverse),
            "BID" => Ok(Self::Bid),
            "ASK" => Ok(Self::Ask),
            "MID" => Ok(Self::Mid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for LimitOrderRejectTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for LimitOrderRejectTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for LimitOrderRejectTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Type of the Transaction. Always set to "LIMIT_ORDER_REJECT" in a
/// LimitOrderRejectTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"LIMIT_ORDER_REJECT\" in a LimitOrderRejectTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LimitOrderRejectTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&LimitOrderRejectTransactionType> for LimitOrderRejectTransactionType {
    fn from(value: &LimitOrderRejectTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for LimitOrderRejectTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for LimitOrderRejectTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for LimitOrderRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for LimitOrderRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for LimitOrderRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A LimitOrderRequest specifies the parameters that may be set when
/// creating a Limit Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A LimitOrderRequest specifies the parameters that may
/// be set when creating a Limit Order.",
///  "type": "object",
///  "properties": {
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "gtdTime": {
///      "description": "The date/time when the Limit Order will be
/// cancelled if its timeInForce is \"GTD\".",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "instrument": {
///      "description": "The Limit Order's Instrument.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "positionFill": {
///      "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///      "type": "string",
///      "enum": [
///        "OPEN_ONLY",
///        "REDUCE_FIRST",
///        "REDUCE_ONLY",
///        "DEFAULT"
///      ]
///    },
///    "price": {
///      "description": "The price threshold specified for the Limit Order.
/// The Limit Order will only be filled by a market price that is equal to
/// or better than this price.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "stopLossOnFill": {
///      "$ref": "#/components/schemas/StopLossDetails"
///    },
///    "takeProfitOnFill": {
///      "$ref": "#/components/schemas/TakeProfitDetails"
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the Limit Order.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeClientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "trailingStopLossOnFill": {
///      "$ref": "#/components/schemas/TrailingStopLossDetails"
///    },
///    "triggerCondition": {
///      "description": "Specification of which price component should be
/// used when determining if an Order should be triggered and filled. This
/// allows Orders to be triggered based on the bid, ask, mid, default (ask
/// for buy, bid for sell) or inverse (ask for sell, bid for buy) price
/// depending on the desired behaviour. Orders are always filled using their
/// default price component.\nThis feature is only provided through the REST
/// API. Clients who choose to specify a non-default trigger condition will
/// not see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///      "type": "string",
///      "enum": [
///        "DEFAULT",
///        "INVERSE",
///        "BID",
///        "ASK",
///        "MID"
///      ]
///    },
///    "type": {
///      "description": "The type of the Order to Create. Must be set to
/// \"LIMIT\" when creating a Market Order.",
///      "type": "string",
///      "enum": [
///        "MARKET",
///        "LIMIT",
///        "STOP",
///        "MARKET_IF_TOUCHED",
///        "TAKE_PROFIT",
///        "STOP_LOSS",
///        "TRAILING_STOP_LOSS",
///        "FIXED_PRICE"
///      ]
///    },
///    "units": {
///      "description": "The quantity requested to be filled by the Limit
/// Order. A posititive number of units results in a long Order, and a
/// negative number of units results in a short Order.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct LimitOrderRequest {
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The date/time when the Limit Order will be cancelled if its
    /// timeInForce is "GTD".
    #[serde(rename = "gtdTime", default, skip_serializing_if = "Option::is_none")]
    pub gtd_time: Option<String>,
    ///The Limit Order's Instrument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    ///Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(
        rename = "positionFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub position_fill: Option<LimitOrderRequestPositionFill>,
    ///The price threshold specified for the Limit Order. The Limit Order
    /// will only be filled by a market price that is equal to or better
    /// than this price.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    #[serde(
        rename = "stopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stop_loss_on_fill: Option<StopLossDetails>,
    #[serde(
        rename = "takeProfitOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub take_profit_on_fill: Option<TakeProfitDetails>,
    ///The time-in-force requested for the Limit Order.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<LimitOrderRequestTimeInForce>,
    #[serde(
        rename = "tradeClientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,
    #[serde(
        rename = "trailingStopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,
    ///Specification of which price component should be used when
    /// determining if an Order should be triggered and filled. This allows
    /// Orders to be triggered based on the bid, ask, mid, default (ask for
    /// buy, bid for sell) or inverse (ask for sell, bid for buy) price
    /// depending on the desired behaviour. Orders are always filled using
    /// their default price component. This feature is only provided
    /// through the REST API. Clients who choose to specify a non-default
    /// trigger condition will not see it reflected in any of OANDA's
    /// proprietary or partner trading platforms, their transaction history
    /// or their account statements. OANDA platforms always assume that an
    /// Order's trigger condition is set to the default value when
    /// indicating the distance from an Order's trigger price, and will
    /// always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when
    /// creating a guaranteed Stop Loss Order. In this case the
    /// TriggerCondition value must either be "DEFAULT", or the "natural"
    /// trigger side "DEFAULT" results in. So for a Stop Loss Order for a
    /// long trade valid values are "DEFAULT" and "BID", and for short
    /// trades "DEFAULT" and "ASK" are valid.
    #[serde(
        rename = "triggerCondition",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trigger_condition: Option<LimitOrderRequestTriggerCondition>,
    ///The type of the Order to Create. Must be set to "LIMIT" when
    /// creating a Market Order.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<LimitOrderRequestType>,
    ///The quantity requested to be filled by the Limit Order. A posititive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<String>,
}

impl From<&LimitOrderRequest> for LimitOrderRequest {
    fn from(value: &LimitOrderRequest) -> Self {
        value.clone()
    }
}

impl LimitOrderRequest {
    pub fn builder() -> builder::LimitOrderRequest {
        Default::default()
    }
}

///Specification of how Positions in the Account are modified when the
/// Order is filled.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///  "type": "string",
///  "enum": [
///    "OPEN_ONLY",
///    "REDUCE_FIRST",
///    "REDUCE_ONLY",
///    "DEFAULT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LimitOrderRequestPositionFill {
    #[serde(rename = "OPEN_ONLY")]
    OpenOnly,
    #[serde(rename = "REDUCE_FIRST")]
    ReduceFirst,
    #[serde(rename = "REDUCE_ONLY")]
    ReduceOnly,
    #[serde(rename = "DEFAULT")]
    Default,
}

impl From<&LimitOrderRequestPositionFill> for LimitOrderRequestPositionFill {
    fn from(value: &LimitOrderRequestPositionFill) -> Self {
        value.clone()
    }
}

impl ToString for LimitOrderRequestPositionFill {
    fn to_string(&self) -> String {
        match *self {
            Self::OpenOnly => "OPEN_ONLY".to_string(),
            Self::ReduceFirst => "REDUCE_FIRST".to_string(),
            Self::ReduceOnly => "REDUCE_ONLY".to_string(),
            Self::Default => "DEFAULT".to_string(),
        }
    }
}

impl std::str::FromStr for LimitOrderRequestPositionFill {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "OPEN_ONLY" => Ok(Self::OpenOnly),
            "REDUCE_FIRST" => Ok(Self::ReduceFirst),
            "REDUCE_ONLY" => Ok(Self::ReduceOnly),
            "DEFAULT" => Ok(Self::Default),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for LimitOrderRequestPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for LimitOrderRequestPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for LimitOrderRequestPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The time-in-force requested for the Limit Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the Limit Order.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LimitOrderRequestTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&LimitOrderRequestTimeInForce> for LimitOrderRequestTimeInForce {
    fn from(value: &LimitOrderRequestTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for LimitOrderRequestTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for LimitOrderRequestTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for LimitOrderRequestTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for LimitOrderRequestTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for LimitOrderRequestTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///Specification of which price component should be used when determining
/// if an Order should be triggered and filled. This allows Orders to be
/// triggered based on the bid, ask, mid, default (ask for buy, bid for
/// sell) or inverse (ask for sell, bid for buy) price depending on the
/// desired behaviour. Orders are always filled using their default price
/// component. This feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order. A special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
/// results in. So for a Stop Loss Order for a long trade valid values are
/// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are valid.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of which price component should be used
/// when determining if an Order should be triggered and filled. This allows
/// Orders to be triggered based on the bid, ask, mid, default (ask for buy,
/// bid for sell) or inverse (ask for sell, bid for buy) price depending on
/// the desired behaviour. Orders are always filled using their default
/// price component.\nThis feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///  "type": "string",
///  "enum": [
///    "DEFAULT",
///    "INVERSE",
///    "BID",
///    "ASK",
///    "MID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LimitOrderRequestTriggerCondition {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "INVERSE")]
    Inverse,
    #[serde(rename = "BID")]
    Bid,
    #[serde(rename = "ASK")]
    Ask,
    #[serde(rename = "MID")]
    Mid,
}

impl From<&LimitOrderRequestTriggerCondition> for LimitOrderRequestTriggerCondition {
    fn from(value: &LimitOrderRequestTriggerCondition) -> Self {
        value.clone()
    }
}

impl ToString for LimitOrderRequestTriggerCondition {
    fn to_string(&self) -> String {
        match *self {
            Self::Default => "DEFAULT".to_string(),
            Self::Inverse => "INVERSE".to_string(),
            Self::Bid => "BID".to_string(),
            Self::Ask => "ASK".to_string(),
            Self::Mid => "MID".to_string(),
        }
    }
}

impl std::str::FromStr for LimitOrderRequestTriggerCondition {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DEFAULT" => Ok(Self::Default),
            "INVERSE" => Ok(Self::Inverse),
            "BID" => Ok(Self::Bid),
            "ASK" => Ok(Self::Ask),
            "MID" => Ok(Self::Mid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for LimitOrderRequestTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for LimitOrderRequestTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for LimitOrderRequestTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The type of the Order to Create. Must be set to "LIMIT" when creating a
/// Market Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The type of the Order to Create. Must be set to
/// \"LIMIT\" when creating a Market Order.",
///  "type": "string",
///  "enum": [
///    "MARKET",
///    "LIMIT",
///    "STOP",
///    "MARKET_IF_TOUCHED",
///    "TAKE_PROFIT",
///    "STOP_LOSS",
///    "TRAILING_STOP_LOSS",
///    "FIXED_PRICE"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LimitOrderRequestType {
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "STOP")]
    Stop,
    #[serde(rename = "MARKET_IF_TOUCHED")]
    MarketIfTouched,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "STOP_LOSS")]
    StopLoss,
    #[serde(rename = "TRAILING_STOP_LOSS")]
    TrailingStopLoss,
    #[serde(rename = "FIXED_PRICE")]
    FixedPrice,
}

impl From<&LimitOrderRequestType> for LimitOrderRequestType {
    fn from(value: &LimitOrderRequestType) -> Self {
        value.clone()
    }
}

impl ToString for LimitOrderRequestType {
    fn to_string(&self) -> String {
        match *self {
            Self::Market => "MARKET".to_string(),
            Self::Limit => "LIMIT".to_string(),
            Self::Stop => "STOP".to_string(),
            Self::MarketIfTouched => "MARKET_IF_TOUCHED".to_string(),
            Self::TakeProfit => "TAKE_PROFIT".to_string(),
            Self::StopLoss => "STOP_LOSS".to_string(),
            Self::TrailingStopLoss => "TRAILING_STOP_LOSS".to_string(),
            Self::FixedPrice => "FIXED_PRICE".to_string(),
        }
    }
}

impl std::str::FromStr for LimitOrderRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "MARKET" => Ok(Self::Market),
            "LIMIT" => Ok(Self::Limit),
            "STOP" => Ok(Self::Stop),
            "MARKET_IF_TOUCHED" => Ok(Self::MarketIfTouched),
            "TAKE_PROFIT" => Ok(Self::TakeProfit),
            "STOP_LOSS" => Ok(Self::StopLoss),
            "TRAILING_STOP_LOSS" => Ok(Self::TrailingStopLoss),
            "FIXED_PRICE" => Ok(Self::FixedPrice),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for LimitOrderRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for LimitOrderRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for LimitOrderRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The current state of the Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The current state of the Order.",
///  "type": "string",
///  "enum": [
///    "PENDING",
///    "FILLED",
///    "TRIGGERED",
///    "CANCELLED"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LimitOrderState {
    #[serde(rename = "PENDING")]
    Pending,
    #[serde(rename = "FILLED")]
    Filled,
    #[serde(rename = "TRIGGERED")]
    Triggered,
    #[serde(rename = "CANCELLED")]
    Cancelled,
}

impl From<&LimitOrderState> for LimitOrderState {
    fn from(value: &LimitOrderState) -> Self {
        value.clone()
    }
}

impl ToString for LimitOrderState {
    fn to_string(&self) -> String {
        match *self {
            Self::Pending => "PENDING".to_string(),
            Self::Filled => "FILLED".to_string(),
            Self::Triggered => "TRIGGERED".to_string(),
            Self::Cancelled => "CANCELLED".to_string(),
        }
    }
}

impl std::str::FromStr for LimitOrderState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "PENDING" => Ok(Self::Pending),
            "FILLED" => Ok(Self::Filled),
            "TRIGGERED" => Ok(Self::Triggered),
            "CANCELLED" => Ok(Self::Cancelled),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for LimitOrderState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for LimitOrderState {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for LimitOrderState {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The time-in-force requested for the Limit Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the Limit Order.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LimitOrderTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&LimitOrderTimeInForce> for LimitOrderTimeInForce {
    fn from(value: &LimitOrderTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for LimitOrderTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for LimitOrderTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for LimitOrderTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for LimitOrderTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for LimitOrderTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A LimitOrderTransaction represents the creation of a Limit Order in the
/// user's Account.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A LimitOrderTransaction represents the creation of a
/// Limit Order in the user's Account.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "cancellingTransactionID": {
///      "description": "The ID of the Transaction that cancels the replaced
/// Order (only provided if this Order replaces an existing Order).",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "gtdTime": {
///      "description": "The date/time when the Limit Order will be
/// cancelled if its timeInForce is \"GTD\".",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "instrument": {
///      "description": "The Limit Order's Instrument.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "positionFill": {
///      "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///      "type": "string",
///      "enum": [
///        "OPEN_ONLY",
///        "REDUCE_FIRST",
///        "REDUCE_ONLY",
///        "DEFAULT"
///      ]
///    },
///    "price": {
///      "description": "The price threshold specified for the Limit Order.
/// The Limit Order will only be filled by a market price that is equal to
/// or better than this price.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "reason": {
///      "description": "The reason that the Limit Order was initiated",
///      "type": "string",
///      "enum": [
///        "CLIENT_ORDER",
///        "REPLACEMENT"
///      ]
///    },
///    "replacesOrderID": {
///      "description": "The ID of the Order that this Order replaces (only
/// provided if this Order replaces an existing Order).",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "stopLossOnFill": {
///      "$ref": "#/components/schemas/StopLossDetails"
///    },
///    "takeProfitOnFill": {
///      "$ref": "#/components/schemas/TakeProfitDetails"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the Limit Order.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeClientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "trailingStopLossOnFill": {
///      "$ref": "#/components/schemas/TrailingStopLossDetails"
///    },
///    "triggerCondition": {
///      "description": "Specification of which price component should be
/// used when determining if an Order should be triggered and filled. This
/// allows Orders to be triggered based on the bid, ask, mid, default (ask
/// for buy, bid for sell) or inverse (ask for sell, bid for buy) price
/// depending on the desired behaviour. Orders are always filled using their
/// default price component.\nThis feature is only provided through the REST
/// API. Clients who choose to specify a non-default trigger condition will
/// not see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///      "type": "string",
///      "enum": [
///        "DEFAULT",
///        "INVERSE",
///        "BID",
///        "ASK",
///        "MID"
///      ]
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"LIMIT_ORDER\" in a LimitOrderTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "units": {
///      "description": "The quantity requested to be filled by the Limit
/// Order. A posititive number of units results in a long Order, and a
/// negative number of units results in a short Order.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct LimitOrderTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    ///The ID of the Transaction that cancels the replaced Order (only
    /// provided if this Order replaces an existing Order).
    #[serde(
        rename = "cancellingTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The date/time when the Limit Order will be cancelled if its
    /// timeInForce is "GTD".
    #[serde(rename = "gtdTime", default, skip_serializing_if = "Option::is_none")]
    pub gtd_time: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The Limit Order's Instrument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    ///Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(
        rename = "positionFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub position_fill: Option<LimitOrderTransactionPositionFill>,
    ///The price threshold specified for the Limit Order. The Limit Order
    /// will only be filled by a market price that is equal to or better
    /// than this price.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The reason that the Limit Order was initiated
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<LimitOrderTransactionReason>,
    ///The ID of the Order that this Order replaces (only provided if this
    /// Order replaces an existing Order).
    #[serde(
        rename = "replacesOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub replaces_order_id: Option<String>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    #[serde(
        rename = "stopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stop_loss_on_fill: Option<StopLossDetails>,
    #[serde(
        rename = "takeProfitOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub take_profit_on_fill: Option<TakeProfitDetails>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The time-in-force requested for the Limit Order.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<LimitOrderTransactionTimeInForce>,
    #[serde(
        rename = "tradeClientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,
    #[serde(
        rename = "trailingStopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,
    ///Specification of which price component should be used when
    /// determining if an Order should be triggered and filled. This allows
    /// Orders to be triggered based on the bid, ask, mid, default (ask for
    /// buy, bid for sell) or inverse (ask for sell, bid for buy) price
    /// depending on the desired behaviour. Orders are always filled using
    /// their default price component. This feature is only provided
    /// through the REST API. Clients who choose to specify a non-default
    /// trigger condition will not see it reflected in any of OANDA's
    /// proprietary or partner trading platforms, their transaction history
    /// or their account statements. OANDA platforms always assume that an
    /// Order's trigger condition is set to the default value when
    /// indicating the distance from an Order's trigger price, and will
    /// always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when
    /// creating a guaranteed Stop Loss Order. In this case the
    /// TriggerCondition value must either be "DEFAULT", or the "natural"
    /// trigger side "DEFAULT" results in. So for a Stop Loss Order for a
    /// long trade valid values are "DEFAULT" and "BID", and for short
    /// trades "DEFAULT" and "ASK" are valid.
    #[serde(
        rename = "triggerCondition",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trigger_condition: Option<LimitOrderTransactionTriggerCondition>,
    ///The Type of the Transaction. Always set to "LIMIT_ORDER" in a
    /// LimitOrderTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<LimitOrderTransactionType>,
    ///The quantity requested to be filled by the Limit Order. A posititive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<String>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&LimitOrderTransaction> for LimitOrderTransaction {
    fn from(value: &LimitOrderTransaction) -> Self {
        value.clone()
    }
}

impl LimitOrderTransaction {
    pub fn builder() -> builder::LimitOrderTransaction {
        Default::default()
    }
}

///Specification of how Positions in the Account are modified when the
/// Order is filled.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///  "type": "string",
///  "enum": [
///    "OPEN_ONLY",
///    "REDUCE_FIRST",
///    "REDUCE_ONLY",
///    "DEFAULT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LimitOrderTransactionPositionFill {
    #[serde(rename = "OPEN_ONLY")]
    OpenOnly,
    #[serde(rename = "REDUCE_FIRST")]
    ReduceFirst,
    #[serde(rename = "REDUCE_ONLY")]
    ReduceOnly,
    #[serde(rename = "DEFAULT")]
    Default,
}

impl From<&LimitOrderTransactionPositionFill> for LimitOrderTransactionPositionFill {
    fn from(value: &LimitOrderTransactionPositionFill) -> Self {
        value.clone()
    }
}

impl ToString for LimitOrderTransactionPositionFill {
    fn to_string(&self) -> String {
        match *self {
            Self::OpenOnly => "OPEN_ONLY".to_string(),
            Self::ReduceFirst => "REDUCE_FIRST".to_string(),
            Self::ReduceOnly => "REDUCE_ONLY".to_string(),
            Self::Default => "DEFAULT".to_string(),
        }
    }
}

impl std::str::FromStr for LimitOrderTransactionPositionFill {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "OPEN_ONLY" => Ok(Self::OpenOnly),
            "REDUCE_FIRST" => Ok(Self::ReduceFirst),
            "REDUCE_ONLY" => Ok(Self::ReduceOnly),
            "DEFAULT" => Ok(Self::Default),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for LimitOrderTransactionPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for LimitOrderTransactionPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for LimitOrderTransactionPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The reason that the Limit Order was initiated
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Limit Order was initiated",
///  "type": "string",
///  "enum": [
///    "CLIENT_ORDER",
///    "REPLACEMENT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LimitOrderTransactionReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "REPLACEMENT")]
    Replacement,
}

impl From<&LimitOrderTransactionReason> for LimitOrderTransactionReason {
    fn from(value: &LimitOrderTransactionReason) -> Self {
        value.clone()
    }
}

impl ToString for LimitOrderTransactionReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ClientOrder => "CLIENT_ORDER".to_string(),
            Self::Replacement => "REPLACEMENT".to_string(),
        }
    }
}

impl std::str::FromStr for LimitOrderTransactionReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CLIENT_ORDER" => Ok(Self::ClientOrder),
            "REPLACEMENT" => Ok(Self::Replacement),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for LimitOrderTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for LimitOrderTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for LimitOrderTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The time-in-force requested for the Limit Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the Limit Order.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LimitOrderTransactionTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&LimitOrderTransactionTimeInForce> for LimitOrderTransactionTimeInForce {
    fn from(value: &LimitOrderTransactionTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for LimitOrderTransactionTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for LimitOrderTransactionTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for LimitOrderTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for LimitOrderTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for LimitOrderTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///Specification of which price component should be used when determining
/// if an Order should be triggered and filled. This allows Orders to be
/// triggered based on the bid, ask, mid, default (ask for buy, bid for
/// sell) or inverse (ask for sell, bid for buy) price depending on the
/// desired behaviour. Orders are always filled using their default price
/// component. This feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order. A special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
/// results in. So for a Stop Loss Order for a long trade valid values are
/// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are valid.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of which price component should be used
/// when determining if an Order should be triggered and filled. This allows
/// Orders to be triggered based on the bid, ask, mid, default (ask for buy,
/// bid for sell) or inverse (ask for sell, bid for buy) price depending on
/// the desired behaviour. Orders are always filled using their default
/// price component.\nThis feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///  "type": "string",
///  "enum": [
///    "DEFAULT",
///    "INVERSE",
///    "BID",
///    "ASK",
///    "MID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LimitOrderTransactionTriggerCondition {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "INVERSE")]
    Inverse,
    #[serde(rename = "BID")]
    Bid,
    #[serde(rename = "ASK")]
    Ask,
    #[serde(rename = "MID")]
    Mid,
}

impl From<&LimitOrderTransactionTriggerCondition> for LimitOrderTransactionTriggerCondition {
    fn from(value: &LimitOrderTransactionTriggerCondition) -> Self {
        value.clone()
    }
}

impl ToString for LimitOrderTransactionTriggerCondition {
    fn to_string(&self) -> String {
        match *self {
            Self::Default => "DEFAULT".to_string(),
            Self::Inverse => "INVERSE".to_string(),
            Self::Bid => "BID".to_string(),
            Self::Ask => "ASK".to_string(),
            Self::Mid => "MID".to_string(),
        }
    }
}

impl std::str::FromStr for LimitOrderTransactionTriggerCondition {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DEFAULT" => Ok(Self::Default),
            "INVERSE" => Ok(Self::Inverse),
            "BID" => Ok(Self::Bid),
            "ASK" => Ok(Self::Ask),
            "MID" => Ok(Self::Mid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for LimitOrderTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for LimitOrderTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for LimitOrderTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Type of the Transaction. Always set to "LIMIT_ORDER" in a
/// LimitOrderTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"LIMIT_ORDER\" in a LimitOrderTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LimitOrderTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&LimitOrderTransactionType> for LimitOrderTransactionType {
    fn from(value: &LimitOrderTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for LimitOrderTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for LimitOrderTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for LimitOrderTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for LimitOrderTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for LimitOrderTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///Specification of which price component should be used when determining
/// if an Order should be triggered and filled. This allows Orders to be
/// triggered based on the bid, ask, mid, default (ask for buy, bid for
/// sell) or inverse (ask for sell, bid for buy) price depending on the
/// desired behaviour. Orders are always filled using their default price
/// component. This feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order. A special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
/// results in. So for a Stop Loss Order for a long trade valid values are
/// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are valid.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of which price component should be used
/// when determining if an Order should be triggered and filled. This allows
/// Orders to be triggered based on the bid, ask, mid, default (ask for buy,
/// bid for sell) or inverse (ask for sell, bid for buy) price depending on
/// the desired behaviour. Orders are always filled using their default
/// price component.\nThis feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///  "type": "string",
///  "enum": [
///    "DEFAULT",
///    "INVERSE",
///    "BID",
///    "ASK",
///    "MID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LimitOrderTriggerCondition {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "INVERSE")]
    Inverse,
    #[serde(rename = "BID")]
    Bid,
    #[serde(rename = "ASK")]
    Ask,
    #[serde(rename = "MID")]
    Mid,
}

impl From<&LimitOrderTriggerCondition> for LimitOrderTriggerCondition {
    fn from(value: &LimitOrderTriggerCondition) -> Self {
        value.clone()
    }
}

impl ToString for LimitOrderTriggerCondition {
    fn to_string(&self) -> String {
        match *self {
            Self::Default => "DEFAULT".to_string(),
            Self::Inverse => "INVERSE".to_string(),
            Self::Bid => "BID".to_string(),
            Self::Ask => "ASK".to_string(),
            Self::Mid => "MID".to_string(),
        }
    }
}

impl std::str::FromStr for LimitOrderTriggerCondition {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DEFAULT" => Ok(Self::Default),
            "INVERSE" => Ok(Self::Inverse),
            "BID" => Ok(Self::Bid),
            "ASK" => Ok(Self::Ask),
            "MID" => Ok(Self::Mid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for LimitOrderTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for LimitOrderTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for LimitOrderTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The type of the Order. Always set to "LIMIT" for Limit Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The type of the Order. Always set to \"LIMIT\" for
/// Limit Orders.",
///  "type": "string",
///  "enum": [
///    "MARKET",
///    "LIMIT",
///    "STOP",
///    "MARKET_IF_TOUCHED",
///    "TAKE_PROFIT",
///    "STOP_LOSS",
///    "TRAILING_STOP_LOSS",
///    "FIXED_PRICE"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LimitOrderType {
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "STOP")]
    Stop,
    #[serde(rename = "MARKET_IF_TOUCHED")]
    MarketIfTouched,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "STOP_LOSS")]
    StopLoss,
    #[serde(rename = "TRAILING_STOP_LOSS")]
    TrailingStopLoss,
    #[serde(rename = "FIXED_PRICE")]
    FixedPrice,
}

impl From<&LimitOrderType> for LimitOrderType {
    fn from(value: &LimitOrderType) -> Self {
        value.clone()
    }
}

impl ToString for LimitOrderType {
    fn to_string(&self) -> String {
        match *self {
            Self::Market => "MARKET".to_string(),
            Self::Limit => "LIMIT".to_string(),
            Self::Stop => "STOP".to_string(),
            Self::MarketIfTouched => "MARKET_IF_TOUCHED".to_string(),
            Self::TakeProfit => "TAKE_PROFIT".to_string(),
            Self::StopLoss => "STOP_LOSS".to_string(),
            Self::TrailingStopLoss => "TRAILING_STOP_LOSS".to_string(),
            Self::FixedPrice => "FIXED_PRICE".to_string(),
        }
    }
}

impl std::str::FromStr for LimitOrderType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "MARKET" => Ok(Self::Market),
            "LIMIT" => Ok(Self::Limit),
            "STOP" => Ok(Self::Stop),
            "MARKET_IF_TOUCHED" => Ok(Self::MarketIfTouched),
            "TAKE_PROFIT" => Ok(Self::TakeProfit),
            "STOP_LOSS" => Ok(Self::StopLoss),
            "TRAILING_STOP_LOSS" => Ok(Self::TrailingStopLoss),
            "FIXED_PRICE" => Ok(Self::FixedPrice),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for LimitOrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for LimitOrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for LimitOrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A LiquidityRegenerationSchedule indicates how liquidity that is used
/// when filling an Order for an instrument is regenerated following the
/// fill.  A liquidity regeneration schedule will be in effect until the
/// timestamp of its final step, but may be replaced by a schedule created
/// for an Order of the same instrument that is filled while it is still in
/// effect.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A LiquidityRegenerationSchedule indicates how liquidity
/// that is used when filling an Order for an instrument is regenerated
/// following the fill.  A liquidity regeneration schedule will be in effect
/// until the timestamp of its final step, but may be replaced by a schedule
/// created for an Order of the same instrument that is filled while it is
/// still in effect.",
///  "type": "object",
///  "properties": {
///    "steps": {
///      "description": "The steps in the Liquidity Regeneration Schedule",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/LiquidityRegenerationScheduleStep"
///      }
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct LiquidityRegenerationSchedule {
    ///The steps in the Liquidity Regeneration Schedule
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub steps: Vec<LiquidityRegenerationScheduleStep>,
}

impl From<&LiquidityRegenerationSchedule> for LiquidityRegenerationSchedule {
    fn from(value: &LiquidityRegenerationSchedule) -> Self {
        value.clone()
    }
}

impl LiquidityRegenerationSchedule {
    pub fn builder() -> builder::LiquidityRegenerationSchedule {
        Default::default()
    }
}

///A liquidity regeneration schedule Step indicates the amount of bid and
/// ask liquidity that is used by the Account at a certain time. These
/// amounts will only change at the timestamp of the following step.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A liquidity regeneration schedule Step indicates the
/// amount of bid and ask liquidity that is used by the Account at a certain
/// time. These amounts will only change at the timestamp of the following
/// step.",
///  "type": "object",
///  "properties": {
///    "askLiquidityUsed": {
///      "description": "The amount of ask liquidity used at this step in
/// the schedule.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "bidLiquidityUsed": {
///      "description": "The amount of bid liquidity used at this step in
/// the schedule.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "timestamp": {
///      "description": "The timestamp of the schedule step.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct LiquidityRegenerationScheduleStep {
    ///The amount of ask liquidity used at this step in the schedule.
    #[serde(
        rename = "askLiquidityUsed",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub ask_liquidity_used: Option<String>,
    ///The amount of bid liquidity used at this step in the schedule.
    #[serde(
        rename = "bidLiquidityUsed",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub bid_liquidity_used: Option<String>,
    ///The timestamp of the schedule step.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<String>,
}

impl From<&LiquidityRegenerationScheduleStep> for LiquidityRegenerationScheduleStep {
    fn from(value: &LiquidityRegenerationScheduleStep) -> Self {
        value.clone()
    }
}

impl LiquidityRegenerationScheduleStep {
    pub fn builder() -> builder::LiquidityRegenerationScheduleStep {
        Default::default()
    }
}

///ListAccountsResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "accounts": {
///      "description": "The list of Accounts the client is authorized to
/// access and their associated properties.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/AccountProperties"
///      }
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ListAccountsResponse {
    ///The list of Accounts the client is authorized to access and their
    /// associated properties.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub accounts: Vec<AccountProperties>,
}

impl From<&ListAccountsResponse> for ListAccountsResponse {
    fn from(value: &ListAccountsResponse) -> Self {
        value.clone()
    }
}

impl ListAccountsResponse {
    pub fn builder() -> builder::ListAccountsResponse {
        Default::default()
    }
}

///ListOpenPositionsResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "lastTransactionID": {
///      "description": "The ID of the most recent Transaction created for
/// the Account",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "positions": {
///      "description": "The list of open Positions in the Account.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/Position"
///      }
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ListOpenPositionsResponse {
    ///The ID of the most recent Transaction created for the Account
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
    ///The list of open Positions in the Account.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub positions: Vec<Position>,
}

impl From<&ListOpenPositionsResponse> for ListOpenPositionsResponse {
    fn from(value: &ListOpenPositionsResponse) -> Self {
        value.clone()
    }
}

impl ListOpenPositionsResponse {
    pub fn builder() -> builder::ListOpenPositionsResponse {
        Default::default()
    }
}

///ListOpenTradesResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "lastTransactionID": {
///      "description": "The ID of the most recent Transaction created for
/// the Account",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "trades": {
///      "description": "The Account's list of open Trades",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/Trade"
///      }
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ListOpenTradesResponse {
    ///The ID of the most recent Transaction created for the Account
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
    ///The Account's list of open Trades
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub trades: Vec<Trade>,
}

impl From<&ListOpenTradesResponse> for ListOpenTradesResponse {
    fn from(value: &ListOpenTradesResponse) -> Self {
        value.clone()
    }
}

impl ListOpenTradesResponse {
    pub fn builder() -> builder::ListOpenTradesResponse {
        Default::default()
    }
}

///ListOrdersResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "lastTransactionID": {
///      "description": "The ID of the most recent Transaction created for
/// the Account",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "orders": {
///      "description": "The list of Order detail objects",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/Order"
///      }
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ListOrdersResponse {
    ///The ID of the most recent Transaction created for the Account
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
    ///The list of Order detail objects
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub orders: Vec<Order>,
}

impl From<&ListOrdersResponse> for ListOrdersResponse {
    fn from(value: &ListOrdersResponse) -> Self {
        value.clone()
    }
}

impl ListOrdersResponse {
    pub fn builder() -> builder::ListOrdersResponse {
        Default::default()
    }
}

///ListPendingOrdersResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "lastTransactionID": {
///      "description": "The ID of the most recent Transaction created for
/// the Account",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "orders": {
///      "description": "The list of pending Order details",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/Order"
///      }
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ListPendingOrdersResponse {
    ///The ID of the most recent Transaction created for the Account
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
    ///The list of pending Order details
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub orders: Vec<Order>,
}

impl From<&ListPendingOrdersResponse> for ListPendingOrdersResponse {
    fn from(value: &ListPendingOrdersResponse) -> Self {
        value.clone()
    }
}

impl ListPendingOrdersResponse {
    pub fn builder() -> builder::ListPendingOrdersResponse {
        Default::default()
    }
}

///ListPositionsResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "lastTransactionID": {
///      "description": "The ID of the most recent Transaction created for
/// the Account",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "positions": {
///      "description": "The list of Account Positions.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/Position"
///      }
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ListPositionsResponse {
    ///The ID of the most recent Transaction created for the Account
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
    ///The list of Account Positions.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub positions: Vec<Position>,
}

impl From<&ListPositionsResponse> for ListPositionsResponse {
    fn from(value: &ListPositionsResponse) -> Self {
        value.clone()
    }
}

impl ListPositionsResponse {
    pub fn builder() -> builder::ListPositionsResponse {
        Default::default()
    }
}

///ListTradesResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "lastTransactionID": {
///      "description": "The ID of the most recent Transaction created for
/// the Account",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "trades": {
///      "description": "The list of Trade detail objects",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/Trade"
///      }
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ListTradesResponse {
    ///The ID of the most recent Transaction created for the Account
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
    ///The list of Trade detail objects
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub trades: Vec<Trade>,
}

impl From<&ListTradesResponse> for ListTradesResponse {
    fn from(value: &ListTradesResponse) -> Self {
        value.clone()
    }
}

impl ListTradesResponse {
    pub fn builder() -> builder::ListTradesResponse {
        Default::default()
    }
}

///ListTransactionsResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "count": {
///      "description": "The number of Transactions that are contained in
/// the pages returned",
///      "type": "integer"
///    },
///    "from": {
///      "description": "The starting time provided in the request.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "lastTransactionID": {
///      "description": "The ID of the most recent Transaction created for
/// the Account",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "pageSize": {
///      "description": "The pageSize provided in the request",
///      "type": "integer"
///    },
///    "pages": {
///      "description": "The list of URLs that represent idrange queries
/// providing the data for each page in the query results",
///      "type": "array",
///      "items": {
///        "type": "string"
///      }
///    },
///    "to": {
///      "description": "The ending time provided in the request.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "type": {
///      "description": "The Transaction-type filter provided in the
/// request",
///      "type": "array",
///      "items": {
///        "description": "A filter that can be used when fetching
/// Transactions",
///        "type": "string",
///        "enum": [
///          "ORDER",
///          "FUNDING",
///          "ADMIN",
///          "CREATE",
///          "CLOSE",
///          "REOPEN",
///          "CLIENT_CONFIGURE",
///          "CLIENT_CONFIGURE_REJECT",
///          "TRANSFER_FUNDS",
///          "TRANSFER_FUNDS_REJECT",
///          "MARKET_ORDER",
///          "MARKET_ORDER_REJECT",
///          "LIMIT_ORDER",
///          "LIMIT_ORDER_REJECT",
///          "STOP_ORDER",
///          "STOP_ORDER_REJECT",
///          "MARKET_IF_TOUCHED_ORDER",
///          "MARKET_IF_TOUCHED_ORDER_REJECT",
///          "TAKE_PROFIT_ORDER",
///          "TAKE_PROFIT_ORDER_REJECT",
///          "STOP_LOSS_ORDER",
///          "STOP_LOSS_ORDER_REJECT",
///          "TRAILING_STOP_LOSS_ORDER",
///          "TRAILING_STOP_LOSS_ORDER_REJECT",
///          "ONE_CANCELS_ALL_ORDER",
///          "ONE_CANCELS_ALL_ORDER_REJECT",
///          "ONE_CANCELS_ALL_ORDER_TRIGGERED",
///          "ORDER_FILL",
///          "ORDER_CANCEL",
///          "ORDER_CANCEL_REJECT",
///          "ORDER_CLIENT_EXTENSIONS_MODIFY",
///          "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///          "TRADE_CLIENT_EXTENSIONS_MODIFY",
///          "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///          "MARGIN_CALL_ENTER",
///          "MARGIN_CALL_EXTEND",
///          "MARGIN_CALL_EXIT",
///          "DELAYED_TRADE_CLOSURE",
///          "DAILY_FINANCING",
///          "RESET_RESETTABLE_PL"
///        ]
///      }
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ListTransactionsResponse {
    ///The number of Transactions that are contained in the pages returned
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<i64>,
    ///The starting time provided in the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<String>,
    ///The ID of the most recent Transaction created for the Account
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
    ///The pageSize provided in the request
    #[serde(rename = "pageSize", default, skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    ///The list of URLs that represent idrange queries providing the data
    /// for each page in the query results
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub pages: Vec<String>,
    ///The ending time provided in the request.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub to: Option<String>,
    ///The Transaction-type filter provided in the request
    #[serde(rename = "type", default, skip_serializing_if = "Vec::is_empty")]
    pub type_: Vec<ListTransactionsResponseTypeItem>,
}

impl From<&ListTransactionsResponse> for ListTransactionsResponse {
    fn from(value: &ListTransactionsResponse) -> Self {
        value.clone()
    }
}

impl ListTransactionsResponse {
    pub fn builder() -> builder::ListTransactionsResponse {
        Default::default()
    }
}

///A filter that can be used when fetching Transactions
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A filter that can be used when fetching Transactions",
///  "type": "string",
///  "enum": [
///    "ORDER",
///    "FUNDING",
///    "ADMIN",
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ONE_CANCELS_ALL_ORDER",
///    "ONE_CANCELS_ALL_ORDER_REJECT",
///    "ONE_CANCELS_ALL_ORDER_TRIGGERED",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ListTransactionsResponseTypeItem {
    #[serde(rename = "ORDER")]
    Order,
    #[serde(rename = "FUNDING")]
    Funding,
    #[serde(rename = "ADMIN")]
    Admin,
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ONE_CANCELS_ALL_ORDER")]
    OneCancelsAllOrder,
    #[serde(rename = "ONE_CANCELS_ALL_ORDER_REJECT")]
    OneCancelsAllOrderReject,
    #[serde(rename = "ONE_CANCELS_ALL_ORDER_TRIGGERED")]
    OneCancelsAllOrderTriggered,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&ListTransactionsResponseTypeItem> for ListTransactionsResponseTypeItem {
    fn from(value: &ListTransactionsResponseTypeItem) -> Self {
        value.clone()
    }
}

impl ToString for ListTransactionsResponseTypeItem {
    fn to_string(&self) -> String {
        match *self {
            Self::Order => "ORDER".to_string(),
            Self::Funding => "FUNDING".to_string(),
            Self::Admin => "ADMIN".to_string(),
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OneCancelsAllOrder => "ONE_CANCELS_ALL_ORDER".to_string(),
            Self::OneCancelsAllOrderReject => "ONE_CANCELS_ALL_ORDER_REJECT".to_string(),
            Self::OneCancelsAllOrderTriggered => "ONE_CANCELS_ALL_ORDER_TRIGGERED".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for ListTransactionsResponseTypeItem {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "ORDER" => Ok(Self::Order),
            "FUNDING" => Ok(Self::Funding),
            "ADMIN" => Ok(Self::Admin),
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ONE_CANCELS_ALL_ORDER" => Ok(Self::OneCancelsAllOrder),
            "ONE_CANCELS_ALL_ORDER_REJECT" => Ok(Self::OneCancelsAllOrderReject),
            "ONE_CANCELS_ALL_ORDER_TRIGGERED" => Ok(Self::OneCancelsAllOrderTriggered),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for ListTransactionsResponseTypeItem {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for ListTransactionsResponseTypeItem {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for ListTransactionsResponseTypeItem {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A MarginCallEnterTransaction is created when an Account enters the
/// margin call state.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A MarginCallEnterTransaction is created when an Account
/// enters the margin call state.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"MARGIN_CALL_ENTER\" for an MarginCallEnterTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MarginCallEnterTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The Type of the Transaction. Always set to "MARGIN_CALL_ENTER" for
    /// an MarginCallEnterTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<MarginCallEnterTransactionType>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&MarginCallEnterTransaction> for MarginCallEnterTransaction {
    fn from(value: &MarginCallEnterTransaction) -> Self {
        value.clone()
    }
}

impl MarginCallEnterTransaction {
    pub fn builder() -> builder::MarginCallEnterTransaction {
        Default::default()
    }
}

///The Type of the Transaction. Always set to "MARGIN_CALL_ENTER" for an
/// MarginCallEnterTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"MARGIN_CALL_ENTER\" for an MarginCallEnterTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarginCallEnterTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&MarginCallEnterTransactionType> for MarginCallEnterTransactionType {
    fn from(value: &MarginCallEnterTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for MarginCallEnterTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for MarginCallEnterTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarginCallEnterTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarginCallEnterTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarginCallEnterTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A MarginCallExitnterTransaction is created when an Account leaves the
/// margin call state.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A MarginCallExitnterTransaction is created when an
/// Account leaves the margin call state.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"MARGIN_CALL_EXIT\" for an MarginCallExitTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MarginCallExitTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The Type of the Transaction. Always set to "MARGIN_CALL_EXIT" for an
    /// MarginCallExitTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<MarginCallExitTransactionType>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&MarginCallExitTransaction> for MarginCallExitTransaction {
    fn from(value: &MarginCallExitTransaction) -> Self {
        value.clone()
    }
}

impl MarginCallExitTransaction {
    pub fn builder() -> builder::MarginCallExitTransaction {
        Default::default()
    }
}

///The Type of the Transaction. Always set to "MARGIN_CALL_EXIT" for an
/// MarginCallExitTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"MARGIN_CALL_EXIT\" for an MarginCallExitTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarginCallExitTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&MarginCallExitTransactionType> for MarginCallExitTransactionType {
    fn from(value: &MarginCallExitTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for MarginCallExitTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for MarginCallExitTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarginCallExitTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarginCallExitTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarginCallExitTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A MarginCallExtendTransaction is created when the margin call state for
/// an Account has been extended.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A MarginCallExtendTransaction is created when the
/// margin call state for an Account has been extended.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "extensionNumber": {
///      "description": "The number of the extensions to the Account's
/// current margin call that have been applied. This value will be set to 1
/// for the first MarginCallExtend Transaction",
///      "type": "integer"
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"MARGIN_CALL_EXTEND\" for an MarginCallExtendTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MarginCallExtendTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    ///The number of the extensions to the Account's current margin call
    /// that have been applied. This value will be set to 1 for the first
    /// MarginCallExtend Transaction
    #[serde(
        rename = "extensionNumber",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub extension_number: Option<i64>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The Type of the Transaction. Always set to "MARGIN_CALL_EXTEND" for
    /// an MarginCallExtendTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<MarginCallExtendTransactionType>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&MarginCallExtendTransaction> for MarginCallExtendTransaction {
    fn from(value: &MarginCallExtendTransaction) -> Self {
        value.clone()
    }
}

impl MarginCallExtendTransaction {
    pub fn builder() -> builder::MarginCallExtendTransaction {
        Default::default()
    }
}

///The Type of the Transaction. Always set to "MARGIN_CALL_EXTEND" for an
/// MarginCallExtendTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"MARGIN_CALL_EXTEND\" for an MarginCallExtendTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarginCallExtendTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&MarginCallExtendTransactionType> for MarginCallExtendTransactionType {
    fn from(value: &MarginCallExtendTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for MarginCallExtendTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for MarginCallExtendTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarginCallExtendTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarginCallExtendTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarginCallExtendTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A MarketIfTouchedOrder is an order that is created with a price
/// threshold, and will only be filled by a market price that is touches or
/// crosses the threshold.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A MarketIfTouchedOrder is an order that is created with
/// a price threshold, and will only be filled by a market price that is
/// touches or crosses the threshold.",
///  "type": "object",
///  "properties": {
///    "cancelledTime": {
///      "description": "Date/time when the Order was cancelled (only
/// provided when the state of the Order is CANCELLED)",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "cancellingTransactionID": {
///      "description": "ID of the Transaction that cancelled the Order
/// (only provided when the Order's state is CANCELLED)",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "createTime": {
///      "description": "The time when the Order was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "filledTime": {
///      "description": "Date/time when the Order was filled (only provided
/// when the Order's state is FILLED)",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "fillingTransactionID": {
///      "description": "ID of the Transaction that filled this Order (only
/// provided when the Order's state is FILLED)",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "gtdTime": {
///      "description": "The date/time when the MarketIfTouched Order will
/// be cancelled if its timeInForce is \"GTD\".",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "id": {
///      "description": "The Order's identifier, unique within the Order's
/// Account.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "initialMarketPrice": {
///      "description": "The Market price at the time when the
/// MarketIfTouched Order was created.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "instrument": {
///      "description": "The MarketIfTouched Order's Instrument.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "positionFill": {
///      "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///      "type": "string",
///      "enum": [
///        "OPEN_ONLY",
///        "REDUCE_FIRST",
///        "REDUCE_ONLY",
///        "DEFAULT"
///      ]
///    },
///    "price": {
///      "description": "The price threshold specified for the
/// MarketIfTouched Order. The MarketIfTouched Order will only be filled by
/// a market price that crosses this price from the direction of the market
/// price at the time when the Order was created (the initialMarketPrice).
/// Depending on the value of the Order's price and initialMarketPrice, the
/// MarketIfTouchedOrder will behave like a Limit or a Stop Order.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "priceBound": {
///      "description": "The worst market price that may be used to fill
/// this MarketIfTouched Order.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "replacedByOrderID": {
///      "description": "The ID of the Order that replaced this Order (only
/// provided if this Order was cancelled as part of a cancel/replace).",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "replacesOrderID": {
///      "description": "The ID of the Order that was replaced by this Order (only provided if this Order was created as part of a cancel/replace).",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "state": {
///      "description": "The current state of the Order.",
///      "type": "string",
///      "enum": [
///        "PENDING",
///        "FILLED",
///        "TRIGGERED",
///        "CANCELLED"
///      ]
///    },
///    "stopLossOnFill": {
///      "$ref": "#/components/schemas/StopLossDetails"
///    },
///    "takeProfitOnFill": {
///      "$ref": "#/components/schemas/TakeProfitDetails"
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the MarketIfTouched
/// Order. Restricted to \"GTC\", \"GFD\" and \"GTD\" for MarketIfTouched
/// Orders.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeClientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "tradeClosedIDs": {
///      "description": "Trade IDs of Trades closed when the Order was
/// filled (only provided when the Order's state is FILLED and one or more
/// Trades were closed as a result of the fill)",
///      "type": "array",
///      "items": {
///        "description": "The Trade's identifier, unique within the Trade's
/// Account.",
///        "type": "string",
///        "format": "The string representation of the OANDA-assigned
/// TradeID. OANDA-assigned TradeIDs are positive integers, and are derived
/// from the TransactionID of the Transaction that opened the Trade."
///      }
///    },
///    "tradeOpenedID": {
///      "description": "Trade ID of Trade opened when the Order was filled
/// (only provided when the Order's state is FILLED and a Trade was opened
/// as a result of the fill)",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "tradeReducedID": {
///      "description": "Trade ID of Trade reduced when the Order was filled
/// (only provided when the Order's state is FILLED and a Trade was reduced
/// as a result of the fill)",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "trailingStopLossOnFill": {
///      "$ref": "#/components/schemas/TrailingStopLossDetails"
///    },
///    "triggerCondition": {
///      "description": "Specification of which price component should be
/// used when determining if an Order should be triggered and filled. This
/// allows Orders to be triggered based on the bid, ask, mid, default (ask
/// for buy, bid for sell) or inverse (ask for sell, bid for buy) price
/// depending on the desired behaviour. Orders are always filled using their
/// default price component.\nThis feature is only provided through the REST
/// API. Clients who choose to specify a non-default trigger condition will
/// not see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///      "type": "string",
///      "enum": [
///        "DEFAULT",
///        "INVERSE",
///        "BID",
///        "ASK",
///        "MID"
///      ]
///    },
///    "type": {
///      "description": "The type of the Order. Always set to
/// \"MARKET_IF_TOUCHED\" for Market If Touched Orders.",
///      "type": "string",
///      "enum": [
///        "MARKET",
///        "LIMIT",
///        "STOP",
///        "MARKET_IF_TOUCHED",
///        "TAKE_PROFIT",
///        "STOP_LOSS",
///        "TRAILING_STOP_LOSS",
///        "FIXED_PRICE"
///      ]
///    },
///    "units": {
///      "description": "The quantity requested to be filled by the
/// MarketIfTouched Order. A posititive number of units results in a long
/// Order, and a negative number of units results in a short Order.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MarketIfTouchedOrder {
    ///Date/time when the Order was cancelled (only provided when the state
    /// of the Order is CANCELLED)
    #[serde(
        rename = "cancelledTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelled_time: Option<String>,
    ///ID of the Transaction that cancelled the Order (only provided when
    /// the Order's state is CANCELLED)
    #[serde(
        rename = "cancellingTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The time when the Order was created.
    #[serde(
        rename = "createTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub create_time: Option<String>,
    ///Date/time when the Order was filled (only provided when the Order's
    /// state is FILLED)
    #[serde(
        rename = "filledTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub filled_time: Option<String>,
    ///ID of the Transaction that filled this Order (only provided when the
    /// Order's state is FILLED)
    #[serde(
        rename = "fillingTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub filling_transaction_id: Option<String>,
    ///The date/time when the MarketIfTouched Order will be cancelled if
    /// its timeInForce is "GTD".
    #[serde(rename = "gtdTime", default, skip_serializing_if = "Option::is_none")]
    pub gtd_time: Option<String>,
    ///The Order's identifier, unique within the Order's Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The Market price at the time when the MarketIfTouched Order was
    /// created.
    #[serde(
        rename = "initialMarketPrice",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub initial_market_price: Option<String>,
    ///The MarketIfTouched Order's Instrument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    ///Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(
        rename = "positionFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub position_fill: Option<MarketIfTouchedOrderPositionFill>,
    ///The price threshold specified for the MarketIfTouched Order. The
    /// MarketIfTouched Order will only be filled by a market price that
    /// crosses this price from the direction of the market price at the
    /// time when the Order was created (the initialMarketPrice). Depending
    /// on the value of the Order's price and initialMarketPrice, the
    /// MarketIfTouchedOrder will behave like a Limit or a Stop Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The worst market price that may be used to fill this MarketIfTouched
    /// Order.
    #[serde(
        rename = "priceBound",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub price_bound: Option<String>,
    ///The ID of the Order that replaced this Order (only provided if this
    /// Order was cancelled as part of a cancel/replace).
    #[serde(
        rename = "replacedByOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub replaced_by_order_id: Option<String>,
    ///The ID of the Order that was replaced by this Order (only provided
    /// if this Order was created as part of a cancel/replace).
    #[serde(
        rename = "replacesOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub replaces_order_id: Option<String>,
    ///The current state of the Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<MarketIfTouchedOrderState>,
    #[serde(
        rename = "stopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stop_loss_on_fill: Option<StopLossDetails>,
    #[serde(
        rename = "takeProfitOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub take_profit_on_fill: Option<TakeProfitDetails>,
    ///The time-in-force requested for the MarketIfTouched Order.
    /// Restricted to "GTC", "GFD" and "GTD" for MarketIfTouched Orders.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<MarketIfTouchedOrderTimeInForce>,
    #[serde(
        rename = "tradeClientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,
    ///Trade IDs of Trades closed when the Order was filled (only provided
    /// when the Order's state is FILLED and one or more Trades were closed
    /// as a result of the fill)
    #[serde(
        rename = "tradeClosedIDs",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub trade_closed_i_ds: Vec<String>,
    ///Trade ID of Trade opened when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was opened as a result
    /// of the fill)
    #[serde(
        rename = "tradeOpenedID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_opened_id: Option<String>,
    ///Trade ID of Trade reduced when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was reduced as a result
    /// of the fill)
    #[serde(
        rename = "tradeReducedID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_reduced_id: Option<String>,
    #[serde(
        rename = "trailingStopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,
    ///Specification of which price component should be used when
    /// determining if an Order should be triggered and filled. This allows
    /// Orders to be triggered based on the bid, ask, mid, default (ask for
    /// buy, bid for sell) or inverse (ask for sell, bid for buy) price
    /// depending on the desired behaviour. Orders are always filled using
    /// their default price component. This feature is only provided
    /// through the REST API. Clients who choose to specify a non-default
    /// trigger condition will not see it reflected in any of OANDA's
    /// proprietary or partner trading platforms, their transaction history
    /// or their account statements. OANDA platforms always assume that an
    /// Order's trigger condition is set to the default value when
    /// indicating the distance from an Order's trigger price, and will
    /// always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when
    /// creating a guaranteed Stop Loss Order. In this case the
    /// TriggerCondition value must either be "DEFAULT", or the "natural"
    /// trigger side "DEFAULT" results in. So for a Stop Loss Order for a
    /// long trade valid values are "DEFAULT" and "BID", and for short
    /// trades "DEFAULT" and "ASK" are valid.
    #[serde(
        rename = "triggerCondition",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trigger_condition: Option<MarketIfTouchedOrderTriggerCondition>,
    ///The type of the Order. Always set to "MARKET_IF_TOUCHED" for Market
    /// If Touched Orders.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<MarketIfTouchedOrderType>,
    ///The quantity requested to be filled by the MarketIfTouched Order. A
    /// posititive number of units results in a long Order, and a negative
    /// number of units results in a short Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<String>,
}

impl From<&MarketIfTouchedOrder> for MarketIfTouchedOrder {
    fn from(value: &MarketIfTouchedOrder) -> Self {
        value.clone()
    }
}

impl MarketIfTouchedOrder {
    pub fn builder() -> builder::MarketIfTouchedOrder {
        Default::default()
    }
}

///Specification of how Positions in the Account are modified when the
/// Order is filled.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///  "type": "string",
///  "enum": [
///    "OPEN_ONLY",
///    "REDUCE_FIRST",
///    "REDUCE_ONLY",
///    "DEFAULT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketIfTouchedOrderPositionFill {
    #[serde(rename = "OPEN_ONLY")]
    OpenOnly,
    #[serde(rename = "REDUCE_FIRST")]
    ReduceFirst,
    #[serde(rename = "REDUCE_ONLY")]
    ReduceOnly,
    #[serde(rename = "DEFAULT")]
    Default,
}

impl From<&MarketIfTouchedOrderPositionFill> for MarketIfTouchedOrderPositionFill {
    fn from(value: &MarketIfTouchedOrderPositionFill) -> Self {
        value.clone()
    }
}

impl ToString for MarketIfTouchedOrderPositionFill {
    fn to_string(&self) -> String {
        match *self {
            Self::OpenOnly => "OPEN_ONLY".to_string(),
            Self::ReduceFirst => "REDUCE_FIRST".to_string(),
            Self::ReduceOnly => "REDUCE_ONLY".to_string(),
            Self::Default => "DEFAULT".to_string(),
        }
    }
}

impl std::str::FromStr for MarketIfTouchedOrderPositionFill {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "OPEN_ONLY" => Ok(Self::OpenOnly),
            "REDUCE_FIRST" => Ok(Self::ReduceFirst),
            "REDUCE_ONLY" => Ok(Self::ReduceOnly),
            "DEFAULT" => Ok(Self::Default),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketIfTouchedOrderPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketIfTouchedOrderPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketIfTouchedOrderPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The reason that the Market-if-touched Order was initiated
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Market-if-touched Order was
/// initiated",
///  "type": "string",
///  "enum": [
///    "CLIENT_ORDER",
///    "REPLACEMENT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketIfTouchedOrderReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "REPLACEMENT")]
    Replacement,
}

impl From<&MarketIfTouchedOrderReason> for MarketIfTouchedOrderReason {
    fn from(value: &MarketIfTouchedOrderReason) -> Self {
        value.clone()
    }
}

impl ToString for MarketIfTouchedOrderReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ClientOrder => "CLIENT_ORDER".to_string(),
            Self::Replacement => "REPLACEMENT".to_string(),
        }
    }
}

impl std::str::FromStr for MarketIfTouchedOrderReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CLIENT_ORDER" => Ok(Self::ClientOrder),
            "REPLACEMENT" => Ok(Self::Replacement),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketIfTouchedOrderReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketIfTouchedOrderReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketIfTouchedOrderReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A MarketIfTouchedOrderRejectTransaction represents the rejection of the
/// creation of a MarketIfTouched Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A MarketIfTouchedOrderRejectTransaction represents the
/// rejection of the creation of a MarketIfTouched Order.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "gtdTime": {
///      "description": "The date/time when the MarketIfTouched Order will
/// be cancelled if its timeInForce is \"GTD\".",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "instrument": {
///      "description": "The MarketIfTouched Order's Instrument.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "intendedReplacesOrderID": {
///      "description": "The ID of the Order that this Order was intended to
/// replace (only provided if this Order was intended to replace an existing
/// Order).",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "positionFill": {
///      "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///      "type": "string",
///      "enum": [
///        "OPEN_ONLY",
///        "REDUCE_FIRST",
///        "REDUCE_ONLY",
///        "DEFAULT"
///      ]
///    },
///    "price": {
///      "description": "The price threshold specified for the
/// MarketIfTouched Order. The MarketIfTouched Order will only be filled by
/// a market price that crosses this price from the direction of the market
/// price at the time when the Order was created (the initialMarketPrice).
/// Depending on the value of the Order's price and initialMarketPrice, the
/// MarketIfTouchedOrder will behave like a Limit or a Stop Order.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "priceBound": {
///      "description": "The worst market price that may be used to fill
/// this MarketIfTouched Order.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "reason": {
///      "description": "The reason that the Market-if-touched Order was
/// initiated",
///      "type": "string",
///      "enum": [
///        "CLIENT_ORDER",
///        "REPLACEMENT"
///      ]
///    },
///    "rejectReason": {
///      "description": "The reason that the Reject Transaction was
/// created",
///      "type": "string",
///      "enum": [
///        "INTERNAL_SERVER_ERROR",
///        "INSTRUMENT_PRICE_UNKNOWN",
///        "ACCOUNT_NOT_ACTIVE",
///        "ACCOUNT_LOCKED",
///        "ACCOUNT_ORDER_CREATION_LOCKED",
///        "ACCOUNT_CONFIGURATION_LOCKED",
///        "ACCOUNT_DEPOSIT_LOCKED",
///        "ACCOUNT_WITHDRAWAL_LOCKED",
///        "ACCOUNT_ORDER_CANCEL_LOCKED",
///        "INSTRUMENT_NOT_TRADEABLE",
///        "PENDING_ORDERS_ALLOWED_EXCEEDED",
///        "ORDER_ID_UNSPECIFIED",
///        "ORDER_DOESNT_EXIST",
///        "ORDER_IDENTIFIER_INCONSISTENCY",
///        "TRADE_ID_UNSPECIFIED",
///        "TRADE_DOESNT_EXIST",
///        "TRADE_IDENTIFIER_INCONSISTENCY",
///        "INSUFFICIENT_MARGIN",
///        "INSTRUMENT_MISSING",
///        "INSTRUMENT_UNKNOWN",
///        "UNITS_MISSING",
///        "UNITS_INVALID",
///        "UNITS_PRECISION_EXCEEDED",
///        "UNITS_LIMIT_EXCEEDED",
///        "UNITS_MIMIMUM_NOT_MET",
///        "PRICE_MISSING",
///        "PRICE_INVALID",
///        "PRICE_PRECISION_EXCEEDED",
///        "PRICE_DISTANCE_MISSING",
///        "PRICE_DISTANCE_INVALID",
///        "PRICE_DISTANCE_PRECISION_EXCEEDED",
///        "PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "PRICE_DISTANCE_MINIMUM_NOT_MET",
///        "TIME_IN_FORCE_MISSING",
///        "TIME_IN_FORCE_INVALID",
///        "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING",
///        "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST",
///        "PRICE_BOUND_INVALID",
///        "PRICE_BOUND_PRECISION_EXCEEDED",
///        "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS",
///        "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED",
///        "CLIENT_ORDER_ID_INVALID",
///        "CLIENT_ORDER_ID_ALREADY_EXISTS",
///        "CLIENT_ORDER_TAG_INVALID",
///        "CLIENT_ORDER_COMMENT_INVALID",
///        "CLIENT_TRADE_ID_INVALID",
///        "CLIENT_TRADE_ID_ALREADY_EXISTS",
///        "CLIENT_TRADE_TAG_INVALID",
///        "CLIENT_TRADE_COMMENT_INVALID",
///        "ORDER_FILL_POSITION_ACTION_MISSING",
///        "ORDER_FILL_POSITION_ACTION_INVALID",
///        "TRIGGER_CONDITION_MISSING",
///        "TRIGGER_CONDITION_INVALID",
///        "ORDER_PARTIAL_FILL_OPTION_MISSING",
///        "ORDER_PARTIAL_FILL_OPTION_INVALID",
///        "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL",
///        "TAKE_PROFIT_ORDER_ALREADY_EXISTS",
///        "TAKE_PROFIT_ON_FILL_PRICE_MISSING",
///        "TAKE_PROFIT_ON_FILL_PRICE_INVALID",
///        "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED",
///        "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING",
///        "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID",
///        "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "STOP_LOSS_ORDER_ALREADY_EXISTS",
///        "STOP_LOSS_ORDER_GUARANTEED_REQUIRED",
///        "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD",
///        "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED",
///        "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION",
///        "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION",
///        "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED",
///        "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///        "STOP_LOSS_ORDER_NOT_CANCELABLE",
///        "STOP_LOSS_ORDER_NOT_REPLACEABLE",
///        "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///        "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///        "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING",
///        "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER",
///        "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///        "STOP_LOSS_ON_FILL_PRICE_MISSING",
///        "STOP_LOSS_ON_FILL_PRICE_INVALID",
///        "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///        "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_DISTANCE_INVALID",
///        "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///        "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING",
///        "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///        "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///        "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET",
///        "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED",
///        "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "CLOSE_TRADE_TYPE_MISSING",
///        "CLOSE_TRADE_PARTIAL_UNITS_MISSING",
///        "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE",
///        "CLOSEOUT_POSITION_DOESNT_EXIST",
///        "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION",
///        "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE",
///        "CLOSEOUT_POSITION_REJECT",
///        "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING",
///        "MARKUP_GROUP_ID_INVALID",
///        "POSITION_AGGREGATION_MODE_INVALID",
///        "ADMIN_CONFIGURE_DATA_MISSING",
///        "MARGIN_RATE_INVALID",
///        "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT",
///        "ALIAS_INVALID",
///        "CLIENT_CONFIGURE_DATA_MISSING",
///        "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL",
///        "AMOUNT_INVALID",
///        "INSUFFICIENT_FUNDS",
///        "AMOUNT_MISSING",
///        "FUNDING_REASON_MISSING",
///        "CLIENT_EXTENSIONS_DATA_MISSING",
///        "REPLACING_ORDER_INVALID",
///        "REPLACING_TRADE_ID_INVALID"
///      ]
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "stopLossOnFill": {
///      "$ref": "#/components/schemas/StopLossDetails"
///    },
///    "takeProfitOnFill": {
///      "$ref": "#/components/schemas/TakeProfitDetails"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the MarketIfTouched
/// Order. Restricted to \"GTC\", \"GFD\" and \"GTD\" for MarketIfTouched
/// Orders.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeClientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "trailingStopLossOnFill": {
///      "$ref": "#/components/schemas/TrailingStopLossDetails"
///    },
///    "triggerCondition": {
///      "description": "Specification of which price component should be
/// used when determining if an Order should be triggered and filled. This
/// allows Orders to be triggered based on the bid, ask, mid, default (ask
/// for buy, bid for sell) or inverse (ask for sell, bid for buy) price
/// depending on the desired behaviour. Orders are always filled using their
/// default price component.\nThis feature is only provided through the REST
/// API. Clients who choose to specify a non-default trigger condition will
/// not see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///      "type": "string",
///      "enum": [
///        "DEFAULT",
///        "INVERSE",
///        "BID",
///        "ASK",
///        "MID"
///      ]
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"MARKET_IF_TOUCHED_ORDER_REJECT\" in a
/// MarketIfTouchedOrderRejectTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "units": {
///      "description": "The quantity requested to be filled by the
/// MarketIfTouched Order. A posititive number of units results in a long
/// Order, and a negative number of units results in a short Order.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MarketIfTouchedOrderRejectTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The date/time when the MarketIfTouched Order will be cancelled if
    /// its timeInForce is "GTD".
    #[serde(rename = "gtdTime", default, skip_serializing_if = "Option::is_none")]
    pub gtd_time: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The MarketIfTouched Order's Instrument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    ///The ID of the Order that this Order was intended to replace (only
    /// provided if this Order was intended to replace an existing Order).
    #[serde(
        rename = "intendedReplacesOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub intended_replaces_order_id: Option<String>,
    ///Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(
        rename = "positionFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub position_fill: Option<MarketIfTouchedOrderRejectTransactionPositionFill>,
    ///The price threshold specified for the MarketIfTouched Order. The
    /// MarketIfTouched Order will only be filled by a market price that
    /// crosses this price from the direction of the market price at the
    /// time when the Order was created (the initialMarketPrice). Depending
    /// on the value of the Order's price and initialMarketPrice, the
    /// MarketIfTouchedOrder will behave like a Limit or a Stop Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The worst market price that may be used to fill this MarketIfTouched
    /// Order.
    #[serde(
        rename = "priceBound",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub price_bound: Option<String>,
    ///The reason that the Market-if-touched Order was initiated
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<MarketIfTouchedOrderRejectTransactionReason>,
    ///The reason that the Reject Transaction was created
    #[serde(
        rename = "rejectReason",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub reject_reason: Option<MarketIfTouchedOrderRejectTransactionRejectReason>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    #[serde(
        rename = "stopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stop_loss_on_fill: Option<StopLossDetails>,
    #[serde(
        rename = "takeProfitOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub take_profit_on_fill: Option<TakeProfitDetails>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The time-in-force requested for the MarketIfTouched Order.
    /// Restricted to "GTC", "GFD" and "GTD" for MarketIfTouched Orders.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<MarketIfTouchedOrderRejectTransactionTimeInForce>,
    #[serde(
        rename = "tradeClientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,
    #[serde(
        rename = "trailingStopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,
    ///Specification of which price component should be used when
    /// determining if an Order should be triggered and filled. This allows
    /// Orders to be triggered based on the bid, ask, mid, default (ask for
    /// buy, bid for sell) or inverse (ask for sell, bid for buy) price
    /// depending on the desired behaviour. Orders are always filled using
    /// their default price component. This feature is only provided
    /// through the REST API. Clients who choose to specify a non-default
    /// trigger condition will not see it reflected in any of OANDA's
    /// proprietary or partner trading platforms, their transaction history
    /// or their account statements. OANDA platforms always assume that an
    /// Order's trigger condition is set to the default value when
    /// indicating the distance from an Order's trigger price, and will
    /// always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when
    /// creating a guaranteed Stop Loss Order. In this case the
    /// TriggerCondition value must either be "DEFAULT", or the "natural"
    /// trigger side "DEFAULT" results in. So for a Stop Loss Order for a
    /// long trade valid values are "DEFAULT" and "BID", and for short
    /// trades "DEFAULT" and "ASK" are valid.
    #[serde(
        rename = "triggerCondition",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trigger_condition: Option<MarketIfTouchedOrderRejectTransactionTriggerCondition>,
    ///The Type of the Transaction. Always set to
    /// "MARKET_IF_TOUCHED_ORDER_REJECT" in a
    /// MarketIfTouchedOrderRejectTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<MarketIfTouchedOrderRejectTransactionType>,
    ///The quantity requested to be filled by the MarketIfTouched Order. A
    /// posititive number of units results in a long Order, and a negative
    /// number of units results in a short Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<String>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&MarketIfTouchedOrderRejectTransaction> for MarketIfTouchedOrderRejectTransaction {
    fn from(value: &MarketIfTouchedOrderRejectTransaction) -> Self {
        value.clone()
    }
}

impl MarketIfTouchedOrderRejectTransaction {
    pub fn builder() -> builder::MarketIfTouchedOrderRejectTransaction {
        Default::default()
    }
}

///Specification of how Positions in the Account are modified when the
/// Order is filled.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///  "type": "string",
///  "enum": [
///    "OPEN_ONLY",
///    "REDUCE_FIRST",
///    "REDUCE_ONLY",
///    "DEFAULT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketIfTouchedOrderRejectTransactionPositionFill {
    #[serde(rename = "OPEN_ONLY")]
    OpenOnly,
    #[serde(rename = "REDUCE_FIRST")]
    ReduceFirst,
    #[serde(rename = "REDUCE_ONLY")]
    ReduceOnly,
    #[serde(rename = "DEFAULT")]
    Default,
}

impl From<&MarketIfTouchedOrderRejectTransactionPositionFill>
    for MarketIfTouchedOrderRejectTransactionPositionFill
{
    fn from(value: &MarketIfTouchedOrderRejectTransactionPositionFill) -> Self {
        value.clone()
    }
}

impl ToString for MarketIfTouchedOrderRejectTransactionPositionFill {
    fn to_string(&self) -> String {
        match *self {
            Self::OpenOnly => "OPEN_ONLY".to_string(),
            Self::ReduceFirst => "REDUCE_FIRST".to_string(),
            Self::ReduceOnly => "REDUCE_ONLY".to_string(),
            Self::Default => "DEFAULT".to_string(),
        }
    }
}

impl std::str::FromStr for MarketIfTouchedOrderRejectTransactionPositionFill {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "OPEN_ONLY" => Ok(Self::OpenOnly),
            "REDUCE_FIRST" => Ok(Self::ReduceFirst),
            "REDUCE_ONLY" => Ok(Self::ReduceOnly),
            "DEFAULT" => Ok(Self::Default),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketIfTouchedOrderRejectTransactionPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketIfTouchedOrderRejectTransactionPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketIfTouchedOrderRejectTransactionPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The reason that the Market-if-touched Order was initiated
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Market-if-touched Order was
/// initiated",
///  "type": "string",
///  "enum": [
///    "CLIENT_ORDER",
///    "REPLACEMENT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketIfTouchedOrderRejectTransactionReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "REPLACEMENT")]
    Replacement,
}

impl From<&MarketIfTouchedOrderRejectTransactionReason>
    for MarketIfTouchedOrderRejectTransactionReason
{
    fn from(value: &MarketIfTouchedOrderRejectTransactionReason) -> Self {
        value.clone()
    }
}

impl ToString for MarketIfTouchedOrderRejectTransactionReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ClientOrder => "CLIENT_ORDER".to_string(),
            Self::Replacement => "REPLACEMENT".to_string(),
        }
    }
}

impl std::str::FromStr for MarketIfTouchedOrderRejectTransactionReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CLIENT_ORDER" => Ok(Self::ClientOrder),
            "REPLACEMENT" => Ok(Self::Replacement),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketIfTouchedOrderRejectTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketIfTouchedOrderRejectTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketIfTouchedOrderRejectTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The reason that the Reject Transaction was created
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Reject Transaction was created",
///  "type": "string",
///  "enum": [
///    "INTERNAL_SERVER_ERROR",
///    "INSTRUMENT_PRICE_UNKNOWN",
///    "ACCOUNT_NOT_ACTIVE",
///    "ACCOUNT_LOCKED",
///    "ACCOUNT_ORDER_CREATION_LOCKED",
///    "ACCOUNT_CONFIGURATION_LOCKED",
///    "ACCOUNT_DEPOSIT_LOCKED",
///    "ACCOUNT_WITHDRAWAL_LOCKED",
///    "ACCOUNT_ORDER_CANCEL_LOCKED",
///    "INSTRUMENT_NOT_TRADEABLE",
///    "PENDING_ORDERS_ALLOWED_EXCEEDED",
///    "ORDER_ID_UNSPECIFIED",
///    "ORDER_DOESNT_EXIST",
///    "ORDER_IDENTIFIER_INCONSISTENCY",
///    "TRADE_ID_UNSPECIFIED",
///    "TRADE_DOESNT_EXIST",
///    "TRADE_IDENTIFIER_INCONSISTENCY",
///    "INSUFFICIENT_MARGIN",
///    "INSTRUMENT_MISSING",
///    "INSTRUMENT_UNKNOWN",
///    "UNITS_MISSING",
///    "UNITS_INVALID",
///    "UNITS_PRECISION_EXCEEDED",
///    "UNITS_LIMIT_EXCEEDED",
///    "UNITS_MIMIMUM_NOT_MET",
///    "PRICE_MISSING",
///    "PRICE_INVALID",
///    "PRICE_PRECISION_EXCEEDED",
///    "PRICE_DISTANCE_MISSING",
///    "PRICE_DISTANCE_INVALID",
///    "PRICE_DISTANCE_PRECISION_EXCEEDED",
///    "PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "PRICE_DISTANCE_MINIMUM_NOT_MET",
///    "TIME_IN_FORCE_MISSING",
///    "TIME_IN_FORCE_INVALID",
///    "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING",
///    "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST",
///    "PRICE_BOUND_INVALID",
///    "PRICE_BOUND_PRECISION_EXCEEDED",
///    "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS",
///    "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED",
///    "CLIENT_ORDER_ID_INVALID",
///    "CLIENT_ORDER_ID_ALREADY_EXISTS",
///    "CLIENT_ORDER_TAG_INVALID",
///    "CLIENT_ORDER_COMMENT_INVALID",
///    "CLIENT_TRADE_ID_INVALID",
///    "CLIENT_TRADE_ID_ALREADY_EXISTS",
///    "CLIENT_TRADE_TAG_INVALID",
///    "CLIENT_TRADE_COMMENT_INVALID",
///    "ORDER_FILL_POSITION_ACTION_MISSING",
///    "ORDER_FILL_POSITION_ACTION_INVALID",
///    "TRIGGER_CONDITION_MISSING",
///    "TRIGGER_CONDITION_INVALID",
///    "ORDER_PARTIAL_FILL_OPTION_MISSING",
///    "ORDER_PARTIAL_FILL_OPTION_INVALID",
///    "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL",
///    "TAKE_PROFIT_ORDER_ALREADY_EXISTS",
///    "TAKE_PROFIT_ON_FILL_PRICE_MISSING",
///    "TAKE_PROFIT_ON_FILL_PRICE_INVALID",
///    "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED",
///    "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING",
///    "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "STOP_LOSS_ORDER_ALREADY_EXISTS",
///    "STOP_LOSS_ORDER_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD",
///    "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION",
///    "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION",
///    "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED",
///    "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ORDER_NOT_CANCELABLE",
///    "STOP_LOSS_ORDER_NOT_REPLACEABLE",
///    "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///    "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING",
///    "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER",
///    "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ON_FILL_PRICE_MISSING",
///    "STOP_LOSS_ON_FILL_PRICE_INVALID",
///    "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_DISTANCE_INVALID",
///    "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///    "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET",
///    "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED",
///    "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "CLOSE_TRADE_TYPE_MISSING",
///    "CLOSE_TRADE_PARTIAL_UNITS_MISSING",
///    "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE",
///    "CLOSEOUT_POSITION_DOESNT_EXIST",
///    "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION",
///    "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE",
///    "CLOSEOUT_POSITION_REJECT",
///    "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING",
///    "MARKUP_GROUP_ID_INVALID",
///    "POSITION_AGGREGATION_MODE_INVALID",
///    "ADMIN_CONFIGURE_DATA_MISSING",
///    "MARGIN_RATE_INVALID",
///    "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT",
///    "ALIAS_INVALID",
///    "CLIENT_CONFIGURE_DATA_MISSING",
///    "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL",
///    "AMOUNT_INVALID",
///    "INSUFFICIENT_FUNDS",
///    "AMOUNT_MISSING",
///    "FUNDING_REASON_MISSING",
///    "CLIENT_EXTENSIONS_DATA_MISSING",
///    "REPLACING_ORDER_INVALID",
///    "REPLACING_TRADE_ID_INVALID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketIfTouchedOrderRejectTransactionRejectReason {
    #[serde(rename = "INTERNAL_SERVER_ERROR")]
    InternalServerError,
    #[serde(rename = "INSTRUMENT_PRICE_UNKNOWN")]
    InstrumentPriceUnknown,
    #[serde(rename = "ACCOUNT_NOT_ACTIVE")]
    AccountNotActive,
    #[serde(rename = "ACCOUNT_LOCKED")]
    AccountLocked,
    #[serde(rename = "ACCOUNT_ORDER_CREATION_LOCKED")]
    AccountOrderCreationLocked,
    #[serde(rename = "ACCOUNT_CONFIGURATION_LOCKED")]
    AccountConfigurationLocked,
    #[serde(rename = "ACCOUNT_DEPOSIT_LOCKED")]
    AccountDepositLocked,
    #[serde(rename = "ACCOUNT_WITHDRAWAL_LOCKED")]
    AccountWithdrawalLocked,
    #[serde(rename = "ACCOUNT_ORDER_CANCEL_LOCKED")]
    AccountOrderCancelLocked,
    #[serde(rename = "INSTRUMENT_NOT_TRADEABLE")]
    InstrumentNotTradeable,
    #[serde(rename = "PENDING_ORDERS_ALLOWED_EXCEEDED")]
    PendingOrdersAllowedExceeded,
    #[serde(rename = "ORDER_ID_UNSPECIFIED")]
    OrderIdUnspecified,
    #[serde(rename = "ORDER_DOESNT_EXIST")]
    OrderDoesntExist,
    #[serde(rename = "ORDER_IDENTIFIER_INCONSISTENCY")]
    OrderIdentifierInconsistency,
    #[serde(rename = "TRADE_ID_UNSPECIFIED")]
    TradeIdUnspecified,
    #[serde(rename = "TRADE_DOESNT_EXIST")]
    TradeDoesntExist,
    #[serde(rename = "TRADE_IDENTIFIER_INCONSISTENCY")]
    TradeIdentifierInconsistency,
    #[serde(rename = "INSUFFICIENT_MARGIN")]
    InsufficientMargin,
    #[serde(rename = "INSTRUMENT_MISSING")]
    InstrumentMissing,
    #[serde(rename = "INSTRUMENT_UNKNOWN")]
    InstrumentUnknown,
    #[serde(rename = "UNITS_MISSING")]
    UnitsMissing,
    #[serde(rename = "UNITS_INVALID")]
    UnitsInvalid,
    #[serde(rename = "UNITS_PRECISION_EXCEEDED")]
    UnitsPrecisionExceeded,
    #[serde(rename = "UNITS_LIMIT_EXCEEDED")]
    UnitsLimitExceeded,
    #[serde(rename = "UNITS_MIMIMUM_NOT_MET")]
    UnitsMimimumNotMet,
    #[serde(rename = "PRICE_MISSING")]
    PriceMissing,
    #[serde(rename = "PRICE_INVALID")]
    PriceInvalid,
    #[serde(rename = "PRICE_PRECISION_EXCEEDED")]
    PricePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MISSING")]
    PriceDistanceMissing,
    #[serde(rename = "PRICE_DISTANCE_INVALID")]
    PriceDistanceInvalid,
    #[serde(rename = "PRICE_DISTANCE_PRECISION_EXCEEDED")]
    PriceDistancePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    PriceDistanceMaximumExceeded,
    #[serde(rename = "PRICE_DISTANCE_MINIMUM_NOT_MET")]
    PriceDistanceMinimumNotMet,
    #[serde(rename = "TIME_IN_FORCE_MISSING")]
    TimeInForceMissing,
    #[serde(rename = "TIME_IN_FORCE_INVALID")]
    TimeInForceInvalid,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING")]
    TimeInForceGtdTimestampMissing,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST")]
    TimeInForceGtdTimestampInPast,
    #[serde(rename = "PRICE_BOUND_INVALID")]
    PriceBoundInvalid,
    #[serde(rename = "PRICE_BOUND_PRECISION_EXCEEDED")]
    PriceBoundPrecisionExceeded,
    #[serde(rename = "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS")]
    OrdersOnFillDuplicateClientOrderIds,
    #[serde(rename = "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED")]
    TradeOnFillClientExtensionsNotSupported,
    #[serde(rename = "CLIENT_ORDER_ID_INVALID")]
    ClientOrderIdInvalid,
    #[serde(rename = "CLIENT_ORDER_ID_ALREADY_EXISTS")]
    ClientOrderIdAlreadyExists,
    #[serde(rename = "CLIENT_ORDER_TAG_INVALID")]
    ClientOrderTagInvalid,
    #[serde(rename = "CLIENT_ORDER_COMMENT_INVALID")]
    ClientOrderCommentInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_INVALID")]
    ClientTradeIdInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_ALREADY_EXISTS")]
    ClientTradeIdAlreadyExists,
    #[serde(rename = "CLIENT_TRADE_TAG_INVALID")]
    ClientTradeTagInvalid,
    #[serde(rename = "CLIENT_TRADE_COMMENT_INVALID")]
    ClientTradeCommentInvalid,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_MISSING")]
    OrderFillPositionActionMissing,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_INVALID")]
    OrderFillPositionActionInvalid,
    #[serde(rename = "TRIGGER_CONDITION_MISSING")]
    TriggerConditionMissing,
    #[serde(rename = "TRIGGER_CONDITION_INVALID")]
    TriggerConditionInvalid,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_MISSING")]
    OrderPartialFillOptionMissing,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_INVALID")]
    OrderPartialFillOptionInvalid,
    #[serde(rename = "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL")]
    InvalidReissueImmediatePartialFill,
    #[serde(rename = "TAKE_PROFIT_ORDER_ALREADY_EXISTS")]
    TakeProfitOrderAlreadyExists,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_MISSING")]
    TakeProfitOnFillPriceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_INVALID")]
    TakeProfitOnFillPriceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    TakeProfitOnFillPricePrecisionExceeded,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING")]
    TakeProfitOnFillTimeInForceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID")]
    TakeProfitOnFillTimeInForceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TakeProfitOnFillGtdTimestampMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TakeProfitOnFillGtdTimestampInPast,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TakeProfitOnFillClientOrderIdInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TakeProfitOnFillClientOrderTagInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TakeProfitOnFillClientOrderCommentInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TakeProfitOnFillTriggerConditionMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TakeProfitOnFillTriggerConditionInvalid,
    #[serde(rename = "STOP_LOSS_ORDER_ALREADY_EXISTS")]
    StopLossOrderAlreadyExists,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_REQUIRED")]
    StopLossOrderGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD")]
    StopLossOrderGuaranteedPriceWithinSpread,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED")]
    StopLossOrderGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION")]
    StopLossOrderGuaranteedHaltedCreateViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION")]
    StopLossOrderGuaranteedHaltedTightenViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED")]
    StopLossOrderGuaranteedHedgingNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOrderGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_CANCELABLE")]
    StopLossOrderNotCancelable,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_REPLACEABLE")]
    StopLossOrderNotReplaceable,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOrderGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOrderPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOrderPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER")]
    StopLossOnFillRequiredForPendingOrder,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED")]
    StopLossOnFillGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED")]
    StopLossOnFillGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_MISSING")]
    StopLossOnFillPriceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_INVALID")]
    StopLossOnFillPriceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    StopLossOnFillPricePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOnFillGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOnFillGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_INVALID")]
    StopLossOnFillDistanceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    StopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED")]
    StopLossOnFillDistancePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOnFillPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOnFillPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    StopLossOnFillTimeInForceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    StopLossOnFillTimeInForceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    StopLossOnFillGtdTimestampMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    StopLossOnFillGtdTimestampInPast,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    StopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    StopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    StopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    StopLossOnFillTriggerConditionMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    StopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS")]
    TrailingStopLossOrderAlreadyExists,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING")]
    TrailingStopLossOnFillPriceDistanceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID")]
    TrailingStopLossOnFillPriceDistanceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED")]
    TrailingStopLossOnFillPriceDistancePrecisionExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    TrailingStopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET")]
    TrailingStopLossOnFillPriceDistanceMinimumNotMet,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    TrailingStopLossOnFillTimeInForceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    TrailingStopLossOnFillTimeInForceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TrailingStopLossOnFillGtdTimestampMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TrailingStopLossOnFillGtdTimestampInPast,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TrailingStopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TrailingStopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TrailingStopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED")]
    TrailingStopLossOrdersNotSupported,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TrailingStopLossOnFillTriggerConditionMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TrailingStopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "CLOSE_TRADE_TYPE_MISSING")]
    CloseTradeTypeMissing,
    #[serde(rename = "CLOSE_TRADE_PARTIAL_UNITS_MISSING")]
    CloseTradePartialUnitsMissing,
    #[serde(rename = "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE")]
    CloseTradeUnitsExceedTradeSize,
    #[serde(rename = "CLOSEOUT_POSITION_DOESNT_EXIST")]
    CloseoutPositionDoesntExist,
    #[serde(rename = "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION")]
    CloseoutPositionIncompleteSpecification,
    #[serde(rename = "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE")]
    CloseoutPositionUnitsExceedPositionSize,
    #[serde(rename = "CLOSEOUT_POSITION_REJECT")]
    CloseoutPositionReject,
    #[serde(rename = "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING")]
    CloseoutPositionPartialUnitsMissing,
    #[serde(rename = "MARKUP_GROUP_ID_INVALID")]
    MarkupGroupIdInvalid,
    #[serde(rename = "POSITION_AGGREGATION_MODE_INVALID")]
    PositionAggregationModeInvalid,
    #[serde(rename = "ADMIN_CONFIGURE_DATA_MISSING")]
    AdminConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_INVALID")]
    MarginRateInvalid,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT")]
    MarginRateWouldTriggerCloseout,
    #[serde(rename = "ALIAS_INVALID")]
    AliasInvalid,
    #[serde(rename = "CLIENT_CONFIGURE_DATA_MISSING")]
    ClientConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL")]
    MarginRateWouldTriggerMarginCall,
    #[serde(rename = "AMOUNT_INVALID")]
    AmountInvalid,
    #[serde(rename = "INSUFFICIENT_FUNDS")]
    InsufficientFunds,
    #[serde(rename = "AMOUNT_MISSING")]
    AmountMissing,
    #[serde(rename = "FUNDING_REASON_MISSING")]
    FundingReasonMissing,
    #[serde(rename = "CLIENT_EXTENSIONS_DATA_MISSING")]
    ClientExtensionsDataMissing,
    #[serde(rename = "REPLACING_ORDER_INVALID")]
    ReplacingOrderInvalid,
    #[serde(rename = "REPLACING_TRADE_ID_INVALID")]
    ReplacingTradeIdInvalid,
}

impl From<&MarketIfTouchedOrderRejectTransactionRejectReason>
    for MarketIfTouchedOrderRejectTransactionRejectReason
{
    fn from(value: &MarketIfTouchedOrderRejectTransactionRejectReason) -> Self {
        value.clone()
    }
}

impl ToString for MarketIfTouchedOrderRejectTransactionRejectReason {
    fn to_string(&self) -> String {
        match *self {
            Self::InternalServerError => "INTERNAL_SERVER_ERROR".to_string(),
            Self::InstrumentPriceUnknown => "INSTRUMENT_PRICE_UNKNOWN".to_string(),
            Self::AccountNotActive => "ACCOUNT_NOT_ACTIVE".to_string(),
            Self::AccountLocked => "ACCOUNT_LOCKED".to_string(),
            Self::AccountOrderCreationLocked => "ACCOUNT_ORDER_CREATION_LOCKED".to_string(),
            Self::AccountConfigurationLocked => "ACCOUNT_CONFIGURATION_LOCKED".to_string(),
            Self::AccountDepositLocked => "ACCOUNT_DEPOSIT_LOCKED".to_string(),
            Self::AccountWithdrawalLocked => "ACCOUNT_WITHDRAWAL_LOCKED".to_string(),
            Self::AccountOrderCancelLocked => "ACCOUNT_ORDER_CANCEL_LOCKED".to_string(),
            Self::InstrumentNotTradeable => "INSTRUMENT_NOT_TRADEABLE".to_string(),
            Self::PendingOrdersAllowedExceeded => "PENDING_ORDERS_ALLOWED_EXCEEDED".to_string(),
            Self::OrderIdUnspecified => "ORDER_ID_UNSPECIFIED".to_string(),
            Self::OrderDoesntExist => "ORDER_DOESNT_EXIST".to_string(),
            Self::OrderIdentifierInconsistency => "ORDER_IDENTIFIER_INCONSISTENCY".to_string(),
            Self::TradeIdUnspecified => "TRADE_ID_UNSPECIFIED".to_string(),
            Self::TradeDoesntExist => "TRADE_DOESNT_EXIST".to_string(),
            Self::TradeIdentifierInconsistency => "TRADE_IDENTIFIER_INCONSISTENCY".to_string(),
            Self::InsufficientMargin => "INSUFFICIENT_MARGIN".to_string(),
            Self::InstrumentMissing => "INSTRUMENT_MISSING".to_string(),
            Self::InstrumentUnknown => "INSTRUMENT_UNKNOWN".to_string(),
            Self::UnitsMissing => "UNITS_MISSING".to_string(),
            Self::UnitsInvalid => "UNITS_INVALID".to_string(),
            Self::UnitsPrecisionExceeded => "UNITS_PRECISION_EXCEEDED".to_string(),
            Self::UnitsLimitExceeded => "UNITS_LIMIT_EXCEEDED".to_string(),
            Self::UnitsMimimumNotMet => "UNITS_MIMIMUM_NOT_MET".to_string(),
            Self::PriceMissing => "PRICE_MISSING".to_string(),
            Self::PriceInvalid => "PRICE_INVALID".to_string(),
            Self::PricePrecisionExceeded => "PRICE_PRECISION_EXCEEDED".to_string(),
            Self::PriceDistanceMissing => "PRICE_DISTANCE_MISSING".to_string(),
            Self::PriceDistanceInvalid => "PRICE_DISTANCE_INVALID".to_string(),
            Self::PriceDistancePrecisionExceeded => "PRICE_DISTANCE_PRECISION_EXCEEDED".to_string(),
            Self::PriceDistanceMaximumExceeded => "PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string(),
            Self::PriceDistanceMinimumNotMet => "PRICE_DISTANCE_MINIMUM_NOT_MET".to_string(),
            Self::TimeInForceMissing => "TIME_IN_FORCE_MISSING".to_string(),
            Self::TimeInForceInvalid => "TIME_IN_FORCE_INVALID".to_string(),
            Self::TimeInForceGtdTimestampMissing => {
                "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TimeInForceGtdTimestampInPast => {
                "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::PriceBoundInvalid => "PRICE_BOUND_INVALID".to_string(),
            Self::PriceBoundPrecisionExceeded => "PRICE_BOUND_PRECISION_EXCEEDED".to_string(),
            Self::OrdersOnFillDuplicateClientOrderIds => {
                "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS".to_string()
            }
            Self::TradeOnFillClientExtensionsNotSupported => {
                "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED".to_string()
            }
            Self::ClientOrderIdInvalid => "CLIENT_ORDER_ID_INVALID".to_string(),
            Self::ClientOrderIdAlreadyExists => "CLIENT_ORDER_ID_ALREADY_EXISTS".to_string(),
            Self::ClientOrderTagInvalid => "CLIENT_ORDER_TAG_INVALID".to_string(),
            Self::ClientOrderCommentInvalid => "CLIENT_ORDER_COMMENT_INVALID".to_string(),
            Self::ClientTradeIdInvalid => "CLIENT_TRADE_ID_INVALID".to_string(),
            Self::ClientTradeIdAlreadyExists => "CLIENT_TRADE_ID_ALREADY_EXISTS".to_string(),
            Self::ClientTradeTagInvalid => "CLIENT_TRADE_TAG_INVALID".to_string(),
            Self::ClientTradeCommentInvalid => "CLIENT_TRADE_COMMENT_INVALID".to_string(),
            Self::OrderFillPositionActionMissing => {
                "ORDER_FILL_POSITION_ACTION_MISSING".to_string()
            }
            Self::OrderFillPositionActionInvalid => {
                "ORDER_FILL_POSITION_ACTION_INVALID".to_string()
            }
            Self::TriggerConditionMissing => "TRIGGER_CONDITION_MISSING".to_string(),
            Self::TriggerConditionInvalid => "TRIGGER_CONDITION_INVALID".to_string(),
            Self::OrderPartialFillOptionMissing => "ORDER_PARTIAL_FILL_OPTION_MISSING".to_string(),
            Self::OrderPartialFillOptionInvalid => "ORDER_PARTIAL_FILL_OPTION_INVALID".to_string(),
            Self::InvalidReissueImmediatePartialFill => {
                "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL".to_string()
            }
            Self::TakeProfitOrderAlreadyExists => "TAKE_PROFIT_ORDER_ALREADY_EXISTS".to_string(),
            Self::TakeProfitOnFillPriceMissing => "TAKE_PROFIT_ON_FILL_PRICE_MISSING".to_string(),
            Self::TakeProfitOnFillPriceInvalid => "TAKE_PROFIT_ON_FILL_PRICE_INVALID".to_string(),
            Self::TakeProfitOnFillPricePrecisionExceeded => {
                "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED".to_string()
            }
            Self::TakeProfitOnFillTimeInForceMissing => {
                "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::TakeProfitOnFillTimeInForceInvalid => {
                "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::TakeProfitOnFillGtdTimestampMissing => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TakeProfitOnFillGtdTimestampInPast => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TakeProfitOnFillClientOrderIdInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::TakeProfitOnFillClientOrderTagInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::TakeProfitOnFillClientOrderCommentInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::TakeProfitOnFillTriggerConditionMissing => {
                "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::TakeProfitOnFillTriggerConditionInvalid => {
                "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::StopLossOrderAlreadyExists => "STOP_LOSS_ORDER_ALREADY_EXISTS".to_string(),
            Self::StopLossOrderGuaranteedRequired => {
                "STOP_LOSS_ORDER_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOrderGuaranteedPriceWithinSpread => {
                "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD".to_string()
            }
            Self::StopLossOrderGuaranteedNotAllowed => {
                "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOrderGuaranteedHaltedCreateViolation => {
                "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION".to_string()
            }
            Self::StopLossOrderGuaranteedHaltedTightenViolation => {
                "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION".to_string()
            }
            Self::StopLossOrderGuaranteedHedgingNotAllowed => {
                "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED".to_string()
            }
            Self::StopLossOrderGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOrderNotCancelable => "STOP_LOSS_ORDER_NOT_CANCELABLE".to_string(),
            Self::StopLossOrderNotReplaceable => "STOP_LOSS_ORDER_NOT_REPLACEABLE".to_string(),
            Self::StopLossOrderGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOrderPriceAndDistanceBothSpecified => {
                "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED".to_string()
            }
            Self::StopLossOrderPriceAndDistanceBothMissing => {
                "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING".to_string()
            }
            Self::StopLossOnFillRequiredForPendingOrder => {
                "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER".to_string()
            }
            Self::StopLossOnFillGuaranteedNotAllowed => {
                "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOnFillGuaranteedRequired => {
                "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOnFillPriceMissing => "STOP_LOSS_ON_FILL_PRICE_MISSING".to_string(),
            Self::StopLossOnFillPriceInvalid => "STOP_LOSS_ON_FILL_PRICE_INVALID".to_string(),
            Self::StopLossOnFillPricePrecisionExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOnFillGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillDistanceInvalid => "STOP_LOSS_ON_FILL_DISTANCE_INVALID".to_string(),
            Self::StopLossOnFillPriceDistanceMaximumExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::StopLossOnFillDistancePrecisionExceeded => {
                "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillPriceAndDistanceBothSpecified => {
                "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED".to_string()
            }
            Self::StopLossOnFillPriceAndDistanceBothMissing => {
                "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING".to_string()
            }
            Self::StopLossOnFillTimeInForceMissing => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::StopLossOnFillTimeInForceInvalid => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::StopLossOnFillGtdTimestampMissing => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::StopLossOnFillGtdTimestampInPast => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::StopLossOnFillClientOrderIdInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::StopLossOnFillClientOrderTagInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::StopLossOnFillClientOrderCommentInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::StopLossOnFillTriggerConditionMissing => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::StopLossOnFillTriggerConditionInvalid => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::TrailingStopLossOrderAlreadyExists => {
                "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistancePrecisionExceeded => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMaximumExceeded => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMinimumNotMet => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET".to_string()
            }
            Self::TrailingStopLossOnFillTimeInForceMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillTimeInForceInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampInPast => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderIdInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderTagInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderCommentInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::TrailingStopLossOrdersNotSupported => {
                "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED".to_string()
            }
            Self::TrailingStopLossOnFillTriggerConditionMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillTriggerConditionInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::CloseTradeTypeMissing => "CLOSE_TRADE_TYPE_MISSING".to_string(),
            Self::CloseTradePartialUnitsMissing => "CLOSE_TRADE_PARTIAL_UNITS_MISSING".to_string(),
            Self::CloseTradeUnitsExceedTradeSize => {
                "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE".to_string()
            }
            Self::CloseoutPositionDoesntExist => "CLOSEOUT_POSITION_DOESNT_EXIST".to_string(),
            Self::CloseoutPositionIncompleteSpecification => {
                "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION".to_string()
            }
            Self::CloseoutPositionUnitsExceedPositionSize => {
                "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE".to_string()
            }
            Self::CloseoutPositionReject => "CLOSEOUT_POSITION_REJECT".to_string(),
            Self::CloseoutPositionPartialUnitsMissing => {
                "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING".to_string()
            }
            Self::MarkupGroupIdInvalid => "MARKUP_GROUP_ID_INVALID".to_string(),
            Self::PositionAggregationModeInvalid => "POSITION_AGGREGATION_MODE_INVALID".to_string(),
            Self::AdminConfigureDataMissing => "ADMIN_CONFIGURE_DATA_MISSING".to_string(),
            Self::MarginRateInvalid => "MARGIN_RATE_INVALID".to_string(),
            Self::MarginRateWouldTriggerCloseout => {
                "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT".to_string()
            }
            Self::AliasInvalid => "ALIAS_INVALID".to_string(),
            Self::ClientConfigureDataMissing => "CLIENT_CONFIGURE_DATA_MISSING".to_string(),
            Self::MarginRateWouldTriggerMarginCall => {
                "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL".to_string()
            }
            Self::AmountInvalid => "AMOUNT_INVALID".to_string(),
            Self::InsufficientFunds => "INSUFFICIENT_FUNDS".to_string(),
            Self::AmountMissing => "AMOUNT_MISSING".to_string(),
            Self::FundingReasonMissing => "FUNDING_REASON_MISSING".to_string(),
            Self::ClientExtensionsDataMissing => "CLIENT_EXTENSIONS_DATA_MISSING".to_string(),
            Self::ReplacingOrderInvalid => "REPLACING_ORDER_INVALID".to_string(),
            Self::ReplacingTradeIdInvalid => "REPLACING_TRADE_ID_INVALID".to_string(),
        }
    }
}

impl std::str::FromStr for MarketIfTouchedOrderRejectTransactionRejectReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "INTERNAL_SERVER_ERROR" => Ok(Self::InternalServerError),
            "INSTRUMENT_PRICE_UNKNOWN" => Ok(Self::InstrumentPriceUnknown),
            "ACCOUNT_NOT_ACTIVE" => Ok(Self::AccountNotActive),
            "ACCOUNT_LOCKED" => Ok(Self::AccountLocked),
            "ACCOUNT_ORDER_CREATION_LOCKED" => Ok(Self::AccountOrderCreationLocked),
            "ACCOUNT_CONFIGURATION_LOCKED" => Ok(Self::AccountConfigurationLocked),
            "ACCOUNT_DEPOSIT_LOCKED" => Ok(Self::AccountDepositLocked),
            "ACCOUNT_WITHDRAWAL_LOCKED" => Ok(Self::AccountWithdrawalLocked),
            "ACCOUNT_ORDER_CANCEL_LOCKED" => Ok(Self::AccountOrderCancelLocked),
            "INSTRUMENT_NOT_TRADEABLE" => Ok(Self::InstrumentNotTradeable),
            "PENDING_ORDERS_ALLOWED_EXCEEDED" => Ok(Self::PendingOrdersAllowedExceeded),
            "ORDER_ID_UNSPECIFIED" => Ok(Self::OrderIdUnspecified),
            "ORDER_DOESNT_EXIST" => Ok(Self::OrderDoesntExist),
            "ORDER_IDENTIFIER_INCONSISTENCY" => Ok(Self::OrderIdentifierInconsistency),
            "TRADE_ID_UNSPECIFIED" => Ok(Self::TradeIdUnspecified),
            "TRADE_DOESNT_EXIST" => Ok(Self::TradeDoesntExist),
            "TRADE_IDENTIFIER_INCONSISTENCY" => Ok(Self::TradeIdentifierInconsistency),
            "INSUFFICIENT_MARGIN" => Ok(Self::InsufficientMargin),
            "INSTRUMENT_MISSING" => Ok(Self::InstrumentMissing),
            "INSTRUMENT_UNKNOWN" => Ok(Self::InstrumentUnknown),
            "UNITS_MISSING" => Ok(Self::UnitsMissing),
            "UNITS_INVALID" => Ok(Self::UnitsInvalid),
            "UNITS_PRECISION_EXCEEDED" => Ok(Self::UnitsPrecisionExceeded),
            "UNITS_LIMIT_EXCEEDED" => Ok(Self::UnitsLimitExceeded),
            "UNITS_MIMIMUM_NOT_MET" => Ok(Self::UnitsMimimumNotMet),
            "PRICE_MISSING" => Ok(Self::PriceMissing),
            "PRICE_INVALID" => Ok(Self::PriceInvalid),
            "PRICE_PRECISION_EXCEEDED" => Ok(Self::PricePrecisionExceeded),
            "PRICE_DISTANCE_MISSING" => Ok(Self::PriceDistanceMissing),
            "PRICE_DISTANCE_INVALID" => Ok(Self::PriceDistanceInvalid),
            "PRICE_DISTANCE_PRECISION_EXCEEDED" => Ok(Self::PriceDistancePrecisionExceeded),
            "PRICE_DISTANCE_MAXIMUM_EXCEEDED" => Ok(Self::PriceDistanceMaximumExceeded),
            "PRICE_DISTANCE_MINIMUM_NOT_MET" => Ok(Self::PriceDistanceMinimumNotMet),
            "TIME_IN_FORCE_MISSING" => Ok(Self::TimeInForceMissing),
            "TIME_IN_FORCE_INVALID" => Ok(Self::TimeInForceInvalid),
            "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING" => Ok(Self::TimeInForceGtdTimestampMissing),
            "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST" => Ok(Self::TimeInForceGtdTimestampInPast),
            "PRICE_BOUND_INVALID" => Ok(Self::PriceBoundInvalid),
            "PRICE_BOUND_PRECISION_EXCEEDED" => Ok(Self::PriceBoundPrecisionExceeded),
            "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS" => {
                Ok(Self::OrdersOnFillDuplicateClientOrderIds)
            }
            "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED" => {
                Ok(Self::TradeOnFillClientExtensionsNotSupported)
            }
            "CLIENT_ORDER_ID_INVALID" => Ok(Self::ClientOrderIdInvalid),
            "CLIENT_ORDER_ID_ALREADY_EXISTS" => Ok(Self::ClientOrderIdAlreadyExists),
            "CLIENT_ORDER_TAG_INVALID" => Ok(Self::ClientOrderTagInvalid),
            "CLIENT_ORDER_COMMENT_INVALID" => Ok(Self::ClientOrderCommentInvalid),
            "CLIENT_TRADE_ID_INVALID" => Ok(Self::ClientTradeIdInvalid),
            "CLIENT_TRADE_ID_ALREADY_EXISTS" => Ok(Self::ClientTradeIdAlreadyExists),
            "CLIENT_TRADE_TAG_INVALID" => Ok(Self::ClientTradeTagInvalid),
            "CLIENT_TRADE_COMMENT_INVALID" => Ok(Self::ClientTradeCommentInvalid),
            "ORDER_FILL_POSITION_ACTION_MISSING" => Ok(Self::OrderFillPositionActionMissing),
            "ORDER_FILL_POSITION_ACTION_INVALID" => Ok(Self::OrderFillPositionActionInvalid),
            "TRIGGER_CONDITION_MISSING" => Ok(Self::TriggerConditionMissing),
            "TRIGGER_CONDITION_INVALID" => Ok(Self::TriggerConditionInvalid),
            "ORDER_PARTIAL_FILL_OPTION_MISSING" => Ok(Self::OrderPartialFillOptionMissing),
            "ORDER_PARTIAL_FILL_OPTION_INVALID" => Ok(Self::OrderPartialFillOptionInvalid),
            "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL" => {
                Ok(Self::InvalidReissueImmediatePartialFill)
            }
            "TAKE_PROFIT_ORDER_ALREADY_EXISTS" => Ok(Self::TakeProfitOrderAlreadyExists),
            "TAKE_PROFIT_ON_FILL_PRICE_MISSING" => Ok(Self::TakeProfitOnFillPriceMissing),
            "TAKE_PROFIT_ON_FILL_PRICE_INVALID" => Ok(Self::TakeProfitOnFillPriceInvalid),
            "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(Self::TakeProfitOnFillPricePrecisionExceeded)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(Self::TakeProfitOnFillTimeInForceMissing)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(Self::TakeProfitOnFillTimeInForceInvalid)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::TakeProfitOnFillGtdTimestampMissing)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TakeProfitOnFillGtdTimestampInPast)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderIdInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderTagInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderCommentInvalid)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::TakeProfitOnFillTriggerConditionMissing)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::TakeProfitOnFillTriggerConditionInvalid)
            }
            "STOP_LOSS_ORDER_ALREADY_EXISTS" => Ok(Self::StopLossOrderAlreadyExists),
            "STOP_LOSS_ORDER_GUARANTEED_REQUIRED" => Ok(Self::StopLossOrderGuaranteedRequired),
            "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD" => {
                Ok(Self::StopLossOrderGuaranteedPriceWithinSpread)
            }
            "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED" => Ok(Self::StopLossOrderGuaranteedNotAllowed),
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION" => {
                Ok(Self::StopLossOrderGuaranteedHaltedCreateViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION" => {
                Ok(Self::StopLossOrderGuaranteedHaltedTightenViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED" => {
                Ok(Self::StopLossOrderGuaranteedHedgingNotAllowed)
            }
            "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOrderGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ORDER_NOT_CANCELABLE" => Ok(Self::StopLossOrderNotCancelable),
            "STOP_LOSS_ORDER_NOT_REPLACEABLE" => Ok(Self::StopLossOrderNotReplaceable),
            "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOrderGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(Self::StopLossOrderPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(Self::StopLossOrderPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER" => {
                Ok(Self::StopLossOnFillRequiredForPendingOrder)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED" => {
                Ok(Self::StopLossOnFillGuaranteedNotAllowed)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED" => Ok(Self::StopLossOnFillGuaranteedRequired),
            "STOP_LOSS_ON_FILL_PRICE_MISSING" => Ok(Self::StopLossOnFillPriceMissing),
            "STOP_LOSS_ON_FILL_PRICE_INVALID" => Ok(Self::StopLossOnFillPriceInvalid),
            "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(Self::StopLossOnFillPricePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOnFillGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOnFillGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_INVALID" => Ok(Self::StopLossOnFillDistanceInvalid),
            "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::StopLossOnFillPriceDistanceMaximumExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(Self::StopLossOnFillDistancePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(Self::StopLossOnFillPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(Self::StopLossOnFillPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => Ok(Self::StopLossOnFillTimeInForceMissing),
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => Ok(Self::StopLossOnFillTimeInForceInvalid),
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::StopLossOnFillGtdTimestampMissing)
            }
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => Ok(Self::StopLossOnFillGtdTimestampInPast),
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderIdInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderTagInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderCommentInvalid)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::StopLossOnFillTriggerConditionMissing)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::StopLossOnFillTriggerConditionInvalid)
            }
            "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS" => {
                Ok(Self::TrailingStopLossOrderAlreadyExists)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(Self::TrailingStopLossOnFillPriceDistancePrecisionExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMaximumExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMinimumNotMet)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(Self::TrailingStopLossOnFillTimeInForceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(Self::TrailingStopLossOnFillTimeInForceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampInPast)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderIdInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderTagInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderCommentInvalid)
            }
            "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED" => {
                Ok(Self::TrailingStopLossOrdersNotSupported)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::TrailingStopLossOnFillTriggerConditionMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::TrailingStopLossOnFillTriggerConditionInvalid)
            }
            "CLOSE_TRADE_TYPE_MISSING" => Ok(Self::CloseTradeTypeMissing),
            "CLOSE_TRADE_PARTIAL_UNITS_MISSING" => Ok(Self::CloseTradePartialUnitsMissing),
            "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE" => Ok(Self::CloseTradeUnitsExceedTradeSize),
            "CLOSEOUT_POSITION_DOESNT_EXIST" => Ok(Self::CloseoutPositionDoesntExist),
            "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION" => {
                Ok(Self::CloseoutPositionIncompleteSpecification)
            }
            "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE" => {
                Ok(Self::CloseoutPositionUnitsExceedPositionSize)
            }
            "CLOSEOUT_POSITION_REJECT" => Ok(Self::CloseoutPositionReject),
            "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING" => {
                Ok(Self::CloseoutPositionPartialUnitsMissing)
            }
            "MARKUP_GROUP_ID_INVALID" => Ok(Self::MarkupGroupIdInvalid),
            "POSITION_AGGREGATION_MODE_INVALID" => Ok(Self::PositionAggregationModeInvalid),
            "ADMIN_CONFIGURE_DATA_MISSING" => Ok(Self::AdminConfigureDataMissing),
            "MARGIN_RATE_INVALID" => Ok(Self::MarginRateInvalid),
            "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT" => Ok(Self::MarginRateWouldTriggerCloseout),
            "ALIAS_INVALID" => Ok(Self::AliasInvalid),
            "CLIENT_CONFIGURE_DATA_MISSING" => Ok(Self::ClientConfigureDataMissing),
            "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL" => Ok(Self::MarginRateWouldTriggerMarginCall),
            "AMOUNT_INVALID" => Ok(Self::AmountInvalid),
            "INSUFFICIENT_FUNDS" => Ok(Self::InsufficientFunds),
            "AMOUNT_MISSING" => Ok(Self::AmountMissing),
            "FUNDING_REASON_MISSING" => Ok(Self::FundingReasonMissing),
            "CLIENT_EXTENSIONS_DATA_MISSING" => Ok(Self::ClientExtensionsDataMissing),
            "REPLACING_ORDER_INVALID" => Ok(Self::ReplacingOrderInvalid),
            "REPLACING_TRADE_ID_INVALID" => Ok(Self::ReplacingTradeIdInvalid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketIfTouchedOrderRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketIfTouchedOrderRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketIfTouchedOrderRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The time-in-force requested for the MarketIfTouched Order. Restricted to
/// "GTC", "GFD" and "GTD" for MarketIfTouched Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the MarketIfTouched
/// Order. Restricted to \"GTC\", \"GFD\" and \"GTD\" for MarketIfTouched
/// Orders.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketIfTouchedOrderRejectTransactionTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&MarketIfTouchedOrderRejectTransactionTimeInForce>
    for MarketIfTouchedOrderRejectTransactionTimeInForce
{
    fn from(value: &MarketIfTouchedOrderRejectTransactionTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for MarketIfTouchedOrderRejectTransactionTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for MarketIfTouchedOrderRejectTransactionTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketIfTouchedOrderRejectTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketIfTouchedOrderRejectTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketIfTouchedOrderRejectTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///Specification of which price component should be used when determining
/// if an Order should be triggered and filled. This allows Orders to be
/// triggered based on the bid, ask, mid, default (ask for buy, bid for
/// sell) or inverse (ask for sell, bid for buy) price depending on the
/// desired behaviour. Orders are always filled using their default price
/// component. This feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order. A special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
/// results in. So for a Stop Loss Order for a long trade valid values are
/// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are valid.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of which price component should be used
/// when determining if an Order should be triggered and filled. This allows
/// Orders to be triggered based on the bid, ask, mid, default (ask for buy,
/// bid for sell) or inverse (ask for sell, bid for buy) price depending on
/// the desired behaviour. Orders are always filled using their default
/// price component.\nThis feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///  "type": "string",
///  "enum": [
///    "DEFAULT",
///    "INVERSE",
///    "BID",
///    "ASK",
///    "MID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketIfTouchedOrderRejectTransactionTriggerCondition {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "INVERSE")]
    Inverse,
    #[serde(rename = "BID")]
    Bid,
    #[serde(rename = "ASK")]
    Ask,
    #[serde(rename = "MID")]
    Mid,
}

impl From<&MarketIfTouchedOrderRejectTransactionTriggerCondition>
    for MarketIfTouchedOrderRejectTransactionTriggerCondition
{
    fn from(value: &MarketIfTouchedOrderRejectTransactionTriggerCondition) -> Self {
        value.clone()
    }
}

impl ToString for MarketIfTouchedOrderRejectTransactionTriggerCondition {
    fn to_string(&self) -> String {
        match *self {
            Self::Default => "DEFAULT".to_string(),
            Self::Inverse => "INVERSE".to_string(),
            Self::Bid => "BID".to_string(),
            Self::Ask => "ASK".to_string(),
            Self::Mid => "MID".to_string(),
        }
    }
}

impl std::str::FromStr for MarketIfTouchedOrderRejectTransactionTriggerCondition {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DEFAULT" => Ok(Self::Default),
            "INVERSE" => Ok(Self::Inverse),
            "BID" => Ok(Self::Bid),
            "ASK" => Ok(Self::Ask),
            "MID" => Ok(Self::Mid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketIfTouchedOrderRejectTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketIfTouchedOrderRejectTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketIfTouchedOrderRejectTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Type of the Transaction. Always set to
/// "MARKET_IF_TOUCHED_ORDER_REJECT" in a
/// MarketIfTouchedOrderRejectTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"MARKET_IF_TOUCHED_ORDER_REJECT\" in a
/// MarketIfTouchedOrderRejectTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketIfTouchedOrderRejectTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&MarketIfTouchedOrderRejectTransactionType>
    for MarketIfTouchedOrderRejectTransactionType
{
    fn from(value: &MarketIfTouchedOrderRejectTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for MarketIfTouchedOrderRejectTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for MarketIfTouchedOrderRejectTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketIfTouchedOrderRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketIfTouchedOrderRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketIfTouchedOrderRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A MarketIfTouchedOrderRequest specifies the parameters that may be set
/// when creating a Market-if-Touched Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A MarketIfTouchedOrderRequest specifies the parameters
/// that may be set when creating a Market-if-Touched Order.",
///  "type": "object",
///  "properties": {
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "gtdTime": {
///      "description": "The date/time when the MarketIfTouched Order will
/// be cancelled if its timeInForce is \"GTD\".",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "instrument": {
///      "description": "The MarketIfTouched Order's Instrument.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "positionFill": {
///      "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///      "type": "string",
///      "enum": [
///        "OPEN_ONLY",
///        "REDUCE_FIRST",
///        "REDUCE_ONLY",
///        "DEFAULT"
///      ]
///    },
///    "price": {
///      "description": "The price threshold specified for the
/// MarketIfTouched Order. The MarketIfTouched Order will only be filled by
/// a market price that crosses this price from the direction of the market
/// price at the time when the Order was created (the initialMarketPrice).
/// Depending on the value of the Order's price and initialMarketPrice, the
/// MarketIfTouchedOrder will behave like a Limit or a Stop Order.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "priceBound": {
///      "description": "The worst market price that may be used to fill
/// this MarketIfTouched Order.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "stopLossOnFill": {
///      "$ref": "#/components/schemas/StopLossDetails"
///    },
///    "takeProfitOnFill": {
///      "$ref": "#/components/schemas/TakeProfitDetails"
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the MarketIfTouched
/// Order. Restricted to \"GTC\", \"GFD\" and \"GTD\" for MarketIfTouched
/// Orders.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeClientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "trailingStopLossOnFill": {
///      "$ref": "#/components/schemas/TrailingStopLossDetails"
///    },
///    "triggerCondition": {
///      "description": "Specification of which price component should be
/// used when determining if an Order should be triggered and filled. This
/// allows Orders to be triggered based on the bid, ask, mid, default (ask
/// for buy, bid for sell) or inverse (ask for sell, bid for buy) price
/// depending on the desired behaviour. Orders are always filled using their
/// default price component.\nThis feature is only provided through the REST
/// API. Clients who choose to specify a non-default trigger condition will
/// not see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///      "type": "string",
///      "enum": [
///        "DEFAULT",
///        "INVERSE",
///        "BID",
///        "ASK",
///        "MID"
///      ]
///    },
///    "type": {
///      "description": "The type of the Order to Create. Must be set to
/// \"MARKET_IF_TOUCHED\" when creating a Market If Touched Order.",
///      "type": "string",
///      "enum": [
///        "MARKET",
///        "LIMIT",
///        "STOP",
///        "MARKET_IF_TOUCHED",
///        "TAKE_PROFIT",
///        "STOP_LOSS",
///        "TRAILING_STOP_LOSS",
///        "FIXED_PRICE"
///      ]
///    },
///    "units": {
///      "description": "The quantity requested to be filled by the
/// MarketIfTouched Order. A posititive number of units results in a long
/// Order, and a negative number of units results in a short Order.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MarketIfTouchedOrderRequest {
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The date/time when the MarketIfTouched Order will be cancelled if
    /// its timeInForce is "GTD".
    #[serde(rename = "gtdTime", default, skip_serializing_if = "Option::is_none")]
    pub gtd_time: Option<String>,
    ///The MarketIfTouched Order's Instrument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    ///Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(
        rename = "positionFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub position_fill: Option<MarketIfTouchedOrderRequestPositionFill>,
    ///The price threshold specified for the MarketIfTouched Order. The
    /// MarketIfTouched Order will only be filled by a market price that
    /// crosses this price from the direction of the market price at the
    /// time when the Order was created (the initialMarketPrice). Depending
    /// on the value of the Order's price and initialMarketPrice, the
    /// MarketIfTouchedOrder will behave like a Limit or a Stop Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The worst market price that may be used to fill this MarketIfTouched
    /// Order.
    #[serde(
        rename = "priceBound",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub price_bound: Option<String>,
    #[serde(
        rename = "stopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stop_loss_on_fill: Option<StopLossDetails>,
    #[serde(
        rename = "takeProfitOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub take_profit_on_fill: Option<TakeProfitDetails>,
    ///The time-in-force requested for the MarketIfTouched Order.
    /// Restricted to "GTC", "GFD" and "GTD" for MarketIfTouched Orders.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<MarketIfTouchedOrderRequestTimeInForce>,
    #[serde(
        rename = "tradeClientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,
    #[serde(
        rename = "trailingStopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,
    ///Specification of which price component should be used when
    /// determining if an Order should be triggered and filled. This allows
    /// Orders to be triggered based on the bid, ask, mid, default (ask for
    /// buy, bid for sell) or inverse (ask for sell, bid for buy) price
    /// depending on the desired behaviour. Orders are always filled using
    /// their default price component. This feature is only provided
    /// through the REST API. Clients who choose to specify a non-default
    /// trigger condition will not see it reflected in any of OANDA's
    /// proprietary or partner trading platforms, their transaction history
    /// or their account statements. OANDA platforms always assume that an
    /// Order's trigger condition is set to the default value when
    /// indicating the distance from an Order's trigger price, and will
    /// always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when
    /// creating a guaranteed Stop Loss Order. In this case the
    /// TriggerCondition value must either be "DEFAULT", or the "natural"
    /// trigger side "DEFAULT" results in. So for a Stop Loss Order for a
    /// long trade valid values are "DEFAULT" and "BID", and for short
    /// trades "DEFAULT" and "ASK" are valid.
    #[serde(
        rename = "triggerCondition",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trigger_condition: Option<MarketIfTouchedOrderRequestTriggerCondition>,
    ///The type of the Order to Create. Must be set to "MARKET_IF_TOUCHED"
    /// when creating a Market If Touched Order.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<MarketIfTouchedOrderRequestType>,
    ///The quantity requested to be filled by the MarketIfTouched Order. A
    /// posititive number of units results in a long Order, and a negative
    /// number of units results in a short Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<String>,
}

impl From<&MarketIfTouchedOrderRequest> for MarketIfTouchedOrderRequest {
    fn from(value: &MarketIfTouchedOrderRequest) -> Self {
        value.clone()
    }
}

impl MarketIfTouchedOrderRequest {
    pub fn builder() -> builder::MarketIfTouchedOrderRequest {
        Default::default()
    }
}

///Specification of how Positions in the Account are modified when the
/// Order is filled.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///  "type": "string",
///  "enum": [
///    "OPEN_ONLY",
///    "REDUCE_FIRST",
///    "REDUCE_ONLY",
///    "DEFAULT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketIfTouchedOrderRequestPositionFill {
    #[serde(rename = "OPEN_ONLY")]
    OpenOnly,
    #[serde(rename = "REDUCE_FIRST")]
    ReduceFirst,
    #[serde(rename = "REDUCE_ONLY")]
    ReduceOnly,
    #[serde(rename = "DEFAULT")]
    Default,
}

impl From<&MarketIfTouchedOrderRequestPositionFill> for MarketIfTouchedOrderRequestPositionFill {
    fn from(value: &MarketIfTouchedOrderRequestPositionFill) -> Self {
        value.clone()
    }
}

impl ToString for MarketIfTouchedOrderRequestPositionFill {
    fn to_string(&self) -> String {
        match *self {
            Self::OpenOnly => "OPEN_ONLY".to_string(),
            Self::ReduceFirst => "REDUCE_FIRST".to_string(),
            Self::ReduceOnly => "REDUCE_ONLY".to_string(),
            Self::Default => "DEFAULT".to_string(),
        }
    }
}

impl std::str::FromStr for MarketIfTouchedOrderRequestPositionFill {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "OPEN_ONLY" => Ok(Self::OpenOnly),
            "REDUCE_FIRST" => Ok(Self::ReduceFirst),
            "REDUCE_ONLY" => Ok(Self::ReduceOnly),
            "DEFAULT" => Ok(Self::Default),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketIfTouchedOrderRequestPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketIfTouchedOrderRequestPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketIfTouchedOrderRequestPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The time-in-force requested for the MarketIfTouched Order. Restricted to
/// "GTC", "GFD" and "GTD" for MarketIfTouched Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the MarketIfTouched
/// Order. Restricted to \"GTC\", \"GFD\" and \"GTD\" for MarketIfTouched
/// Orders.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketIfTouchedOrderRequestTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&MarketIfTouchedOrderRequestTimeInForce> for MarketIfTouchedOrderRequestTimeInForce {
    fn from(value: &MarketIfTouchedOrderRequestTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for MarketIfTouchedOrderRequestTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for MarketIfTouchedOrderRequestTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketIfTouchedOrderRequestTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketIfTouchedOrderRequestTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketIfTouchedOrderRequestTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///Specification of which price component should be used when determining
/// if an Order should be triggered and filled. This allows Orders to be
/// triggered based on the bid, ask, mid, default (ask for buy, bid for
/// sell) or inverse (ask for sell, bid for buy) price depending on the
/// desired behaviour. Orders are always filled using their default price
/// component. This feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order. A special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
/// results in. So for a Stop Loss Order for a long trade valid values are
/// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are valid.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of which price component should be used
/// when determining if an Order should be triggered and filled. This allows
/// Orders to be triggered based on the bid, ask, mid, default (ask for buy,
/// bid for sell) or inverse (ask for sell, bid for buy) price depending on
/// the desired behaviour. Orders are always filled using their default
/// price component.\nThis feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///  "type": "string",
///  "enum": [
///    "DEFAULT",
///    "INVERSE",
///    "BID",
///    "ASK",
///    "MID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketIfTouchedOrderRequestTriggerCondition {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "INVERSE")]
    Inverse,
    #[serde(rename = "BID")]
    Bid,
    #[serde(rename = "ASK")]
    Ask,
    #[serde(rename = "MID")]
    Mid,
}

impl From<&MarketIfTouchedOrderRequestTriggerCondition>
    for MarketIfTouchedOrderRequestTriggerCondition
{
    fn from(value: &MarketIfTouchedOrderRequestTriggerCondition) -> Self {
        value.clone()
    }
}

impl ToString for MarketIfTouchedOrderRequestTriggerCondition {
    fn to_string(&self) -> String {
        match *self {
            Self::Default => "DEFAULT".to_string(),
            Self::Inverse => "INVERSE".to_string(),
            Self::Bid => "BID".to_string(),
            Self::Ask => "ASK".to_string(),
            Self::Mid => "MID".to_string(),
        }
    }
}

impl std::str::FromStr for MarketIfTouchedOrderRequestTriggerCondition {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DEFAULT" => Ok(Self::Default),
            "INVERSE" => Ok(Self::Inverse),
            "BID" => Ok(Self::Bid),
            "ASK" => Ok(Self::Ask),
            "MID" => Ok(Self::Mid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketIfTouchedOrderRequestTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketIfTouchedOrderRequestTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketIfTouchedOrderRequestTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The type of the Order to Create. Must be set to "MARKET_IF_TOUCHED" when
/// creating a Market If Touched Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The type of the Order to Create. Must be set to
/// \"MARKET_IF_TOUCHED\" when creating a Market If Touched Order.",
///  "type": "string",
///  "enum": [
///    "MARKET",
///    "LIMIT",
///    "STOP",
///    "MARKET_IF_TOUCHED",
///    "TAKE_PROFIT",
///    "STOP_LOSS",
///    "TRAILING_STOP_LOSS",
///    "FIXED_PRICE"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketIfTouchedOrderRequestType {
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "STOP")]
    Stop,
    #[serde(rename = "MARKET_IF_TOUCHED")]
    MarketIfTouched,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "STOP_LOSS")]
    StopLoss,
    #[serde(rename = "TRAILING_STOP_LOSS")]
    TrailingStopLoss,
    #[serde(rename = "FIXED_PRICE")]
    FixedPrice,
}

impl From<&MarketIfTouchedOrderRequestType> for MarketIfTouchedOrderRequestType {
    fn from(value: &MarketIfTouchedOrderRequestType) -> Self {
        value.clone()
    }
}

impl ToString for MarketIfTouchedOrderRequestType {
    fn to_string(&self) -> String {
        match *self {
            Self::Market => "MARKET".to_string(),
            Self::Limit => "LIMIT".to_string(),
            Self::Stop => "STOP".to_string(),
            Self::MarketIfTouched => "MARKET_IF_TOUCHED".to_string(),
            Self::TakeProfit => "TAKE_PROFIT".to_string(),
            Self::StopLoss => "STOP_LOSS".to_string(),
            Self::TrailingStopLoss => "TRAILING_STOP_LOSS".to_string(),
            Self::FixedPrice => "FIXED_PRICE".to_string(),
        }
    }
}

impl std::str::FromStr for MarketIfTouchedOrderRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "MARKET" => Ok(Self::Market),
            "LIMIT" => Ok(Self::Limit),
            "STOP" => Ok(Self::Stop),
            "MARKET_IF_TOUCHED" => Ok(Self::MarketIfTouched),
            "TAKE_PROFIT" => Ok(Self::TakeProfit),
            "STOP_LOSS" => Ok(Self::StopLoss),
            "TRAILING_STOP_LOSS" => Ok(Self::TrailingStopLoss),
            "FIXED_PRICE" => Ok(Self::FixedPrice),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketIfTouchedOrderRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketIfTouchedOrderRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketIfTouchedOrderRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The current state of the Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The current state of the Order.",
///  "type": "string",
///  "enum": [
///    "PENDING",
///    "FILLED",
///    "TRIGGERED",
///    "CANCELLED"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketIfTouchedOrderState {
    #[serde(rename = "PENDING")]
    Pending,
    #[serde(rename = "FILLED")]
    Filled,
    #[serde(rename = "TRIGGERED")]
    Triggered,
    #[serde(rename = "CANCELLED")]
    Cancelled,
}

impl From<&MarketIfTouchedOrderState> for MarketIfTouchedOrderState {
    fn from(value: &MarketIfTouchedOrderState) -> Self {
        value.clone()
    }
}

impl ToString for MarketIfTouchedOrderState {
    fn to_string(&self) -> String {
        match *self {
            Self::Pending => "PENDING".to_string(),
            Self::Filled => "FILLED".to_string(),
            Self::Triggered => "TRIGGERED".to_string(),
            Self::Cancelled => "CANCELLED".to_string(),
        }
    }
}

impl std::str::FromStr for MarketIfTouchedOrderState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "PENDING" => Ok(Self::Pending),
            "FILLED" => Ok(Self::Filled),
            "TRIGGERED" => Ok(Self::Triggered),
            "CANCELLED" => Ok(Self::Cancelled),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketIfTouchedOrderState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketIfTouchedOrderState {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketIfTouchedOrderState {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The time-in-force requested for the MarketIfTouched Order. Restricted to
/// "GTC", "GFD" and "GTD" for MarketIfTouched Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the MarketIfTouched
/// Order. Restricted to \"GTC\", \"GFD\" and \"GTD\" for MarketIfTouched
/// Orders.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketIfTouchedOrderTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&MarketIfTouchedOrderTimeInForce> for MarketIfTouchedOrderTimeInForce {
    fn from(value: &MarketIfTouchedOrderTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for MarketIfTouchedOrderTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for MarketIfTouchedOrderTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketIfTouchedOrderTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketIfTouchedOrderTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketIfTouchedOrderTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A MarketIfTouchedOrderTransaction represents the creation of a
/// MarketIfTouched Order in the user's Account.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A MarketIfTouchedOrderTransaction represents the
/// creation of a MarketIfTouched Order in the user's Account.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "cancellingTransactionID": {
///      "description": "The ID of the Transaction that cancels the replaced
/// Order (only provided if this Order replaces an existing Order).",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "gtdTime": {
///      "description": "The date/time when the MarketIfTouched Order will
/// be cancelled if its timeInForce is \"GTD\".",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "instrument": {
///      "description": "The MarketIfTouched Order's Instrument.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "positionFill": {
///      "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///      "type": "string",
///      "enum": [
///        "OPEN_ONLY",
///        "REDUCE_FIRST",
///        "REDUCE_ONLY",
///        "DEFAULT"
///      ]
///    },
///    "price": {
///      "description": "The price threshold specified for the
/// MarketIfTouched Order. The MarketIfTouched Order will only be filled by
/// a market price that crosses this price from the direction of the market
/// price at the time when the Order was created (the initialMarketPrice).
/// Depending on the value of the Order's price and initialMarketPrice, the
/// MarketIfTouchedOrder will behave like a Limit or a Stop Order.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "priceBound": {
///      "description": "The worst market price that may be used to fill
/// this MarketIfTouched Order.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "reason": {
///      "description": "The reason that the Market-if-touched Order was
/// initiated",
///      "type": "string",
///      "enum": [
///        "CLIENT_ORDER",
///        "REPLACEMENT"
///      ]
///    },
///    "replacesOrderID": {
///      "description": "The ID of the Order that this Order replaces (only
/// provided if this Order replaces an existing Order).",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "stopLossOnFill": {
///      "$ref": "#/components/schemas/StopLossDetails"
///    },
///    "takeProfitOnFill": {
///      "$ref": "#/components/schemas/TakeProfitDetails"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the MarketIfTouched
/// Order. Restricted to \"GTC\", \"GFD\" and \"GTD\" for MarketIfTouched
/// Orders.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeClientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "trailingStopLossOnFill": {
///      "$ref": "#/components/schemas/TrailingStopLossDetails"
///    },
///    "triggerCondition": {
///      "description": "Specification of which price component should be
/// used when determining if an Order should be triggered and filled. This
/// allows Orders to be triggered based on the bid, ask, mid, default (ask
/// for buy, bid for sell) or inverse (ask for sell, bid for buy) price
/// depending on the desired behaviour. Orders are always filled using their
/// default price component.\nThis feature is only provided through the REST
/// API. Clients who choose to specify a non-default trigger condition will
/// not see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///      "type": "string",
///      "enum": [
///        "DEFAULT",
///        "INVERSE",
///        "BID",
///        "ASK",
///        "MID"
///      ]
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"MARKET_IF_TOUCHED_ORDER\" in a MarketIfTouchedOrderTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "units": {
///      "description": "The quantity requested to be filled by the
/// MarketIfTouched Order. A posititive number of units results in a long
/// Order, and a negative number of units results in a short Order.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MarketIfTouchedOrderTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    ///The ID of the Transaction that cancels the replaced Order (only
    /// provided if this Order replaces an existing Order).
    #[serde(
        rename = "cancellingTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The date/time when the MarketIfTouched Order will be cancelled if
    /// its timeInForce is "GTD".
    #[serde(rename = "gtdTime", default, skip_serializing_if = "Option::is_none")]
    pub gtd_time: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The MarketIfTouched Order's Instrument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    ///Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(
        rename = "positionFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub position_fill: Option<MarketIfTouchedOrderTransactionPositionFill>,
    ///The price threshold specified for the MarketIfTouched Order. The
    /// MarketIfTouched Order will only be filled by a market price that
    /// crosses this price from the direction of the market price at the
    /// time when the Order was created (the initialMarketPrice). Depending
    /// on the value of the Order's price and initialMarketPrice, the
    /// MarketIfTouchedOrder will behave like a Limit or a Stop Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The worst market price that may be used to fill this MarketIfTouched
    /// Order.
    #[serde(
        rename = "priceBound",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub price_bound: Option<String>,
    ///The reason that the Market-if-touched Order was initiated
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<MarketIfTouchedOrderTransactionReason>,
    ///The ID of the Order that this Order replaces (only provided if this
    /// Order replaces an existing Order).
    #[serde(
        rename = "replacesOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub replaces_order_id: Option<String>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    #[serde(
        rename = "stopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stop_loss_on_fill: Option<StopLossDetails>,
    #[serde(
        rename = "takeProfitOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub take_profit_on_fill: Option<TakeProfitDetails>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The time-in-force requested for the MarketIfTouched Order.
    /// Restricted to "GTC", "GFD" and "GTD" for MarketIfTouched Orders.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<MarketIfTouchedOrderTransactionTimeInForce>,
    #[serde(
        rename = "tradeClientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,
    #[serde(
        rename = "trailingStopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,
    ///Specification of which price component should be used when
    /// determining if an Order should be triggered and filled. This allows
    /// Orders to be triggered based on the bid, ask, mid, default (ask for
    /// buy, bid for sell) or inverse (ask for sell, bid for buy) price
    /// depending on the desired behaviour. Orders are always filled using
    /// their default price component. This feature is only provided
    /// through the REST API. Clients who choose to specify a non-default
    /// trigger condition will not see it reflected in any of OANDA's
    /// proprietary or partner trading platforms, their transaction history
    /// or their account statements. OANDA platforms always assume that an
    /// Order's trigger condition is set to the default value when
    /// indicating the distance from an Order's trigger price, and will
    /// always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when
    /// creating a guaranteed Stop Loss Order. In this case the
    /// TriggerCondition value must either be "DEFAULT", or the "natural"
    /// trigger side "DEFAULT" results in. So for a Stop Loss Order for a
    /// long trade valid values are "DEFAULT" and "BID", and for short
    /// trades "DEFAULT" and "ASK" are valid.
    #[serde(
        rename = "triggerCondition",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trigger_condition: Option<MarketIfTouchedOrderTransactionTriggerCondition>,
    ///The Type of the Transaction. Always set to "MARKET_IF_TOUCHED_ORDER"
    /// in a MarketIfTouchedOrderTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<MarketIfTouchedOrderTransactionType>,
    ///The quantity requested to be filled by the MarketIfTouched Order. A
    /// posititive number of units results in a long Order, and a negative
    /// number of units results in a short Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<String>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&MarketIfTouchedOrderTransaction> for MarketIfTouchedOrderTransaction {
    fn from(value: &MarketIfTouchedOrderTransaction) -> Self {
        value.clone()
    }
}

impl MarketIfTouchedOrderTransaction {
    pub fn builder() -> builder::MarketIfTouchedOrderTransaction {
        Default::default()
    }
}

///Specification of how Positions in the Account are modified when the
/// Order is filled.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///  "type": "string",
///  "enum": [
///    "OPEN_ONLY",
///    "REDUCE_FIRST",
///    "REDUCE_ONLY",
///    "DEFAULT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketIfTouchedOrderTransactionPositionFill {
    #[serde(rename = "OPEN_ONLY")]
    OpenOnly,
    #[serde(rename = "REDUCE_FIRST")]
    ReduceFirst,
    #[serde(rename = "REDUCE_ONLY")]
    ReduceOnly,
    #[serde(rename = "DEFAULT")]
    Default,
}

impl From<&MarketIfTouchedOrderTransactionPositionFill>
    for MarketIfTouchedOrderTransactionPositionFill
{
    fn from(value: &MarketIfTouchedOrderTransactionPositionFill) -> Self {
        value.clone()
    }
}

impl ToString for MarketIfTouchedOrderTransactionPositionFill {
    fn to_string(&self) -> String {
        match *self {
            Self::OpenOnly => "OPEN_ONLY".to_string(),
            Self::ReduceFirst => "REDUCE_FIRST".to_string(),
            Self::ReduceOnly => "REDUCE_ONLY".to_string(),
            Self::Default => "DEFAULT".to_string(),
        }
    }
}

impl std::str::FromStr for MarketIfTouchedOrderTransactionPositionFill {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "OPEN_ONLY" => Ok(Self::OpenOnly),
            "REDUCE_FIRST" => Ok(Self::ReduceFirst),
            "REDUCE_ONLY" => Ok(Self::ReduceOnly),
            "DEFAULT" => Ok(Self::Default),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketIfTouchedOrderTransactionPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketIfTouchedOrderTransactionPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketIfTouchedOrderTransactionPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The reason that the Market-if-touched Order was initiated
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Market-if-touched Order was
/// initiated",
///  "type": "string",
///  "enum": [
///    "CLIENT_ORDER",
///    "REPLACEMENT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketIfTouchedOrderTransactionReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "REPLACEMENT")]
    Replacement,
}

impl From<&MarketIfTouchedOrderTransactionReason> for MarketIfTouchedOrderTransactionReason {
    fn from(value: &MarketIfTouchedOrderTransactionReason) -> Self {
        value.clone()
    }
}

impl ToString for MarketIfTouchedOrderTransactionReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ClientOrder => "CLIENT_ORDER".to_string(),
            Self::Replacement => "REPLACEMENT".to_string(),
        }
    }
}

impl std::str::FromStr for MarketIfTouchedOrderTransactionReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CLIENT_ORDER" => Ok(Self::ClientOrder),
            "REPLACEMENT" => Ok(Self::Replacement),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketIfTouchedOrderTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketIfTouchedOrderTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketIfTouchedOrderTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The time-in-force requested for the MarketIfTouched Order. Restricted to
/// "GTC", "GFD" and "GTD" for MarketIfTouched Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the MarketIfTouched
/// Order. Restricted to \"GTC\", \"GFD\" and \"GTD\" for MarketIfTouched
/// Orders.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketIfTouchedOrderTransactionTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&MarketIfTouchedOrderTransactionTimeInForce>
    for MarketIfTouchedOrderTransactionTimeInForce
{
    fn from(value: &MarketIfTouchedOrderTransactionTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for MarketIfTouchedOrderTransactionTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for MarketIfTouchedOrderTransactionTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketIfTouchedOrderTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketIfTouchedOrderTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketIfTouchedOrderTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///Specification of which price component should be used when determining
/// if an Order should be triggered and filled. This allows Orders to be
/// triggered based on the bid, ask, mid, default (ask for buy, bid for
/// sell) or inverse (ask for sell, bid for buy) price depending on the
/// desired behaviour. Orders are always filled using their default price
/// component. This feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order. A special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
/// results in. So for a Stop Loss Order for a long trade valid values are
/// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are valid.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of which price component should be used
/// when determining if an Order should be triggered and filled. This allows
/// Orders to be triggered based on the bid, ask, mid, default (ask for buy,
/// bid for sell) or inverse (ask for sell, bid for buy) price depending on
/// the desired behaviour. Orders are always filled using their default
/// price component.\nThis feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///  "type": "string",
///  "enum": [
///    "DEFAULT",
///    "INVERSE",
///    "BID",
///    "ASK",
///    "MID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketIfTouchedOrderTransactionTriggerCondition {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "INVERSE")]
    Inverse,
    #[serde(rename = "BID")]
    Bid,
    #[serde(rename = "ASK")]
    Ask,
    #[serde(rename = "MID")]
    Mid,
}

impl From<&MarketIfTouchedOrderTransactionTriggerCondition>
    for MarketIfTouchedOrderTransactionTriggerCondition
{
    fn from(value: &MarketIfTouchedOrderTransactionTriggerCondition) -> Self {
        value.clone()
    }
}

impl ToString for MarketIfTouchedOrderTransactionTriggerCondition {
    fn to_string(&self) -> String {
        match *self {
            Self::Default => "DEFAULT".to_string(),
            Self::Inverse => "INVERSE".to_string(),
            Self::Bid => "BID".to_string(),
            Self::Ask => "ASK".to_string(),
            Self::Mid => "MID".to_string(),
        }
    }
}

impl std::str::FromStr for MarketIfTouchedOrderTransactionTriggerCondition {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DEFAULT" => Ok(Self::Default),
            "INVERSE" => Ok(Self::Inverse),
            "BID" => Ok(Self::Bid),
            "ASK" => Ok(Self::Ask),
            "MID" => Ok(Self::Mid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketIfTouchedOrderTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketIfTouchedOrderTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketIfTouchedOrderTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Type of the Transaction. Always set to "MARKET_IF_TOUCHED_ORDER" in
/// a MarketIfTouchedOrderTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"MARKET_IF_TOUCHED_ORDER\" in a MarketIfTouchedOrderTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketIfTouchedOrderTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&MarketIfTouchedOrderTransactionType> for MarketIfTouchedOrderTransactionType {
    fn from(value: &MarketIfTouchedOrderTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for MarketIfTouchedOrderTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for MarketIfTouchedOrderTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketIfTouchedOrderTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketIfTouchedOrderTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketIfTouchedOrderTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///Specification of which price component should be used when determining
/// if an Order should be triggered and filled. This allows Orders to be
/// triggered based on the bid, ask, mid, default (ask for buy, bid for
/// sell) or inverse (ask for sell, bid for buy) price depending on the
/// desired behaviour. Orders are always filled using their default price
/// component. This feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order. A special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
/// results in. So for a Stop Loss Order for a long trade valid values are
/// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are valid.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of which price component should be used
/// when determining if an Order should be triggered and filled. This allows
/// Orders to be triggered based on the bid, ask, mid, default (ask for buy,
/// bid for sell) or inverse (ask for sell, bid for buy) price depending on
/// the desired behaviour. Orders are always filled using their default
/// price component.\nThis feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///  "type": "string",
///  "enum": [
///    "DEFAULT",
///    "INVERSE",
///    "BID",
///    "ASK",
///    "MID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketIfTouchedOrderTriggerCondition {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "INVERSE")]
    Inverse,
    #[serde(rename = "BID")]
    Bid,
    #[serde(rename = "ASK")]
    Ask,
    #[serde(rename = "MID")]
    Mid,
}

impl From<&MarketIfTouchedOrderTriggerCondition> for MarketIfTouchedOrderTriggerCondition {
    fn from(value: &MarketIfTouchedOrderTriggerCondition) -> Self {
        value.clone()
    }
}

impl ToString for MarketIfTouchedOrderTriggerCondition {
    fn to_string(&self) -> String {
        match *self {
            Self::Default => "DEFAULT".to_string(),
            Self::Inverse => "INVERSE".to_string(),
            Self::Bid => "BID".to_string(),
            Self::Ask => "ASK".to_string(),
            Self::Mid => "MID".to_string(),
        }
    }
}

impl std::str::FromStr for MarketIfTouchedOrderTriggerCondition {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DEFAULT" => Ok(Self::Default),
            "INVERSE" => Ok(Self::Inverse),
            "BID" => Ok(Self::Bid),
            "ASK" => Ok(Self::Ask),
            "MID" => Ok(Self::Mid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketIfTouchedOrderTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketIfTouchedOrderTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketIfTouchedOrderTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The type of the Order. Always set to "MARKET_IF_TOUCHED" for Market If
/// Touched Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The type of the Order. Always set to
/// \"MARKET_IF_TOUCHED\" for Market If Touched Orders.",
///  "type": "string",
///  "enum": [
///    "MARKET",
///    "LIMIT",
///    "STOP",
///    "MARKET_IF_TOUCHED",
///    "TAKE_PROFIT",
///    "STOP_LOSS",
///    "TRAILING_STOP_LOSS",
///    "FIXED_PRICE"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketIfTouchedOrderType {
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "STOP")]
    Stop,
    #[serde(rename = "MARKET_IF_TOUCHED")]
    MarketIfTouched,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "STOP_LOSS")]
    StopLoss,
    #[serde(rename = "TRAILING_STOP_LOSS")]
    TrailingStopLoss,
    #[serde(rename = "FIXED_PRICE")]
    FixedPrice,
}

impl From<&MarketIfTouchedOrderType> for MarketIfTouchedOrderType {
    fn from(value: &MarketIfTouchedOrderType) -> Self {
        value.clone()
    }
}

impl ToString for MarketIfTouchedOrderType {
    fn to_string(&self) -> String {
        match *self {
            Self::Market => "MARKET".to_string(),
            Self::Limit => "LIMIT".to_string(),
            Self::Stop => "STOP".to_string(),
            Self::MarketIfTouched => "MARKET_IF_TOUCHED".to_string(),
            Self::TakeProfit => "TAKE_PROFIT".to_string(),
            Self::StopLoss => "STOP_LOSS".to_string(),
            Self::TrailingStopLoss => "TRAILING_STOP_LOSS".to_string(),
            Self::FixedPrice => "FIXED_PRICE".to_string(),
        }
    }
}

impl std::str::FromStr for MarketIfTouchedOrderType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "MARKET" => Ok(Self::Market),
            "LIMIT" => Ok(Self::Limit),
            "STOP" => Ok(Self::Stop),
            "MARKET_IF_TOUCHED" => Ok(Self::MarketIfTouched),
            "TAKE_PROFIT" => Ok(Self::TakeProfit),
            "STOP_LOSS" => Ok(Self::StopLoss),
            "TRAILING_STOP_LOSS" => Ok(Self::TrailingStopLoss),
            "FIXED_PRICE" => Ok(Self::FixedPrice),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketIfTouchedOrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketIfTouchedOrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketIfTouchedOrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A MarketOrder is an order that is filled immediately upon creation using
/// the current market price.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A MarketOrder is an order that is filled immediately
/// upon creation using the current market price.",
///  "type": "object",
///  "properties": {
///    "cancelledTime": {
///      "description": "Date/time when the Order was cancelled (only
/// provided when the state of the Order is CANCELLED)",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "cancellingTransactionID": {
///      "description": "ID of the Transaction that cancelled the Order
/// (only provided when the Order's state is CANCELLED)",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "createTime": {
///      "description": "The time when the Order was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "delayedTradeClose": {
///      "$ref": "#/components/schemas/MarketOrderDelayedTradeClose"
///    },
///    "filledTime": {
///      "description": "Date/time when the Order was filled (only provided
/// when the Order's state is FILLED)",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "fillingTransactionID": {
///      "description": "ID of the Transaction that filled this Order (only
/// provided when the Order's state is FILLED)",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "id": {
///      "description": "The Order's identifier, unique within the Order's
/// Account.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "instrument": {
///      "description": "The Market Order's Instrument.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "longPositionCloseout": {
///      "$ref": "#/components/schemas/MarketOrderPositionCloseout"
///    },
///    "marginCloseout": {
///      "$ref": "#/components/schemas/MarketOrderMarginCloseout"
///    },
///    "positionFill": {
///      "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///      "type": "string",
///      "enum": [
///        "OPEN_ONLY",
///        "REDUCE_FIRST",
///        "REDUCE_ONLY",
///        "DEFAULT"
///      ]
///    },
///    "priceBound": {
///      "description": "The worst price that the client is willing to have
/// the Market Order filled at.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "shortPositionCloseout": {
///      "$ref": "#/components/schemas/MarketOrderPositionCloseout"
///    },
///    "state": {
///      "description": "The current state of the Order.",
///      "type": "string",
///      "enum": [
///        "PENDING",
///        "FILLED",
///        "TRIGGERED",
///        "CANCELLED"
///      ]
///    },
///    "stopLossOnFill": {
///      "$ref": "#/components/schemas/StopLossDetails"
///    },
///    "takeProfitOnFill": {
///      "$ref": "#/components/schemas/TakeProfitDetails"
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the Market Order.
/// Restricted to FOK or IOC for a MarketOrder.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeClientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "tradeClose": {
///      "$ref": "#/components/schemas/MarketOrderTradeClose"
///    },
///    "tradeClosedIDs": {
///      "description": "Trade IDs of Trades closed when the Order was
/// filled (only provided when the Order's state is FILLED and one or more
/// Trades were closed as a result of the fill)",
///      "type": "array",
///      "items": {
///        "description": "The Trade's identifier, unique within the Trade's
/// Account.",
///        "type": "string",
///        "format": "The string representation of the OANDA-assigned
/// TradeID. OANDA-assigned TradeIDs are positive integers, and are derived
/// from the TransactionID of the Transaction that opened the Trade."
///      }
///    },
///    "tradeOpenedID": {
///      "description": "Trade ID of Trade opened when the Order was filled
/// (only provided when the Order's state is FILLED and a Trade was opened
/// as a result of the fill)",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "tradeReducedID": {
///      "description": "Trade ID of Trade reduced when the Order was filled
/// (only provided when the Order's state is FILLED and a Trade was reduced
/// as a result of the fill)",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "trailingStopLossOnFill": {
///      "$ref": "#/components/schemas/TrailingStopLossDetails"
///    },
///    "type": {
///      "description": "The type of the Order. Always set to \"MARKET\" for
/// Market Orders.",
///      "type": "string",
///      "enum": [
///        "MARKET",
///        "LIMIT",
///        "STOP",
///        "MARKET_IF_TOUCHED",
///        "TAKE_PROFIT",
///        "STOP_LOSS",
///        "TRAILING_STOP_LOSS",
///        "FIXED_PRICE"
///      ]
///    },
///    "units": {
///      "description": "The quantity requested to be filled by the Market
/// Order. A posititive number of units results in a long Order, and a
/// negative number of units results in a short Order.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MarketOrder {
    ///Date/time when the Order was cancelled (only provided when the state
    /// of the Order is CANCELLED)
    #[serde(
        rename = "cancelledTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelled_time: Option<String>,
    ///ID of the Transaction that cancelled the Order (only provided when
    /// the Order's state is CANCELLED)
    #[serde(
        rename = "cancellingTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The time when the Order was created.
    #[serde(
        rename = "createTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub create_time: Option<String>,
    #[serde(
        rename = "delayedTradeClose",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub delayed_trade_close: Option<MarketOrderDelayedTradeClose>,
    ///Date/time when the Order was filled (only provided when the Order's
    /// state is FILLED)
    #[serde(
        rename = "filledTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub filled_time: Option<String>,
    ///ID of the Transaction that filled this Order (only provided when the
    /// Order's state is FILLED)
    #[serde(
        rename = "fillingTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub filling_transaction_id: Option<String>,
    ///The Order's identifier, unique within the Order's Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The Market Order's Instrument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    #[serde(
        rename = "longPositionCloseout",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub long_position_closeout: Option<MarketOrderPositionCloseout>,
    #[serde(
        rename = "marginCloseout",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_closeout: Option<MarketOrderMarginCloseout>,
    ///Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(
        rename = "positionFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub position_fill: Option<MarketOrderPositionFill>,
    ///The worst price that the client is willing to have the Market Order
    /// filled at.
    #[serde(
        rename = "priceBound",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub price_bound: Option<String>,
    #[serde(
        rename = "shortPositionCloseout",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub short_position_closeout: Option<MarketOrderPositionCloseout>,
    ///The current state of the Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<MarketOrderState>,
    #[serde(
        rename = "stopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stop_loss_on_fill: Option<StopLossDetails>,
    #[serde(
        rename = "takeProfitOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub take_profit_on_fill: Option<TakeProfitDetails>,
    ///The time-in-force requested for the Market Order. Restricted to FOK
    /// or IOC for a MarketOrder.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<MarketOrderTimeInForce>,
    #[serde(
        rename = "tradeClientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,
    #[serde(
        rename = "tradeClose",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_close: Option<MarketOrderTradeClose>,
    ///Trade IDs of Trades closed when the Order was filled (only provided
    /// when the Order's state is FILLED and one or more Trades were closed
    /// as a result of the fill)
    #[serde(
        rename = "tradeClosedIDs",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub trade_closed_i_ds: Vec<String>,
    ///Trade ID of Trade opened when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was opened as a result
    /// of the fill)
    #[serde(
        rename = "tradeOpenedID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_opened_id: Option<String>,
    ///Trade ID of Trade reduced when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was reduced as a result
    /// of the fill)
    #[serde(
        rename = "tradeReducedID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_reduced_id: Option<String>,
    #[serde(
        rename = "trailingStopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,
    ///The type of the Order. Always set to "MARKET" for Market Orders.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<MarketOrderType>,
    ///The quantity requested to be filled by the Market Order. A
    /// posititive number of units results in a long Order, and a negative
    /// number of units results in a short Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<String>,
}

impl From<&MarketOrder> for MarketOrder {
    fn from(value: &MarketOrder) -> Self {
        value.clone()
    }
}

impl MarketOrder {
    pub fn builder() -> builder::MarketOrder {
        Default::default()
    }
}

///Details for the Market Order extensions specific to a Market Order
/// placed with the intent of fully closing a specific open trade that
/// should have already been closed but wasn't due to halted market
/// conditions
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Details for the Market Order extensions specific to a
/// Market Order placed with the intent of fully closing a specific open
/// trade that should have already been closed but wasn't due to halted
/// market conditions",
///  "type": "object",
///  "properties": {
///    "clientTradeID": {
///      "description": "The Client ID of the Trade being closed",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "sourceTransactionID": {
///      "description": "The Transaction ID of the DelayedTradeClosure
/// transaction to which this Delayed Trade Close belongs to",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "tradeID": {
///      "description": "The ID of the Trade being closed",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MarketOrderDelayedTradeClose {
    ///The Client ID of the Trade being closed
    #[serde(
        rename = "clientTradeID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_trade_id: Option<String>,
    ///The Transaction ID of the DelayedTradeClosure transaction to which
    /// this Delayed Trade Close belongs to
    #[serde(
        rename = "sourceTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub source_transaction_id: Option<String>,
    ///The ID of the Trade being closed
    #[serde(rename = "tradeID", default, skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,
}

impl From<&MarketOrderDelayedTradeClose> for MarketOrderDelayedTradeClose {
    fn from(value: &MarketOrderDelayedTradeClose) -> Self {
        value.clone()
    }
}

impl MarketOrderDelayedTradeClose {
    pub fn builder() -> builder::MarketOrderDelayedTradeClose {
        Default::default()
    }
}

///Details for the Market Order extensions specific to a Market Order
/// placed that is part of a Market Order Margin Closeout in a client's
/// account
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Details for the Market Order extensions specific to a
/// Market Order placed that is part of a Market Order Margin Closeout in a
/// client's account",
///  "type": "object",
///  "properties": {
///    "reason": {
///      "description": "The reason the Market Order was created to perform
/// a margin closeout",
///      "type": "string",
///      "enum": [
///        "MARGIN_CHECK_VIOLATION",
///        "REGULATORY_MARGIN_CALL_VIOLATION",
///        "REGULATORY_MARGIN_CHECK_VIOLATION"
///      ]
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MarketOrderMarginCloseout {
    ///The reason the Market Order was created to perform a margin closeout
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<MarketOrderMarginCloseoutReason>,
}

impl From<&MarketOrderMarginCloseout> for MarketOrderMarginCloseout {
    fn from(value: &MarketOrderMarginCloseout) -> Self {
        value.clone()
    }
}

impl MarketOrderMarginCloseout {
    pub fn builder() -> builder::MarketOrderMarginCloseout {
        Default::default()
    }
}

///The reason the Market Order was created to perform a margin closeout
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason the Market Order was created to perform a
/// margin closeout",
///  "type": "string",
///  "enum": [
///    "MARGIN_CHECK_VIOLATION",
///    "REGULATORY_MARGIN_CALL_VIOLATION",
///    "REGULATORY_MARGIN_CHECK_VIOLATION"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketOrderMarginCloseoutReason {
    #[serde(rename = "MARGIN_CHECK_VIOLATION")]
    MarginCheckViolation,
    #[serde(rename = "REGULATORY_MARGIN_CALL_VIOLATION")]
    RegulatoryMarginCallViolation,
    #[serde(rename = "REGULATORY_MARGIN_CHECK_VIOLATION")]
    RegulatoryMarginCheckViolation,
}

impl From<&MarketOrderMarginCloseoutReason> for MarketOrderMarginCloseoutReason {
    fn from(value: &MarketOrderMarginCloseoutReason) -> Self {
        value.clone()
    }
}

impl ToString for MarketOrderMarginCloseoutReason {
    fn to_string(&self) -> String {
        match *self {
            Self::MarginCheckViolation => "MARGIN_CHECK_VIOLATION".to_string(),
            Self::RegulatoryMarginCallViolation => "REGULATORY_MARGIN_CALL_VIOLATION".to_string(),
            Self::RegulatoryMarginCheckViolation => "REGULATORY_MARGIN_CHECK_VIOLATION".to_string(),
        }
    }
}

impl std::str::FromStr for MarketOrderMarginCloseoutReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "MARGIN_CHECK_VIOLATION" => Ok(Self::MarginCheckViolation),
            "REGULATORY_MARGIN_CALL_VIOLATION" => Ok(Self::RegulatoryMarginCallViolation),
            "REGULATORY_MARGIN_CHECK_VIOLATION" => Ok(Self::RegulatoryMarginCheckViolation),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketOrderMarginCloseoutReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketOrderMarginCloseoutReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketOrderMarginCloseoutReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A MarketOrderPositionCloseout specifies the extensions to a Market Order
/// when it has been created to closeout a specific Position.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A MarketOrderPositionCloseout specifies the extensions
/// to a Market Order when it has been created to closeout a specific
/// Position.",
///  "type": "object",
///  "properties": {
///    "instrument": {
///      "description": "The instrument of the Position being closed out.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "units": {
///      "description": "Indication of how much of the Position to close.
/// Either \"ALL\", or a DecimalNumber reflection a partial close of the
/// Trade. The DecimalNumber must always be positive, and represent a number
/// that doesn't exceed the absolute size of the Position.",
///      "type": "string"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MarketOrderPositionCloseout {
    ///The instrument of the Position being closed out.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    ///Indication of how much of the Position to close. Either "ALL", or a
    /// DecimalNumber reflection a partial close of the Trade. The
    /// DecimalNumber must always be positive, and represent a number that
    /// doesn't exceed the absolute size of the Position.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<String>,
}

impl From<&MarketOrderPositionCloseout> for MarketOrderPositionCloseout {
    fn from(value: &MarketOrderPositionCloseout) -> Self {
        value.clone()
    }
}

impl MarketOrderPositionCloseout {
    pub fn builder() -> builder::MarketOrderPositionCloseout {
        Default::default()
    }
}

///Specification of how Positions in the Account are modified when the
/// Order is filled.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///  "type": "string",
///  "enum": [
///    "OPEN_ONLY",
///    "REDUCE_FIRST",
///    "REDUCE_ONLY",
///    "DEFAULT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketOrderPositionFill {
    #[serde(rename = "OPEN_ONLY")]
    OpenOnly,
    #[serde(rename = "REDUCE_FIRST")]
    ReduceFirst,
    #[serde(rename = "REDUCE_ONLY")]
    ReduceOnly,
    #[serde(rename = "DEFAULT")]
    Default,
}

impl From<&MarketOrderPositionFill> for MarketOrderPositionFill {
    fn from(value: &MarketOrderPositionFill) -> Self {
        value.clone()
    }
}

impl ToString for MarketOrderPositionFill {
    fn to_string(&self) -> String {
        match *self {
            Self::OpenOnly => "OPEN_ONLY".to_string(),
            Self::ReduceFirst => "REDUCE_FIRST".to_string(),
            Self::ReduceOnly => "REDUCE_ONLY".to_string(),
            Self::Default => "DEFAULT".to_string(),
        }
    }
}

impl std::str::FromStr for MarketOrderPositionFill {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "OPEN_ONLY" => Ok(Self::OpenOnly),
            "REDUCE_FIRST" => Ok(Self::ReduceFirst),
            "REDUCE_ONLY" => Ok(Self::ReduceOnly),
            "DEFAULT" => Ok(Self::Default),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketOrderPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketOrderPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketOrderPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The reason that the Market Order was created
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Market Order was created",
///  "type": "string",
///  "enum": [
///    "CLIENT_ORDER",
///    "TRADE_CLOSE",
///    "POSITION_CLOSEOUT",
///    "MARGIN_CLOSEOUT",
///    "DELAYED_TRADE_CLOSE"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketOrderReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "TRADE_CLOSE")]
    TradeClose,
    #[serde(rename = "POSITION_CLOSEOUT")]
    PositionCloseout,
    #[serde(rename = "MARGIN_CLOSEOUT")]
    MarginCloseout,
    #[serde(rename = "DELAYED_TRADE_CLOSE")]
    DelayedTradeClose,
}

impl From<&MarketOrderReason> for MarketOrderReason {
    fn from(value: &MarketOrderReason) -> Self {
        value.clone()
    }
}

impl ToString for MarketOrderReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ClientOrder => "CLIENT_ORDER".to_string(),
            Self::TradeClose => "TRADE_CLOSE".to_string(),
            Self::PositionCloseout => "POSITION_CLOSEOUT".to_string(),
            Self::MarginCloseout => "MARGIN_CLOSEOUT".to_string(),
            Self::DelayedTradeClose => "DELAYED_TRADE_CLOSE".to_string(),
        }
    }
}

impl std::str::FromStr for MarketOrderReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CLIENT_ORDER" => Ok(Self::ClientOrder),
            "TRADE_CLOSE" => Ok(Self::TradeClose),
            "POSITION_CLOSEOUT" => Ok(Self::PositionCloseout),
            "MARGIN_CLOSEOUT" => Ok(Self::MarginCloseout),
            "DELAYED_TRADE_CLOSE" => Ok(Self::DelayedTradeClose),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketOrderReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketOrderReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketOrderReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A MarketOrderRejectTransaction represents the rejection of the creation
/// of a Market Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A MarketOrderRejectTransaction represents the rejection
/// of the creation of a Market Order.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "delayedTradeClose": {
///      "$ref": "#/components/schemas/MarketOrderDelayedTradeClose"
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "instrument": {
///      "description": "The Market Order's Instrument.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "longPositionCloseout": {
///      "$ref": "#/components/schemas/MarketOrderPositionCloseout"
///    },
///    "marginCloseout": {
///      "$ref": "#/components/schemas/MarketOrderMarginCloseout"
///    },
///    "positionFill": {
///      "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///      "type": "string",
///      "enum": [
///        "OPEN_ONLY",
///        "REDUCE_FIRST",
///        "REDUCE_ONLY",
///        "DEFAULT"
///      ]
///    },
///    "priceBound": {
///      "description": "The worst price that the client is willing to have
/// the Market Order filled at.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "reason": {
///      "description": "The reason that the Market Order was created",
///      "type": "string",
///      "enum": [
///        "CLIENT_ORDER",
///        "TRADE_CLOSE",
///        "POSITION_CLOSEOUT",
///        "MARGIN_CLOSEOUT",
///        "DELAYED_TRADE_CLOSE"
///      ]
///    },
///    "rejectReason": {
///      "description": "The reason that the Reject Transaction was
/// created",
///      "type": "string",
///      "enum": [
///        "INTERNAL_SERVER_ERROR",
///        "INSTRUMENT_PRICE_UNKNOWN",
///        "ACCOUNT_NOT_ACTIVE",
///        "ACCOUNT_LOCKED",
///        "ACCOUNT_ORDER_CREATION_LOCKED",
///        "ACCOUNT_CONFIGURATION_LOCKED",
///        "ACCOUNT_DEPOSIT_LOCKED",
///        "ACCOUNT_WITHDRAWAL_LOCKED",
///        "ACCOUNT_ORDER_CANCEL_LOCKED",
///        "INSTRUMENT_NOT_TRADEABLE",
///        "PENDING_ORDERS_ALLOWED_EXCEEDED",
///        "ORDER_ID_UNSPECIFIED",
///        "ORDER_DOESNT_EXIST",
///        "ORDER_IDENTIFIER_INCONSISTENCY",
///        "TRADE_ID_UNSPECIFIED",
///        "TRADE_DOESNT_EXIST",
///        "TRADE_IDENTIFIER_INCONSISTENCY",
///        "INSUFFICIENT_MARGIN",
///        "INSTRUMENT_MISSING",
///        "INSTRUMENT_UNKNOWN",
///        "UNITS_MISSING",
///        "UNITS_INVALID",
///        "UNITS_PRECISION_EXCEEDED",
///        "UNITS_LIMIT_EXCEEDED",
///        "UNITS_MIMIMUM_NOT_MET",
///        "PRICE_MISSING",
///        "PRICE_INVALID",
///        "PRICE_PRECISION_EXCEEDED",
///        "PRICE_DISTANCE_MISSING",
///        "PRICE_DISTANCE_INVALID",
///        "PRICE_DISTANCE_PRECISION_EXCEEDED",
///        "PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "PRICE_DISTANCE_MINIMUM_NOT_MET",
///        "TIME_IN_FORCE_MISSING",
///        "TIME_IN_FORCE_INVALID",
///        "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING",
///        "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST",
///        "PRICE_BOUND_INVALID",
///        "PRICE_BOUND_PRECISION_EXCEEDED",
///        "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS",
///        "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED",
///        "CLIENT_ORDER_ID_INVALID",
///        "CLIENT_ORDER_ID_ALREADY_EXISTS",
///        "CLIENT_ORDER_TAG_INVALID",
///        "CLIENT_ORDER_COMMENT_INVALID",
///        "CLIENT_TRADE_ID_INVALID",
///        "CLIENT_TRADE_ID_ALREADY_EXISTS",
///        "CLIENT_TRADE_TAG_INVALID",
///        "CLIENT_TRADE_COMMENT_INVALID",
///        "ORDER_FILL_POSITION_ACTION_MISSING",
///        "ORDER_FILL_POSITION_ACTION_INVALID",
///        "TRIGGER_CONDITION_MISSING",
///        "TRIGGER_CONDITION_INVALID",
///        "ORDER_PARTIAL_FILL_OPTION_MISSING",
///        "ORDER_PARTIAL_FILL_OPTION_INVALID",
///        "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL",
///        "TAKE_PROFIT_ORDER_ALREADY_EXISTS",
///        "TAKE_PROFIT_ON_FILL_PRICE_MISSING",
///        "TAKE_PROFIT_ON_FILL_PRICE_INVALID",
///        "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED",
///        "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING",
///        "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID",
///        "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "STOP_LOSS_ORDER_ALREADY_EXISTS",
///        "STOP_LOSS_ORDER_GUARANTEED_REQUIRED",
///        "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD",
///        "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED",
///        "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION",
///        "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION",
///        "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED",
///        "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///        "STOP_LOSS_ORDER_NOT_CANCELABLE",
///        "STOP_LOSS_ORDER_NOT_REPLACEABLE",
///        "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///        "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///        "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING",
///        "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER",
///        "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///        "STOP_LOSS_ON_FILL_PRICE_MISSING",
///        "STOP_LOSS_ON_FILL_PRICE_INVALID",
///        "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///        "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_DISTANCE_INVALID",
///        "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///        "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING",
///        "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///        "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///        "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET",
///        "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED",
///        "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "CLOSE_TRADE_TYPE_MISSING",
///        "CLOSE_TRADE_PARTIAL_UNITS_MISSING",
///        "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE",
///        "CLOSEOUT_POSITION_DOESNT_EXIST",
///        "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION",
///        "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE",
///        "CLOSEOUT_POSITION_REJECT",
///        "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING",
///        "MARKUP_GROUP_ID_INVALID",
///        "POSITION_AGGREGATION_MODE_INVALID",
///        "ADMIN_CONFIGURE_DATA_MISSING",
///        "MARGIN_RATE_INVALID",
///        "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT",
///        "ALIAS_INVALID",
///        "CLIENT_CONFIGURE_DATA_MISSING",
///        "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL",
///        "AMOUNT_INVALID",
///        "INSUFFICIENT_FUNDS",
///        "AMOUNT_MISSING",
///        "FUNDING_REASON_MISSING",
///        "CLIENT_EXTENSIONS_DATA_MISSING",
///        "REPLACING_ORDER_INVALID",
///        "REPLACING_TRADE_ID_INVALID"
///      ]
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "shortPositionCloseout": {
///      "$ref": "#/components/schemas/MarketOrderPositionCloseout"
///    },
///    "stopLossOnFill": {
///      "$ref": "#/components/schemas/StopLossDetails"
///    },
///    "takeProfitOnFill": {
///      "$ref": "#/components/schemas/TakeProfitDetails"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the Market Order.
/// Restricted to FOK or IOC for a MarketOrder.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeClientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "tradeClose": {
///      "$ref": "#/components/schemas/MarketOrderTradeClose"
///    },
///    "trailingStopLossOnFill": {
///      "$ref": "#/components/schemas/TrailingStopLossDetails"
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"MARKET_ORDER_REJECT\" in a MarketOrderRejectTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "units": {
///      "description": "The quantity requested to be filled by the Market
/// Order. A posititive number of units results in a long Order, and a
/// negative number of units results in a short Order.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MarketOrderRejectTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    #[serde(
        rename = "delayedTradeClose",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub delayed_trade_close: Option<MarketOrderDelayedTradeClose>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The Market Order's Instrument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    #[serde(
        rename = "longPositionCloseout",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub long_position_closeout: Option<MarketOrderPositionCloseout>,
    #[serde(
        rename = "marginCloseout",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_closeout: Option<MarketOrderMarginCloseout>,
    ///Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(
        rename = "positionFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub position_fill: Option<MarketOrderRejectTransactionPositionFill>,
    ///The worst price that the client is willing to have the Market Order
    /// filled at.
    #[serde(
        rename = "priceBound",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub price_bound: Option<String>,
    ///The reason that the Market Order was created
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<MarketOrderRejectTransactionReason>,
    ///The reason that the Reject Transaction was created
    #[serde(
        rename = "rejectReason",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub reject_reason: Option<MarketOrderRejectTransactionRejectReason>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    #[serde(
        rename = "shortPositionCloseout",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub short_position_closeout: Option<MarketOrderPositionCloseout>,
    #[serde(
        rename = "stopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stop_loss_on_fill: Option<StopLossDetails>,
    #[serde(
        rename = "takeProfitOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub take_profit_on_fill: Option<TakeProfitDetails>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The time-in-force requested for the Market Order. Restricted to FOK
    /// or IOC for a MarketOrder.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<MarketOrderRejectTransactionTimeInForce>,
    #[serde(
        rename = "tradeClientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,
    #[serde(
        rename = "tradeClose",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_close: Option<MarketOrderTradeClose>,
    #[serde(
        rename = "trailingStopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,
    ///The Type of the Transaction. Always set to "MARKET_ORDER_REJECT" in
    /// a MarketOrderRejectTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<MarketOrderRejectTransactionType>,
    ///The quantity requested to be filled by the Market Order. A
    /// posititive number of units results in a long Order, and a negative
    /// number of units results in a short Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<String>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&MarketOrderRejectTransaction> for MarketOrderRejectTransaction {
    fn from(value: &MarketOrderRejectTransaction) -> Self {
        value.clone()
    }
}

impl MarketOrderRejectTransaction {
    pub fn builder() -> builder::MarketOrderRejectTransaction {
        Default::default()
    }
}

///Specification of how Positions in the Account are modified when the
/// Order is filled.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///  "type": "string",
///  "enum": [
///    "OPEN_ONLY",
///    "REDUCE_FIRST",
///    "REDUCE_ONLY",
///    "DEFAULT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketOrderRejectTransactionPositionFill {
    #[serde(rename = "OPEN_ONLY")]
    OpenOnly,
    #[serde(rename = "REDUCE_FIRST")]
    ReduceFirst,
    #[serde(rename = "REDUCE_ONLY")]
    ReduceOnly,
    #[serde(rename = "DEFAULT")]
    Default,
}

impl From<&MarketOrderRejectTransactionPositionFill> for MarketOrderRejectTransactionPositionFill {
    fn from(value: &MarketOrderRejectTransactionPositionFill) -> Self {
        value.clone()
    }
}

impl ToString for MarketOrderRejectTransactionPositionFill {
    fn to_string(&self) -> String {
        match *self {
            Self::OpenOnly => "OPEN_ONLY".to_string(),
            Self::ReduceFirst => "REDUCE_FIRST".to_string(),
            Self::ReduceOnly => "REDUCE_ONLY".to_string(),
            Self::Default => "DEFAULT".to_string(),
        }
    }
}

impl std::str::FromStr for MarketOrderRejectTransactionPositionFill {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "OPEN_ONLY" => Ok(Self::OpenOnly),
            "REDUCE_FIRST" => Ok(Self::ReduceFirst),
            "REDUCE_ONLY" => Ok(Self::ReduceOnly),
            "DEFAULT" => Ok(Self::Default),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketOrderRejectTransactionPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketOrderRejectTransactionPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketOrderRejectTransactionPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The reason that the Market Order was created
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Market Order was created",
///  "type": "string",
///  "enum": [
///    "CLIENT_ORDER",
///    "TRADE_CLOSE",
///    "POSITION_CLOSEOUT",
///    "MARGIN_CLOSEOUT",
///    "DELAYED_TRADE_CLOSE"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketOrderRejectTransactionReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "TRADE_CLOSE")]
    TradeClose,
    #[serde(rename = "POSITION_CLOSEOUT")]
    PositionCloseout,
    #[serde(rename = "MARGIN_CLOSEOUT")]
    MarginCloseout,
    #[serde(rename = "DELAYED_TRADE_CLOSE")]
    DelayedTradeClose,
}

impl From<&MarketOrderRejectTransactionReason> for MarketOrderRejectTransactionReason {
    fn from(value: &MarketOrderRejectTransactionReason) -> Self {
        value.clone()
    }
}

impl ToString for MarketOrderRejectTransactionReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ClientOrder => "CLIENT_ORDER".to_string(),
            Self::TradeClose => "TRADE_CLOSE".to_string(),
            Self::PositionCloseout => "POSITION_CLOSEOUT".to_string(),
            Self::MarginCloseout => "MARGIN_CLOSEOUT".to_string(),
            Self::DelayedTradeClose => "DELAYED_TRADE_CLOSE".to_string(),
        }
    }
}

impl std::str::FromStr for MarketOrderRejectTransactionReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CLIENT_ORDER" => Ok(Self::ClientOrder),
            "TRADE_CLOSE" => Ok(Self::TradeClose),
            "POSITION_CLOSEOUT" => Ok(Self::PositionCloseout),
            "MARGIN_CLOSEOUT" => Ok(Self::MarginCloseout),
            "DELAYED_TRADE_CLOSE" => Ok(Self::DelayedTradeClose),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketOrderRejectTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketOrderRejectTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketOrderRejectTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The reason that the Reject Transaction was created
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Reject Transaction was created",
///  "type": "string",
///  "enum": [
///    "INTERNAL_SERVER_ERROR",
///    "INSTRUMENT_PRICE_UNKNOWN",
///    "ACCOUNT_NOT_ACTIVE",
///    "ACCOUNT_LOCKED",
///    "ACCOUNT_ORDER_CREATION_LOCKED",
///    "ACCOUNT_CONFIGURATION_LOCKED",
///    "ACCOUNT_DEPOSIT_LOCKED",
///    "ACCOUNT_WITHDRAWAL_LOCKED",
///    "ACCOUNT_ORDER_CANCEL_LOCKED",
///    "INSTRUMENT_NOT_TRADEABLE",
///    "PENDING_ORDERS_ALLOWED_EXCEEDED",
///    "ORDER_ID_UNSPECIFIED",
///    "ORDER_DOESNT_EXIST",
///    "ORDER_IDENTIFIER_INCONSISTENCY",
///    "TRADE_ID_UNSPECIFIED",
///    "TRADE_DOESNT_EXIST",
///    "TRADE_IDENTIFIER_INCONSISTENCY",
///    "INSUFFICIENT_MARGIN",
///    "INSTRUMENT_MISSING",
///    "INSTRUMENT_UNKNOWN",
///    "UNITS_MISSING",
///    "UNITS_INVALID",
///    "UNITS_PRECISION_EXCEEDED",
///    "UNITS_LIMIT_EXCEEDED",
///    "UNITS_MIMIMUM_NOT_MET",
///    "PRICE_MISSING",
///    "PRICE_INVALID",
///    "PRICE_PRECISION_EXCEEDED",
///    "PRICE_DISTANCE_MISSING",
///    "PRICE_DISTANCE_INVALID",
///    "PRICE_DISTANCE_PRECISION_EXCEEDED",
///    "PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "PRICE_DISTANCE_MINIMUM_NOT_MET",
///    "TIME_IN_FORCE_MISSING",
///    "TIME_IN_FORCE_INVALID",
///    "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING",
///    "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST",
///    "PRICE_BOUND_INVALID",
///    "PRICE_BOUND_PRECISION_EXCEEDED",
///    "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS",
///    "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED",
///    "CLIENT_ORDER_ID_INVALID",
///    "CLIENT_ORDER_ID_ALREADY_EXISTS",
///    "CLIENT_ORDER_TAG_INVALID",
///    "CLIENT_ORDER_COMMENT_INVALID",
///    "CLIENT_TRADE_ID_INVALID",
///    "CLIENT_TRADE_ID_ALREADY_EXISTS",
///    "CLIENT_TRADE_TAG_INVALID",
///    "CLIENT_TRADE_COMMENT_INVALID",
///    "ORDER_FILL_POSITION_ACTION_MISSING",
///    "ORDER_FILL_POSITION_ACTION_INVALID",
///    "TRIGGER_CONDITION_MISSING",
///    "TRIGGER_CONDITION_INVALID",
///    "ORDER_PARTIAL_FILL_OPTION_MISSING",
///    "ORDER_PARTIAL_FILL_OPTION_INVALID",
///    "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL",
///    "TAKE_PROFIT_ORDER_ALREADY_EXISTS",
///    "TAKE_PROFIT_ON_FILL_PRICE_MISSING",
///    "TAKE_PROFIT_ON_FILL_PRICE_INVALID",
///    "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED",
///    "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING",
///    "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "STOP_LOSS_ORDER_ALREADY_EXISTS",
///    "STOP_LOSS_ORDER_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD",
///    "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION",
///    "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION",
///    "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED",
///    "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ORDER_NOT_CANCELABLE",
///    "STOP_LOSS_ORDER_NOT_REPLACEABLE",
///    "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///    "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING",
///    "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER",
///    "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ON_FILL_PRICE_MISSING",
///    "STOP_LOSS_ON_FILL_PRICE_INVALID",
///    "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_DISTANCE_INVALID",
///    "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///    "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET",
///    "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED",
///    "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "CLOSE_TRADE_TYPE_MISSING",
///    "CLOSE_TRADE_PARTIAL_UNITS_MISSING",
///    "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE",
///    "CLOSEOUT_POSITION_DOESNT_EXIST",
///    "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION",
///    "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE",
///    "CLOSEOUT_POSITION_REJECT",
///    "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING",
///    "MARKUP_GROUP_ID_INVALID",
///    "POSITION_AGGREGATION_MODE_INVALID",
///    "ADMIN_CONFIGURE_DATA_MISSING",
///    "MARGIN_RATE_INVALID",
///    "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT",
///    "ALIAS_INVALID",
///    "CLIENT_CONFIGURE_DATA_MISSING",
///    "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL",
///    "AMOUNT_INVALID",
///    "INSUFFICIENT_FUNDS",
///    "AMOUNT_MISSING",
///    "FUNDING_REASON_MISSING",
///    "CLIENT_EXTENSIONS_DATA_MISSING",
///    "REPLACING_ORDER_INVALID",
///    "REPLACING_TRADE_ID_INVALID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketOrderRejectTransactionRejectReason {
    #[serde(rename = "INTERNAL_SERVER_ERROR")]
    InternalServerError,
    #[serde(rename = "INSTRUMENT_PRICE_UNKNOWN")]
    InstrumentPriceUnknown,
    #[serde(rename = "ACCOUNT_NOT_ACTIVE")]
    AccountNotActive,
    #[serde(rename = "ACCOUNT_LOCKED")]
    AccountLocked,
    #[serde(rename = "ACCOUNT_ORDER_CREATION_LOCKED")]
    AccountOrderCreationLocked,
    #[serde(rename = "ACCOUNT_CONFIGURATION_LOCKED")]
    AccountConfigurationLocked,
    #[serde(rename = "ACCOUNT_DEPOSIT_LOCKED")]
    AccountDepositLocked,
    #[serde(rename = "ACCOUNT_WITHDRAWAL_LOCKED")]
    AccountWithdrawalLocked,
    #[serde(rename = "ACCOUNT_ORDER_CANCEL_LOCKED")]
    AccountOrderCancelLocked,
    #[serde(rename = "INSTRUMENT_NOT_TRADEABLE")]
    InstrumentNotTradeable,
    #[serde(rename = "PENDING_ORDERS_ALLOWED_EXCEEDED")]
    PendingOrdersAllowedExceeded,
    #[serde(rename = "ORDER_ID_UNSPECIFIED")]
    OrderIdUnspecified,
    #[serde(rename = "ORDER_DOESNT_EXIST")]
    OrderDoesntExist,
    #[serde(rename = "ORDER_IDENTIFIER_INCONSISTENCY")]
    OrderIdentifierInconsistency,
    #[serde(rename = "TRADE_ID_UNSPECIFIED")]
    TradeIdUnspecified,
    #[serde(rename = "TRADE_DOESNT_EXIST")]
    TradeDoesntExist,
    #[serde(rename = "TRADE_IDENTIFIER_INCONSISTENCY")]
    TradeIdentifierInconsistency,
    #[serde(rename = "INSUFFICIENT_MARGIN")]
    InsufficientMargin,
    #[serde(rename = "INSTRUMENT_MISSING")]
    InstrumentMissing,
    #[serde(rename = "INSTRUMENT_UNKNOWN")]
    InstrumentUnknown,
    #[serde(rename = "UNITS_MISSING")]
    UnitsMissing,
    #[serde(rename = "UNITS_INVALID")]
    UnitsInvalid,
    #[serde(rename = "UNITS_PRECISION_EXCEEDED")]
    UnitsPrecisionExceeded,
    #[serde(rename = "UNITS_LIMIT_EXCEEDED")]
    UnitsLimitExceeded,
    #[serde(rename = "UNITS_MIMIMUM_NOT_MET")]
    UnitsMimimumNotMet,
    #[serde(rename = "PRICE_MISSING")]
    PriceMissing,
    #[serde(rename = "PRICE_INVALID")]
    PriceInvalid,
    #[serde(rename = "PRICE_PRECISION_EXCEEDED")]
    PricePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MISSING")]
    PriceDistanceMissing,
    #[serde(rename = "PRICE_DISTANCE_INVALID")]
    PriceDistanceInvalid,
    #[serde(rename = "PRICE_DISTANCE_PRECISION_EXCEEDED")]
    PriceDistancePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    PriceDistanceMaximumExceeded,
    #[serde(rename = "PRICE_DISTANCE_MINIMUM_NOT_MET")]
    PriceDistanceMinimumNotMet,
    #[serde(rename = "TIME_IN_FORCE_MISSING")]
    TimeInForceMissing,
    #[serde(rename = "TIME_IN_FORCE_INVALID")]
    TimeInForceInvalid,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING")]
    TimeInForceGtdTimestampMissing,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST")]
    TimeInForceGtdTimestampInPast,
    #[serde(rename = "PRICE_BOUND_INVALID")]
    PriceBoundInvalid,
    #[serde(rename = "PRICE_BOUND_PRECISION_EXCEEDED")]
    PriceBoundPrecisionExceeded,
    #[serde(rename = "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS")]
    OrdersOnFillDuplicateClientOrderIds,
    #[serde(rename = "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED")]
    TradeOnFillClientExtensionsNotSupported,
    #[serde(rename = "CLIENT_ORDER_ID_INVALID")]
    ClientOrderIdInvalid,
    #[serde(rename = "CLIENT_ORDER_ID_ALREADY_EXISTS")]
    ClientOrderIdAlreadyExists,
    #[serde(rename = "CLIENT_ORDER_TAG_INVALID")]
    ClientOrderTagInvalid,
    #[serde(rename = "CLIENT_ORDER_COMMENT_INVALID")]
    ClientOrderCommentInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_INVALID")]
    ClientTradeIdInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_ALREADY_EXISTS")]
    ClientTradeIdAlreadyExists,
    #[serde(rename = "CLIENT_TRADE_TAG_INVALID")]
    ClientTradeTagInvalid,
    #[serde(rename = "CLIENT_TRADE_COMMENT_INVALID")]
    ClientTradeCommentInvalid,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_MISSING")]
    OrderFillPositionActionMissing,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_INVALID")]
    OrderFillPositionActionInvalid,
    #[serde(rename = "TRIGGER_CONDITION_MISSING")]
    TriggerConditionMissing,
    #[serde(rename = "TRIGGER_CONDITION_INVALID")]
    TriggerConditionInvalid,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_MISSING")]
    OrderPartialFillOptionMissing,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_INVALID")]
    OrderPartialFillOptionInvalid,
    #[serde(rename = "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL")]
    InvalidReissueImmediatePartialFill,
    #[serde(rename = "TAKE_PROFIT_ORDER_ALREADY_EXISTS")]
    TakeProfitOrderAlreadyExists,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_MISSING")]
    TakeProfitOnFillPriceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_INVALID")]
    TakeProfitOnFillPriceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    TakeProfitOnFillPricePrecisionExceeded,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING")]
    TakeProfitOnFillTimeInForceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID")]
    TakeProfitOnFillTimeInForceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TakeProfitOnFillGtdTimestampMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TakeProfitOnFillGtdTimestampInPast,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TakeProfitOnFillClientOrderIdInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TakeProfitOnFillClientOrderTagInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TakeProfitOnFillClientOrderCommentInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TakeProfitOnFillTriggerConditionMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TakeProfitOnFillTriggerConditionInvalid,
    #[serde(rename = "STOP_LOSS_ORDER_ALREADY_EXISTS")]
    StopLossOrderAlreadyExists,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_REQUIRED")]
    StopLossOrderGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD")]
    StopLossOrderGuaranteedPriceWithinSpread,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED")]
    StopLossOrderGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION")]
    StopLossOrderGuaranteedHaltedCreateViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION")]
    StopLossOrderGuaranteedHaltedTightenViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED")]
    StopLossOrderGuaranteedHedgingNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOrderGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_CANCELABLE")]
    StopLossOrderNotCancelable,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_REPLACEABLE")]
    StopLossOrderNotReplaceable,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOrderGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOrderPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOrderPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER")]
    StopLossOnFillRequiredForPendingOrder,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED")]
    StopLossOnFillGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED")]
    StopLossOnFillGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_MISSING")]
    StopLossOnFillPriceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_INVALID")]
    StopLossOnFillPriceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    StopLossOnFillPricePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOnFillGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOnFillGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_INVALID")]
    StopLossOnFillDistanceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    StopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED")]
    StopLossOnFillDistancePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOnFillPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOnFillPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    StopLossOnFillTimeInForceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    StopLossOnFillTimeInForceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    StopLossOnFillGtdTimestampMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    StopLossOnFillGtdTimestampInPast,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    StopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    StopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    StopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    StopLossOnFillTriggerConditionMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    StopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS")]
    TrailingStopLossOrderAlreadyExists,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING")]
    TrailingStopLossOnFillPriceDistanceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID")]
    TrailingStopLossOnFillPriceDistanceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED")]
    TrailingStopLossOnFillPriceDistancePrecisionExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    TrailingStopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET")]
    TrailingStopLossOnFillPriceDistanceMinimumNotMet,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    TrailingStopLossOnFillTimeInForceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    TrailingStopLossOnFillTimeInForceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TrailingStopLossOnFillGtdTimestampMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TrailingStopLossOnFillGtdTimestampInPast,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TrailingStopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TrailingStopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TrailingStopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED")]
    TrailingStopLossOrdersNotSupported,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TrailingStopLossOnFillTriggerConditionMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TrailingStopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "CLOSE_TRADE_TYPE_MISSING")]
    CloseTradeTypeMissing,
    #[serde(rename = "CLOSE_TRADE_PARTIAL_UNITS_MISSING")]
    CloseTradePartialUnitsMissing,
    #[serde(rename = "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE")]
    CloseTradeUnitsExceedTradeSize,
    #[serde(rename = "CLOSEOUT_POSITION_DOESNT_EXIST")]
    CloseoutPositionDoesntExist,
    #[serde(rename = "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION")]
    CloseoutPositionIncompleteSpecification,
    #[serde(rename = "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE")]
    CloseoutPositionUnitsExceedPositionSize,
    #[serde(rename = "CLOSEOUT_POSITION_REJECT")]
    CloseoutPositionReject,
    #[serde(rename = "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING")]
    CloseoutPositionPartialUnitsMissing,
    #[serde(rename = "MARKUP_GROUP_ID_INVALID")]
    MarkupGroupIdInvalid,
    #[serde(rename = "POSITION_AGGREGATION_MODE_INVALID")]
    PositionAggregationModeInvalid,
    #[serde(rename = "ADMIN_CONFIGURE_DATA_MISSING")]
    AdminConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_INVALID")]
    MarginRateInvalid,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT")]
    MarginRateWouldTriggerCloseout,
    #[serde(rename = "ALIAS_INVALID")]
    AliasInvalid,
    #[serde(rename = "CLIENT_CONFIGURE_DATA_MISSING")]
    ClientConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL")]
    MarginRateWouldTriggerMarginCall,
    #[serde(rename = "AMOUNT_INVALID")]
    AmountInvalid,
    #[serde(rename = "INSUFFICIENT_FUNDS")]
    InsufficientFunds,
    #[serde(rename = "AMOUNT_MISSING")]
    AmountMissing,
    #[serde(rename = "FUNDING_REASON_MISSING")]
    FundingReasonMissing,
    #[serde(rename = "CLIENT_EXTENSIONS_DATA_MISSING")]
    ClientExtensionsDataMissing,
    #[serde(rename = "REPLACING_ORDER_INVALID")]
    ReplacingOrderInvalid,
    #[serde(rename = "REPLACING_TRADE_ID_INVALID")]
    ReplacingTradeIdInvalid,
}

impl From<&MarketOrderRejectTransactionRejectReason> for MarketOrderRejectTransactionRejectReason {
    fn from(value: &MarketOrderRejectTransactionRejectReason) -> Self {
        value.clone()
    }
}

impl ToString for MarketOrderRejectTransactionRejectReason {
    fn to_string(&self) -> String {
        match *self {
            Self::InternalServerError => "INTERNAL_SERVER_ERROR".to_string(),
            Self::InstrumentPriceUnknown => "INSTRUMENT_PRICE_UNKNOWN".to_string(),
            Self::AccountNotActive => "ACCOUNT_NOT_ACTIVE".to_string(),
            Self::AccountLocked => "ACCOUNT_LOCKED".to_string(),
            Self::AccountOrderCreationLocked => "ACCOUNT_ORDER_CREATION_LOCKED".to_string(),
            Self::AccountConfigurationLocked => "ACCOUNT_CONFIGURATION_LOCKED".to_string(),
            Self::AccountDepositLocked => "ACCOUNT_DEPOSIT_LOCKED".to_string(),
            Self::AccountWithdrawalLocked => "ACCOUNT_WITHDRAWAL_LOCKED".to_string(),
            Self::AccountOrderCancelLocked => "ACCOUNT_ORDER_CANCEL_LOCKED".to_string(),
            Self::InstrumentNotTradeable => "INSTRUMENT_NOT_TRADEABLE".to_string(),
            Self::PendingOrdersAllowedExceeded => "PENDING_ORDERS_ALLOWED_EXCEEDED".to_string(),
            Self::OrderIdUnspecified => "ORDER_ID_UNSPECIFIED".to_string(),
            Self::OrderDoesntExist => "ORDER_DOESNT_EXIST".to_string(),
            Self::OrderIdentifierInconsistency => "ORDER_IDENTIFIER_INCONSISTENCY".to_string(),
            Self::TradeIdUnspecified => "TRADE_ID_UNSPECIFIED".to_string(),
            Self::TradeDoesntExist => "TRADE_DOESNT_EXIST".to_string(),
            Self::TradeIdentifierInconsistency => "TRADE_IDENTIFIER_INCONSISTENCY".to_string(),
            Self::InsufficientMargin => "INSUFFICIENT_MARGIN".to_string(),
            Self::InstrumentMissing => "INSTRUMENT_MISSING".to_string(),
            Self::InstrumentUnknown => "INSTRUMENT_UNKNOWN".to_string(),
            Self::UnitsMissing => "UNITS_MISSING".to_string(),
            Self::UnitsInvalid => "UNITS_INVALID".to_string(),
            Self::UnitsPrecisionExceeded => "UNITS_PRECISION_EXCEEDED".to_string(),
            Self::UnitsLimitExceeded => "UNITS_LIMIT_EXCEEDED".to_string(),
            Self::UnitsMimimumNotMet => "UNITS_MIMIMUM_NOT_MET".to_string(),
            Self::PriceMissing => "PRICE_MISSING".to_string(),
            Self::PriceInvalid => "PRICE_INVALID".to_string(),
            Self::PricePrecisionExceeded => "PRICE_PRECISION_EXCEEDED".to_string(),
            Self::PriceDistanceMissing => "PRICE_DISTANCE_MISSING".to_string(),
            Self::PriceDistanceInvalid => "PRICE_DISTANCE_INVALID".to_string(),
            Self::PriceDistancePrecisionExceeded => "PRICE_DISTANCE_PRECISION_EXCEEDED".to_string(),
            Self::PriceDistanceMaximumExceeded => "PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string(),
            Self::PriceDistanceMinimumNotMet => "PRICE_DISTANCE_MINIMUM_NOT_MET".to_string(),
            Self::TimeInForceMissing => "TIME_IN_FORCE_MISSING".to_string(),
            Self::TimeInForceInvalid => "TIME_IN_FORCE_INVALID".to_string(),
            Self::TimeInForceGtdTimestampMissing => {
                "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TimeInForceGtdTimestampInPast => {
                "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::PriceBoundInvalid => "PRICE_BOUND_INVALID".to_string(),
            Self::PriceBoundPrecisionExceeded => "PRICE_BOUND_PRECISION_EXCEEDED".to_string(),
            Self::OrdersOnFillDuplicateClientOrderIds => {
                "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS".to_string()
            }
            Self::TradeOnFillClientExtensionsNotSupported => {
                "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED".to_string()
            }
            Self::ClientOrderIdInvalid => "CLIENT_ORDER_ID_INVALID".to_string(),
            Self::ClientOrderIdAlreadyExists => "CLIENT_ORDER_ID_ALREADY_EXISTS".to_string(),
            Self::ClientOrderTagInvalid => "CLIENT_ORDER_TAG_INVALID".to_string(),
            Self::ClientOrderCommentInvalid => "CLIENT_ORDER_COMMENT_INVALID".to_string(),
            Self::ClientTradeIdInvalid => "CLIENT_TRADE_ID_INVALID".to_string(),
            Self::ClientTradeIdAlreadyExists => "CLIENT_TRADE_ID_ALREADY_EXISTS".to_string(),
            Self::ClientTradeTagInvalid => "CLIENT_TRADE_TAG_INVALID".to_string(),
            Self::ClientTradeCommentInvalid => "CLIENT_TRADE_COMMENT_INVALID".to_string(),
            Self::OrderFillPositionActionMissing => {
                "ORDER_FILL_POSITION_ACTION_MISSING".to_string()
            }
            Self::OrderFillPositionActionInvalid => {
                "ORDER_FILL_POSITION_ACTION_INVALID".to_string()
            }
            Self::TriggerConditionMissing => "TRIGGER_CONDITION_MISSING".to_string(),
            Self::TriggerConditionInvalid => "TRIGGER_CONDITION_INVALID".to_string(),
            Self::OrderPartialFillOptionMissing => "ORDER_PARTIAL_FILL_OPTION_MISSING".to_string(),
            Self::OrderPartialFillOptionInvalid => "ORDER_PARTIAL_FILL_OPTION_INVALID".to_string(),
            Self::InvalidReissueImmediatePartialFill => {
                "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL".to_string()
            }
            Self::TakeProfitOrderAlreadyExists => "TAKE_PROFIT_ORDER_ALREADY_EXISTS".to_string(),
            Self::TakeProfitOnFillPriceMissing => "TAKE_PROFIT_ON_FILL_PRICE_MISSING".to_string(),
            Self::TakeProfitOnFillPriceInvalid => "TAKE_PROFIT_ON_FILL_PRICE_INVALID".to_string(),
            Self::TakeProfitOnFillPricePrecisionExceeded => {
                "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED".to_string()
            }
            Self::TakeProfitOnFillTimeInForceMissing => {
                "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::TakeProfitOnFillTimeInForceInvalid => {
                "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::TakeProfitOnFillGtdTimestampMissing => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TakeProfitOnFillGtdTimestampInPast => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TakeProfitOnFillClientOrderIdInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::TakeProfitOnFillClientOrderTagInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::TakeProfitOnFillClientOrderCommentInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::TakeProfitOnFillTriggerConditionMissing => {
                "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::TakeProfitOnFillTriggerConditionInvalid => {
                "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::StopLossOrderAlreadyExists => "STOP_LOSS_ORDER_ALREADY_EXISTS".to_string(),
            Self::StopLossOrderGuaranteedRequired => {
                "STOP_LOSS_ORDER_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOrderGuaranteedPriceWithinSpread => {
                "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD".to_string()
            }
            Self::StopLossOrderGuaranteedNotAllowed => {
                "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOrderGuaranteedHaltedCreateViolation => {
                "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION".to_string()
            }
            Self::StopLossOrderGuaranteedHaltedTightenViolation => {
                "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION".to_string()
            }
            Self::StopLossOrderGuaranteedHedgingNotAllowed => {
                "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED".to_string()
            }
            Self::StopLossOrderGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOrderNotCancelable => "STOP_LOSS_ORDER_NOT_CANCELABLE".to_string(),
            Self::StopLossOrderNotReplaceable => "STOP_LOSS_ORDER_NOT_REPLACEABLE".to_string(),
            Self::StopLossOrderGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOrderPriceAndDistanceBothSpecified => {
                "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED".to_string()
            }
            Self::StopLossOrderPriceAndDistanceBothMissing => {
                "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING".to_string()
            }
            Self::StopLossOnFillRequiredForPendingOrder => {
                "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER".to_string()
            }
            Self::StopLossOnFillGuaranteedNotAllowed => {
                "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOnFillGuaranteedRequired => {
                "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOnFillPriceMissing => "STOP_LOSS_ON_FILL_PRICE_MISSING".to_string(),
            Self::StopLossOnFillPriceInvalid => "STOP_LOSS_ON_FILL_PRICE_INVALID".to_string(),
            Self::StopLossOnFillPricePrecisionExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOnFillGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillDistanceInvalid => "STOP_LOSS_ON_FILL_DISTANCE_INVALID".to_string(),
            Self::StopLossOnFillPriceDistanceMaximumExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::StopLossOnFillDistancePrecisionExceeded => {
                "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillPriceAndDistanceBothSpecified => {
                "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED".to_string()
            }
            Self::StopLossOnFillPriceAndDistanceBothMissing => {
                "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING".to_string()
            }
            Self::StopLossOnFillTimeInForceMissing => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::StopLossOnFillTimeInForceInvalid => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::StopLossOnFillGtdTimestampMissing => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::StopLossOnFillGtdTimestampInPast => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::StopLossOnFillClientOrderIdInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::StopLossOnFillClientOrderTagInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::StopLossOnFillClientOrderCommentInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::StopLossOnFillTriggerConditionMissing => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::StopLossOnFillTriggerConditionInvalid => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::TrailingStopLossOrderAlreadyExists => {
                "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistancePrecisionExceeded => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMaximumExceeded => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMinimumNotMet => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET".to_string()
            }
            Self::TrailingStopLossOnFillTimeInForceMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillTimeInForceInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampInPast => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderIdInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderTagInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderCommentInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::TrailingStopLossOrdersNotSupported => {
                "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED".to_string()
            }
            Self::TrailingStopLossOnFillTriggerConditionMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillTriggerConditionInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::CloseTradeTypeMissing => "CLOSE_TRADE_TYPE_MISSING".to_string(),
            Self::CloseTradePartialUnitsMissing => "CLOSE_TRADE_PARTIAL_UNITS_MISSING".to_string(),
            Self::CloseTradeUnitsExceedTradeSize => {
                "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE".to_string()
            }
            Self::CloseoutPositionDoesntExist => "CLOSEOUT_POSITION_DOESNT_EXIST".to_string(),
            Self::CloseoutPositionIncompleteSpecification => {
                "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION".to_string()
            }
            Self::CloseoutPositionUnitsExceedPositionSize => {
                "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE".to_string()
            }
            Self::CloseoutPositionReject => "CLOSEOUT_POSITION_REJECT".to_string(),
            Self::CloseoutPositionPartialUnitsMissing => {
                "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING".to_string()
            }
            Self::MarkupGroupIdInvalid => "MARKUP_GROUP_ID_INVALID".to_string(),
            Self::PositionAggregationModeInvalid => "POSITION_AGGREGATION_MODE_INVALID".to_string(),
            Self::AdminConfigureDataMissing => "ADMIN_CONFIGURE_DATA_MISSING".to_string(),
            Self::MarginRateInvalid => "MARGIN_RATE_INVALID".to_string(),
            Self::MarginRateWouldTriggerCloseout => {
                "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT".to_string()
            }
            Self::AliasInvalid => "ALIAS_INVALID".to_string(),
            Self::ClientConfigureDataMissing => "CLIENT_CONFIGURE_DATA_MISSING".to_string(),
            Self::MarginRateWouldTriggerMarginCall => {
                "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL".to_string()
            }
            Self::AmountInvalid => "AMOUNT_INVALID".to_string(),
            Self::InsufficientFunds => "INSUFFICIENT_FUNDS".to_string(),
            Self::AmountMissing => "AMOUNT_MISSING".to_string(),
            Self::FundingReasonMissing => "FUNDING_REASON_MISSING".to_string(),
            Self::ClientExtensionsDataMissing => "CLIENT_EXTENSIONS_DATA_MISSING".to_string(),
            Self::ReplacingOrderInvalid => "REPLACING_ORDER_INVALID".to_string(),
            Self::ReplacingTradeIdInvalid => "REPLACING_TRADE_ID_INVALID".to_string(),
        }
    }
}

impl std::str::FromStr for MarketOrderRejectTransactionRejectReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "INTERNAL_SERVER_ERROR" => Ok(Self::InternalServerError),
            "INSTRUMENT_PRICE_UNKNOWN" => Ok(Self::InstrumentPriceUnknown),
            "ACCOUNT_NOT_ACTIVE" => Ok(Self::AccountNotActive),
            "ACCOUNT_LOCKED" => Ok(Self::AccountLocked),
            "ACCOUNT_ORDER_CREATION_LOCKED" => Ok(Self::AccountOrderCreationLocked),
            "ACCOUNT_CONFIGURATION_LOCKED" => Ok(Self::AccountConfigurationLocked),
            "ACCOUNT_DEPOSIT_LOCKED" => Ok(Self::AccountDepositLocked),
            "ACCOUNT_WITHDRAWAL_LOCKED" => Ok(Self::AccountWithdrawalLocked),
            "ACCOUNT_ORDER_CANCEL_LOCKED" => Ok(Self::AccountOrderCancelLocked),
            "INSTRUMENT_NOT_TRADEABLE" => Ok(Self::InstrumentNotTradeable),
            "PENDING_ORDERS_ALLOWED_EXCEEDED" => Ok(Self::PendingOrdersAllowedExceeded),
            "ORDER_ID_UNSPECIFIED" => Ok(Self::OrderIdUnspecified),
            "ORDER_DOESNT_EXIST" => Ok(Self::OrderDoesntExist),
            "ORDER_IDENTIFIER_INCONSISTENCY" => Ok(Self::OrderIdentifierInconsistency),
            "TRADE_ID_UNSPECIFIED" => Ok(Self::TradeIdUnspecified),
            "TRADE_DOESNT_EXIST" => Ok(Self::TradeDoesntExist),
            "TRADE_IDENTIFIER_INCONSISTENCY" => Ok(Self::TradeIdentifierInconsistency),
            "INSUFFICIENT_MARGIN" => Ok(Self::InsufficientMargin),
            "INSTRUMENT_MISSING" => Ok(Self::InstrumentMissing),
            "INSTRUMENT_UNKNOWN" => Ok(Self::InstrumentUnknown),
            "UNITS_MISSING" => Ok(Self::UnitsMissing),
            "UNITS_INVALID" => Ok(Self::UnitsInvalid),
            "UNITS_PRECISION_EXCEEDED" => Ok(Self::UnitsPrecisionExceeded),
            "UNITS_LIMIT_EXCEEDED" => Ok(Self::UnitsLimitExceeded),
            "UNITS_MIMIMUM_NOT_MET" => Ok(Self::UnitsMimimumNotMet),
            "PRICE_MISSING" => Ok(Self::PriceMissing),
            "PRICE_INVALID" => Ok(Self::PriceInvalid),
            "PRICE_PRECISION_EXCEEDED" => Ok(Self::PricePrecisionExceeded),
            "PRICE_DISTANCE_MISSING" => Ok(Self::PriceDistanceMissing),
            "PRICE_DISTANCE_INVALID" => Ok(Self::PriceDistanceInvalid),
            "PRICE_DISTANCE_PRECISION_EXCEEDED" => Ok(Self::PriceDistancePrecisionExceeded),
            "PRICE_DISTANCE_MAXIMUM_EXCEEDED" => Ok(Self::PriceDistanceMaximumExceeded),
            "PRICE_DISTANCE_MINIMUM_NOT_MET" => Ok(Self::PriceDistanceMinimumNotMet),
            "TIME_IN_FORCE_MISSING" => Ok(Self::TimeInForceMissing),
            "TIME_IN_FORCE_INVALID" => Ok(Self::TimeInForceInvalid),
            "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING" => Ok(Self::TimeInForceGtdTimestampMissing),
            "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST" => Ok(Self::TimeInForceGtdTimestampInPast),
            "PRICE_BOUND_INVALID" => Ok(Self::PriceBoundInvalid),
            "PRICE_BOUND_PRECISION_EXCEEDED" => Ok(Self::PriceBoundPrecisionExceeded),
            "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS" => {
                Ok(Self::OrdersOnFillDuplicateClientOrderIds)
            }
            "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED" => {
                Ok(Self::TradeOnFillClientExtensionsNotSupported)
            }
            "CLIENT_ORDER_ID_INVALID" => Ok(Self::ClientOrderIdInvalid),
            "CLIENT_ORDER_ID_ALREADY_EXISTS" => Ok(Self::ClientOrderIdAlreadyExists),
            "CLIENT_ORDER_TAG_INVALID" => Ok(Self::ClientOrderTagInvalid),
            "CLIENT_ORDER_COMMENT_INVALID" => Ok(Self::ClientOrderCommentInvalid),
            "CLIENT_TRADE_ID_INVALID" => Ok(Self::ClientTradeIdInvalid),
            "CLIENT_TRADE_ID_ALREADY_EXISTS" => Ok(Self::ClientTradeIdAlreadyExists),
            "CLIENT_TRADE_TAG_INVALID" => Ok(Self::ClientTradeTagInvalid),
            "CLIENT_TRADE_COMMENT_INVALID" => Ok(Self::ClientTradeCommentInvalid),
            "ORDER_FILL_POSITION_ACTION_MISSING" => Ok(Self::OrderFillPositionActionMissing),
            "ORDER_FILL_POSITION_ACTION_INVALID" => Ok(Self::OrderFillPositionActionInvalid),
            "TRIGGER_CONDITION_MISSING" => Ok(Self::TriggerConditionMissing),
            "TRIGGER_CONDITION_INVALID" => Ok(Self::TriggerConditionInvalid),
            "ORDER_PARTIAL_FILL_OPTION_MISSING" => Ok(Self::OrderPartialFillOptionMissing),
            "ORDER_PARTIAL_FILL_OPTION_INVALID" => Ok(Self::OrderPartialFillOptionInvalid),
            "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL" => {
                Ok(Self::InvalidReissueImmediatePartialFill)
            }
            "TAKE_PROFIT_ORDER_ALREADY_EXISTS" => Ok(Self::TakeProfitOrderAlreadyExists),
            "TAKE_PROFIT_ON_FILL_PRICE_MISSING" => Ok(Self::TakeProfitOnFillPriceMissing),
            "TAKE_PROFIT_ON_FILL_PRICE_INVALID" => Ok(Self::TakeProfitOnFillPriceInvalid),
            "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(Self::TakeProfitOnFillPricePrecisionExceeded)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(Self::TakeProfitOnFillTimeInForceMissing)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(Self::TakeProfitOnFillTimeInForceInvalid)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::TakeProfitOnFillGtdTimestampMissing)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TakeProfitOnFillGtdTimestampInPast)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderIdInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderTagInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderCommentInvalid)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::TakeProfitOnFillTriggerConditionMissing)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::TakeProfitOnFillTriggerConditionInvalid)
            }
            "STOP_LOSS_ORDER_ALREADY_EXISTS" => Ok(Self::StopLossOrderAlreadyExists),
            "STOP_LOSS_ORDER_GUARANTEED_REQUIRED" => Ok(Self::StopLossOrderGuaranteedRequired),
            "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD" => {
                Ok(Self::StopLossOrderGuaranteedPriceWithinSpread)
            }
            "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED" => Ok(Self::StopLossOrderGuaranteedNotAllowed),
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION" => {
                Ok(Self::StopLossOrderGuaranteedHaltedCreateViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION" => {
                Ok(Self::StopLossOrderGuaranteedHaltedTightenViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED" => {
                Ok(Self::StopLossOrderGuaranteedHedgingNotAllowed)
            }
            "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOrderGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ORDER_NOT_CANCELABLE" => Ok(Self::StopLossOrderNotCancelable),
            "STOP_LOSS_ORDER_NOT_REPLACEABLE" => Ok(Self::StopLossOrderNotReplaceable),
            "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOrderGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(Self::StopLossOrderPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(Self::StopLossOrderPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER" => {
                Ok(Self::StopLossOnFillRequiredForPendingOrder)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED" => {
                Ok(Self::StopLossOnFillGuaranteedNotAllowed)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED" => Ok(Self::StopLossOnFillGuaranteedRequired),
            "STOP_LOSS_ON_FILL_PRICE_MISSING" => Ok(Self::StopLossOnFillPriceMissing),
            "STOP_LOSS_ON_FILL_PRICE_INVALID" => Ok(Self::StopLossOnFillPriceInvalid),
            "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(Self::StopLossOnFillPricePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOnFillGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOnFillGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_INVALID" => Ok(Self::StopLossOnFillDistanceInvalid),
            "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::StopLossOnFillPriceDistanceMaximumExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(Self::StopLossOnFillDistancePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(Self::StopLossOnFillPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(Self::StopLossOnFillPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => Ok(Self::StopLossOnFillTimeInForceMissing),
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => Ok(Self::StopLossOnFillTimeInForceInvalid),
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::StopLossOnFillGtdTimestampMissing)
            }
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => Ok(Self::StopLossOnFillGtdTimestampInPast),
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderIdInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderTagInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderCommentInvalid)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::StopLossOnFillTriggerConditionMissing)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::StopLossOnFillTriggerConditionInvalid)
            }
            "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS" => {
                Ok(Self::TrailingStopLossOrderAlreadyExists)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(Self::TrailingStopLossOnFillPriceDistancePrecisionExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMaximumExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMinimumNotMet)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(Self::TrailingStopLossOnFillTimeInForceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(Self::TrailingStopLossOnFillTimeInForceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampInPast)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderIdInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderTagInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderCommentInvalid)
            }
            "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED" => {
                Ok(Self::TrailingStopLossOrdersNotSupported)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::TrailingStopLossOnFillTriggerConditionMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::TrailingStopLossOnFillTriggerConditionInvalid)
            }
            "CLOSE_TRADE_TYPE_MISSING" => Ok(Self::CloseTradeTypeMissing),
            "CLOSE_TRADE_PARTIAL_UNITS_MISSING" => Ok(Self::CloseTradePartialUnitsMissing),
            "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE" => Ok(Self::CloseTradeUnitsExceedTradeSize),
            "CLOSEOUT_POSITION_DOESNT_EXIST" => Ok(Self::CloseoutPositionDoesntExist),
            "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION" => {
                Ok(Self::CloseoutPositionIncompleteSpecification)
            }
            "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE" => {
                Ok(Self::CloseoutPositionUnitsExceedPositionSize)
            }
            "CLOSEOUT_POSITION_REJECT" => Ok(Self::CloseoutPositionReject),
            "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING" => {
                Ok(Self::CloseoutPositionPartialUnitsMissing)
            }
            "MARKUP_GROUP_ID_INVALID" => Ok(Self::MarkupGroupIdInvalid),
            "POSITION_AGGREGATION_MODE_INVALID" => Ok(Self::PositionAggregationModeInvalid),
            "ADMIN_CONFIGURE_DATA_MISSING" => Ok(Self::AdminConfigureDataMissing),
            "MARGIN_RATE_INVALID" => Ok(Self::MarginRateInvalid),
            "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT" => Ok(Self::MarginRateWouldTriggerCloseout),
            "ALIAS_INVALID" => Ok(Self::AliasInvalid),
            "CLIENT_CONFIGURE_DATA_MISSING" => Ok(Self::ClientConfigureDataMissing),
            "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL" => Ok(Self::MarginRateWouldTriggerMarginCall),
            "AMOUNT_INVALID" => Ok(Self::AmountInvalid),
            "INSUFFICIENT_FUNDS" => Ok(Self::InsufficientFunds),
            "AMOUNT_MISSING" => Ok(Self::AmountMissing),
            "FUNDING_REASON_MISSING" => Ok(Self::FundingReasonMissing),
            "CLIENT_EXTENSIONS_DATA_MISSING" => Ok(Self::ClientExtensionsDataMissing),
            "REPLACING_ORDER_INVALID" => Ok(Self::ReplacingOrderInvalid),
            "REPLACING_TRADE_ID_INVALID" => Ok(Self::ReplacingTradeIdInvalid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketOrderRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketOrderRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketOrderRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The time-in-force requested for the Market Order. Restricted to FOK or
/// IOC for a MarketOrder.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the Market Order.
/// Restricted to FOK or IOC for a MarketOrder.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketOrderRejectTransactionTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&MarketOrderRejectTransactionTimeInForce> for MarketOrderRejectTransactionTimeInForce {
    fn from(value: &MarketOrderRejectTransactionTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for MarketOrderRejectTransactionTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for MarketOrderRejectTransactionTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketOrderRejectTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketOrderRejectTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketOrderRejectTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Type of the Transaction. Always set to "MARKET_ORDER_REJECT" in a
/// MarketOrderRejectTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"MARKET_ORDER_REJECT\" in a MarketOrderRejectTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketOrderRejectTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&MarketOrderRejectTransactionType> for MarketOrderRejectTransactionType {
    fn from(value: &MarketOrderRejectTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for MarketOrderRejectTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for MarketOrderRejectTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketOrderRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketOrderRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketOrderRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A MarketOrderRequest specifies the parameters that may be set when
/// creating a Market Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A MarketOrderRequest specifies the parameters that may
/// be set when creating a Market Order.",
///  "type": "object",
///  "properties": {
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "instrument": {
///      "description": "The Market Order's Instrument.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "positionFill": {
///      "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///      "type": "string",
///      "enum": [
///        "OPEN_ONLY",
///        "REDUCE_FIRST",
///        "REDUCE_ONLY",
///        "DEFAULT"
///      ]
///    },
///    "priceBound": {
///      "description": "The worst price that the client is willing to have
/// the Market Order filled at.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "stopLossOnFill": {
///      "$ref": "#/components/schemas/StopLossDetails"
///    },
///    "takeProfitOnFill": {
///      "$ref": "#/components/schemas/TakeProfitDetails"
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the Market Order.
/// Restricted to FOK or IOC for a MarketOrder.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeClientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "trailingStopLossOnFill": {
///      "$ref": "#/components/schemas/TrailingStopLossDetails"
///    },
///    "type": {
///      "description": "The type of the Order to Create. Must be set to
/// \"MARKET\" when creating a Market Order.",
///      "type": "string",
///      "enum": [
///        "MARKET",
///        "LIMIT",
///        "STOP",
///        "MARKET_IF_TOUCHED",
///        "TAKE_PROFIT",
///        "STOP_LOSS",
///        "TRAILING_STOP_LOSS",
///        "FIXED_PRICE"
///      ]
///    },
///    "units": {
///      "description": "The quantity requested to be filled by the Market
/// Order. A posititive number of units results in a long Order, and a
/// negative number of units results in a short Order.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MarketOrderRequest {
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The Market Order's Instrument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    ///Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(
        rename = "positionFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub position_fill: Option<MarketOrderRequestPositionFill>,
    ///The worst price that the client is willing to have the Market Order
    /// filled at.
    #[serde(
        rename = "priceBound",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub price_bound: Option<String>,
    #[serde(
        rename = "stopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stop_loss_on_fill: Option<StopLossDetails>,
    #[serde(
        rename = "takeProfitOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub take_profit_on_fill: Option<TakeProfitDetails>,
    ///The time-in-force requested for the Market Order. Restricted to FOK
    /// or IOC for a MarketOrder.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<MarketOrderRequestTimeInForce>,
    #[serde(
        rename = "tradeClientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,
    #[serde(
        rename = "trailingStopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,
    ///The type of the Order to Create. Must be set to "MARKET" when
    /// creating a Market Order.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<MarketOrderRequestType>,
    ///The quantity requested to be filled by the Market Order. A
    /// posititive number of units results in a long Order, and a negative
    /// number of units results in a short Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<String>,
}

impl From<&MarketOrderRequest> for MarketOrderRequest {
    fn from(value: &MarketOrderRequest) -> Self {
        value.clone()
    }
}

impl MarketOrderRequest {
    pub fn builder() -> builder::MarketOrderRequest {
        Default::default()
    }
}

///Specification of how Positions in the Account are modified when the
/// Order is filled.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///  "type": "string",
///  "enum": [
///    "OPEN_ONLY",
///    "REDUCE_FIRST",
///    "REDUCE_ONLY",
///    "DEFAULT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketOrderRequestPositionFill {
    #[serde(rename = "OPEN_ONLY")]
    OpenOnly,
    #[serde(rename = "REDUCE_FIRST")]
    ReduceFirst,
    #[serde(rename = "REDUCE_ONLY")]
    ReduceOnly,
    #[serde(rename = "DEFAULT")]
    Default,
}

impl From<&MarketOrderRequestPositionFill> for MarketOrderRequestPositionFill {
    fn from(value: &MarketOrderRequestPositionFill) -> Self {
        value.clone()
    }
}

impl ToString for MarketOrderRequestPositionFill {
    fn to_string(&self) -> String {
        match *self {
            Self::OpenOnly => "OPEN_ONLY".to_string(),
            Self::ReduceFirst => "REDUCE_FIRST".to_string(),
            Self::ReduceOnly => "REDUCE_ONLY".to_string(),
            Self::Default => "DEFAULT".to_string(),
        }
    }
}

impl std::str::FromStr for MarketOrderRequestPositionFill {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "OPEN_ONLY" => Ok(Self::OpenOnly),
            "REDUCE_FIRST" => Ok(Self::ReduceFirst),
            "REDUCE_ONLY" => Ok(Self::ReduceOnly),
            "DEFAULT" => Ok(Self::Default),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketOrderRequestPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketOrderRequestPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketOrderRequestPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The time-in-force requested for the Market Order. Restricted to FOK or
/// IOC for a MarketOrder.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the Market Order.
/// Restricted to FOK or IOC for a MarketOrder.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketOrderRequestTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&MarketOrderRequestTimeInForce> for MarketOrderRequestTimeInForce {
    fn from(value: &MarketOrderRequestTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for MarketOrderRequestTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for MarketOrderRequestTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketOrderRequestTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketOrderRequestTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketOrderRequestTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The type of the Order to Create. Must be set to "MARKET" when creating a
/// Market Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The type of the Order to Create. Must be set to
/// \"MARKET\" when creating a Market Order.",
///  "type": "string",
///  "enum": [
///    "MARKET",
///    "LIMIT",
///    "STOP",
///    "MARKET_IF_TOUCHED",
///    "TAKE_PROFIT",
///    "STOP_LOSS",
///    "TRAILING_STOP_LOSS",
///    "FIXED_PRICE"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketOrderRequestType {
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "STOP")]
    Stop,
    #[serde(rename = "MARKET_IF_TOUCHED")]
    MarketIfTouched,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "STOP_LOSS")]
    StopLoss,
    #[serde(rename = "TRAILING_STOP_LOSS")]
    TrailingStopLoss,
    #[serde(rename = "FIXED_PRICE")]
    FixedPrice,
}

impl From<&MarketOrderRequestType> for MarketOrderRequestType {
    fn from(value: &MarketOrderRequestType) -> Self {
        value.clone()
    }
}

impl ToString for MarketOrderRequestType {
    fn to_string(&self) -> String {
        match *self {
            Self::Market => "MARKET".to_string(),
            Self::Limit => "LIMIT".to_string(),
            Self::Stop => "STOP".to_string(),
            Self::MarketIfTouched => "MARKET_IF_TOUCHED".to_string(),
            Self::TakeProfit => "TAKE_PROFIT".to_string(),
            Self::StopLoss => "STOP_LOSS".to_string(),
            Self::TrailingStopLoss => "TRAILING_STOP_LOSS".to_string(),
            Self::FixedPrice => "FIXED_PRICE".to_string(),
        }
    }
}

impl std::str::FromStr for MarketOrderRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "MARKET" => Ok(Self::Market),
            "LIMIT" => Ok(Self::Limit),
            "STOP" => Ok(Self::Stop),
            "MARKET_IF_TOUCHED" => Ok(Self::MarketIfTouched),
            "TAKE_PROFIT" => Ok(Self::TakeProfit),
            "STOP_LOSS" => Ok(Self::StopLoss),
            "TRAILING_STOP_LOSS" => Ok(Self::TrailingStopLoss),
            "FIXED_PRICE" => Ok(Self::FixedPrice),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketOrderRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketOrderRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketOrderRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The current state of the Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The current state of the Order.",
///  "type": "string",
///  "enum": [
///    "PENDING",
///    "FILLED",
///    "TRIGGERED",
///    "CANCELLED"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketOrderState {
    #[serde(rename = "PENDING")]
    Pending,
    #[serde(rename = "FILLED")]
    Filled,
    #[serde(rename = "TRIGGERED")]
    Triggered,
    #[serde(rename = "CANCELLED")]
    Cancelled,
}

impl From<&MarketOrderState> for MarketOrderState {
    fn from(value: &MarketOrderState) -> Self {
        value.clone()
    }
}

impl ToString for MarketOrderState {
    fn to_string(&self) -> String {
        match *self {
            Self::Pending => "PENDING".to_string(),
            Self::Filled => "FILLED".to_string(),
            Self::Triggered => "TRIGGERED".to_string(),
            Self::Cancelled => "CANCELLED".to_string(),
        }
    }
}

impl std::str::FromStr for MarketOrderState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "PENDING" => Ok(Self::Pending),
            "FILLED" => Ok(Self::Filled),
            "TRIGGERED" => Ok(Self::Triggered),
            "CANCELLED" => Ok(Self::Cancelled),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketOrderState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketOrderState {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketOrderState {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The time-in-force requested for the Market Order. Restricted to FOK or
/// IOC for a MarketOrder.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the Market Order.
/// Restricted to FOK or IOC for a MarketOrder.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketOrderTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&MarketOrderTimeInForce> for MarketOrderTimeInForce {
    fn from(value: &MarketOrderTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for MarketOrderTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for MarketOrderTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketOrderTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketOrderTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketOrderTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A MarketOrderTradeClose specifies the extensions to a Market Order that
/// has been created specifically to close a Trade.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A MarketOrderTradeClose specifies the extensions to a
/// Market Order that has been created specifically to close a Trade.",
///  "type": "object",
///  "properties": {
///    "clientTradeID": {
///      "description": "The client ID of the Trade requested to be closed",
///      "type": "string"
///    },
///    "tradeID": {
///      "description": "The ID of the Trade requested to be closed",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "units": {
///      "description": "Indication of how much of the Trade to close.
/// Either \"ALL\", or a DecimalNumber reflection a partial close of the
/// Trade.",
///      "type": "string"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MarketOrderTradeClose {
    ///The client ID of the Trade requested to be closed
    #[serde(
        rename = "clientTradeID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_trade_id: Option<String>,
    ///The ID of the Trade requested to be closed
    #[serde(rename = "tradeID", default, skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,
    ///Indication of how much of the Trade to close. Either "ALL", or a
    /// DecimalNumber reflection a partial close of the Trade.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<String>,
}

impl From<&MarketOrderTradeClose> for MarketOrderTradeClose {
    fn from(value: &MarketOrderTradeClose) -> Self {
        value.clone()
    }
}

impl MarketOrderTradeClose {
    pub fn builder() -> builder::MarketOrderTradeClose {
        Default::default()
    }
}

///A MarketOrderTransaction represents the creation of a Market Order in
/// the user's account. A Market Order is an Order that is filled
/// immediately at the current market price. Market Orders can be
/// specialized when they are created to accomplish a specific task: to
/// close a Trade, to closeout a Position or to particiate in in a Margin
/// closeout.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A MarketOrderTransaction represents the creation of a
/// Market Order in the user's account. A Market Order is an Order that is
/// filled immediately at the current market price.\nMarket Orders can be
/// specialized when they are created to accomplish a specific task: to
/// close a Trade, to closeout a Position or to particiate in in a Margin
/// closeout.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "delayedTradeClose": {
///      "$ref": "#/components/schemas/MarketOrderDelayedTradeClose"
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "instrument": {
///      "description": "The Market Order's Instrument.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "longPositionCloseout": {
///      "$ref": "#/components/schemas/MarketOrderPositionCloseout"
///    },
///    "marginCloseout": {
///      "$ref": "#/components/schemas/MarketOrderMarginCloseout"
///    },
///    "positionFill": {
///      "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///      "type": "string",
///      "enum": [
///        "OPEN_ONLY",
///        "REDUCE_FIRST",
///        "REDUCE_ONLY",
///        "DEFAULT"
///      ]
///    },
///    "priceBound": {
///      "description": "The worst price that the client is willing to have
/// the Market Order filled at.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "reason": {
///      "description": "The reason that the Market Order was created",
///      "type": "string",
///      "enum": [
///        "CLIENT_ORDER",
///        "TRADE_CLOSE",
///        "POSITION_CLOSEOUT",
///        "MARGIN_CLOSEOUT",
///        "DELAYED_TRADE_CLOSE"
///      ]
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "shortPositionCloseout": {
///      "$ref": "#/components/schemas/MarketOrderPositionCloseout"
///    },
///    "stopLossOnFill": {
///      "$ref": "#/components/schemas/StopLossDetails"
///    },
///    "takeProfitOnFill": {
///      "$ref": "#/components/schemas/TakeProfitDetails"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the Market Order.
/// Restricted to FOK or IOC for a MarketOrder.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeClientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "tradeClose": {
///      "$ref": "#/components/schemas/MarketOrderTradeClose"
///    },
///    "trailingStopLossOnFill": {
///      "$ref": "#/components/schemas/TrailingStopLossDetails"
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"MARKET_ORDER\" in a MarketOrderTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "units": {
///      "description": "The quantity requested to be filled by the Market
/// Order. A posititive number of units results in a long Order, and a
/// negative number of units results in a short Order.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MarketOrderTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    #[serde(
        rename = "delayedTradeClose",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub delayed_trade_close: Option<MarketOrderDelayedTradeClose>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The Market Order's Instrument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    #[serde(
        rename = "longPositionCloseout",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub long_position_closeout: Option<MarketOrderPositionCloseout>,
    #[serde(
        rename = "marginCloseout",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_closeout: Option<MarketOrderMarginCloseout>,
    ///Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(
        rename = "positionFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub position_fill: Option<MarketOrderTransactionPositionFill>,
    ///The worst price that the client is willing to have the Market Order
    /// filled at.
    #[serde(
        rename = "priceBound",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub price_bound: Option<String>,
    ///The reason that the Market Order was created
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<MarketOrderTransactionReason>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    #[serde(
        rename = "shortPositionCloseout",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub short_position_closeout: Option<MarketOrderPositionCloseout>,
    #[serde(
        rename = "stopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stop_loss_on_fill: Option<StopLossDetails>,
    #[serde(
        rename = "takeProfitOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub take_profit_on_fill: Option<TakeProfitDetails>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The time-in-force requested for the Market Order. Restricted to FOK
    /// or IOC for a MarketOrder.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<MarketOrderTransactionTimeInForce>,
    #[serde(
        rename = "tradeClientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,
    #[serde(
        rename = "tradeClose",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_close: Option<MarketOrderTradeClose>,
    #[serde(
        rename = "trailingStopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,
    ///The Type of the Transaction. Always set to "MARKET_ORDER" in a
    /// MarketOrderTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<MarketOrderTransactionType>,
    ///The quantity requested to be filled by the Market Order. A
    /// posititive number of units results in a long Order, and a negative
    /// number of units results in a short Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<String>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&MarketOrderTransaction> for MarketOrderTransaction {
    fn from(value: &MarketOrderTransaction) -> Self {
        value.clone()
    }
}

impl MarketOrderTransaction {
    pub fn builder() -> builder::MarketOrderTransaction {
        Default::default()
    }
}

///Specification of how Positions in the Account are modified when the
/// Order is filled.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///  "type": "string",
///  "enum": [
///    "OPEN_ONLY",
///    "REDUCE_FIRST",
///    "REDUCE_ONLY",
///    "DEFAULT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketOrderTransactionPositionFill {
    #[serde(rename = "OPEN_ONLY")]
    OpenOnly,
    #[serde(rename = "REDUCE_FIRST")]
    ReduceFirst,
    #[serde(rename = "REDUCE_ONLY")]
    ReduceOnly,
    #[serde(rename = "DEFAULT")]
    Default,
}

impl From<&MarketOrderTransactionPositionFill> for MarketOrderTransactionPositionFill {
    fn from(value: &MarketOrderTransactionPositionFill) -> Self {
        value.clone()
    }
}

impl ToString for MarketOrderTransactionPositionFill {
    fn to_string(&self) -> String {
        match *self {
            Self::OpenOnly => "OPEN_ONLY".to_string(),
            Self::ReduceFirst => "REDUCE_FIRST".to_string(),
            Self::ReduceOnly => "REDUCE_ONLY".to_string(),
            Self::Default => "DEFAULT".to_string(),
        }
    }
}

impl std::str::FromStr for MarketOrderTransactionPositionFill {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "OPEN_ONLY" => Ok(Self::OpenOnly),
            "REDUCE_FIRST" => Ok(Self::ReduceFirst),
            "REDUCE_ONLY" => Ok(Self::ReduceOnly),
            "DEFAULT" => Ok(Self::Default),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketOrderTransactionPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketOrderTransactionPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketOrderTransactionPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The reason that the Market Order was created
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Market Order was created",
///  "type": "string",
///  "enum": [
///    "CLIENT_ORDER",
///    "TRADE_CLOSE",
///    "POSITION_CLOSEOUT",
///    "MARGIN_CLOSEOUT",
///    "DELAYED_TRADE_CLOSE"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketOrderTransactionReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "TRADE_CLOSE")]
    TradeClose,
    #[serde(rename = "POSITION_CLOSEOUT")]
    PositionCloseout,
    #[serde(rename = "MARGIN_CLOSEOUT")]
    MarginCloseout,
    #[serde(rename = "DELAYED_TRADE_CLOSE")]
    DelayedTradeClose,
}

impl From<&MarketOrderTransactionReason> for MarketOrderTransactionReason {
    fn from(value: &MarketOrderTransactionReason) -> Self {
        value.clone()
    }
}

impl ToString for MarketOrderTransactionReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ClientOrder => "CLIENT_ORDER".to_string(),
            Self::TradeClose => "TRADE_CLOSE".to_string(),
            Self::PositionCloseout => "POSITION_CLOSEOUT".to_string(),
            Self::MarginCloseout => "MARGIN_CLOSEOUT".to_string(),
            Self::DelayedTradeClose => "DELAYED_TRADE_CLOSE".to_string(),
        }
    }
}

impl std::str::FromStr for MarketOrderTransactionReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CLIENT_ORDER" => Ok(Self::ClientOrder),
            "TRADE_CLOSE" => Ok(Self::TradeClose),
            "POSITION_CLOSEOUT" => Ok(Self::PositionCloseout),
            "MARGIN_CLOSEOUT" => Ok(Self::MarginCloseout),
            "DELAYED_TRADE_CLOSE" => Ok(Self::DelayedTradeClose),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketOrderTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketOrderTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketOrderTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The time-in-force requested for the Market Order. Restricted to FOK or
/// IOC for a MarketOrder.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the Market Order.
/// Restricted to FOK or IOC for a MarketOrder.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketOrderTransactionTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&MarketOrderTransactionTimeInForce> for MarketOrderTransactionTimeInForce {
    fn from(value: &MarketOrderTransactionTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for MarketOrderTransactionTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for MarketOrderTransactionTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketOrderTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketOrderTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketOrderTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Type of the Transaction. Always set to "MARKET_ORDER" in a
/// MarketOrderTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"MARKET_ORDER\" in a MarketOrderTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketOrderTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&MarketOrderTransactionType> for MarketOrderTransactionType {
    fn from(value: &MarketOrderTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for MarketOrderTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for MarketOrderTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketOrderTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketOrderTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketOrderTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The type of the Order. Always set to "MARKET" for Market Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The type of the Order. Always set to \"MARKET\" for
/// Market Orders.",
///  "type": "string",
///  "enum": [
///    "MARKET",
///    "LIMIT",
///    "STOP",
///    "MARKET_IF_TOUCHED",
///    "TAKE_PROFIT",
///    "STOP_LOSS",
///    "TRAILING_STOP_LOSS",
///    "FIXED_PRICE"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarketOrderType {
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "STOP")]
    Stop,
    #[serde(rename = "MARKET_IF_TOUCHED")]
    MarketIfTouched,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "STOP_LOSS")]
    StopLoss,
    #[serde(rename = "TRAILING_STOP_LOSS")]
    TrailingStopLoss,
    #[serde(rename = "FIXED_PRICE")]
    FixedPrice,
}

impl From<&MarketOrderType> for MarketOrderType {
    fn from(value: &MarketOrderType) -> Self {
        value.clone()
    }
}

impl ToString for MarketOrderType {
    fn to_string(&self) -> String {
        match *self {
            Self::Market => "MARKET".to_string(),
            Self::Limit => "LIMIT".to_string(),
            Self::Stop => "STOP".to_string(),
            Self::MarketIfTouched => "MARKET_IF_TOUCHED".to_string(),
            Self::TakeProfit => "TAKE_PROFIT".to_string(),
            Self::StopLoss => "STOP_LOSS".to_string(),
            Self::TrailingStopLoss => "TRAILING_STOP_LOSS".to_string(),
            Self::FixedPrice => "FIXED_PRICE".to_string(),
        }
    }
}

impl std::str::FromStr for MarketOrderType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "MARKET" => Ok(Self::Market),
            "LIMIT" => Ok(Self::Limit),
            "STOP" => Ok(Self::Stop),
            "MARKET_IF_TOUCHED" => Ok(Self::MarketIfTouched),
            "TAKE_PROFIT" => Ok(Self::TakeProfit),
            "STOP_LOSS" => Ok(Self::StopLoss),
            "TRAILING_STOP_LOSS" => Ok(Self::TrailingStopLoss),
            "FIXED_PRICE" => Ok(Self::FixedPrice),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for MarketOrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for MarketOrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for MarketOrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A TransactionHeartbeat object is injected into the Transaction stream to
/// ensure that the HTTP connection remains active.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A TransactionHeartbeat object is injected into the Transaction stream to ensure that the HTTP connection remains active.",
///  "type": "object",
///  "properties": {
///    "time": {
///      "description": "The date/time when the TransactionHeartbeat was
/// created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "type": {
///      "description": "The string \"HEARTBEAT\"",
///      "type": "string"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Mt4TransactionHeartbeat {
    ///The date/time when the TransactionHeartbeat was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The string "HEARTBEAT"
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
}

impl From<&Mt4TransactionHeartbeat> for Mt4TransactionHeartbeat {
    fn from(value: &Mt4TransactionHeartbeat) -> Self {
        value.clone()
    }
}

impl Mt4TransactionHeartbeat {
    pub fn builder() -> builder::Mt4TransactionHeartbeat {
        Default::default()
    }
}

///OpenTradeFinancing is used to pay/collect daily financing charge for an
/// open Trade within an Account
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "OpenTradeFinancing is used to pay/collect daily
/// financing charge for an open Trade within an Account",
///  "type": "object",
///  "properties": {
///    "financing": {
///      "description": "The amount of financing paid/collected for the
/// Trade.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "tradeID": {
///      "description": "The ID of the Trade that financing is being
/// paid/collected for.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OpenTradeFinancing {
    ///The amount of financing paid/collected for the Trade.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub financing: Option<String>,
    ///The ID of the Trade that financing is being paid/collected for.
    #[serde(rename = "tradeID", default, skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,
}

impl From<&OpenTradeFinancing> for OpenTradeFinancing {
    fn from(value: &OpenTradeFinancing) -> Self {
        value.clone()
    }
}

impl OpenTradeFinancing {
    pub fn builder() -> builder::OpenTradeFinancing {
        Default::default()
    }
}

///The base Order definition specifies the properties that are common to
/// all Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The base Order definition specifies the properties that
/// are common to all Orders.",
///  "type": "object",
///  "properties": {
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "createTime": {
///      "description": "The time when the Order was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "id": {
///      "description": "The Order's identifier, unique within the Order's
/// Account.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "state": {
///      "description": "The current state of the Order.",
///      "type": "string",
///      "enum": [
///        "PENDING",
///        "FILLED",
///        "TRIGGERED",
///        "CANCELLED"
///      ]
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Order {
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The time when the Order was created.
    #[serde(
        rename = "createTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub create_time: Option<String>,
    ///The Order's identifier, unique within the Order's Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The current state of the Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<OrderState>,
}

impl From<&Order> for Order {
    fn from(value: &Order) -> Self {
        value.clone()
    }
}

impl Order {
    pub fn builder() -> builder::Order {
        Default::default()
    }
}

///The representation of an instrument's order book at a point in time
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The representation of an instrument's order book at a
/// point in time",
///  "type": "object",
///  "properties": {
///    "bucketWidth": {
///      "description": "The price width for each bucket. Each bucket covers
/// the price range from the bucket's price to the bucket's price +
/// bucketWidth.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "buckets": {
///      "description": "The partitioned order book, divided into buckets
/// using a default bucket width. These buckets are only provided for price
/// ranges which actually contain order or position data.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/OrderBookBucket"
///      }
///    },
///    "instrument": {
///      "description": "The order book's instrument",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "price": {
///      "description": "The price (midpoint) for the order book's
/// instrument at the time of the order book snapshot",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "time": {
///      "description": "The time when the order book snapshot was
/// created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OrderBook {
    ///The price width for each bucket. Each bucket covers the price range
    /// from the bucket's price to the bucket's price + bucketWidth.
    #[serde(
        rename = "bucketWidth",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub bucket_width: Option<String>,
    ///The partitioned order book, divided into buckets using a default
    /// bucket width. These buckets are only provided for price ranges which
    /// actually contain order or position data.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub buckets: Vec<OrderBookBucket>,
    ///The order book's instrument
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    ///The price (midpoint) for the order book's instrument at the time of
    /// the order book snapshot
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The time when the order book snapshot was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
}

impl From<&OrderBook> for OrderBook {
    fn from(value: &OrderBook) -> Self {
        value.clone()
    }
}

impl OrderBook {
    pub fn builder() -> builder::OrderBook {
        Default::default()
    }
}

///The order book data for a partition of the instrument's prices.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The order book data for a partition of the instrument's
/// prices.",
///  "type": "object",
///  "properties": {
///    "longCountPercent": {
///      "description": "The percentage of the total number of orders
/// represented by the long orders found in this bucket.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "price": {
///      "description": "The lowest price (inclusive) covered by the bucket.
/// The bucket covers the price range from the price to price + the order
/// book's bucketWidth.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "shortCountPercent": {
///      "description": "The percentage of the total number of orders
/// represented by the short orders found in this bucket.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OrderBookBucket {
    ///The percentage of the total number of orders represented by the long
    /// orders found in this bucket.
    #[serde(
        rename = "longCountPercent",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub long_count_percent: Option<String>,
    ///The lowest price (inclusive) covered by the bucket. The bucket
    /// covers the price range from the price to price + the order book's
    /// bucketWidth.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The percentage of the total number of orders represented by the
    /// short orders found in this bucket.
    #[serde(
        rename = "shortCountPercent",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub short_count_percent: Option<String>,
}

impl From<&OrderBookBucket> for OrderBookBucket {
    fn from(value: &OrderBookBucket) -> Self {
        value.clone()
    }
}

impl OrderBookBucket {
    pub fn builder() -> builder::OrderBookBucket {
        Default::default()
    }
}

///The reason that an Order was cancelled.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that an Order was cancelled.",
///  "type": "string",
///  "enum": [
///    "INTERNAL_SERVER_ERROR",
///    "ACCOUNT_LOCKED",
///    "ACCOUNT_NEW_POSITIONS_LOCKED",
///    "ACCOUNT_ORDER_CREATION_LOCKED",
///    "ACCOUNT_ORDER_FILL_LOCKED",
///    "CLIENT_REQUEST",
///    "MIGRATION",
///    "MARKET_HALTED",
///    "LINKED_TRADE_CLOSED",
///    "TIME_IN_FORCE_EXPIRED",
///    "INSUFFICIENT_MARGIN",
///    "FIFO_VIOLATION",
///    "BOUNDS_VIOLATION",
///    "CLIENT_REQUEST_REPLACED",
///    "INSUFFICIENT_LIQUIDITY",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TAKE_PROFIT_ON_FILL_LOSS",
///    "LOSING_TAKE_PROFIT",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "STOP_LOSS_ON_FILL_LOSS",
///    "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "STOP_LOSS_ON_FILL_REQUIRED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_HEDGING_NOT_ALLOWED",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "TAKE_PROFIT_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "CLIENT_TRADE_ID_ALREADY_EXISTS",
///    "POSITION_CLOSEOUT_FAILED",
///    "OPEN_TRADES_ALLOWED_EXCEEDED",
///    "PENDING_ORDERS_ALLOWED_EXCEEDED",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS",
///    "POSITION_SIZE_EXCEEDED",
///    "HEDGING_GSLO_VIOLATION",
///    "ACCOUNT_POSITION_VALUE_LIMIT_EXCEEDED",
///    "INSTRUMENT_BID_REDUCE_ONLY",
///    "INSTRUMENT_ASK_REDUCE_ONLY",
///    "INSTRUMENT_BID_HALTED",
///    "INSTRUMENT_ASK_HALTED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_BID_HALTED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_ASK_HALTED"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrderCancelReason {
    #[serde(rename = "INTERNAL_SERVER_ERROR")]
    InternalServerError,
    #[serde(rename = "ACCOUNT_LOCKED")]
    AccountLocked,
    #[serde(rename = "ACCOUNT_NEW_POSITIONS_LOCKED")]
    AccountNewPositionsLocked,
    #[serde(rename = "ACCOUNT_ORDER_CREATION_LOCKED")]
    AccountOrderCreationLocked,
    #[serde(rename = "ACCOUNT_ORDER_FILL_LOCKED")]
    AccountOrderFillLocked,
    #[serde(rename = "CLIENT_REQUEST")]
    ClientRequest,
    #[serde(rename = "MIGRATION")]
    Migration,
    #[serde(rename = "MARKET_HALTED")]
    MarketHalted,
    #[serde(rename = "LINKED_TRADE_CLOSED")]
    LinkedTradeClosed,
    #[serde(rename = "TIME_IN_FORCE_EXPIRED")]
    TimeInForceExpired,
    #[serde(rename = "INSUFFICIENT_MARGIN")]
    InsufficientMargin,
    #[serde(rename = "FIFO_VIOLATION")]
    FifoViolation,
    #[serde(rename = "BOUNDS_VIOLATION")]
    BoundsViolation,
    #[serde(rename = "CLIENT_REQUEST_REPLACED")]
    ClientRequestReplaced,
    #[serde(rename = "INSUFFICIENT_LIQUIDITY")]
    InsufficientLiquidity,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TakeProfitOnFillGtdTimestampInPast,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_LOSS")]
    TakeProfitOnFillLoss,
    #[serde(rename = "LOSING_TAKE_PROFIT")]
    LosingTakeProfit,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    StopLossOnFillGtdTimestampInPast,
    #[serde(rename = "STOP_LOSS_ON_FILL_LOSS")]
    StopLossOnFillLoss,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    StopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_REQUIRED")]
    StopLossOnFillRequired,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED")]
    StopLossOnFillGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED")]
    StopLossOnFillGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOnFillGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOnFillGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_HEDGING_NOT_ALLOWED")]
    StopLossOnFillGuaranteedHedgingNotAllowed,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    StopLossOnFillTimeInForceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    StopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    TakeProfitOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TrailingStopLossOnFillGtdTimestampInPast,
    #[serde(rename = "CLIENT_TRADE_ID_ALREADY_EXISTS")]
    ClientTradeIdAlreadyExists,
    #[serde(rename = "POSITION_CLOSEOUT_FAILED")]
    PositionCloseoutFailed,
    #[serde(rename = "OPEN_TRADES_ALLOWED_EXCEEDED")]
    OpenTradesAllowedExceeded,
    #[serde(rename = "PENDING_ORDERS_ALLOWED_EXCEEDED")]
    PendingOrdersAllowedExceeded,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS")]
    TakeProfitOnFillClientOrderIdAlreadyExists,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS")]
    StopLossOnFillClientOrderIdAlreadyExists,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS")]
    TrailingStopLossOnFillClientOrderIdAlreadyExists,
    #[serde(rename = "POSITION_SIZE_EXCEEDED")]
    PositionSizeExceeded,
    #[serde(rename = "HEDGING_GSLO_VIOLATION")]
    HedgingGsloViolation,
    #[serde(rename = "ACCOUNT_POSITION_VALUE_LIMIT_EXCEEDED")]
    AccountPositionValueLimitExceeded,
    #[serde(rename = "INSTRUMENT_BID_REDUCE_ONLY")]
    InstrumentBidReduceOnly,
    #[serde(rename = "INSTRUMENT_ASK_REDUCE_ONLY")]
    InstrumentAskReduceOnly,
    #[serde(rename = "INSTRUMENT_BID_HALTED")]
    InstrumentBidHalted,
    #[serde(rename = "INSTRUMENT_ASK_HALTED")]
    InstrumentAskHalted,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_BID_HALTED")]
    StopLossOnFillGuaranteedBidHalted,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_ASK_HALTED")]
    StopLossOnFillGuaranteedAskHalted,
}

impl From<&OrderCancelReason> for OrderCancelReason {
    fn from(value: &OrderCancelReason) -> Self {
        value.clone()
    }
}

impl ToString for OrderCancelReason {
    fn to_string(&self) -> String {
        match *self {
            Self::InternalServerError => "INTERNAL_SERVER_ERROR".to_string(),
            Self::AccountLocked => "ACCOUNT_LOCKED".to_string(),
            Self::AccountNewPositionsLocked => "ACCOUNT_NEW_POSITIONS_LOCKED".to_string(),
            Self::AccountOrderCreationLocked => "ACCOUNT_ORDER_CREATION_LOCKED".to_string(),
            Self::AccountOrderFillLocked => "ACCOUNT_ORDER_FILL_LOCKED".to_string(),
            Self::ClientRequest => "CLIENT_REQUEST".to_string(),
            Self::Migration => "MIGRATION".to_string(),
            Self::MarketHalted => "MARKET_HALTED".to_string(),
            Self::LinkedTradeClosed => "LINKED_TRADE_CLOSED".to_string(),
            Self::TimeInForceExpired => "TIME_IN_FORCE_EXPIRED".to_string(),
            Self::InsufficientMargin => "INSUFFICIENT_MARGIN".to_string(),
            Self::FifoViolation => "FIFO_VIOLATION".to_string(),
            Self::BoundsViolation => "BOUNDS_VIOLATION".to_string(),
            Self::ClientRequestReplaced => "CLIENT_REQUEST_REPLACED".to_string(),
            Self::InsufficientLiquidity => "INSUFFICIENT_LIQUIDITY".to_string(),
            Self::TakeProfitOnFillGtdTimestampInPast => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TakeProfitOnFillLoss => "TAKE_PROFIT_ON_FILL_LOSS".to_string(),
            Self::LosingTakeProfit => "LOSING_TAKE_PROFIT".to_string(),
            Self::StopLossOnFillGtdTimestampInPast => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::StopLossOnFillLoss => "STOP_LOSS_ON_FILL_LOSS".to_string(),
            Self::StopLossOnFillPriceDistanceMaximumExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::StopLossOnFillRequired => "STOP_LOSS_ON_FILL_REQUIRED".to_string(),
            Self::StopLossOnFillGuaranteedRequired => {
                "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOnFillGuaranteedNotAllowed => {
                "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOnFillGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOnFillGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillGuaranteedHedgingNotAllowed => {
                "STOP_LOSS_ON_FILL_GUARANTEED_HEDGING_NOT_ALLOWED".to_string()
            }
            Self::StopLossOnFillTimeInForceInvalid => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::StopLossOnFillTriggerConditionInvalid => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::TakeProfitOnFillPriceDistanceMaximumExceeded => {
                "TAKE_PROFIT_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampInPast => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::ClientTradeIdAlreadyExists => "CLIENT_TRADE_ID_ALREADY_EXISTS".to_string(),
            Self::PositionCloseoutFailed => "POSITION_CLOSEOUT_FAILED".to_string(),
            Self::OpenTradesAllowedExceeded => "OPEN_TRADES_ALLOWED_EXCEEDED".to_string(),
            Self::PendingOrdersAllowedExceeded => "PENDING_ORDERS_ALLOWED_EXCEEDED".to_string(),
            Self::TakeProfitOnFillClientOrderIdAlreadyExists => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS".to_string()
            }
            Self::StopLossOnFillClientOrderIdAlreadyExists => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderIdAlreadyExists => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS".to_string()
            }
            Self::PositionSizeExceeded => "POSITION_SIZE_EXCEEDED".to_string(),
            Self::HedgingGsloViolation => "HEDGING_GSLO_VIOLATION".to_string(),
            Self::AccountPositionValueLimitExceeded => {
                "ACCOUNT_POSITION_VALUE_LIMIT_EXCEEDED".to_string()
            }
            Self::InstrumentBidReduceOnly => "INSTRUMENT_BID_REDUCE_ONLY".to_string(),
            Self::InstrumentAskReduceOnly => "INSTRUMENT_ASK_REDUCE_ONLY".to_string(),
            Self::InstrumentBidHalted => "INSTRUMENT_BID_HALTED".to_string(),
            Self::InstrumentAskHalted => "INSTRUMENT_ASK_HALTED".to_string(),
            Self::StopLossOnFillGuaranteedBidHalted => {
                "STOP_LOSS_ON_FILL_GUARANTEED_BID_HALTED".to_string()
            }
            Self::StopLossOnFillGuaranteedAskHalted => {
                "STOP_LOSS_ON_FILL_GUARANTEED_ASK_HALTED".to_string()
            }
        }
    }
}

impl std::str::FromStr for OrderCancelReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "INTERNAL_SERVER_ERROR" => Ok(Self::InternalServerError),
            "ACCOUNT_LOCKED" => Ok(Self::AccountLocked),
            "ACCOUNT_NEW_POSITIONS_LOCKED" => Ok(Self::AccountNewPositionsLocked),
            "ACCOUNT_ORDER_CREATION_LOCKED" => Ok(Self::AccountOrderCreationLocked),
            "ACCOUNT_ORDER_FILL_LOCKED" => Ok(Self::AccountOrderFillLocked),
            "CLIENT_REQUEST" => Ok(Self::ClientRequest),
            "MIGRATION" => Ok(Self::Migration),
            "MARKET_HALTED" => Ok(Self::MarketHalted),
            "LINKED_TRADE_CLOSED" => Ok(Self::LinkedTradeClosed),
            "TIME_IN_FORCE_EXPIRED" => Ok(Self::TimeInForceExpired),
            "INSUFFICIENT_MARGIN" => Ok(Self::InsufficientMargin),
            "FIFO_VIOLATION" => Ok(Self::FifoViolation),
            "BOUNDS_VIOLATION" => Ok(Self::BoundsViolation),
            "CLIENT_REQUEST_REPLACED" => Ok(Self::ClientRequestReplaced),
            "INSUFFICIENT_LIQUIDITY" => Ok(Self::InsufficientLiquidity),
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TakeProfitOnFillGtdTimestampInPast)
            }
            "TAKE_PROFIT_ON_FILL_LOSS" => Ok(Self::TakeProfitOnFillLoss),
            "LOSING_TAKE_PROFIT" => Ok(Self::LosingTakeProfit),
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => Ok(Self::StopLossOnFillGtdTimestampInPast),
            "STOP_LOSS_ON_FILL_LOSS" => Ok(Self::StopLossOnFillLoss),
            "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::StopLossOnFillPriceDistanceMaximumExceeded)
            }
            "STOP_LOSS_ON_FILL_REQUIRED" => Ok(Self::StopLossOnFillRequired),
            "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED" => Ok(Self::StopLossOnFillGuaranteedRequired),
            "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED" => {
                Ok(Self::StopLossOnFillGuaranteedNotAllowed)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOnFillGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOnFillGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_HEDGING_NOT_ALLOWED" => {
                Ok(Self::StopLossOnFillGuaranteedHedgingNotAllowed)
            }
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => Ok(Self::StopLossOnFillTimeInForceInvalid),
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::StopLossOnFillTriggerConditionInvalid)
            }
            "TAKE_PROFIT_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::TakeProfitOnFillPriceDistanceMaximumExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampInPast)
            }
            "CLIENT_TRADE_ID_ALREADY_EXISTS" => Ok(Self::ClientTradeIdAlreadyExists),
            "POSITION_CLOSEOUT_FAILED" => Ok(Self::PositionCloseoutFailed),
            "OPEN_TRADES_ALLOWED_EXCEEDED" => Ok(Self::OpenTradesAllowedExceeded),
            "PENDING_ORDERS_ALLOWED_EXCEEDED" => Ok(Self::PendingOrdersAllowedExceeded),
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS" => {
                Ok(Self::TakeProfitOnFillClientOrderIdAlreadyExists)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS" => {
                Ok(Self::StopLossOnFillClientOrderIdAlreadyExists)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS" => {
                Ok(Self::TrailingStopLossOnFillClientOrderIdAlreadyExists)
            }
            "POSITION_SIZE_EXCEEDED" => Ok(Self::PositionSizeExceeded),
            "HEDGING_GSLO_VIOLATION" => Ok(Self::HedgingGsloViolation),
            "ACCOUNT_POSITION_VALUE_LIMIT_EXCEEDED" => Ok(Self::AccountPositionValueLimitExceeded),
            "INSTRUMENT_BID_REDUCE_ONLY" => Ok(Self::InstrumentBidReduceOnly),
            "INSTRUMENT_ASK_REDUCE_ONLY" => Ok(Self::InstrumentAskReduceOnly),
            "INSTRUMENT_BID_HALTED" => Ok(Self::InstrumentBidHalted),
            "INSTRUMENT_ASK_HALTED" => Ok(Self::InstrumentAskHalted),
            "STOP_LOSS_ON_FILL_GUARANTEED_BID_HALTED" => {
                Ok(Self::StopLossOnFillGuaranteedBidHalted)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_ASK_HALTED" => {
                Ok(Self::StopLossOnFillGuaranteedAskHalted)
            }
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for OrderCancelReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for OrderCancelReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for OrderCancelReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///An OrderCancelRejectTransaction represents the rejection of the
/// cancellation of an Order in the client's Account.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "An OrderCancelRejectTransaction represents the
/// rejection of the cancellation of an Order in the client's Account.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientOrderID": {
///      "description": "The client ID of the Order intended to be cancelled
/// (only provided if the Order has a client Order ID).",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "orderID": {
///      "description": "The ID of the Order intended to be cancelled",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "rejectReason": {
///      "description": "The reason that the Reject Transaction was
/// created",
///      "type": "string",
///      "enum": [
///        "INTERNAL_SERVER_ERROR",
///        "INSTRUMENT_PRICE_UNKNOWN",
///        "ACCOUNT_NOT_ACTIVE",
///        "ACCOUNT_LOCKED",
///        "ACCOUNT_ORDER_CREATION_LOCKED",
///        "ACCOUNT_CONFIGURATION_LOCKED",
///        "ACCOUNT_DEPOSIT_LOCKED",
///        "ACCOUNT_WITHDRAWAL_LOCKED",
///        "ACCOUNT_ORDER_CANCEL_LOCKED",
///        "INSTRUMENT_NOT_TRADEABLE",
///        "PENDING_ORDERS_ALLOWED_EXCEEDED",
///        "ORDER_ID_UNSPECIFIED",
///        "ORDER_DOESNT_EXIST",
///        "ORDER_IDENTIFIER_INCONSISTENCY",
///        "TRADE_ID_UNSPECIFIED",
///        "TRADE_DOESNT_EXIST",
///        "TRADE_IDENTIFIER_INCONSISTENCY",
///        "INSUFFICIENT_MARGIN",
///        "INSTRUMENT_MISSING",
///        "INSTRUMENT_UNKNOWN",
///        "UNITS_MISSING",
///        "UNITS_INVALID",
///        "UNITS_PRECISION_EXCEEDED",
///        "UNITS_LIMIT_EXCEEDED",
///        "UNITS_MIMIMUM_NOT_MET",
///        "PRICE_MISSING",
///        "PRICE_INVALID",
///        "PRICE_PRECISION_EXCEEDED",
///        "PRICE_DISTANCE_MISSING",
///        "PRICE_DISTANCE_INVALID",
///        "PRICE_DISTANCE_PRECISION_EXCEEDED",
///        "PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "PRICE_DISTANCE_MINIMUM_NOT_MET",
///        "TIME_IN_FORCE_MISSING",
///        "TIME_IN_FORCE_INVALID",
///        "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING",
///        "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST",
///        "PRICE_BOUND_INVALID",
///        "PRICE_BOUND_PRECISION_EXCEEDED",
///        "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS",
///        "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED",
///        "CLIENT_ORDER_ID_INVALID",
///        "CLIENT_ORDER_ID_ALREADY_EXISTS",
///        "CLIENT_ORDER_TAG_INVALID",
///        "CLIENT_ORDER_COMMENT_INVALID",
///        "CLIENT_TRADE_ID_INVALID",
///        "CLIENT_TRADE_ID_ALREADY_EXISTS",
///        "CLIENT_TRADE_TAG_INVALID",
///        "CLIENT_TRADE_COMMENT_INVALID",
///        "ORDER_FILL_POSITION_ACTION_MISSING",
///        "ORDER_FILL_POSITION_ACTION_INVALID",
///        "TRIGGER_CONDITION_MISSING",
///        "TRIGGER_CONDITION_INVALID",
///        "ORDER_PARTIAL_FILL_OPTION_MISSING",
///        "ORDER_PARTIAL_FILL_OPTION_INVALID",
///        "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL",
///        "TAKE_PROFIT_ORDER_ALREADY_EXISTS",
///        "TAKE_PROFIT_ON_FILL_PRICE_MISSING",
///        "TAKE_PROFIT_ON_FILL_PRICE_INVALID",
///        "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED",
///        "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING",
///        "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID",
///        "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "STOP_LOSS_ORDER_ALREADY_EXISTS",
///        "STOP_LOSS_ORDER_GUARANTEED_REQUIRED",
///        "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD",
///        "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED",
///        "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION",
///        "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION",
///        "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED",
///        "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///        "STOP_LOSS_ORDER_NOT_CANCELABLE",
///        "STOP_LOSS_ORDER_NOT_REPLACEABLE",
///        "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///        "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///        "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING",
///        "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER",
///        "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///        "STOP_LOSS_ON_FILL_PRICE_MISSING",
///        "STOP_LOSS_ON_FILL_PRICE_INVALID",
///        "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///        "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_DISTANCE_INVALID",
///        "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///        "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING",
///        "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///        "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///        "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET",
///        "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED",
///        "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "CLOSE_TRADE_TYPE_MISSING",
///        "CLOSE_TRADE_PARTIAL_UNITS_MISSING",
///        "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE",
///        "CLOSEOUT_POSITION_DOESNT_EXIST",
///        "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION",
///        "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE",
///        "CLOSEOUT_POSITION_REJECT",
///        "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING",
///        "MARKUP_GROUP_ID_INVALID",
///        "POSITION_AGGREGATION_MODE_INVALID",
///        "ADMIN_CONFIGURE_DATA_MISSING",
///        "MARGIN_RATE_INVALID",
///        "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT",
///        "ALIAS_INVALID",
///        "CLIENT_CONFIGURE_DATA_MISSING",
///        "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL",
///        "AMOUNT_INVALID",
///        "INSUFFICIENT_FUNDS",
///        "AMOUNT_MISSING",
///        "FUNDING_REASON_MISSING",
///        "CLIENT_EXTENSIONS_DATA_MISSING",
///        "REPLACING_ORDER_INVALID",
///        "REPLACING_TRADE_ID_INVALID"
///      ]
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"ORDER_CANCEL_REJECT\" for an OrderCancelRejectTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OrderCancelRejectTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    ///The client ID of the Order intended to be cancelled (only provided
    /// if the Order has a client Order ID).
    #[serde(
        rename = "clientOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_order_id: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The ID of the Order intended to be cancelled
    #[serde(rename = "orderID", default, skip_serializing_if = "Option::is_none")]
    pub order_id: Option<String>,
    ///The reason that the Reject Transaction was created
    #[serde(
        rename = "rejectReason",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub reject_reason: Option<OrderCancelRejectTransactionRejectReason>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The Type of the Transaction. Always set to "ORDER_CANCEL_REJECT" for
    /// an OrderCancelRejectTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<OrderCancelRejectTransactionType>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&OrderCancelRejectTransaction> for OrderCancelRejectTransaction {
    fn from(value: &OrderCancelRejectTransaction) -> Self {
        value.clone()
    }
}

impl OrderCancelRejectTransaction {
    pub fn builder() -> builder::OrderCancelRejectTransaction {
        Default::default()
    }
}

///The reason that the Reject Transaction was created
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Reject Transaction was created",
///  "type": "string",
///  "enum": [
///    "INTERNAL_SERVER_ERROR",
///    "INSTRUMENT_PRICE_UNKNOWN",
///    "ACCOUNT_NOT_ACTIVE",
///    "ACCOUNT_LOCKED",
///    "ACCOUNT_ORDER_CREATION_LOCKED",
///    "ACCOUNT_CONFIGURATION_LOCKED",
///    "ACCOUNT_DEPOSIT_LOCKED",
///    "ACCOUNT_WITHDRAWAL_LOCKED",
///    "ACCOUNT_ORDER_CANCEL_LOCKED",
///    "INSTRUMENT_NOT_TRADEABLE",
///    "PENDING_ORDERS_ALLOWED_EXCEEDED",
///    "ORDER_ID_UNSPECIFIED",
///    "ORDER_DOESNT_EXIST",
///    "ORDER_IDENTIFIER_INCONSISTENCY",
///    "TRADE_ID_UNSPECIFIED",
///    "TRADE_DOESNT_EXIST",
///    "TRADE_IDENTIFIER_INCONSISTENCY",
///    "INSUFFICIENT_MARGIN",
///    "INSTRUMENT_MISSING",
///    "INSTRUMENT_UNKNOWN",
///    "UNITS_MISSING",
///    "UNITS_INVALID",
///    "UNITS_PRECISION_EXCEEDED",
///    "UNITS_LIMIT_EXCEEDED",
///    "UNITS_MIMIMUM_NOT_MET",
///    "PRICE_MISSING",
///    "PRICE_INVALID",
///    "PRICE_PRECISION_EXCEEDED",
///    "PRICE_DISTANCE_MISSING",
///    "PRICE_DISTANCE_INVALID",
///    "PRICE_DISTANCE_PRECISION_EXCEEDED",
///    "PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "PRICE_DISTANCE_MINIMUM_NOT_MET",
///    "TIME_IN_FORCE_MISSING",
///    "TIME_IN_FORCE_INVALID",
///    "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING",
///    "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST",
///    "PRICE_BOUND_INVALID",
///    "PRICE_BOUND_PRECISION_EXCEEDED",
///    "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS",
///    "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED",
///    "CLIENT_ORDER_ID_INVALID",
///    "CLIENT_ORDER_ID_ALREADY_EXISTS",
///    "CLIENT_ORDER_TAG_INVALID",
///    "CLIENT_ORDER_COMMENT_INVALID",
///    "CLIENT_TRADE_ID_INVALID",
///    "CLIENT_TRADE_ID_ALREADY_EXISTS",
///    "CLIENT_TRADE_TAG_INVALID",
///    "CLIENT_TRADE_COMMENT_INVALID",
///    "ORDER_FILL_POSITION_ACTION_MISSING",
///    "ORDER_FILL_POSITION_ACTION_INVALID",
///    "TRIGGER_CONDITION_MISSING",
///    "TRIGGER_CONDITION_INVALID",
///    "ORDER_PARTIAL_FILL_OPTION_MISSING",
///    "ORDER_PARTIAL_FILL_OPTION_INVALID",
///    "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL",
///    "TAKE_PROFIT_ORDER_ALREADY_EXISTS",
///    "TAKE_PROFIT_ON_FILL_PRICE_MISSING",
///    "TAKE_PROFIT_ON_FILL_PRICE_INVALID",
///    "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED",
///    "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING",
///    "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "STOP_LOSS_ORDER_ALREADY_EXISTS",
///    "STOP_LOSS_ORDER_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD",
///    "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION",
///    "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION",
///    "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED",
///    "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ORDER_NOT_CANCELABLE",
///    "STOP_LOSS_ORDER_NOT_REPLACEABLE",
///    "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///    "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING",
///    "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER",
///    "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ON_FILL_PRICE_MISSING",
///    "STOP_LOSS_ON_FILL_PRICE_INVALID",
///    "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_DISTANCE_INVALID",
///    "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///    "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET",
///    "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED",
///    "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "CLOSE_TRADE_TYPE_MISSING",
///    "CLOSE_TRADE_PARTIAL_UNITS_MISSING",
///    "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE",
///    "CLOSEOUT_POSITION_DOESNT_EXIST",
///    "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION",
///    "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE",
///    "CLOSEOUT_POSITION_REJECT",
///    "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING",
///    "MARKUP_GROUP_ID_INVALID",
///    "POSITION_AGGREGATION_MODE_INVALID",
///    "ADMIN_CONFIGURE_DATA_MISSING",
///    "MARGIN_RATE_INVALID",
///    "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT",
///    "ALIAS_INVALID",
///    "CLIENT_CONFIGURE_DATA_MISSING",
///    "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL",
///    "AMOUNT_INVALID",
///    "INSUFFICIENT_FUNDS",
///    "AMOUNT_MISSING",
///    "FUNDING_REASON_MISSING",
///    "CLIENT_EXTENSIONS_DATA_MISSING",
///    "REPLACING_ORDER_INVALID",
///    "REPLACING_TRADE_ID_INVALID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrderCancelRejectTransactionRejectReason {
    #[serde(rename = "INTERNAL_SERVER_ERROR")]
    InternalServerError,
    #[serde(rename = "INSTRUMENT_PRICE_UNKNOWN")]
    InstrumentPriceUnknown,
    #[serde(rename = "ACCOUNT_NOT_ACTIVE")]
    AccountNotActive,
    #[serde(rename = "ACCOUNT_LOCKED")]
    AccountLocked,
    #[serde(rename = "ACCOUNT_ORDER_CREATION_LOCKED")]
    AccountOrderCreationLocked,
    #[serde(rename = "ACCOUNT_CONFIGURATION_LOCKED")]
    AccountConfigurationLocked,
    #[serde(rename = "ACCOUNT_DEPOSIT_LOCKED")]
    AccountDepositLocked,
    #[serde(rename = "ACCOUNT_WITHDRAWAL_LOCKED")]
    AccountWithdrawalLocked,
    #[serde(rename = "ACCOUNT_ORDER_CANCEL_LOCKED")]
    AccountOrderCancelLocked,
    #[serde(rename = "INSTRUMENT_NOT_TRADEABLE")]
    InstrumentNotTradeable,
    #[serde(rename = "PENDING_ORDERS_ALLOWED_EXCEEDED")]
    PendingOrdersAllowedExceeded,
    #[serde(rename = "ORDER_ID_UNSPECIFIED")]
    OrderIdUnspecified,
    #[serde(rename = "ORDER_DOESNT_EXIST")]
    OrderDoesntExist,
    #[serde(rename = "ORDER_IDENTIFIER_INCONSISTENCY")]
    OrderIdentifierInconsistency,
    #[serde(rename = "TRADE_ID_UNSPECIFIED")]
    TradeIdUnspecified,
    #[serde(rename = "TRADE_DOESNT_EXIST")]
    TradeDoesntExist,
    #[serde(rename = "TRADE_IDENTIFIER_INCONSISTENCY")]
    TradeIdentifierInconsistency,
    #[serde(rename = "INSUFFICIENT_MARGIN")]
    InsufficientMargin,
    #[serde(rename = "INSTRUMENT_MISSING")]
    InstrumentMissing,
    #[serde(rename = "INSTRUMENT_UNKNOWN")]
    InstrumentUnknown,
    #[serde(rename = "UNITS_MISSING")]
    UnitsMissing,
    #[serde(rename = "UNITS_INVALID")]
    UnitsInvalid,
    #[serde(rename = "UNITS_PRECISION_EXCEEDED")]
    UnitsPrecisionExceeded,
    #[serde(rename = "UNITS_LIMIT_EXCEEDED")]
    UnitsLimitExceeded,
    #[serde(rename = "UNITS_MIMIMUM_NOT_MET")]
    UnitsMimimumNotMet,
    #[serde(rename = "PRICE_MISSING")]
    PriceMissing,
    #[serde(rename = "PRICE_INVALID")]
    PriceInvalid,
    #[serde(rename = "PRICE_PRECISION_EXCEEDED")]
    PricePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MISSING")]
    PriceDistanceMissing,
    #[serde(rename = "PRICE_DISTANCE_INVALID")]
    PriceDistanceInvalid,
    #[serde(rename = "PRICE_DISTANCE_PRECISION_EXCEEDED")]
    PriceDistancePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    PriceDistanceMaximumExceeded,
    #[serde(rename = "PRICE_DISTANCE_MINIMUM_NOT_MET")]
    PriceDistanceMinimumNotMet,
    #[serde(rename = "TIME_IN_FORCE_MISSING")]
    TimeInForceMissing,
    #[serde(rename = "TIME_IN_FORCE_INVALID")]
    TimeInForceInvalid,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING")]
    TimeInForceGtdTimestampMissing,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST")]
    TimeInForceGtdTimestampInPast,
    #[serde(rename = "PRICE_BOUND_INVALID")]
    PriceBoundInvalid,
    #[serde(rename = "PRICE_BOUND_PRECISION_EXCEEDED")]
    PriceBoundPrecisionExceeded,
    #[serde(rename = "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS")]
    OrdersOnFillDuplicateClientOrderIds,
    #[serde(rename = "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED")]
    TradeOnFillClientExtensionsNotSupported,
    #[serde(rename = "CLIENT_ORDER_ID_INVALID")]
    ClientOrderIdInvalid,
    #[serde(rename = "CLIENT_ORDER_ID_ALREADY_EXISTS")]
    ClientOrderIdAlreadyExists,
    #[serde(rename = "CLIENT_ORDER_TAG_INVALID")]
    ClientOrderTagInvalid,
    #[serde(rename = "CLIENT_ORDER_COMMENT_INVALID")]
    ClientOrderCommentInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_INVALID")]
    ClientTradeIdInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_ALREADY_EXISTS")]
    ClientTradeIdAlreadyExists,
    #[serde(rename = "CLIENT_TRADE_TAG_INVALID")]
    ClientTradeTagInvalid,
    #[serde(rename = "CLIENT_TRADE_COMMENT_INVALID")]
    ClientTradeCommentInvalid,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_MISSING")]
    OrderFillPositionActionMissing,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_INVALID")]
    OrderFillPositionActionInvalid,
    #[serde(rename = "TRIGGER_CONDITION_MISSING")]
    TriggerConditionMissing,
    #[serde(rename = "TRIGGER_CONDITION_INVALID")]
    TriggerConditionInvalid,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_MISSING")]
    OrderPartialFillOptionMissing,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_INVALID")]
    OrderPartialFillOptionInvalid,
    #[serde(rename = "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL")]
    InvalidReissueImmediatePartialFill,
    #[serde(rename = "TAKE_PROFIT_ORDER_ALREADY_EXISTS")]
    TakeProfitOrderAlreadyExists,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_MISSING")]
    TakeProfitOnFillPriceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_INVALID")]
    TakeProfitOnFillPriceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    TakeProfitOnFillPricePrecisionExceeded,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING")]
    TakeProfitOnFillTimeInForceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID")]
    TakeProfitOnFillTimeInForceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TakeProfitOnFillGtdTimestampMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TakeProfitOnFillGtdTimestampInPast,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TakeProfitOnFillClientOrderIdInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TakeProfitOnFillClientOrderTagInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TakeProfitOnFillClientOrderCommentInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TakeProfitOnFillTriggerConditionMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TakeProfitOnFillTriggerConditionInvalid,
    #[serde(rename = "STOP_LOSS_ORDER_ALREADY_EXISTS")]
    StopLossOrderAlreadyExists,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_REQUIRED")]
    StopLossOrderGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD")]
    StopLossOrderGuaranteedPriceWithinSpread,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED")]
    StopLossOrderGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION")]
    StopLossOrderGuaranteedHaltedCreateViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION")]
    StopLossOrderGuaranteedHaltedTightenViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED")]
    StopLossOrderGuaranteedHedgingNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOrderGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_CANCELABLE")]
    StopLossOrderNotCancelable,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_REPLACEABLE")]
    StopLossOrderNotReplaceable,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOrderGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOrderPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOrderPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER")]
    StopLossOnFillRequiredForPendingOrder,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED")]
    StopLossOnFillGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED")]
    StopLossOnFillGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_MISSING")]
    StopLossOnFillPriceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_INVALID")]
    StopLossOnFillPriceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    StopLossOnFillPricePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOnFillGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOnFillGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_INVALID")]
    StopLossOnFillDistanceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    StopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED")]
    StopLossOnFillDistancePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOnFillPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOnFillPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    StopLossOnFillTimeInForceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    StopLossOnFillTimeInForceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    StopLossOnFillGtdTimestampMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    StopLossOnFillGtdTimestampInPast,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    StopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    StopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    StopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    StopLossOnFillTriggerConditionMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    StopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS")]
    TrailingStopLossOrderAlreadyExists,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING")]
    TrailingStopLossOnFillPriceDistanceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID")]
    TrailingStopLossOnFillPriceDistanceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED")]
    TrailingStopLossOnFillPriceDistancePrecisionExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    TrailingStopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET")]
    TrailingStopLossOnFillPriceDistanceMinimumNotMet,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    TrailingStopLossOnFillTimeInForceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    TrailingStopLossOnFillTimeInForceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TrailingStopLossOnFillGtdTimestampMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TrailingStopLossOnFillGtdTimestampInPast,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TrailingStopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TrailingStopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TrailingStopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED")]
    TrailingStopLossOrdersNotSupported,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TrailingStopLossOnFillTriggerConditionMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TrailingStopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "CLOSE_TRADE_TYPE_MISSING")]
    CloseTradeTypeMissing,
    #[serde(rename = "CLOSE_TRADE_PARTIAL_UNITS_MISSING")]
    CloseTradePartialUnitsMissing,
    #[serde(rename = "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE")]
    CloseTradeUnitsExceedTradeSize,
    #[serde(rename = "CLOSEOUT_POSITION_DOESNT_EXIST")]
    CloseoutPositionDoesntExist,
    #[serde(rename = "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION")]
    CloseoutPositionIncompleteSpecification,
    #[serde(rename = "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE")]
    CloseoutPositionUnitsExceedPositionSize,
    #[serde(rename = "CLOSEOUT_POSITION_REJECT")]
    CloseoutPositionReject,
    #[serde(rename = "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING")]
    CloseoutPositionPartialUnitsMissing,
    #[serde(rename = "MARKUP_GROUP_ID_INVALID")]
    MarkupGroupIdInvalid,
    #[serde(rename = "POSITION_AGGREGATION_MODE_INVALID")]
    PositionAggregationModeInvalid,
    #[serde(rename = "ADMIN_CONFIGURE_DATA_MISSING")]
    AdminConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_INVALID")]
    MarginRateInvalid,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT")]
    MarginRateWouldTriggerCloseout,
    #[serde(rename = "ALIAS_INVALID")]
    AliasInvalid,
    #[serde(rename = "CLIENT_CONFIGURE_DATA_MISSING")]
    ClientConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL")]
    MarginRateWouldTriggerMarginCall,
    #[serde(rename = "AMOUNT_INVALID")]
    AmountInvalid,
    #[serde(rename = "INSUFFICIENT_FUNDS")]
    InsufficientFunds,
    #[serde(rename = "AMOUNT_MISSING")]
    AmountMissing,
    #[serde(rename = "FUNDING_REASON_MISSING")]
    FundingReasonMissing,
    #[serde(rename = "CLIENT_EXTENSIONS_DATA_MISSING")]
    ClientExtensionsDataMissing,
    #[serde(rename = "REPLACING_ORDER_INVALID")]
    ReplacingOrderInvalid,
    #[serde(rename = "REPLACING_TRADE_ID_INVALID")]
    ReplacingTradeIdInvalid,
}

impl From<&OrderCancelRejectTransactionRejectReason> for OrderCancelRejectTransactionRejectReason {
    fn from(value: &OrderCancelRejectTransactionRejectReason) -> Self {
        value.clone()
    }
}

impl ToString for OrderCancelRejectTransactionRejectReason {
    fn to_string(&self) -> String {
        match *self {
            Self::InternalServerError => "INTERNAL_SERVER_ERROR".to_string(),
            Self::InstrumentPriceUnknown => "INSTRUMENT_PRICE_UNKNOWN".to_string(),
            Self::AccountNotActive => "ACCOUNT_NOT_ACTIVE".to_string(),
            Self::AccountLocked => "ACCOUNT_LOCKED".to_string(),
            Self::AccountOrderCreationLocked => "ACCOUNT_ORDER_CREATION_LOCKED".to_string(),
            Self::AccountConfigurationLocked => "ACCOUNT_CONFIGURATION_LOCKED".to_string(),
            Self::AccountDepositLocked => "ACCOUNT_DEPOSIT_LOCKED".to_string(),
            Self::AccountWithdrawalLocked => "ACCOUNT_WITHDRAWAL_LOCKED".to_string(),
            Self::AccountOrderCancelLocked => "ACCOUNT_ORDER_CANCEL_LOCKED".to_string(),
            Self::InstrumentNotTradeable => "INSTRUMENT_NOT_TRADEABLE".to_string(),
            Self::PendingOrdersAllowedExceeded => "PENDING_ORDERS_ALLOWED_EXCEEDED".to_string(),
            Self::OrderIdUnspecified => "ORDER_ID_UNSPECIFIED".to_string(),
            Self::OrderDoesntExist => "ORDER_DOESNT_EXIST".to_string(),
            Self::OrderIdentifierInconsistency => "ORDER_IDENTIFIER_INCONSISTENCY".to_string(),
            Self::TradeIdUnspecified => "TRADE_ID_UNSPECIFIED".to_string(),
            Self::TradeDoesntExist => "TRADE_DOESNT_EXIST".to_string(),
            Self::TradeIdentifierInconsistency => "TRADE_IDENTIFIER_INCONSISTENCY".to_string(),
            Self::InsufficientMargin => "INSUFFICIENT_MARGIN".to_string(),
            Self::InstrumentMissing => "INSTRUMENT_MISSING".to_string(),
            Self::InstrumentUnknown => "INSTRUMENT_UNKNOWN".to_string(),
            Self::UnitsMissing => "UNITS_MISSING".to_string(),
            Self::UnitsInvalid => "UNITS_INVALID".to_string(),
            Self::UnitsPrecisionExceeded => "UNITS_PRECISION_EXCEEDED".to_string(),
            Self::UnitsLimitExceeded => "UNITS_LIMIT_EXCEEDED".to_string(),
            Self::UnitsMimimumNotMet => "UNITS_MIMIMUM_NOT_MET".to_string(),
            Self::PriceMissing => "PRICE_MISSING".to_string(),
            Self::PriceInvalid => "PRICE_INVALID".to_string(),
            Self::PricePrecisionExceeded => "PRICE_PRECISION_EXCEEDED".to_string(),
            Self::PriceDistanceMissing => "PRICE_DISTANCE_MISSING".to_string(),
            Self::PriceDistanceInvalid => "PRICE_DISTANCE_INVALID".to_string(),
            Self::PriceDistancePrecisionExceeded => "PRICE_DISTANCE_PRECISION_EXCEEDED".to_string(),
            Self::PriceDistanceMaximumExceeded => "PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string(),
            Self::PriceDistanceMinimumNotMet => "PRICE_DISTANCE_MINIMUM_NOT_MET".to_string(),
            Self::TimeInForceMissing => "TIME_IN_FORCE_MISSING".to_string(),
            Self::TimeInForceInvalid => "TIME_IN_FORCE_INVALID".to_string(),
            Self::TimeInForceGtdTimestampMissing => {
                "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TimeInForceGtdTimestampInPast => {
                "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::PriceBoundInvalid => "PRICE_BOUND_INVALID".to_string(),
            Self::PriceBoundPrecisionExceeded => "PRICE_BOUND_PRECISION_EXCEEDED".to_string(),
            Self::OrdersOnFillDuplicateClientOrderIds => {
                "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS".to_string()
            }
            Self::TradeOnFillClientExtensionsNotSupported => {
                "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED".to_string()
            }
            Self::ClientOrderIdInvalid => "CLIENT_ORDER_ID_INVALID".to_string(),
            Self::ClientOrderIdAlreadyExists => "CLIENT_ORDER_ID_ALREADY_EXISTS".to_string(),
            Self::ClientOrderTagInvalid => "CLIENT_ORDER_TAG_INVALID".to_string(),
            Self::ClientOrderCommentInvalid => "CLIENT_ORDER_COMMENT_INVALID".to_string(),
            Self::ClientTradeIdInvalid => "CLIENT_TRADE_ID_INVALID".to_string(),
            Self::ClientTradeIdAlreadyExists => "CLIENT_TRADE_ID_ALREADY_EXISTS".to_string(),
            Self::ClientTradeTagInvalid => "CLIENT_TRADE_TAG_INVALID".to_string(),
            Self::ClientTradeCommentInvalid => "CLIENT_TRADE_COMMENT_INVALID".to_string(),
            Self::OrderFillPositionActionMissing => {
                "ORDER_FILL_POSITION_ACTION_MISSING".to_string()
            }
            Self::OrderFillPositionActionInvalid => {
                "ORDER_FILL_POSITION_ACTION_INVALID".to_string()
            }
            Self::TriggerConditionMissing => "TRIGGER_CONDITION_MISSING".to_string(),
            Self::TriggerConditionInvalid => "TRIGGER_CONDITION_INVALID".to_string(),
            Self::OrderPartialFillOptionMissing => "ORDER_PARTIAL_FILL_OPTION_MISSING".to_string(),
            Self::OrderPartialFillOptionInvalid => "ORDER_PARTIAL_FILL_OPTION_INVALID".to_string(),
            Self::InvalidReissueImmediatePartialFill => {
                "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL".to_string()
            }
            Self::TakeProfitOrderAlreadyExists => "TAKE_PROFIT_ORDER_ALREADY_EXISTS".to_string(),
            Self::TakeProfitOnFillPriceMissing => "TAKE_PROFIT_ON_FILL_PRICE_MISSING".to_string(),
            Self::TakeProfitOnFillPriceInvalid => "TAKE_PROFIT_ON_FILL_PRICE_INVALID".to_string(),
            Self::TakeProfitOnFillPricePrecisionExceeded => {
                "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED".to_string()
            }
            Self::TakeProfitOnFillTimeInForceMissing => {
                "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::TakeProfitOnFillTimeInForceInvalid => {
                "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::TakeProfitOnFillGtdTimestampMissing => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TakeProfitOnFillGtdTimestampInPast => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TakeProfitOnFillClientOrderIdInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::TakeProfitOnFillClientOrderTagInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::TakeProfitOnFillClientOrderCommentInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::TakeProfitOnFillTriggerConditionMissing => {
                "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::TakeProfitOnFillTriggerConditionInvalid => {
                "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::StopLossOrderAlreadyExists => "STOP_LOSS_ORDER_ALREADY_EXISTS".to_string(),
            Self::StopLossOrderGuaranteedRequired => {
                "STOP_LOSS_ORDER_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOrderGuaranteedPriceWithinSpread => {
                "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD".to_string()
            }
            Self::StopLossOrderGuaranteedNotAllowed => {
                "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOrderGuaranteedHaltedCreateViolation => {
                "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION".to_string()
            }
            Self::StopLossOrderGuaranteedHaltedTightenViolation => {
                "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION".to_string()
            }
            Self::StopLossOrderGuaranteedHedgingNotAllowed => {
                "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED".to_string()
            }
            Self::StopLossOrderGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOrderNotCancelable => "STOP_LOSS_ORDER_NOT_CANCELABLE".to_string(),
            Self::StopLossOrderNotReplaceable => "STOP_LOSS_ORDER_NOT_REPLACEABLE".to_string(),
            Self::StopLossOrderGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOrderPriceAndDistanceBothSpecified => {
                "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED".to_string()
            }
            Self::StopLossOrderPriceAndDistanceBothMissing => {
                "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING".to_string()
            }
            Self::StopLossOnFillRequiredForPendingOrder => {
                "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER".to_string()
            }
            Self::StopLossOnFillGuaranteedNotAllowed => {
                "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOnFillGuaranteedRequired => {
                "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOnFillPriceMissing => "STOP_LOSS_ON_FILL_PRICE_MISSING".to_string(),
            Self::StopLossOnFillPriceInvalid => "STOP_LOSS_ON_FILL_PRICE_INVALID".to_string(),
            Self::StopLossOnFillPricePrecisionExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOnFillGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillDistanceInvalid => "STOP_LOSS_ON_FILL_DISTANCE_INVALID".to_string(),
            Self::StopLossOnFillPriceDistanceMaximumExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::StopLossOnFillDistancePrecisionExceeded => {
                "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillPriceAndDistanceBothSpecified => {
                "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED".to_string()
            }
            Self::StopLossOnFillPriceAndDistanceBothMissing => {
                "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING".to_string()
            }
            Self::StopLossOnFillTimeInForceMissing => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::StopLossOnFillTimeInForceInvalid => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::StopLossOnFillGtdTimestampMissing => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::StopLossOnFillGtdTimestampInPast => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::StopLossOnFillClientOrderIdInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::StopLossOnFillClientOrderTagInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::StopLossOnFillClientOrderCommentInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::StopLossOnFillTriggerConditionMissing => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::StopLossOnFillTriggerConditionInvalid => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::TrailingStopLossOrderAlreadyExists => {
                "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistancePrecisionExceeded => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMaximumExceeded => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMinimumNotMet => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET".to_string()
            }
            Self::TrailingStopLossOnFillTimeInForceMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillTimeInForceInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampInPast => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderIdInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderTagInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderCommentInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::TrailingStopLossOrdersNotSupported => {
                "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED".to_string()
            }
            Self::TrailingStopLossOnFillTriggerConditionMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillTriggerConditionInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::CloseTradeTypeMissing => "CLOSE_TRADE_TYPE_MISSING".to_string(),
            Self::CloseTradePartialUnitsMissing => "CLOSE_TRADE_PARTIAL_UNITS_MISSING".to_string(),
            Self::CloseTradeUnitsExceedTradeSize => {
                "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE".to_string()
            }
            Self::CloseoutPositionDoesntExist => "CLOSEOUT_POSITION_DOESNT_EXIST".to_string(),
            Self::CloseoutPositionIncompleteSpecification => {
                "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION".to_string()
            }
            Self::CloseoutPositionUnitsExceedPositionSize => {
                "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE".to_string()
            }
            Self::CloseoutPositionReject => "CLOSEOUT_POSITION_REJECT".to_string(),
            Self::CloseoutPositionPartialUnitsMissing => {
                "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING".to_string()
            }
            Self::MarkupGroupIdInvalid => "MARKUP_GROUP_ID_INVALID".to_string(),
            Self::PositionAggregationModeInvalid => "POSITION_AGGREGATION_MODE_INVALID".to_string(),
            Self::AdminConfigureDataMissing => "ADMIN_CONFIGURE_DATA_MISSING".to_string(),
            Self::MarginRateInvalid => "MARGIN_RATE_INVALID".to_string(),
            Self::MarginRateWouldTriggerCloseout => {
                "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT".to_string()
            }
            Self::AliasInvalid => "ALIAS_INVALID".to_string(),
            Self::ClientConfigureDataMissing => "CLIENT_CONFIGURE_DATA_MISSING".to_string(),
            Self::MarginRateWouldTriggerMarginCall => {
                "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL".to_string()
            }
            Self::AmountInvalid => "AMOUNT_INVALID".to_string(),
            Self::InsufficientFunds => "INSUFFICIENT_FUNDS".to_string(),
            Self::AmountMissing => "AMOUNT_MISSING".to_string(),
            Self::FundingReasonMissing => "FUNDING_REASON_MISSING".to_string(),
            Self::ClientExtensionsDataMissing => "CLIENT_EXTENSIONS_DATA_MISSING".to_string(),
            Self::ReplacingOrderInvalid => "REPLACING_ORDER_INVALID".to_string(),
            Self::ReplacingTradeIdInvalid => "REPLACING_TRADE_ID_INVALID".to_string(),
        }
    }
}

impl std::str::FromStr for OrderCancelRejectTransactionRejectReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "INTERNAL_SERVER_ERROR" => Ok(Self::InternalServerError),
            "INSTRUMENT_PRICE_UNKNOWN" => Ok(Self::InstrumentPriceUnknown),
            "ACCOUNT_NOT_ACTIVE" => Ok(Self::AccountNotActive),
            "ACCOUNT_LOCKED" => Ok(Self::AccountLocked),
            "ACCOUNT_ORDER_CREATION_LOCKED" => Ok(Self::AccountOrderCreationLocked),
            "ACCOUNT_CONFIGURATION_LOCKED" => Ok(Self::AccountConfigurationLocked),
            "ACCOUNT_DEPOSIT_LOCKED" => Ok(Self::AccountDepositLocked),
            "ACCOUNT_WITHDRAWAL_LOCKED" => Ok(Self::AccountWithdrawalLocked),
            "ACCOUNT_ORDER_CANCEL_LOCKED" => Ok(Self::AccountOrderCancelLocked),
            "INSTRUMENT_NOT_TRADEABLE" => Ok(Self::InstrumentNotTradeable),
            "PENDING_ORDERS_ALLOWED_EXCEEDED" => Ok(Self::PendingOrdersAllowedExceeded),
            "ORDER_ID_UNSPECIFIED" => Ok(Self::OrderIdUnspecified),
            "ORDER_DOESNT_EXIST" => Ok(Self::OrderDoesntExist),
            "ORDER_IDENTIFIER_INCONSISTENCY" => Ok(Self::OrderIdentifierInconsistency),
            "TRADE_ID_UNSPECIFIED" => Ok(Self::TradeIdUnspecified),
            "TRADE_DOESNT_EXIST" => Ok(Self::TradeDoesntExist),
            "TRADE_IDENTIFIER_INCONSISTENCY" => Ok(Self::TradeIdentifierInconsistency),
            "INSUFFICIENT_MARGIN" => Ok(Self::InsufficientMargin),
            "INSTRUMENT_MISSING" => Ok(Self::InstrumentMissing),
            "INSTRUMENT_UNKNOWN" => Ok(Self::InstrumentUnknown),
            "UNITS_MISSING" => Ok(Self::UnitsMissing),
            "UNITS_INVALID" => Ok(Self::UnitsInvalid),
            "UNITS_PRECISION_EXCEEDED" => Ok(Self::UnitsPrecisionExceeded),
            "UNITS_LIMIT_EXCEEDED" => Ok(Self::UnitsLimitExceeded),
            "UNITS_MIMIMUM_NOT_MET" => Ok(Self::UnitsMimimumNotMet),
            "PRICE_MISSING" => Ok(Self::PriceMissing),
            "PRICE_INVALID" => Ok(Self::PriceInvalid),
            "PRICE_PRECISION_EXCEEDED" => Ok(Self::PricePrecisionExceeded),
            "PRICE_DISTANCE_MISSING" => Ok(Self::PriceDistanceMissing),
            "PRICE_DISTANCE_INVALID" => Ok(Self::PriceDistanceInvalid),
            "PRICE_DISTANCE_PRECISION_EXCEEDED" => Ok(Self::PriceDistancePrecisionExceeded),
            "PRICE_DISTANCE_MAXIMUM_EXCEEDED" => Ok(Self::PriceDistanceMaximumExceeded),
            "PRICE_DISTANCE_MINIMUM_NOT_MET" => Ok(Self::PriceDistanceMinimumNotMet),
            "TIME_IN_FORCE_MISSING" => Ok(Self::TimeInForceMissing),
            "TIME_IN_FORCE_INVALID" => Ok(Self::TimeInForceInvalid),
            "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING" => Ok(Self::TimeInForceGtdTimestampMissing),
            "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST" => Ok(Self::TimeInForceGtdTimestampInPast),
            "PRICE_BOUND_INVALID" => Ok(Self::PriceBoundInvalid),
            "PRICE_BOUND_PRECISION_EXCEEDED" => Ok(Self::PriceBoundPrecisionExceeded),
            "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS" => {
                Ok(Self::OrdersOnFillDuplicateClientOrderIds)
            }
            "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED" => {
                Ok(Self::TradeOnFillClientExtensionsNotSupported)
            }
            "CLIENT_ORDER_ID_INVALID" => Ok(Self::ClientOrderIdInvalid),
            "CLIENT_ORDER_ID_ALREADY_EXISTS" => Ok(Self::ClientOrderIdAlreadyExists),
            "CLIENT_ORDER_TAG_INVALID" => Ok(Self::ClientOrderTagInvalid),
            "CLIENT_ORDER_COMMENT_INVALID" => Ok(Self::ClientOrderCommentInvalid),
            "CLIENT_TRADE_ID_INVALID" => Ok(Self::ClientTradeIdInvalid),
            "CLIENT_TRADE_ID_ALREADY_EXISTS" => Ok(Self::ClientTradeIdAlreadyExists),
            "CLIENT_TRADE_TAG_INVALID" => Ok(Self::ClientTradeTagInvalid),
            "CLIENT_TRADE_COMMENT_INVALID" => Ok(Self::ClientTradeCommentInvalid),
            "ORDER_FILL_POSITION_ACTION_MISSING" => Ok(Self::OrderFillPositionActionMissing),
            "ORDER_FILL_POSITION_ACTION_INVALID" => Ok(Self::OrderFillPositionActionInvalid),
            "TRIGGER_CONDITION_MISSING" => Ok(Self::TriggerConditionMissing),
            "TRIGGER_CONDITION_INVALID" => Ok(Self::TriggerConditionInvalid),
            "ORDER_PARTIAL_FILL_OPTION_MISSING" => Ok(Self::OrderPartialFillOptionMissing),
            "ORDER_PARTIAL_FILL_OPTION_INVALID" => Ok(Self::OrderPartialFillOptionInvalid),
            "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL" => {
                Ok(Self::InvalidReissueImmediatePartialFill)
            }
            "TAKE_PROFIT_ORDER_ALREADY_EXISTS" => Ok(Self::TakeProfitOrderAlreadyExists),
            "TAKE_PROFIT_ON_FILL_PRICE_MISSING" => Ok(Self::TakeProfitOnFillPriceMissing),
            "TAKE_PROFIT_ON_FILL_PRICE_INVALID" => Ok(Self::TakeProfitOnFillPriceInvalid),
            "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(Self::TakeProfitOnFillPricePrecisionExceeded)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(Self::TakeProfitOnFillTimeInForceMissing)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(Self::TakeProfitOnFillTimeInForceInvalid)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::TakeProfitOnFillGtdTimestampMissing)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TakeProfitOnFillGtdTimestampInPast)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderIdInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderTagInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderCommentInvalid)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::TakeProfitOnFillTriggerConditionMissing)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::TakeProfitOnFillTriggerConditionInvalid)
            }
            "STOP_LOSS_ORDER_ALREADY_EXISTS" => Ok(Self::StopLossOrderAlreadyExists),
            "STOP_LOSS_ORDER_GUARANTEED_REQUIRED" => Ok(Self::StopLossOrderGuaranteedRequired),
            "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD" => {
                Ok(Self::StopLossOrderGuaranteedPriceWithinSpread)
            }
            "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED" => Ok(Self::StopLossOrderGuaranteedNotAllowed),
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION" => {
                Ok(Self::StopLossOrderGuaranteedHaltedCreateViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION" => {
                Ok(Self::StopLossOrderGuaranteedHaltedTightenViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED" => {
                Ok(Self::StopLossOrderGuaranteedHedgingNotAllowed)
            }
            "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOrderGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ORDER_NOT_CANCELABLE" => Ok(Self::StopLossOrderNotCancelable),
            "STOP_LOSS_ORDER_NOT_REPLACEABLE" => Ok(Self::StopLossOrderNotReplaceable),
            "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOrderGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(Self::StopLossOrderPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(Self::StopLossOrderPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER" => {
                Ok(Self::StopLossOnFillRequiredForPendingOrder)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED" => {
                Ok(Self::StopLossOnFillGuaranteedNotAllowed)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED" => Ok(Self::StopLossOnFillGuaranteedRequired),
            "STOP_LOSS_ON_FILL_PRICE_MISSING" => Ok(Self::StopLossOnFillPriceMissing),
            "STOP_LOSS_ON_FILL_PRICE_INVALID" => Ok(Self::StopLossOnFillPriceInvalid),
            "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(Self::StopLossOnFillPricePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOnFillGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOnFillGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_INVALID" => Ok(Self::StopLossOnFillDistanceInvalid),
            "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::StopLossOnFillPriceDistanceMaximumExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(Self::StopLossOnFillDistancePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(Self::StopLossOnFillPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(Self::StopLossOnFillPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => Ok(Self::StopLossOnFillTimeInForceMissing),
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => Ok(Self::StopLossOnFillTimeInForceInvalid),
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::StopLossOnFillGtdTimestampMissing)
            }
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => Ok(Self::StopLossOnFillGtdTimestampInPast),
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderIdInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderTagInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderCommentInvalid)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::StopLossOnFillTriggerConditionMissing)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::StopLossOnFillTriggerConditionInvalid)
            }
            "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS" => {
                Ok(Self::TrailingStopLossOrderAlreadyExists)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(Self::TrailingStopLossOnFillPriceDistancePrecisionExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMaximumExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMinimumNotMet)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(Self::TrailingStopLossOnFillTimeInForceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(Self::TrailingStopLossOnFillTimeInForceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampInPast)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderIdInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderTagInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderCommentInvalid)
            }
            "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED" => {
                Ok(Self::TrailingStopLossOrdersNotSupported)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::TrailingStopLossOnFillTriggerConditionMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::TrailingStopLossOnFillTriggerConditionInvalid)
            }
            "CLOSE_TRADE_TYPE_MISSING" => Ok(Self::CloseTradeTypeMissing),
            "CLOSE_TRADE_PARTIAL_UNITS_MISSING" => Ok(Self::CloseTradePartialUnitsMissing),
            "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE" => Ok(Self::CloseTradeUnitsExceedTradeSize),
            "CLOSEOUT_POSITION_DOESNT_EXIST" => Ok(Self::CloseoutPositionDoesntExist),
            "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION" => {
                Ok(Self::CloseoutPositionIncompleteSpecification)
            }
            "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE" => {
                Ok(Self::CloseoutPositionUnitsExceedPositionSize)
            }
            "CLOSEOUT_POSITION_REJECT" => Ok(Self::CloseoutPositionReject),
            "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING" => {
                Ok(Self::CloseoutPositionPartialUnitsMissing)
            }
            "MARKUP_GROUP_ID_INVALID" => Ok(Self::MarkupGroupIdInvalid),
            "POSITION_AGGREGATION_MODE_INVALID" => Ok(Self::PositionAggregationModeInvalid),
            "ADMIN_CONFIGURE_DATA_MISSING" => Ok(Self::AdminConfigureDataMissing),
            "MARGIN_RATE_INVALID" => Ok(Self::MarginRateInvalid),
            "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT" => Ok(Self::MarginRateWouldTriggerCloseout),
            "ALIAS_INVALID" => Ok(Self::AliasInvalid),
            "CLIENT_CONFIGURE_DATA_MISSING" => Ok(Self::ClientConfigureDataMissing),
            "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL" => Ok(Self::MarginRateWouldTriggerMarginCall),
            "AMOUNT_INVALID" => Ok(Self::AmountInvalid),
            "INSUFFICIENT_FUNDS" => Ok(Self::InsufficientFunds),
            "AMOUNT_MISSING" => Ok(Self::AmountMissing),
            "FUNDING_REASON_MISSING" => Ok(Self::FundingReasonMissing),
            "CLIENT_EXTENSIONS_DATA_MISSING" => Ok(Self::ClientExtensionsDataMissing),
            "REPLACING_ORDER_INVALID" => Ok(Self::ReplacingOrderInvalid),
            "REPLACING_TRADE_ID_INVALID" => Ok(Self::ReplacingTradeIdInvalid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for OrderCancelRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for OrderCancelRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for OrderCancelRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Type of the Transaction. Always set to "ORDER_CANCEL_REJECT" for an
/// OrderCancelRejectTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"ORDER_CANCEL_REJECT\" for an OrderCancelRejectTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrderCancelRejectTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&OrderCancelRejectTransactionType> for OrderCancelRejectTransactionType {
    fn from(value: &OrderCancelRejectTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for OrderCancelRejectTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for OrderCancelRejectTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for OrderCancelRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for OrderCancelRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for OrderCancelRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///An OrderCancelTransaction represents the cancellation of an Order in the
/// client's Account.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "An OrderCancelTransaction represents the cancellation
/// of an Order in the client's Account.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientOrderID": {
///      "description": "The client ID of the Order cancelled (only provided
/// if the Order has a client Order ID).",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "orderID": {
///      "description": "The ID of the Order cancelled",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "reason": {
///      "description": "The reason that the Order was cancelled.",
///      "type": "string",
///      "enum": [
///        "INTERNAL_SERVER_ERROR",
///        "ACCOUNT_LOCKED",
///        "ACCOUNT_NEW_POSITIONS_LOCKED",
///        "ACCOUNT_ORDER_CREATION_LOCKED",
///        "ACCOUNT_ORDER_FILL_LOCKED",
///        "CLIENT_REQUEST",
///        "MIGRATION",
///        "MARKET_HALTED",
///        "LINKED_TRADE_CLOSED",
///        "TIME_IN_FORCE_EXPIRED",
///        "INSUFFICIENT_MARGIN",
///        "FIFO_VIOLATION",
///        "BOUNDS_VIOLATION",
///        "CLIENT_REQUEST_REPLACED",
///        "INSUFFICIENT_LIQUIDITY",
///        "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "TAKE_PROFIT_ON_FILL_LOSS",
///        "LOSING_TAKE_PROFIT",
///        "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "STOP_LOSS_ON_FILL_LOSS",
///        "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "STOP_LOSS_ON_FILL_REQUIRED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///        "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_HEDGING_NOT_ALLOWED",
///        "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///        "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "TAKE_PROFIT_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "CLIENT_TRADE_ID_ALREADY_EXISTS",
///        "POSITION_CLOSEOUT_FAILED",
///        "OPEN_TRADES_ALLOWED_EXCEEDED",
///        "PENDING_ORDERS_ALLOWED_EXCEEDED",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS",
///        "POSITION_SIZE_EXCEEDED",
///        "HEDGING_GSLO_VIOLATION",
///        "ACCOUNT_POSITION_VALUE_LIMIT_EXCEEDED",
///        "INSTRUMENT_BID_REDUCE_ONLY",
///        "INSTRUMENT_ASK_REDUCE_ONLY",
///        "INSTRUMENT_BID_HALTED",
///        "INSTRUMENT_ASK_HALTED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_BID_HALTED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_ASK_HALTED"
///      ]
///    },
///    "replacedByOrderID": {
///      "description": "The ID of the Order that replaced this Order (only
/// provided if this Order was cancelled for replacement).",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"ORDER_CANCEL\" for an OrderCancelTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OrderCancelTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    ///The client ID of the Order cancelled (only provided if the Order has
    /// a client Order ID).
    #[serde(
        rename = "clientOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_order_id: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The ID of the Order cancelled
    #[serde(rename = "orderID", default, skip_serializing_if = "Option::is_none")]
    pub order_id: Option<String>,
    ///The reason that the Order was cancelled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<OrderCancelTransactionReason>,
    ///The ID of the Order that replaced this Order (only provided if this
    /// Order was cancelled for replacement).
    #[serde(
        rename = "replacedByOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub replaced_by_order_id: Option<String>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The Type of the Transaction. Always set to "ORDER_CANCEL" for an
    /// OrderCancelTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<OrderCancelTransactionType>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&OrderCancelTransaction> for OrderCancelTransaction {
    fn from(value: &OrderCancelTransaction) -> Self {
        value.clone()
    }
}

impl OrderCancelTransaction {
    pub fn builder() -> builder::OrderCancelTransaction {
        Default::default()
    }
}

///The reason that the Order was cancelled.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Order was cancelled.",
///  "type": "string",
///  "enum": [
///    "INTERNAL_SERVER_ERROR",
///    "ACCOUNT_LOCKED",
///    "ACCOUNT_NEW_POSITIONS_LOCKED",
///    "ACCOUNT_ORDER_CREATION_LOCKED",
///    "ACCOUNT_ORDER_FILL_LOCKED",
///    "CLIENT_REQUEST",
///    "MIGRATION",
///    "MARKET_HALTED",
///    "LINKED_TRADE_CLOSED",
///    "TIME_IN_FORCE_EXPIRED",
///    "INSUFFICIENT_MARGIN",
///    "FIFO_VIOLATION",
///    "BOUNDS_VIOLATION",
///    "CLIENT_REQUEST_REPLACED",
///    "INSUFFICIENT_LIQUIDITY",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TAKE_PROFIT_ON_FILL_LOSS",
///    "LOSING_TAKE_PROFIT",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "STOP_LOSS_ON_FILL_LOSS",
///    "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "STOP_LOSS_ON_FILL_REQUIRED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_HEDGING_NOT_ALLOWED",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "TAKE_PROFIT_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "CLIENT_TRADE_ID_ALREADY_EXISTS",
///    "POSITION_CLOSEOUT_FAILED",
///    "OPEN_TRADES_ALLOWED_EXCEEDED",
///    "PENDING_ORDERS_ALLOWED_EXCEEDED",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS",
///    "POSITION_SIZE_EXCEEDED",
///    "HEDGING_GSLO_VIOLATION",
///    "ACCOUNT_POSITION_VALUE_LIMIT_EXCEEDED",
///    "INSTRUMENT_BID_REDUCE_ONLY",
///    "INSTRUMENT_ASK_REDUCE_ONLY",
///    "INSTRUMENT_BID_HALTED",
///    "INSTRUMENT_ASK_HALTED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_BID_HALTED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_ASK_HALTED"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrderCancelTransactionReason {
    #[serde(rename = "INTERNAL_SERVER_ERROR")]
    InternalServerError,
    #[serde(rename = "ACCOUNT_LOCKED")]
    AccountLocked,
    #[serde(rename = "ACCOUNT_NEW_POSITIONS_LOCKED")]
    AccountNewPositionsLocked,
    #[serde(rename = "ACCOUNT_ORDER_CREATION_LOCKED")]
    AccountOrderCreationLocked,
    #[serde(rename = "ACCOUNT_ORDER_FILL_LOCKED")]
    AccountOrderFillLocked,
    #[serde(rename = "CLIENT_REQUEST")]
    ClientRequest,
    #[serde(rename = "MIGRATION")]
    Migration,
    #[serde(rename = "MARKET_HALTED")]
    MarketHalted,
    #[serde(rename = "LINKED_TRADE_CLOSED")]
    LinkedTradeClosed,
    #[serde(rename = "TIME_IN_FORCE_EXPIRED")]
    TimeInForceExpired,
    #[serde(rename = "INSUFFICIENT_MARGIN")]
    InsufficientMargin,
    #[serde(rename = "FIFO_VIOLATION")]
    FifoViolation,
    #[serde(rename = "BOUNDS_VIOLATION")]
    BoundsViolation,
    #[serde(rename = "CLIENT_REQUEST_REPLACED")]
    ClientRequestReplaced,
    #[serde(rename = "INSUFFICIENT_LIQUIDITY")]
    InsufficientLiquidity,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TakeProfitOnFillGtdTimestampInPast,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_LOSS")]
    TakeProfitOnFillLoss,
    #[serde(rename = "LOSING_TAKE_PROFIT")]
    LosingTakeProfit,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    StopLossOnFillGtdTimestampInPast,
    #[serde(rename = "STOP_LOSS_ON_FILL_LOSS")]
    StopLossOnFillLoss,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    StopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_REQUIRED")]
    StopLossOnFillRequired,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED")]
    StopLossOnFillGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED")]
    StopLossOnFillGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOnFillGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOnFillGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_HEDGING_NOT_ALLOWED")]
    StopLossOnFillGuaranteedHedgingNotAllowed,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    StopLossOnFillTimeInForceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    StopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    TakeProfitOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TrailingStopLossOnFillGtdTimestampInPast,
    #[serde(rename = "CLIENT_TRADE_ID_ALREADY_EXISTS")]
    ClientTradeIdAlreadyExists,
    #[serde(rename = "POSITION_CLOSEOUT_FAILED")]
    PositionCloseoutFailed,
    #[serde(rename = "OPEN_TRADES_ALLOWED_EXCEEDED")]
    OpenTradesAllowedExceeded,
    #[serde(rename = "PENDING_ORDERS_ALLOWED_EXCEEDED")]
    PendingOrdersAllowedExceeded,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS")]
    TakeProfitOnFillClientOrderIdAlreadyExists,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS")]
    StopLossOnFillClientOrderIdAlreadyExists,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS")]
    TrailingStopLossOnFillClientOrderIdAlreadyExists,
    #[serde(rename = "POSITION_SIZE_EXCEEDED")]
    PositionSizeExceeded,
    #[serde(rename = "HEDGING_GSLO_VIOLATION")]
    HedgingGsloViolation,
    #[serde(rename = "ACCOUNT_POSITION_VALUE_LIMIT_EXCEEDED")]
    AccountPositionValueLimitExceeded,
    #[serde(rename = "INSTRUMENT_BID_REDUCE_ONLY")]
    InstrumentBidReduceOnly,
    #[serde(rename = "INSTRUMENT_ASK_REDUCE_ONLY")]
    InstrumentAskReduceOnly,
    #[serde(rename = "INSTRUMENT_BID_HALTED")]
    InstrumentBidHalted,
    #[serde(rename = "INSTRUMENT_ASK_HALTED")]
    InstrumentAskHalted,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_BID_HALTED")]
    StopLossOnFillGuaranteedBidHalted,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_ASK_HALTED")]
    StopLossOnFillGuaranteedAskHalted,
}

impl From<&OrderCancelTransactionReason> for OrderCancelTransactionReason {
    fn from(value: &OrderCancelTransactionReason) -> Self {
        value.clone()
    }
}

impl ToString for OrderCancelTransactionReason {
    fn to_string(&self) -> String {
        match *self {
            Self::InternalServerError => "INTERNAL_SERVER_ERROR".to_string(),
            Self::AccountLocked => "ACCOUNT_LOCKED".to_string(),
            Self::AccountNewPositionsLocked => "ACCOUNT_NEW_POSITIONS_LOCKED".to_string(),
            Self::AccountOrderCreationLocked => "ACCOUNT_ORDER_CREATION_LOCKED".to_string(),
            Self::AccountOrderFillLocked => "ACCOUNT_ORDER_FILL_LOCKED".to_string(),
            Self::ClientRequest => "CLIENT_REQUEST".to_string(),
            Self::Migration => "MIGRATION".to_string(),
            Self::MarketHalted => "MARKET_HALTED".to_string(),
            Self::LinkedTradeClosed => "LINKED_TRADE_CLOSED".to_string(),
            Self::TimeInForceExpired => "TIME_IN_FORCE_EXPIRED".to_string(),
            Self::InsufficientMargin => "INSUFFICIENT_MARGIN".to_string(),
            Self::FifoViolation => "FIFO_VIOLATION".to_string(),
            Self::BoundsViolation => "BOUNDS_VIOLATION".to_string(),
            Self::ClientRequestReplaced => "CLIENT_REQUEST_REPLACED".to_string(),
            Self::InsufficientLiquidity => "INSUFFICIENT_LIQUIDITY".to_string(),
            Self::TakeProfitOnFillGtdTimestampInPast => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TakeProfitOnFillLoss => "TAKE_PROFIT_ON_FILL_LOSS".to_string(),
            Self::LosingTakeProfit => "LOSING_TAKE_PROFIT".to_string(),
            Self::StopLossOnFillGtdTimestampInPast => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::StopLossOnFillLoss => "STOP_LOSS_ON_FILL_LOSS".to_string(),
            Self::StopLossOnFillPriceDistanceMaximumExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::StopLossOnFillRequired => "STOP_LOSS_ON_FILL_REQUIRED".to_string(),
            Self::StopLossOnFillGuaranteedRequired => {
                "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOnFillGuaranteedNotAllowed => {
                "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOnFillGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOnFillGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillGuaranteedHedgingNotAllowed => {
                "STOP_LOSS_ON_FILL_GUARANTEED_HEDGING_NOT_ALLOWED".to_string()
            }
            Self::StopLossOnFillTimeInForceInvalid => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::StopLossOnFillTriggerConditionInvalid => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::TakeProfitOnFillPriceDistanceMaximumExceeded => {
                "TAKE_PROFIT_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampInPast => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::ClientTradeIdAlreadyExists => "CLIENT_TRADE_ID_ALREADY_EXISTS".to_string(),
            Self::PositionCloseoutFailed => "POSITION_CLOSEOUT_FAILED".to_string(),
            Self::OpenTradesAllowedExceeded => "OPEN_TRADES_ALLOWED_EXCEEDED".to_string(),
            Self::PendingOrdersAllowedExceeded => "PENDING_ORDERS_ALLOWED_EXCEEDED".to_string(),
            Self::TakeProfitOnFillClientOrderIdAlreadyExists => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS".to_string()
            }
            Self::StopLossOnFillClientOrderIdAlreadyExists => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderIdAlreadyExists => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS".to_string()
            }
            Self::PositionSizeExceeded => "POSITION_SIZE_EXCEEDED".to_string(),
            Self::HedgingGsloViolation => "HEDGING_GSLO_VIOLATION".to_string(),
            Self::AccountPositionValueLimitExceeded => {
                "ACCOUNT_POSITION_VALUE_LIMIT_EXCEEDED".to_string()
            }
            Self::InstrumentBidReduceOnly => "INSTRUMENT_BID_REDUCE_ONLY".to_string(),
            Self::InstrumentAskReduceOnly => "INSTRUMENT_ASK_REDUCE_ONLY".to_string(),
            Self::InstrumentBidHalted => "INSTRUMENT_BID_HALTED".to_string(),
            Self::InstrumentAskHalted => "INSTRUMENT_ASK_HALTED".to_string(),
            Self::StopLossOnFillGuaranteedBidHalted => {
                "STOP_LOSS_ON_FILL_GUARANTEED_BID_HALTED".to_string()
            }
            Self::StopLossOnFillGuaranteedAskHalted => {
                "STOP_LOSS_ON_FILL_GUARANTEED_ASK_HALTED".to_string()
            }
        }
    }
}

impl std::str::FromStr for OrderCancelTransactionReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "INTERNAL_SERVER_ERROR" => Ok(Self::InternalServerError),
            "ACCOUNT_LOCKED" => Ok(Self::AccountLocked),
            "ACCOUNT_NEW_POSITIONS_LOCKED" => Ok(Self::AccountNewPositionsLocked),
            "ACCOUNT_ORDER_CREATION_LOCKED" => Ok(Self::AccountOrderCreationLocked),
            "ACCOUNT_ORDER_FILL_LOCKED" => Ok(Self::AccountOrderFillLocked),
            "CLIENT_REQUEST" => Ok(Self::ClientRequest),
            "MIGRATION" => Ok(Self::Migration),
            "MARKET_HALTED" => Ok(Self::MarketHalted),
            "LINKED_TRADE_CLOSED" => Ok(Self::LinkedTradeClosed),
            "TIME_IN_FORCE_EXPIRED" => Ok(Self::TimeInForceExpired),
            "INSUFFICIENT_MARGIN" => Ok(Self::InsufficientMargin),
            "FIFO_VIOLATION" => Ok(Self::FifoViolation),
            "BOUNDS_VIOLATION" => Ok(Self::BoundsViolation),
            "CLIENT_REQUEST_REPLACED" => Ok(Self::ClientRequestReplaced),
            "INSUFFICIENT_LIQUIDITY" => Ok(Self::InsufficientLiquidity),
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TakeProfitOnFillGtdTimestampInPast)
            }
            "TAKE_PROFIT_ON_FILL_LOSS" => Ok(Self::TakeProfitOnFillLoss),
            "LOSING_TAKE_PROFIT" => Ok(Self::LosingTakeProfit),
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => Ok(Self::StopLossOnFillGtdTimestampInPast),
            "STOP_LOSS_ON_FILL_LOSS" => Ok(Self::StopLossOnFillLoss),
            "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::StopLossOnFillPriceDistanceMaximumExceeded)
            }
            "STOP_LOSS_ON_FILL_REQUIRED" => Ok(Self::StopLossOnFillRequired),
            "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED" => Ok(Self::StopLossOnFillGuaranteedRequired),
            "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED" => {
                Ok(Self::StopLossOnFillGuaranteedNotAllowed)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOnFillGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOnFillGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_HEDGING_NOT_ALLOWED" => {
                Ok(Self::StopLossOnFillGuaranteedHedgingNotAllowed)
            }
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => Ok(Self::StopLossOnFillTimeInForceInvalid),
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::StopLossOnFillTriggerConditionInvalid)
            }
            "TAKE_PROFIT_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::TakeProfitOnFillPriceDistanceMaximumExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampInPast)
            }
            "CLIENT_TRADE_ID_ALREADY_EXISTS" => Ok(Self::ClientTradeIdAlreadyExists),
            "POSITION_CLOSEOUT_FAILED" => Ok(Self::PositionCloseoutFailed),
            "OPEN_TRADES_ALLOWED_EXCEEDED" => Ok(Self::OpenTradesAllowedExceeded),
            "PENDING_ORDERS_ALLOWED_EXCEEDED" => Ok(Self::PendingOrdersAllowedExceeded),
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS" => {
                Ok(Self::TakeProfitOnFillClientOrderIdAlreadyExists)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS" => {
                Ok(Self::StopLossOnFillClientOrderIdAlreadyExists)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_ALREADY_EXISTS" => {
                Ok(Self::TrailingStopLossOnFillClientOrderIdAlreadyExists)
            }
            "POSITION_SIZE_EXCEEDED" => Ok(Self::PositionSizeExceeded),
            "HEDGING_GSLO_VIOLATION" => Ok(Self::HedgingGsloViolation),
            "ACCOUNT_POSITION_VALUE_LIMIT_EXCEEDED" => Ok(Self::AccountPositionValueLimitExceeded),
            "INSTRUMENT_BID_REDUCE_ONLY" => Ok(Self::InstrumentBidReduceOnly),
            "INSTRUMENT_ASK_REDUCE_ONLY" => Ok(Self::InstrumentAskReduceOnly),
            "INSTRUMENT_BID_HALTED" => Ok(Self::InstrumentBidHalted),
            "INSTRUMENT_ASK_HALTED" => Ok(Self::InstrumentAskHalted),
            "STOP_LOSS_ON_FILL_GUARANTEED_BID_HALTED" => {
                Ok(Self::StopLossOnFillGuaranteedBidHalted)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_ASK_HALTED" => {
                Ok(Self::StopLossOnFillGuaranteedAskHalted)
            }
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for OrderCancelTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for OrderCancelTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for OrderCancelTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Type of the Transaction. Always set to "ORDER_CANCEL" for an
/// OrderCancelTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"ORDER_CANCEL\" for an OrderCancelTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrderCancelTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&OrderCancelTransactionType> for OrderCancelTransactionType {
    fn from(value: &OrderCancelTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for OrderCancelTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for OrderCancelTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for OrderCancelTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for OrderCancelTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for OrderCancelTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A OrderClientExtensionsModifyRejectTransaction represents the rejection
/// of the modification of an Order's Client Extensions.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A OrderClientExtensionsModifyRejectTransaction
/// represents the rejection of the modification of an Order's Client
/// Extensions.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientExtensionsModify": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "clientOrderID": {
///      "description": "The original Client ID of the Order who's client
/// extensions are to be modified.",
///      "type": "string"
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "orderID": {
///      "description": "The ID of the Order who's client extensions are to
/// be modified.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "rejectReason": {
///      "description": "The reason that the Reject Transaction was
/// created",
///      "type": "string",
///      "enum": [
///        "INTERNAL_SERVER_ERROR",
///        "INSTRUMENT_PRICE_UNKNOWN",
///        "ACCOUNT_NOT_ACTIVE",
///        "ACCOUNT_LOCKED",
///        "ACCOUNT_ORDER_CREATION_LOCKED",
///        "ACCOUNT_CONFIGURATION_LOCKED",
///        "ACCOUNT_DEPOSIT_LOCKED",
///        "ACCOUNT_WITHDRAWAL_LOCKED",
///        "ACCOUNT_ORDER_CANCEL_LOCKED",
///        "INSTRUMENT_NOT_TRADEABLE",
///        "PENDING_ORDERS_ALLOWED_EXCEEDED",
///        "ORDER_ID_UNSPECIFIED",
///        "ORDER_DOESNT_EXIST",
///        "ORDER_IDENTIFIER_INCONSISTENCY",
///        "TRADE_ID_UNSPECIFIED",
///        "TRADE_DOESNT_EXIST",
///        "TRADE_IDENTIFIER_INCONSISTENCY",
///        "INSUFFICIENT_MARGIN",
///        "INSTRUMENT_MISSING",
///        "INSTRUMENT_UNKNOWN",
///        "UNITS_MISSING",
///        "UNITS_INVALID",
///        "UNITS_PRECISION_EXCEEDED",
///        "UNITS_LIMIT_EXCEEDED",
///        "UNITS_MIMIMUM_NOT_MET",
///        "PRICE_MISSING",
///        "PRICE_INVALID",
///        "PRICE_PRECISION_EXCEEDED",
///        "PRICE_DISTANCE_MISSING",
///        "PRICE_DISTANCE_INVALID",
///        "PRICE_DISTANCE_PRECISION_EXCEEDED",
///        "PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "PRICE_DISTANCE_MINIMUM_NOT_MET",
///        "TIME_IN_FORCE_MISSING",
///        "TIME_IN_FORCE_INVALID",
///        "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING",
///        "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST",
///        "PRICE_BOUND_INVALID",
///        "PRICE_BOUND_PRECISION_EXCEEDED",
///        "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS",
///        "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED",
///        "CLIENT_ORDER_ID_INVALID",
///        "CLIENT_ORDER_ID_ALREADY_EXISTS",
///        "CLIENT_ORDER_TAG_INVALID",
///        "CLIENT_ORDER_COMMENT_INVALID",
///        "CLIENT_TRADE_ID_INVALID",
///        "CLIENT_TRADE_ID_ALREADY_EXISTS",
///        "CLIENT_TRADE_TAG_INVALID",
///        "CLIENT_TRADE_COMMENT_INVALID",
///        "ORDER_FILL_POSITION_ACTION_MISSING",
///        "ORDER_FILL_POSITION_ACTION_INVALID",
///        "TRIGGER_CONDITION_MISSING",
///        "TRIGGER_CONDITION_INVALID",
///        "ORDER_PARTIAL_FILL_OPTION_MISSING",
///        "ORDER_PARTIAL_FILL_OPTION_INVALID",
///        "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL",
///        "TAKE_PROFIT_ORDER_ALREADY_EXISTS",
///        "TAKE_PROFIT_ON_FILL_PRICE_MISSING",
///        "TAKE_PROFIT_ON_FILL_PRICE_INVALID",
///        "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED",
///        "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING",
///        "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID",
///        "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "STOP_LOSS_ORDER_ALREADY_EXISTS",
///        "STOP_LOSS_ORDER_GUARANTEED_REQUIRED",
///        "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD",
///        "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED",
///        "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION",
///        "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION",
///        "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED",
///        "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///        "STOP_LOSS_ORDER_NOT_CANCELABLE",
///        "STOP_LOSS_ORDER_NOT_REPLACEABLE",
///        "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///        "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///        "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING",
///        "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER",
///        "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///        "STOP_LOSS_ON_FILL_PRICE_MISSING",
///        "STOP_LOSS_ON_FILL_PRICE_INVALID",
///        "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///        "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_DISTANCE_INVALID",
///        "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///        "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING",
///        "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///        "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///        "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET",
///        "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED",
///        "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "CLOSE_TRADE_TYPE_MISSING",
///        "CLOSE_TRADE_PARTIAL_UNITS_MISSING",
///        "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE",
///        "CLOSEOUT_POSITION_DOESNT_EXIST",
///        "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION",
///        "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE",
///        "CLOSEOUT_POSITION_REJECT",
///        "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING",
///        "MARKUP_GROUP_ID_INVALID",
///        "POSITION_AGGREGATION_MODE_INVALID",
///        "ADMIN_CONFIGURE_DATA_MISSING",
///        "MARGIN_RATE_INVALID",
///        "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT",
///        "ALIAS_INVALID",
///        "CLIENT_CONFIGURE_DATA_MISSING",
///        "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL",
///        "AMOUNT_INVALID",
///        "INSUFFICIENT_FUNDS",
///        "AMOUNT_MISSING",
///        "FUNDING_REASON_MISSING",
///        "CLIENT_EXTENSIONS_DATA_MISSING",
///        "REPLACING_ORDER_INVALID",
///        "REPLACING_TRADE_ID_INVALID"
///      ]
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "tradeClientExtensionsModify": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT\" for a
/// OrderClientExtensionsModifyRejectTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OrderClientExtensionsModifyRejectTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    #[serde(
        rename = "clientExtensionsModify",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions_modify: Option<ClientExtensions>,
    ///The original Client ID of the Order who's client extensions are to
    /// be modified.
    #[serde(
        rename = "clientOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_order_id: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The ID of the Order who's client extensions are to be modified.
    #[serde(rename = "orderID", default, skip_serializing_if = "Option::is_none")]
    pub order_id: Option<String>,
    ///The reason that the Reject Transaction was created
    #[serde(
        rename = "rejectReason",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub reject_reason: Option<OrderClientExtensionsModifyRejectTransactionRejectReason>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    #[serde(
        rename = "tradeClientExtensionsModify",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions_modify: Option<ClientExtensions>,
    ///The Type of the Transaction. Always set to
    /// "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" for a
    /// OrderClientExtensionsModifyRejectTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<OrderClientExtensionsModifyRejectTransactionType>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&OrderClientExtensionsModifyRejectTransaction>
    for OrderClientExtensionsModifyRejectTransaction
{
    fn from(value: &OrderClientExtensionsModifyRejectTransaction) -> Self {
        value.clone()
    }
}

impl OrderClientExtensionsModifyRejectTransaction {
    pub fn builder() -> builder::OrderClientExtensionsModifyRejectTransaction {
        Default::default()
    }
}

///The reason that the Reject Transaction was created
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Reject Transaction was created",
///  "type": "string",
///  "enum": [
///    "INTERNAL_SERVER_ERROR",
///    "INSTRUMENT_PRICE_UNKNOWN",
///    "ACCOUNT_NOT_ACTIVE",
///    "ACCOUNT_LOCKED",
///    "ACCOUNT_ORDER_CREATION_LOCKED",
///    "ACCOUNT_CONFIGURATION_LOCKED",
///    "ACCOUNT_DEPOSIT_LOCKED",
///    "ACCOUNT_WITHDRAWAL_LOCKED",
///    "ACCOUNT_ORDER_CANCEL_LOCKED",
///    "INSTRUMENT_NOT_TRADEABLE",
///    "PENDING_ORDERS_ALLOWED_EXCEEDED",
///    "ORDER_ID_UNSPECIFIED",
///    "ORDER_DOESNT_EXIST",
///    "ORDER_IDENTIFIER_INCONSISTENCY",
///    "TRADE_ID_UNSPECIFIED",
///    "TRADE_DOESNT_EXIST",
///    "TRADE_IDENTIFIER_INCONSISTENCY",
///    "INSUFFICIENT_MARGIN",
///    "INSTRUMENT_MISSING",
///    "INSTRUMENT_UNKNOWN",
///    "UNITS_MISSING",
///    "UNITS_INVALID",
///    "UNITS_PRECISION_EXCEEDED",
///    "UNITS_LIMIT_EXCEEDED",
///    "UNITS_MIMIMUM_NOT_MET",
///    "PRICE_MISSING",
///    "PRICE_INVALID",
///    "PRICE_PRECISION_EXCEEDED",
///    "PRICE_DISTANCE_MISSING",
///    "PRICE_DISTANCE_INVALID",
///    "PRICE_DISTANCE_PRECISION_EXCEEDED",
///    "PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "PRICE_DISTANCE_MINIMUM_NOT_MET",
///    "TIME_IN_FORCE_MISSING",
///    "TIME_IN_FORCE_INVALID",
///    "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING",
///    "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST",
///    "PRICE_BOUND_INVALID",
///    "PRICE_BOUND_PRECISION_EXCEEDED",
///    "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS",
///    "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED",
///    "CLIENT_ORDER_ID_INVALID",
///    "CLIENT_ORDER_ID_ALREADY_EXISTS",
///    "CLIENT_ORDER_TAG_INVALID",
///    "CLIENT_ORDER_COMMENT_INVALID",
///    "CLIENT_TRADE_ID_INVALID",
///    "CLIENT_TRADE_ID_ALREADY_EXISTS",
///    "CLIENT_TRADE_TAG_INVALID",
///    "CLIENT_TRADE_COMMENT_INVALID",
///    "ORDER_FILL_POSITION_ACTION_MISSING",
///    "ORDER_FILL_POSITION_ACTION_INVALID",
///    "TRIGGER_CONDITION_MISSING",
///    "TRIGGER_CONDITION_INVALID",
///    "ORDER_PARTIAL_FILL_OPTION_MISSING",
///    "ORDER_PARTIAL_FILL_OPTION_INVALID",
///    "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL",
///    "TAKE_PROFIT_ORDER_ALREADY_EXISTS",
///    "TAKE_PROFIT_ON_FILL_PRICE_MISSING",
///    "TAKE_PROFIT_ON_FILL_PRICE_INVALID",
///    "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED",
///    "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING",
///    "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "STOP_LOSS_ORDER_ALREADY_EXISTS",
///    "STOP_LOSS_ORDER_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD",
///    "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION",
///    "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION",
///    "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED",
///    "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ORDER_NOT_CANCELABLE",
///    "STOP_LOSS_ORDER_NOT_REPLACEABLE",
///    "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///    "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING",
///    "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER",
///    "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ON_FILL_PRICE_MISSING",
///    "STOP_LOSS_ON_FILL_PRICE_INVALID",
///    "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_DISTANCE_INVALID",
///    "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///    "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET",
///    "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED",
///    "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "CLOSE_TRADE_TYPE_MISSING",
///    "CLOSE_TRADE_PARTIAL_UNITS_MISSING",
///    "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE",
///    "CLOSEOUT_POSITION_DOESNT_EXIST",
///    "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION",
///    "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE",
///    "CLOSEOUT_POSITION_REJECT",
///    "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING",
///    "MARKUP_GROUP_ID_INVALID",
///    "POSITION_AGGREGATION_MODE_INVALID",
///    "ADMIN_CONFIGURE_DATA_MISSING",
///    "MARGIN_RATE_INVALID",
///    "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT",
///    "ALIAS_INVALID",
///    "CLIENT_CONFIGURE_DATA_MISSING",
///    "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL",
///    "AMOUNT_INVALID",
///    "INSUFFICIENT_FUNDS",
///    "AMOUNT_MISSING",
///    "FUNDING_REASON_MISSING",
///    "CLIENT_EXTENSIONS_DATA_MISSING",
///    "REPLACING_ORDER_INVALID",
///    "REPLACING_TRADE_ID_INVALID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrderClientExtensionsModifyRejectTransactionRejectReason {
    #[serde(rename = "INTERNAL_SERVER_ERROR")]
    InternalServerError,
    #[serde(rename = "INSTRUMENT_PRICE_UNKNOWN")]
    InstrumentPriceUnknown,
    #[serde(rename = "ACCOUNT_NOT_ACTIVE")]
    AccountNotActive,
    #[serde(rename = "ACCOUNT_LOCKED")]
    AccountLocked,
    #[serde(rename = "ACCOUNT_ORDER_CREATION_LOCKED")]
    AccountOrderCreationLocked,
    #[serde(rename = "ACCOUNT_CONFIGURATION_LOCKED")]
    AccountConfigurationLocked,
    #[serde(rename = "ACCOUNT_DEPOSIT_LOCKED")]
    AccountDepositLocked,
    #[serde(rename = "ACCOUNT_WITHDRAWAL_LOCKED")]
    AccountWithdrawalLocked,
    #[serde(rename = "ACCOUNT_ORDER_CANCEL_LOCKED")]
    AccountOrderCancelLocked,
    #[serde(rename = "INSTRUMENT_NOT_TRADEABLE")]
    InstrumentNotTradeable,
    #[serde(rename = "PENDING_ORDERS_ALLOWED_EXCEEDED")]
    PendingOrdersAllowedExceeded,
    #[serde(rename = "ORDER_ID_UNSPECIFIED")]
    OrderIdUnspecified,
    #[serde(rename = "ORDER_DOESNT_EXIST")]
    OrderDoesntExist,
    #[serde(rename = "ORDER_IDENTIFIER_INCONSISTENCY")]
    OrderIdentifierInconsistency,
    #[serde(rename = "TRADE_ID_UNSPECIFIED")]
    TradeIdUnspecified,
    #[serde(rename = "TRADE_DOESNT_EXIST")]
    TradeDoesntExist,
    #[serde(rename = "TRADE_IDENTIFIER_INCONSISTENCY")]
    TradeIdentifierInconsistency,
    #[serde(rename = "INSUFFICIENT_MARGIN")]
    InsufficientMargin,
    #[serde(rename = "INSTRUMENT_MISSING")]
    InstrumentMissing,
    #[serde(rename = "INSTRUMENT_UNKNOWN")]
    InstrumentUnknown,
    #[serde(rename = "UNITS_MISSING")]
    UnitsMissing,
    #[serde(rename = "UNITS_INVALID")]
    UnitsInvalid,
    #[serde(rename = "UNITS_PRECISION_EXCEEDED")]
    UnitsPrecisionExceeded,
    #[serde(rename = "UNITS_LIMIT_EXCEEDED")]
    UnitsLimitExceeded,
    #[serde(rename = "UNITS_MIMIMUM_NOT_MET")]
    UnitsMimimumNotMet,
    #[serde(rename = "PRICE_MISSING")]
    PriceMissing,
    #[serde(rename = "PRICE_INVALID")]
    PriceInvalid,
    #[serde(rename = "PRICE_PRECISION_EXCEEDED")]
    PricePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MISSING")]
    PriceDistanceMissing,
    #[serde(rename = "PRICE_DISTANCE_INVALID")]
    PriceDistanceInvalid,
    #[serde(rename = "PRICE_DISTANCE_PRECISION_EXCEEDED")]
    PriceDistancePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    PriceDistanceMaximumExceeded,
    #[serde(rename = "PRICE_DISTANCE_MINIMUM_NOT_MET")]
    PriceDistanceMinimumNotMet,
    #[serde(rename = "TIME_IN_FORCE_MISSING")]
    TimeInForceMissing,
    #[serde(rename = "TIME_IN_FORCE_INVALID")]
    TimeInForceInvalid,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING")]
    TimeInForceGtdTimestampMissing,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST")]
    TimeInForceGtdTimestampInPast,
    #[serde(rename = "PRICE_BOUND_INVALID")]
    PriceBoundInvalid,
    #[serde(rename = "PRICE_BOUND_PRECISION_EXCEEDED")]
    PriceBoundPrecisionExceeded,
    #[serde(rename = "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS")]
    OrdersOnFillDuplicateClientOrderIds,
    #[serde(rename = "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED")]
    TradeOnFillClientExtensionsNotSupported,
    #[serde(rename = "CLIENT_ORDER_ID_INVALID")]
    ClientOrderIdInvalid,
    #[serde(rename = "CLIENT_ORDER_ID_ALREADY_EXISTS")]
    ClientOrderIdAlreadyExists,
    #[serde(rename = "CLIENT_ORDER_TAG_INVALID")]
    ClientOrderTagInvalid,
    #[serde(rename = "CLIENT_ORDER_COMMENT_INVALID")]
    ClientOrderCommentInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_INVALID")]
    ClientTradeIdInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_ALREADY_EXISTS")]
    ClientTradeIdAlreadyExists,
    #[serde(rename = "CLIENT_TRADE_TAG_INVALID")]
    ClientTradeTagInvalid,
    #[serde(rename = "CLIENT_TRADE_COMMENT_INVALID")]
    ClientTradeCommentInvalid,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_MISSING")]
    OrderFillPositionActionMissing,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_INVALID")]
    OrderFillPositionActionInvalid,
    #[serde(rename = "TRIGGER_CONDITION_MISSING")]
    TriggerConditionMissing,
    #[serde(rename = "TRIGGER_CONDITION_INVALID")]
    TriggerConditionInvalid,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_MISSING")]
    OrderPartialFillOptionMissing,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_INVALID")]
    OrderPartialFillOptionInvalid,
    #[serde(rename = "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL")]
    InvalidReissueImmediatePartialFill,
    #[serde(rename = "TAKE_PROFIT_ORDER_ALREADY_EXISTS")]
    TakeProfitOrderAlreadyExists,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_MISSING")]
    TakeProfitOnFillPriceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_INVALID")]
    TakeProfitOnFillPriceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    TakeProfitOnFillPricePrecisionExceeded,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING")]
    TakeProfitOnFillTimeInForceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID")]
    TakeProfitOnFillTimeInForceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TakeProfitOnFillGtdTimestampMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TakeProfitOnFillGtdTimestampInPast,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TakeProfitOnFillClientOrderIdInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TakeProfitOnFillClientOrderTagInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TakeProfitOnFillClientOrderCommentInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TakeProfitOnFillTriggerConditionMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TakeProfitOnFillTriggerConditionInvalid,
    #[serde(rename = "STOP_LOSS_ORDER_ALREADY_EXISTS")]
    StopLossOrderAlreadyExists,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_REQUIRED")]
    StopLossOrderGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD")]
    StopLossOrderGuaranteedPriceWithinSpread,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED")]
    StopLossOrderGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION")]
    StopLossOrderGuaranteedHaltedCreateViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION")]
    StopLossOrderGuaranteedHaltedTightenViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED")]
    StopLossOrderGuaranteedHedgingNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOrderGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_CANCELABLE")]
    StopLossOrderNotCancelable,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_REPLACEABLE")]
    StopLossOrderNotReplaceable,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOrderGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOrderPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOrderPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER")]
    StopLossOnFillRequiredForPendingOrder,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED")]
    StopLossOnFillGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED")]
    StopLossOnFillGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_MISSING")]
    StopLossOnFillPriceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_INVALID")]
    StopLossOnFillPriceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    StopLossOnFillPricePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOnFillGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOnFillGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_INVALID")]
    StopLossOnFillDistanceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    StopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED")]
    StopLossOnFillDistancePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOnFillPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOnFillPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    StopLossOnFillTimeInForceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    StopLossOnFillTimeInForceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    StopLossOnFillGtdTimestampMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    StopLossOnFillGtdTimestampInPast,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    StopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    StopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    StopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    StopLossOnFillTriggerConditionMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    StopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS")]
    TrailingStopLossOrderAlreadyExists,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING")]
    TrailingStopLossOnFillPriceDistanceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID")]
    TrailingStopLossOnFillPriceDistanceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED")]
    TrailingStopLossOnFillPriceDistancePrecisionExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    TrailingStopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET")]
    TrailingStopLossOnFillPriceDistanceMinimumNotMet,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    TrailingStopLossOnFillTimeInForceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    TrailingStopLossOnFillTimeInForceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TrailingStopLossOnFillGtdTimestampMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TrailingStopLossOnFillGtdTimestampInPast,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TrailingStopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TrailingStopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TrailingStopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED")]
    TrailingStopLossOrdersNotSupported,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TrailingStopLossOnFillTriggerConditionMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TrailingStopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "CLOSE_TRADE_TYPE_MISSING")]
    CloseTradeTypeMissing,
    #[serde(rename = "CLOSE_TRADE_PARTIAL_UNITS_MISSING")]
    CloseTradePartialUnitsMissing,
    #[serde(rename = "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE")]
    CloseTradeUnitsExceedTradeSize,
    #[serde(rename = "CLOSEOUT_POSITION_DOESNT_EXIST")]
    CloseoutPositionDoesntExist,
    #[serde(rename = "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION")]
    CloseoutPositionIncompleteSpecification,
    #[serde(rename = "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE")]
    CloseoutPositionUnitsExceedPositionSize,
    #[serde(rename = "CLOSEOUT_POSITION_REJECT")]
    CloseoutPositionReject,
    #[serde(rename = "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING")]
    CloseoutPositionPartialUnitsMissing,
    #[serde(rename = "MARKUP_GROUP_ID_INVALID")]
    MarkupGroupIdInvalid,
    #[serde(rename = "POSITION_AGGREGATION_MODE_INVALID")]
    PositionAggregationModeInvalid,
    #[serde(rename = "ADMIN_CONFIGURE_DATA_MISSING")]
    AdminConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_INVALID")]
    MarginRateInvalid,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT")]
    MarginRateWouldTriggerCloseout,
    #[serde(rename = "ALIAS_INVALID")]
    AliasInvalid,
    #[serde(rename = "CLIENT_CONFIGURE_DATA_MISSING")]
    ClientConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL")]
    MarginRateWouldTriggerMarginCall,
    #[serde(rename = "AMOUNT_INVALID")]
    AmountInvalid,
    #[serde(rename = "INSUFFICIENT_FUNDS")]
    InsufficientFunds,
    #[serde(rename = "AMOUNT_MISSING")]
    AmountMissing,
    #[serde(rename = "FUNDING_REASON_MISSING")]
    FundingReasonMissing,
    #[serde(rename = "CLIENT_EXTENSIONS_DATA_MISSING")]
    ClientExtensionsDataMissing,
    #[serde(rename = "REPLACING_ORDER_INVALID")]
    ReplacingOrderInvalid,
    #[serde(rename = "REPLACING_TRADE_ID_INVALID")]
    ReplacingTradeIdInvalid,
}

impl From<&OrderClientExtensionsModifyRejectTransactionRejectReason>
    for OrderClientExtensionsModifyRejectTransactionRejectReason
{
    fn from(value: &OrderClientExtensionsModifyRejectTransactionRejectReason) -> Self {
        value.clone()
    }
}

impl ToString for OrderClientExtensionsModifyRejectTransactionRejectReason {
    fn to_string(&self) -> String {
        match *self {
            Self::InternalServerError => "INTERNAL_SERVER_ERROR".to_string(),
            Self::InstrumentPriceUnknown => "INSTRUMENT_PRICE_UNKNOWN".to_string(),
            Self::AccountNotActive => "ACCOUNT_NOT_ACTIVE".to_string(),
            Self::AccountLocked => "ACCOUNT_LOCKED".to_string(),
            Self::AccountOrderCreationLocked => "ACCOUNT_ORDER_CREATION_LOCKED".to_string(),
            Self::AccountConfigurationLocked => "ACCOUNT_CONFIGURATION_LOCKED".to_string(),
            Self::AccountDepositLocked => "ACCOUNT_DEPOSIT_LOCKED".to_string(),
            Self::AccountWithdrawalLocked => "ACCOUNT_WITHDRAWAL_LOCKED".to_string(),
            Self::AccountOrderCancelLocked => "ACCOUNT_ORDER_CANCEL_LOCKED".to_string(),
            Self::InstrumentNotTradeable => "INSTRUMENT_NOT_TRADEABLE".to_string(),
            Self::PendingOrdersAllowedExceeded => "PENDING_ORDERS_ALLOWED_EXCEEDED".to_string(),
            Self::OrderIdUnspecified => "ORDER_ID_UNSPECIFIED".to_string(),
            Self::OrderDoesntExist => "ORDER_DOESNT_EXIST".to_string(),
            Self::OrderIdentifierInconsistency => "ORDER_IDENTIFIER_INCONSISTENCY".to_string(),
            Self::TradeIdUnspecified => "TRADE_ID_UNSPECIFIED".to_string(),
            Self::TradeDoesntExist => "TRADE_DOESNT_EXIST".to_string(),
            Self::TradeIdentifierInconsistency => "TRADE_IDENTIFIER_INCONSISTENCY".to_string(),
            Self::InsufficientMargin => "INSUFFICIENT_MARGIN".to_string(),
            Self::InstrumentMissing => "INSTRUMENT_MISSING".to_string(),
            Self::InstrumentUnknown => "INSTRUMENT_UNKNOWN".to_string(),
            Self::UnitsMissing => "UNITS_MISSING".to_string(),
            Self::UnitsInvalid => "UNITS_INVALID".to_string(),
            Self::UnitsPrecisionExceeded => "UNITS_PRECISION_EXCEEDED".to_string(),
            Self::UnitsLimitExceeded => "UNITS_LIMIT_EXCEEDED".to_string(),
            Self::UnitsMimimumNotMet => "UNITS_MIMIMUM_NOT_MET".to_string(),
            Self::PriceMissing => "PRICE_MISSING".to_string(),
            Self::PriceInvalid => "PRICE_INVALID".to_string(),
            Self::PricePrecisionExceeded => "PRICE_PRECISION_EXCEEDED".to_string(),
            Self::PriceDistanceMissing => "PRICE_DISTANCE_MISSING".to_string(),
            Self::PriceDistanceInvalid => "PRICE_DISTANCE_INVALID".to_string(),
            Self::PriceDistancePrecisionExceeded => "PRICE_DISTANCE_PRECISION_EXCEEDED".to_string(),
            Self::PriceDistanceMaximumExceeded => "PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string(),
            Self::PriceDistanceMinimumNotMet => "PRICE_DISTANCE_MINIMUM_NOT_MET".to_string(),
            Self::TimeInForceMissing => "TIME_IN_FORCE_MISSING".to_string(),
            Self::TimeInForceInvalid => "TIME_IN_FORCE_INVALID".to_string(),
            Self::TimeInForceGtdTimestampMissing => {
                "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TimeInForceGtdTimestampInPast => {
                "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::PriceBoundInvalid => "PRICE_BOUND_INVALID".to_string(),
            Self::PriceBoundPrecisionExceeded => "PRICE_BOUND_PRECISION_EXCEEDED".to_string(),
            Self::OrdersOnFillDuplicateClientOrderIds => {
                "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS".to_string()
            }
            Self::TradeOnFillClientExtensionsNotSupported => {
                "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED".to_string()
            }
            Self::ClientOrderIdInvalid => "CLIENT_ORDER_ID_INVALID".to_string(),
            Self::ClientOrderIdAlreadyExists => "CLIENT_ORDER_ID_ALREADY_EXISTS".to_string(),
            Self::ClientOrderTagInvalid => "CLIENT_ORDER_TAG_INVALID".to_string(),
            Self::ClientOrderCommentInvalid => "CLIENT_ORDER_COMMENT_INVALID".to_string(),
            Self::ClientTradeIdInvalid => "CLIENT_TRADE_ID_INVALID".to_string(),
            Self::ClientTradeIdAlreadyExists => "CLIENT_TRADE_ID_ALREADY_EXISTS".to_string(),
            Self::ClientTradeTagInvalid => "CLIENT_TRADE_TAG_INVALID".to_string(),
            Self::ClientTradeCommentInvalid => "CLIENT_TRADE_COMMENT_INVALID".to_string(),
            Self::OrderFillPositionActionMissing => {
                "ORDER_FILL_POSITION_ACTION_MISSING".to_string()
            }
            Self::OrderFillPositionActionInvalid => {
                "ORDER_FILL_POSITION_ACTION_INVALID".to_string()
            }
            Self::TriggerConditionMissing => "TRIGGER_CONDITION_MISSING".to_string(),
            Self::TriggerConditionInvalid => "TRIGGER_CONDITION_INVALID".to_string(),
            Self::OrderPartialFillOptionMissing => "ORDER_PARTIAL_FILL_OPTION_MISSING".to_string(),
            Self::OrderPartialFillOptionInvalid => "ORDER_PARTIAL_FILL_OPTION_INVALID".to_string(),
            Self::InvalidReissueImmediatePartialFill => {
                "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL".to_string()
            }
            Self::TakeProfitOrderAlreadyExists => "TAKE_PROFIT_ORDER_ALREADY_EXISTS".to_string(),
            Self::TakeProfitOnFillPriceMissing => "TAKE_PROFIT_ON_FILL_PRICE_MISSING".to_string(),
            Self::TakeProfitOnFillPriceInvalid => "TAKE_PROFIT_ON_FILL_PRICE_INVALID".to_string(),
            Self::TakeProfitOnFillPricePrecisionExceeded => {
                "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED".to_string()
            }
            Self::TakeProfitOnFillTimeInForceMissing => {
                "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::TakeProfitOnFillTimeInForceInvalid => {
                "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::TakeProfitOnFillGtdTimestampMissing => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TakeProfitOnFillGtdTimestampInPast => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TakeProfitOnFillClientOrderIdInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::TakeProfitOnFillClientOrderTagInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::TakeProfitOnFillClientOrderCommentInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::TakeProfitOnFillTriggerConditionMissing => {
                "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::TakeProfitOnFillTriggerConditionInvalid => {
                "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::StopLossOrderAlreadyExists => "STOP_LOSS_ORDER_ALREADY_EXISTS".to_string(),
            Self::StopLossOrderGuaranteedRequired => {
                "STOP_LOSS_ORDER_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOrderGuaranteedPriceWithinSpread => {
                "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD".to_string()
            }
            Self::StopLossOrderGuaranteedNotAllowed => {
                "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOrderGuaranteedHaltedCreateViolation => {
                "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION".to_string()
            }
            Self::StopLossOrderGuaranteedHaltedTightenViolation => {
                "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION".to_string()
            }
            Self::StopLossOrderGuaranteedHedgingNotAllowed => {
                "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED".to_string()
            }
            Self::StopLossOrderGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOrderNotCancelable => "STOP_LOSS_ORDER_NOT_CANCELABLE".to_string(),
            Self::StopLossOrderNotReplaceable => "STOP_LOSS_ORDER_NOT_REPLACEABLE".to_string(),
            Self::StopLossOrderGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOrderPriceAndDistanceBothSpecified => {
                "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED".to_string()
            }
            Self::StopLossOrderPriceAndDistanceBothMissing => {
                "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING".to_string()
            }
            Self::StopLossOnFillRequiredForPendingOrder => {
                "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER".to_string()
            }
            Self::StopLossOnFillGuaranteedNotAllowed => {
                "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOnFillGuaranteedRequired => {
                "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOnFillPriceMissing => "STOP_LOSS_ON_FILL_PRICE_MISSING".to_string(),
            Self::StopLossOnFillPriceInvalid => "STOP_LOSS_ON_FILL_PRICE_INVALID".to_string(),
            Self::StopLossOnFillPricePrecisionExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOnFillGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillDistanceInvalid => "STOP_LOSS_ON_FILL_DISTANCE_INVALID".to_string(),
            Self::StopLossOnFillPriceDistanceMaximumExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::StopLossOnFillDistancePrecisionExceeded => {
                "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillPriceAndDistanceBothSpecified => {
                "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED".to_string()
            }
            Self::StopLossOnFillPriceAndDistanceBothMissing => {
                "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING".to_string()
            }
            Self::StopLossOnFillTimeInForceMissing => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::StopLossOnFillTimeInForceInvalid => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::StopLossOnFillGtdTimestampMissing => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::StopLossOnFillGtdTimestampInPast => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::StopLossOnFillClientOrderIdInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::StopLossOnFillClientOrderTagInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::StopLossOnFillClientOrderCommentInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::StopLossOnFillTriggerConditionMissing => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::StopLossOnFillTriggerConditionInvalid => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::TrailingStopLossOrderAlreadyExists => {
                "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistancePrecisionExceeded => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMaximumExceeded => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMinimumNotMet => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET".to_string()
            }
            Self::TrailingStopLossOnFillTimeInForceMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillTimeInForceInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampInPast => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderIdInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderTagInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderCommentInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::TrailingStopLossOrdersNotSupported => {
                "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED".to_string()
            }
            Self::TrailingStopLossOnFillTriggerConditionMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillTriggerConditionInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::CloseTradeTypeMissing => "CLOSE_TRADE_TYPE_MISSING".to_string(),
            Self::CloseTradePartialUnitsMissing => "CLOSE_TRADE_PARTIAL_UNITS_MISSING".to_string(),
            Self::CloseTradeUnitsExceedTradeSize => {
                "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE".to_string()
            }
            Self::CloseoutPositionDoesntExist => "CLOSEOUT_POSITION_DOESNT_EXIST".to_string(),
            Self::CloseoutPositionIncompleteSpecification => {
                "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION".to_string()
            }
            Self::CloseoutPositionUnitsExceedPositionSize => {
                "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE".to_string()
            }
            Self::CloseoutPositionReject => "CLOSEOUT_POSITION_REJECT".to_string(),
            Self::CloseoutPositionPartialUnitsMissing => {
                "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING".to_string()
            }
            Self::MarkupGroupIdInvalid => "MARKUP_GROUP_ID_INVALID".to_string(),
            Self::PositionAggregationModeInvalid => "POSITION_AGGREGATION_MODE_INVALID".to_string(),
            Self::AdminConfigureDataMissing => "ADMIN_CONFIGURE_DATA_MISSING".to_string(),
            Self::MarginRateInvalid => "MARGIN_RATE_INVALID".to_string(),
            Self::MarginRateWouldTriggerCloseout => {
                "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT".to_string()
            }
            Self::AliasInvalid => "ALIAS_INVALID".to_string(),
            Self::ClientConfigureDataMissing => "CLIENT_CONFIGURE_DATA_MISSING".to_string(),
            Self::MarginRateWouldTriggerMarginCall => {
                "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL".to_string()
            }
            Self::AmountInvalid => "AMOUNT_INVALID".to_string(),
            Self::InsufficientFunds => "INSUFFICIENT_FUNDS".to_string(),
            Self::AmountMissing => "AMOUNT_MISSING".to_string(),
            Self::FundingReasonMissing => "FUNDING_REASON_MISSING".to_string(),
            Self::ClientExtensionsDataMissing => "CLIENT_EXTENSIONS_DATA_MISSING".to_string(),
            Self::ReplacingOrderInvalid => "REPLACING_ORDER_INVALID".to_string(),
            Self::ReplacingTradeIdInvalid => "REPLACING_TRADE_ID_INVALID".to_string(),
        }
    }
}

impl std::str::FromStr for OrderClientExtensionsModifyRejectTransactionRejectReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "INTERNAL_SERVER_ERROR" => Ok(Self::InternalServerError),
            "INSTRUMENT_PRICE_UNKNOWN" => Ok(Self::InstrumentPriceUnknown),
            "ACCOUNT_NOT_ACTIVE" => Ok(Self::AccountNotActive),
            "ACCOUNT_LOCKED" => Ok(Self::AccountLocked),
            "ACCOUNT_ORDER_CREATION_LOCKED" => Ok(Self::AccountOrderCreationLocked),
            "ACCOUNT_CONFIGURATION_LOCKED" => Ok(Self::AccountConfigurationLocked),
            "ACCOUNT_DEPOSIT_LOCKED" => Ok(Self::AccountDepositLocked),
            "ACCOUNT_WITHDRAWAL_LOCKED" => Ok(Self::AccountWithdrawalLocked),
            "ACCOUNT_ORDER_CANCEL_LOCKED" => Ok(Self::AccountOrderCancelLocked),
            "INSTRUMENT_NOT_TRADEABLE" => Ok(Self::InstrumentNotTradeable),
            "PENDING_ORDERS_ALLOWED_EXCEEDED" => Ok(Self::PendingOrdersAllowedExceeded),
            "ORDER_ID_UNSPECIFIED" => Ok(Self::OrderIdUnspecified),
            "ORDER_DOESNT_EXIST" => Ok(Self::OrderDoesntExist),
            "ORDER_IDENTIFIER_INCONSISTENCY" => Ok(Self::OrderIdentifierInconsistency),
            "TRADE_ID_UNSPECIFIED" => Ok(Self::TradeIdUnspecified),
            "TRADE_DOESNT_EXIST" => Ok(Self::TradeDoesntExist),
            "TRADE_IDENTIFIER_INCONSISTENCY" => Ok(Self::TradeIdentifierInconsistency),
            "INSUFFICIENT_MARGIN" => Ok(Self::InsufficientMargin),
            "INSTRUMENT_MISSING" => Ok(Self::InstrumentMissing),
            "INSTRUMENT_UNKNOWN" => Ok(Self::InstrumentUnknown),
            "UNITS_MISSING" => Ok(Self::UnitsMissing),
            "UNITS_INVALID" => Ok(Self::UnitsInvalid),
            "UNITS_PRECISION_EXCEEDED" => Ok(Self::UnitsPrecisionExceeded),
            "UNITS_LIMIT_EXCEEDED" => Ok(Self::UnitsLimitExceeded),
            "UNITS_MIMIMUM_NOT_MET" => Ok(Self::UnitsMimimumNotMet),
            "PRICE_MISSING" => Ok(Self::PriceMissing),
            "PRICE_INVALID" => Ok(Self::PriceInvalid),
            "PRICE_PRECISION_EXCEEDED" => Ok(Self::PricePrecisionExceeded),
            "PRICE_DISTANCE_MISSING" => Ok(Self::PriceDistanceMissing),
            "PRICE_DISTANCE_INVALID" => Ok(Self::PriceDistanceInvalid),
            "PRICE_DISTANCE_PRECISION_EXCEEDED" => Ok(Self::PriceDistancePrecisionExceeded),
            "PRICE_DISTANCE_MAXIMUM_EXCEEDED" => Ok(Self::PriceDistanceMaximumExceeded),
            "PRICE_DISTANCE_MINIMUM_NOT_MET" => Ok(Self::PriceDistanceMinimumNotMet),
            "TIME_IN_FORCE_MISSING" => Ok(Self::TimeInForceMissing),
            "TIME_IN_FORCE_INVALID" => Ok(Self::TimeInForceInvalid),
            "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING" => Ok(Self::TimeInForceGtdTimestampMissing),
            "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST" => Ok(Self::TimeInForceGtdTimestampInPast),
            "PRICE_BOUND_INVALID" => Ok(Self::PriceBoundInvalid),
            "PRICE_BOUND_PRECISION_EXCEEDED" => Ok(Self::PriceBoundPrecisionExceeded),
            "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS" => {
                Ok(Self::OrdersOnFillDuplicateClientOrderIds)
            }
            "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED" => {
                Ok(Self::TradeOnFillClientExtensionsNotSupported)
            }
            "CLIENT_ORDER_ID_INVALID" => Ok(Self::ClientOrderIdInvalid),
            "CLIENT_ORDER_ID_ALREADY_EXISTS" => Ok(Self::ClientOrderIdAlreadyExists),
            "CLIENT_ORDER_TAG_INVALID" => Ok(Self::ClientOrderTagInvalid),
            "CLIENT_ORDER_COMMENT_INVALID" => Ok(Self::ClientOrderCommentInvalid),
            "CLIENT_TRADE_ID_INVALID" => Ok(Self::ClientTradeIdInvalid),
            "CLIENT_TRADE_ID_ALREADY_EXISTS" => Ok(Self::ClientTradeIdAlreadyExists),
            "CLIENT_TRADE_TAG_INVALID" => Ok(Self::ClientTradeTagInvalid),
            "CLIENT_TRADE_COMMENT_INVALID" => Ok(Self::ClientTradeCommentInvalid),
            "ORDER_FILL_POSITION_ACTION_MISSING" => Ok(Self::OrderFillPositionActionMissing),
            "ORDER_FILL_POSITION_ACTION_INVALID" => Ok(Self::OrderFillPositionActionInvalid),
            "TRIGGER_CONDITION_MISSING" => Ok(Self::TriggerConditionMissing),
            "TRIGGER_CONDITION_INVALID" => Ok(Self::TriggerConditionInvalid),
            "ORDER_PARTIAL_FILL_OPTION_MISSING" => Ok(Self::OrderPartialFillOptionMissing),
            "ORDER_PARTIAL_FILL_OPTION_INVALID" => Ok(Self::OrderPartialFillOptionInvalid),
            "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL" => {
                Ok(Self::InvalidReissueImmediatePartialFill)
            }
            "TAKE_PROFIT_ORDER_ALREADY_EXISTS" => Ok(Self::TakeProfitOrderAlreadyExists),
            "TAKE_PROFIT_ON_FILL_PRICE_MISSING" => Ok(Self::TakeProfitOnFillPriceMissing),
            "TAKE_PROFIT_ON_FILL_PRICE_INVALID" => Ok(Self::TakeProfitOnFillPriceInvalid),
            "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(Self::TakeProfitOnFillPricePrecisionExceeded)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(Self::TakeProfitOnFillTimeInForceMissing)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(Self::TakeProfitOnFillTimeInForceInvalid)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::TakeProfitOnFillGtdTimestampMissing)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TakeProfitOnFillGtdTimestampInPast)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderIdInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderTagInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderCommentInvalid)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::TakeProfitOnFillTriggerConditionMissing)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::TakeProfitOnFillTriggerConditionInvalid)
            }
            "STOP_LOSS_ORDER_ALREADY_EXISTS" => Ok(Self::StopLossOrderAlreadyExists),
            "STOP_LOSS_ORDER_GUARANTEED_REQUIRED" => Ok(Self::StopLossOrderGuaranteedRequired),
            "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD" => {
                Ok(Self::StopLossOrderGuaranteedPriceWithinSpread)
            }
            "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED" => Ok(Self::StopLossOrderGuaranteedNotAllowed),
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION" => {
                Ok(Self::StopLossOrderGuaranteedHaltedCreateViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION" => {
                Ok(Self::StopLossOrderGuaranteedHaltedTightenViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED" => {
                Ok(Self::StopLossOrderGuaranteedHedgingNotAllowed)
            }
            "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOrderGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ORDER_NOT_CANCELABLE" => Ok(Self::StopLossOrderNotCancelable),
            "STOP_LOSS_ORDER_NOT_REPLACEABLE" => Ok(Self::StopLossOrderNotReplaceable),
            "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOrderGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(Self::StopLossOrderPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(Self::StopLossOrderPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER" => {
                Ok(Self::StopLossOnFillRequiredForPendingOrder)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED" => {
                Ok(Self::StopLossOnFillGuaranteedNotAllowed)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED" => Ok(Self::StopLossOnFillGuaranteedRequired),
            "STOP_LOSS_ON_FILL_PRICE_MISSING" => Ok(Self::StopLossOnFillPriceMissing),
            "STOP_LOSS_ON_FILL_PRICE_INVALID" => Ok(Self::StopLossOnFillPriceInvalid),
            "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(Self::StopLossOnFillPricePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOnFillGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOnFillGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_INVALID" => Ok(Self::StopLossOnFillDistanceInvalid),
            "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::StopLossOnFillPriceDistanceMaximumExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(Self::StopLossOnFillDistancePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(Self::StopLossOnFillPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(Self::StopLossOnFillPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => Ok(Self::StopLossOnFillTimeInForceMissing),
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => Ok(Self::StopLossOnFillTimeInForceInvalid),
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::StopLossOnFillGtdTimestampMissing)
            }
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => Ok(Self::StopLossOnFillGtdTimestampInPast),
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderIdInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderTagInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderCommentInvalid)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::StopLossOnFillTriggerConditionMissing)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::StopLossOnFillTriggerConditionInvalid)
            }
            "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS" => {
                Ok(Self::TrailingStopLossOrderAlreadyExists)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(Self::TrailingStopLossOnFillPriceDistancePrecisionExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMaximumExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMinimumNotMet)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(Self::TrailingStopLossOnFillTimeInForceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(Self::TrailingStopLossOnFillTimeInForceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampInPast)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderIdInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderTagInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderCommentInvalid)
            }
            "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED" => {
                Ok(Self::TrailingStopLossOrdersNotSupported)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::TrailingStopLossOnFillTriggerConditionMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::TrailingStopLossOnFillTriggerConditionInvalid)
            }
            "CLOSE_TRADE_TYPE_MISSING" => Ok(Self::CloseTradeTypeMissing),
            "CLOSE_TRADE_PARTIAL_UNITS_MISSING" => Ok(Self::CloseTradePartialUnitsMissing),
            "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE" => Ok(Self::CloseTradeUnitsExceedTradeSize),
            "CLOSEOUT_POSITION_DOESNT_EXIST" => Ok(Self::CloseoutPositionDoesntExist),
            "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION" => {
                Ok(Self::CloseoutPositionIncompleteSpecification)
            }
            "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE" => {
                Ok(Self::CloseoutPositionUnitsExceedPositionSize)
            }
            "CLOSEOUT_POSITION_REJECT" => Ok(Self::CloseoutPositionReject),
            "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING" => {
                Ok(Self::CloseoutPositionPartialUnitsMissing)
            }
            "MARKUP_GROUP_ID_INVALID" => Ok(Self::MarkupGroupIdInvalid),
            "POSITION_AGGREGATION_MODE_INVALID" => Ok(Self::PositionAggregationModeInvalid),
            "ADMIN_CONFIGURE_DATA_MISSING" => Ok(Self::AdminConfigureDataMissing),
            "MARGIN_RATE_INVALID" => Ok(Self::MarginRateInvalid),
            "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT" => Ok(Self::MarginRateWouldTriggerCloseout),
            "ALIAS_INVALID" => Ok(Self::AliasInvalid),
            "CLIENT_CONFIGURE_DATA_MISSING" => Ok(Self::ClientConfigureDataMissing),
            "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL" => Ok(Self::MarginRateWouldTriggerMarginCall),
            "AMOUNT_INVALID" => Ok(Self::AmountInvalid),
            "INSUFFICIENT_FUNDS" => Ok(Self::InsufficientFunds),
            "AMOUNT_MISSING" => Ok(Self::AmountMissing),
            "FUNDING_REASON_MISSING" => Ok(Self::FundingReasonMissing),
            "CLIENT_EXTENSIONS_DATA_MISSING" => Ok(Self::ClientExtensionsDataMissing),
            "REPLACING_ORDER_INVALID" => Ok(Self::ReplacingOrderInvalid),
            "REPLACING_TRADE_ID_INVALID" => Ok(Self::ReplacingTradeIdInvalid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for OrderClientExtensionsModifyRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for OrderClientExtensionsModifyRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for OrderClientExtensionsModifyRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Type of the Transaction. Always set to
/// "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" for a
/// OrderClientExtensionsModifyRejectTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT\" for a
/// OrderClientExtensionsModifyRejectTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrderClientExtensionsModifyRejectTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&OrderClientExtensionsModifyRejectTransactionType>
    for OrderClientExtensionsModifyRejectTransactionType
{
    fn from(value: &OrderClientExtensionsModifyRejectTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for OrderClientExtensionsModifyRejectTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for OrderClientExtensionsModifyRejectTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for OrderClientExtensionsModifyRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for OrderClientExtensionsModifyRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for OrderClientExtensionsModifyRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A OrderClientExtensionsModifyTransaction represents the modification of
/// an Order's Client Extensions.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A OrderClientExtensionsModifyTransaction represents the
/// modification of an Order's Client Extensions.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientExtensionsModify": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "clientOrderID": {
///      "description": "The original Client ID of the Order who's client
/// extensions are to be modified.",
///      "type": "string"
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "orderID": {
///      "description": "The ID of the Order who's client extensions are to
/// be modified.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "tradeClientExtensionsModify": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"ORDER_CLIENT_EXTENSIONS_MODIFY\" for a
/// OrderClienteExtensionsModifyTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OrderClientExtensionsModifyTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    #[serde(
        rename = "clientExtensionsModify",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions_modify: Option<ClientExtensions>,
    ///The original Client ID of the Order who's client extensions are to
    /// be modified.
    #[serde(
        rename = "clientOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_order_id: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The ID of the Order who's client extensions are to be modified.
    #[serde(rename = "orderID", default, skip_serializing_if = "Option::is_none")]
    pub order_id: Option<String>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    #[serde(
        rename = "tradeClientExtensionsModify",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions_modify: Option<ClientExtensions>,
    ///The Type of the Transaction. Always set to
    /// "ORDER_CLIENT_EXTENSIONS_MODIFY" for a
    /// OrderClienteExtensionsModifyTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<OrderClientExtensionsModifyTransactionType>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&OrderClientExtensionsModifyTransaction> for OrderClientExtensionsModifyTransaction {
    fn from(value: &OrderClientExtensionsModifyTransaction) -> Self {
        value.clone()
    }
}

impl OrderClientExtensionsModifyTransaction {
    pub fn builder() -> builder::OrderClientExtensionsModifyTransaction {
        Default::default()
    }
}

///The Type of the Transaction. Always set to
/// "ORDER_CLIENT_EXTENSIONS_MODIFY" for a
/// OrderClienteExtensionsModifyTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"ORDER_CLIENT_EXTENSIONS_MODIFY\" for a
/// OrderClienteExtensionsModifyTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrderClientExtensionsModifyTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&OrderClientExtensionsModifyTransactionType>
    for OrderClientExtensionsModifyTransactionType
{
    fn from(value: &OrderClientExtensionsModifyTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for OrderClientExtensionsModifyTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for OrderClientExtensionsModifyTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for OrderClientExtensionsModifyTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for OrderClientExtensionsModifyTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for OrderClientExtensionsModifyTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The reason that an Order was filled
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that an Order was filled",
///  "type": "string",
///  "enum": [
///    "LIMIT_ORDER",
///    "STOP_ORDER",
///    "MARKET_IF_TOUCHED_ORDER",
///    "TAKE_PROFIT_ORDER",
///    "STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER",
///    "MARKET_ORDER",
///    "MARKET_ORDER_TRADE_CLOSE",
///    "MARKET_ORDER_POSITION_CLOSEOUT",
///    "MARKET_ORDER_MARGIN_CLOSEOUT",
///    "MARKET_ORDER_DELAYED_TRADE_CLOSE"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrderFillReason {
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_TRADE_CLOSE")]
    MarketOrderTradeClose,
    #[serde(rename = "MARKET_ORDER_POSITION_CLOSEOUT")]
    MarketOrderPositionCloseout,
    #[serde(rename = "MARKET_ORDER_MARGIN_CLOSEOUT")]
    MarketOrderMarginCloseout,
    #[serde(rename = "MARKET_ORDER_DELAYED_TRADE_CLOSE")]
    MarketOrderDelayedTradeClose,
}

impl From<&OrderFillReason> for OrderFillReason {
    fn from(value: &OrderFillReason) -> Self {
        value.clone()
    }
}

impl ToString for OrderFillReason {
    fn to_string(&self) -> String {
        match *self {
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderTradeClose => "MARKET_ORDER_TRADE_CLOSE".to_string(),
            Self::MarketOrderPositionCloseout => "MARKET_ORDER_POSITION_CLOSEOUT".to_string(),
            Self::MarketOrderMarginCloseout => "MARKET_ORDER_MARGIN_CLOSEOUT".to_string(),
            Self::MarketOrderDelayedTradeClose => "MARKET_ORDER_DELAYED_TRADE_CLOSE".to_string(),
        }
    }
}

impl std::str::FromStr for OrderFillReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_TRADE_CLOSE" => Ok(Self::MarketOrderTradeClose),
            "MARKET_ORDER_POSITION_CLOSEOUT" => Ok(Self::MarketOrderPositionCloseout),
            "MARKET_ORDER_MARGIN_CLOSEOUT" => Ok(Self::MarketOrderMarginCloseout),
            "MARKET_ORDER_DELAYED_TRADE_CLOSE" => Ok(Self::MarketOrderDelayedTradeClose),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for OrderFillReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for OrderFillReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for OrderFillReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///An OrderFillTransaction represents the filling of an Order in the
/// client's Account.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "An OrderFillTransaction represents the filling of an
/// Order in the client's Account.",
///  "type": "object",
///  "properties": {
///    "accountBalance": {
///      "description": "The Account's balance after the Order was filled.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientOrderID": {
///      "description": "The client Order ID of the Order filled (only
/// provided if the client has assigned one).",
///      "type": "string"
///    },
///    "commission": {
///      "description": "The commission charged in the Account's home
/// currency as a result of filling the Order. The commission is always
/// represented as a positive quantity of the Account's home currency,
/// however it reduces the balance in the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "financing": {
///      "description": "The financing paid or collected when the Order was
/// filled.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "fullPrice": {
///      "$ref": "#/components/schemas/ClientPrice"
///    },
///    "fullVWAP": {
///      "description": "The price that all of the units of the OrderFill
/// should have been filled at, in the absence of guaranteed price
/// execution. This factors in the Account's current ClientPrice, used
/// liquidity and the units of the OrderFill only. If no Trades were closed
/// with their price clamped for guaranteed stop loss enforcement, then this
/// value will match the price fields of each Trade opened, closed, and
/// reduced, and they will all be the exact same.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "gainQuoteHomeConversionFactor": {
///      "description": "This is the conversion factor in effect for the Account at the time of the OrderFill for converting any gains realized in Instrument quote units into units of the Account's home currency.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "guaranteedExecutionFee": {
///      "description": "The total guaranteed execution fees charged for all
/// Trades opened, closed or reduced with guaranteed Stop Loss Orders.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "halfSpreadCost": {
///      "description": "The half spread cost for the OrderFill, which is
/// the sum of the halfSpreadCost values in the tradeOpened, tradesClosed
/// and tradeReduced fields. This can be a positive or negative value and is
/// represented in the home currency of the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "instrument": {
///      "description": "The name of the filled Order's instrument.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "lossQuoteHomeConversionFactor": {
///      "description": "This is the conversion factor in effect for the Account at the time of the OrderFill for converting any losses realized in Instrument quote units into units of the Account's home currency.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "orderID": {
///      "description": "The ID of the Order filled.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "pl": {
///      "description": "The profit or loss incurred when the Order was
/// filled.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "price": {
///      "description": "This field is now deprecated and should no longer
/// be used. The individual tradesClosed, tradeReduced and tradeOpened
/// fields contain the exact/official price each unit was filled at.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "reason": {
///      "description": "The reason that an Order was filled",
///      "type": "string",
///      "enum": [
///        "LIMIT_ORDER",
///        "STOP_ORDER",
///        "MARKET_IF_TOUCHED_ORDER",
///        "TAKE_PROFIT_ORDER",
///        "STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER",
///        "MARKET_ORDER",
///        "MARKET_ORDER_TRADE_CLOSE",
///        "MARKET_ORDER_POSITION_CLOSEOUT",
///        "MARKET_ORDER_MARGIN_CLOSEOUT",
///        "MARKET_ORDER_DELAYED_TRADE_CLOSE"
///      ]
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "tradeOpened": {
///      "$ref": "#/components/schemas/TradeOpen"
///    },
///    "tradeReduced": {
///      "$ref": "#/components/schemas/TradeReduce"
///    },
///    "tradesClosed": {
///      "description": "The Trades that were closed when the Order was
/// filled (only provided if filling the Order resulted in a closing open
/// Trades).",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/TradeReduce"
///      }
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"ORDER_FILL\" for an OrderFillTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "units": {
///      "description": "The number of units filled by the OrderFill.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OrderFillTransaction {
    ///The Account's balance after the Order was filled.
    #[serde(
        rename = "accountBalance",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub account_balance: Option<String>,
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    ///The client Order ID of the Order filled (only provided if the client
    /// has assigned one).
    #[serde(
        rename = "clientOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_order_id: Option<String>,
    ///The commission charged in the Account's home currency as a result of
    /// filling the Order. The commission is always represented as a
    /// positive quantity of the Account's home currency, however it reduces
    /// the balance in the Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commission: Option<String>,
    ///The financing paid or collected when the Order was filled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub financing: Option<String>,
    #[serde(rename = "fullPrice", default, skip_serializing_if = "Option::is_none")]
    pub full_price: Option<ClientPrice>,
    ///The price that all of the units of the OrderFill should have been
    /// filled at, in the absence of guaranteed price execution. This
    /// factors in the Account's current ClientPrice, used liquidity and the
    /// units of the OrderFill only. If no Trades were closed with their
    /// price clamped for guaranteed stop loss enforcement, then this value
    /// will match the price fields of each Trade opened, closed, and
    /// reduced, and they will all be the exact same.
    #[serde(rename = "fullVWAP", default, skip_serializing_if = "Option::is_none")]
    pub full_vwap: Option<String>,
    ///This is the conversion factor in effect for the Account at the time
    /// of the OrderFill for converting any gains realized in Instrument
    /// quote units into units of the Account's home currency.
    #[serde(
        rename = "gainQuoteHomeConversionFactor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub gain_quote_home_conversion_factor: Option<String>,
    ///The total guaranteed execution fees charged for all Trades opened,
    /// closed or reduced with guaranteed Stop Loss Orders.
    #[serde(
        rename = "guaranteedExecutionFee",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub guaranteed_execution_fee: Option<String>,
    ///The half spread cost for the OrderFill, which is the sum of the
    /// halfSpreadCost values in the tradeOpened, tradesClosed and
    /// tradeReduced fields. This can be a positive or negative value and is
    /// represented in the home currency of the Account.
    #[serde(
        rename = "halfSpreadCost",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub half_spread_cost: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The name of the filled Order's instrument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    ///This is the conversion factor in effect for the Account at the time
    /// of the OrderFill for converting any losses realized in Instrument
    /// quote units into units of the Account's home currency.
    #[serde(
        rename = "lossQuoteHomeConversionFactor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub loss_quote_home_conversion_factor: Option<String>,
    ///The ID of the Order filled.
    #[serde(rename = "orderID", default, skip_serializing_if = "Option::is_none")]
    pub order_id: Option<String>,
    ///The profit or loss incurred when the Order was filled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pl: Option<String>,
    ///This field is now deprecated and should no longer be used. The
    /// individual tradesClosed, tradeReduced and tradeOpened fields contain
    /// the exact/official price each unit was filled at.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The reason that an Order was filled
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<OrderFillTransactionReason>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    #[serde(
        rename = "tradeOpened",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_opened: Option<TradeOpen>,
    #[serde(
        rename = "tradeReduced",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_reduced: Option<TradeReduce>,
    ///The Trades that were closed when the Order was filled (only provided
    /// if filling the Order resulted in a closing open Trades).
    #[serde(
        rename = "tradesClosed",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub trades_closed: Vec<TradeReduce>,
    ///The Type of the Transaction. Always set to "ORDER_FILL" for an
    /// OrderFillTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<OrderFillTransactionType>,
    ///The number of units filled by the OrderFill.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<String>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&OrderFillTransaction> for OrderFillTransaction {
    fn from(value: &OrderFillTransaction) -> Self {
        value.clone()
    }
}

impl OrderFillTransaction {
    pub fn builder() -> builder::OrderFillTransaction {
        Default::default()
    }
}

///The reason that an Order was filled
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that an Order was filled",
///  "type": "string",
///  "enum": [
///    "LIMIT_ORDER",
///    "STOP_ORDER",
///    "MARKET_IF_TOUCHED_ORDER",
///    "TAKE_PROFIT_ORDER",
///    "STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER",
///    "MARKET_ORDER",
///    "MARKET_ORDER_TRADE_CLOSE",
///    "MARKET_ORDER_POSITION_CLOSEOUT",
///    "MARKET_ORDER_MARGIN_CLOSEOUT",
///    "MARKET_ORDER_DELAYED_TRADE_CLOSE"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrderFillTransactionReason {
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_TRADE_CLOSE")]
    MarketOrderTradeClose,
    #[serde(rename = "MARKET_ORDER_POSITION_CLOSEOUT")]
    MarketOrderPositionCloseout,
    #[serde(rename = "MARKET_ORDER_MARGIN_CLOSEOUT")]
    MarketOrderMarginCloseout,
    #[serde(rename = "MARKET_ORDER_DELAYED_TRADE_CLOSE")]
    MarketOrderDelayedTradeClose,
}

impl From<&OrderFillTransactionReason> for OrderFillTransactionReason {
    fn from(value: &OrderFillTransactionReason) -> Self {
        value.clone()
    }
}

impl ToString for OrderFillTransactionReason {
    fn to_string(&self) -> String {
        match *self {
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderTradeClose => "MARKET_ORDER_TRADE_CLOSE".to_string(),
            Self::MarketOrderPositionCloseout => "MARKET_ORDER_POSITION_CLOSEOUT".to_string(),
            Self::MarketOrderMarginCloseout => "MARKET_ORDER_MARGIN_CLOSEOUT".to_string(),
            Self::MarketOrderDelayedTradeClose => "MARKET_ORDER_DELAYED_TRADE_CLOSE".to_string(),
        }
    }
}

impl std::str::FromStr for OrderFillTransactionReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_TRADE_CLOSE" => Ok(Self::MarketOrderTradeClose),
            "MARKET_ORDER_POSITION_CLOSEOUT" => Ok(Self::MarketOrderPositionCloseout),
            "MARKET_ORDER_MARGIN_CLOSEOUT" => Ok(Self::MarketOrderMarginCloseout),
            "MARKET_ORDER_DELAYED_TRADE_CLOSE" => Ok(Self::MarketOrderDelayedTradeClose),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for OrderFillTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for OrderFillTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for OrderFillTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Type of the Transaction. Always set to "ORDER_FILL" for an
/// OrderFillTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"ORDER_FILL\" for an OrderFillTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrderFillTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&OrderFillTransactionType> for OrderFillTransactionType {
    fn from(value: &OrderFillTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for OrderFillTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for OrderFillTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for OrderFillTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for OrderFillTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for OrderFillTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Order's identifier, unique within the Order's Account.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Order's identifier, unique within the Order's
/// Account.",
///  "type": "string",
///  "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct OrderId(pub String);
impl std::ops::Deref for OrderId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl From<OrderId> for String {
    fn from(value: OrderId) -> Self {
        value.0
    }
}

impl From<&OrderId> for OrderId {
    fn from(value: &OrderId) -> Self {
        value.clone()
    }
}

impl From<String> for OrderId {
    fn from(value: String) -> Self {
        Self(value)
    }
}

impl std::str::FromStr for OrderId {
    type Err = std::convert::Infallible;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}

impl ToString for OrderId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

///An OrderIdentifier is used to refer to an Order, and contains both the
/// OrderID and the ClientOrderID.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "An OrderIdentifier is used to refer to an Order, and
/// contains both the OrderID and the ClientOrderID.",
///  "type": "object",
///  "properties": {
///    "clientOrderID": {
///      "description": "The client-provided client Order ID",
///      "type": "string"
///    },
///    "orderID": {
///      "description": "The OANDA-assigned Order ID",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OrderIdentifier {
    ///The client-provided client Order ID
    #[serde(
        rename = "clientOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_order_id: Option<String>,
    ///The OANDA-assigned Order ID
    #[serde(rename = "orderID", default, skip_serializing_if = "Option::is_none")]
    pub order_id: Option<String>,
}

impl From<&OrderIdentifier> for OrderIdentifier {
    fn from(value: &OrderIdentifier) -> Self {
        value.clone()
    }
}

impl OrderIdentifier {
    pub fn builder() -> builder::OrderIdentifier {
        Default::default()
    }
}

///Specification of how Positions in the Account are modified when the
/// Order is filled.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///  "type": "string",
///  "enum": [
///    "OPEN_ONLY",
///    "REDUCE_FIRST",
///    "REDUCE_ONLY",
///    "DEFAULT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrderPositionFill {
    #[serde(rename = "OPEN_ONLY")]
    OpenOnly,
    #[serde(rename = "REDUCE_FIRST")]
    ReduceFirst,
    #[serde(rename = "REDUCE_ONLY")]
    ReduceOnly,
    #[serde(rename = "DEFAULT")]
    Default,
}

impl From<&OrderPositionFill> for OrderPositionFill {
    fn from(value: &OrderPositionFill) -> Self {
        value.clone()
    }
}

impl ToString for OrderPositionFill {
    fn to_string(&self) -> String {
        match *self {
            Self::OpenOnly => "OPEN_ONLY".to_string(),
            Self::ReduceFirst => "REDUCE_FIRST".to_string(),
            Self::ReduceOnly => "REDUCE_ONLY".to_string(),
            Self::Default => "DEFAULT".to_string(),
        }
    }
}

impl std::str::FromStr for OrderPositionFill {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "OPEN_ONLY" => Ok(Self::OpenOnly),
            "REDUCE_FIRST" => Ok(Self::ReduceFirst),
            "REDUCE_ONLY" => Ok(Self::ReduceOnly),
            "DEFAULT" => Ok(Self::Default),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for OrderPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for OrderPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for OrderPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The base Order specification used when requesting that an Order be
/// created. Each specific Order-type extends this definition.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The base Order specification used when requesting that an Order be created. Each specific Order-type extends this definition.",
///  "type": "object"
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OrderRequest(pub serde_json::Map<String, serde_json::Value>);
impl std::ops::Deref for OrderRequest {
    type Target = serde_json::Map<String, serde_json::Value>;
    fn deref(&self) -> &serde_json::Map<String, serde_json::Value> {
        &self.0
    }
}

impl From<OrderRequest> for serde_json::Map<String, serde_json::Value> {
    fn from(value: OrderRequest) -> Self {
        value.0
    }
}

impl From<&OrderRequest> for OrderRequest {
    fn from(value: &OrderRequest) -> Self {
        value.clone()
    }
}

impl From<serde_json::Map<String, serde_json::Value>> for OrderRequest {
    fn from(value: serde_json::Map<String, serde_json::Value>) -> Self {
        Self(value)
    }
}

///The specification of an Order as referred to by clients
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The specification of an Order as referred to by
/// clients",
///  "type": "string",
///  "format": "Either the Order's OANDA-assigned OrderID or the Order's
/// client-provided ClientID prefixed by the \"@\" symbol"
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct OrderSpecifier(pub String);
impl std::ops::Deref for OrderSpecifier {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl From<OrderSpecifier> for String {
    fn from(value: OrderSpecifier) -> Self {
        value.0
    }
}

impl From<&OrderSpecifier> for OrderSpecifier {
    fn from(value: &OrderSpecifier) -> Self {
        value.clone()
    }
}

impl From<String> for OrderSpecifier {
    fn from(value: String) -> Self {
        Self(value)
    }
}

impl std::str::FromStr for OrderSpecifier {
    type Err = std::convert::Infallible;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}

impl ToString for OrderSpecifier {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

///The current state of the Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The current state of the Order.",
///  "type": "string",
///  "enum": [
///    "PENDING",
///    "FILLED",
///    "TRIGGERED",
///    "CANCELLED"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrderState {
    #[serde(rename = "PENDING")]
    Pending,
    #[serde(rename = "FILLED")]
    Filled,
    #[serde(rename = "TRIGGERED")]
    Triggered,
    #[serde(rename = "CANCELLED")]
    Cancelled,
}

impl From<&OrderState> for OrderState {
    fn from(value: &OrderState) -> Self {
        value.clone()
    }
}

impl ToString for OrderState {
    fn to_string(&self) -> String {
        match *self {
            Self::Pending => "PENDING".to_string(),
            Self::Filled => "FILLED".to_string(),
            Self::Triggered => "TRIGGERED".to_string(),
            Self::Cancelled => "CANCELLED".to_string(),
        }
    }
}

impl std::str::FromStr for OrderState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "PENDING" => Ok(Self::Pending),
            "FILLED" => Ok(Self::Filled),
            "TRIGGERED" => Ok(Self::Triggered),
            "CANCELLED" => Ok(Self::Cancelled),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for OrderState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for OrderState {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for OrderState {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The state to filter the requested Orders by.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The state to filter the requested Orders by.",
///  "type": "string",
///  "enum": [
///    "PENDING",
///    "FILLED",
///    "TRIGGERED",
///    "CANCELLED",
///    "ALL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrderStateFilter {
    #[serde(rename = "PENDING")]
    Pending,
    #[serde(rename = "FILLED")]
    Filled,
    #[serde(rename = "TRIGGERED")]
    Triggered,
    #[serde(rename = "CANCELLED")]
    Cancelled,
    #[serde(rename = "ALL")]
    All,
}

impl From<&OrderStateFilter> for OrderStateFilter {
    fn from(value: &OrderStateFilter) -> Self {
        value.clone()
    }
}

impl ToString for OrderStateFilter {
    fn to_string(&self) -> String {
        match *self {
            Self::Pending => "PENDING".to_string(),
            Self::Filled => "FILLED".to_string(),
            Self::Triggered => "TRIGGERED".to_string(),
            Self::Cancelled => "CANCELLED".to_string(),
            Self::All => "ALL".to_string(),
        }
    }
}

impl std::str::FromStr for OrderStateFilter {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "PENDING" => Ok(Self::Pending),
            "FILLED" => Ok(Self::Filled),
            "TRIGGERED" => Ok(Self::Triggered),
            "CANCELLED" => Ok(Self::Cancelled),
            "ALL" => Ok(Self::All),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for OrderStateFilter {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for OrderStateFilter {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for OrderStateFilter {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///Specification of which price component should be used when determining
/// if an Order should be triggered and filled. This allows Orders to be
/// triggered based on the bid, ask, mid, default (ask for buy, bid for
/// sell) or inverse (ask for sell, bid for buy) price depending on the
/// desired behaviour. Orders are always filled using their default price
/// component. This feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order. A special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
/// results in. So for a Stop Loss Order for a long trade valid values are
/// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are valid.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of which price component should be used
/// when determining if an Order should be triggered and filled. This allows
/// Orders to be triggered based on the bid, ask, mid, default (ask for buy,
/// bid for sell) or inverse (ask for sell, bid for buy) price depending on
/// the desired behaviour. Orders are always filled using their default
/// price component.\nThis feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///  "type": "string",
///  "enum": [
///    "DEFAULT",
///    "INVERSE",
///    "BID",
///    "ASK",
///    "MID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrderTriggerCondition {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "INVERSE")]
    Inverse,
    #[serde(rename = "BID")]
    Bid,
    #[serde(rename = "ASK")]
    Ask,
    #[serde(rename = "MID")]
    Mid,
}

impl From<&OrderTriggerCondition> for OrderTriggerCondition {
    fn from(value: &OrderTriggerCondition) -> Self {
        value.clone()
    }
}

impl ToString for OrderTriggerCondition {
    fn to_string(&self) -> String {
        match *self {
            Self::Default => "DEFAULT".to_string(),
            Self::Inverse => "INVERSE".to_string(),
            Self::Bid => "BID".to_string(),
            Self::Ask => "ASK".to_string(),
            Self::Mid => "MID".to_string(),
        }
    }
}

impl std::str::FromStr for OrderTriggerCondition {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DEFAULT" => Ok(Self::Default),
            "INVERSE" => Ok(Self::Inverse),
            "BID" => Ok(Self::Bid),
            "ASK" => Ok(Self::Ask),
            "MID" => Ok(Self::Mid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for OrderTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for OrderTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for OrderTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The type of the Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The type of the Order.",
///  "type": "string",
///  "enum": [
///    "MARKET",
///    "LIMIT",
///    "STOP",
///    "MARKET_IF_TOUCHED",
///    "TAKE_PROFIT",
///    "STOP_LOSS",
///    "TRAILING_STOP_LOSS",
///    "FIXED_PRICE"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrderType {
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "STOP")]
    Stop,
    #[serde(rename = "MARKET_IF_TOUCHED")]
    MarketIfTouched,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "STOP_LOSS")]
    StopLoss,
    #[serde(rename = "TRAILING_STOP_LOSS")]
    TrailingStopLoss,
    #[serde(rename = "FIXED_PRICE")]
    FixedPrice,
}

impl From<&OrderType> for OrderType {
    fn from(value: &OrderType) -> Self {
        value.clone()
    }
}

impl ToString for OrderType {
    fn to_string(&self) -> String {
        match *self {
            Self::Market => "MARKET".to_string(),
            Self::Limit => "LIMIT".to_string(),
            Self::Stop => "STOP".to_string(),
            Self::MarketIfTouched => "MARKET_IF_TOUCHED".to_string(),
            Self::TakeProfit => "TAKE_PROFIT".to_string(),
            Self::StopLoss => "STOP_LOSS".to_string(),
            Self::TrailingStopLoss => "TRAILING_STOP_LOSS".to_string(),
            Self::FixedPrice => "FIXED_PRICE".to_string(),
        }
    }
}

impl std::str::FromStr for OrderType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "MARKET" => Ok(Self::Market),
            "LIMIT" => Ok(Self::Limit),
            "STOP" => Ok(Self::Stop),
            "MARKET_IF_TOUCHED" => Ok(Self::MarketIfTouched),
            "TAKE_PROFIT" => Ok(Self::TakeProfit),
            "STOP_LOSS" => Ok(Self::StopLoss),
            "TRAILING_STOP_LOSS" => Ok(Self::TrailingStopLoss),
            "FIXED_PRICE" => Ok(Self::FixedPrice),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for OrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for OrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for OrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The specification of a Position within an Account.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The specification of a Position within an Account.",
///  "type": "object",
///  "properties": {
///    "commission": {
///      "description": "The total amount of commission paid for this
/// instrument over the lifetime of the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "financing": {
///      "description": "The total amount of financing paid/collected for
/// this instrument over the lifetime of the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "guaranteedExecutionFees": {
///      "description": "The total amount of fees charged over the lifetime
/// of the Account for the execution of guaranteed Stop Loss Orders for this
/// instrument.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "instrument": {
///      "description": "The Position's Instrument.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "long": {
///      "$ref": "#/components/schemas/PositionSide"
///    },
///    "marginUsed": {
///      "description": "Margin currently used by the Position.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "pl": {
///      "description": "Profit/loss realized by the Position over the
/// lifetime of the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "resettablePL": {
///      "description": "Profit/loss realized by the Position since the
/// Account's resettablePL was last reset by the client.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "short": {
///      "$ref": "#/components/schemas/PositionSide"
///    },
///    "unrealizedPL": {
///      "description": "The unrealized profit/loss of all open Trades that
/// contribute to this Position.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Position {
    ///The total amount of commission paid for this instrument over the
    /// lifetime of the Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub commission: Option<String>,
    ///The total amount of financing paid/collected for this instrument
    /// over the lifetime of the Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub financing: Option<String>,
    ///The total amount of fees charged over the lifetime of the Account
    /// for the execution of guaranteed Stop Loss Orders for this
    /// instrument.
    #[serde(
        rename = "guaranteedExecutionFees",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub guaranteed_execution_fees: Option<String>,
    ///The Position's Instrument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub long: Option<PositionSide>,
    ///Margin currently used by the Position.
    #[serde(
        rename = "marginUsed",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_used: Option<String>,
    ///Profit/loss realized by the Position over the lifetime of the
    /// Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pl: Option<String>,
    ///Profit/loss realized by the Position since the Account's
    /// resettablePL was last reset by the client.
    #[serde(
        rename = "resettablePL",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub resettable_pl: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub short: Option<PositionSide>,
    ///The unrealized profit/loss of all open Trades that contribute to
    /// this Position.
    #[serde(
        rename = "unrealizedPL",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub unrealized_pl: Option<String>,
}

impl From<&Position> for Position {
    fn from(value: &Position) -> Self {
        value.clone()
    }
}

impl Position {
    pub fn builder() -> builder::Position {
        Default::default()
    }
}

///The way that position values for an Account are calculated and
/// aggregated.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The way that position values for an Account are
/// calculated and aggregated.",
///  "type": "string",
///  "enum": [
///    "ABSOLUTE_SUM",
///    "MAXIMAL_SIDE",
///    "NET_SUM"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PositionAggregationMode {
    #[serde(rename = "ABSOLUTE_SUM")]
    AbsoluteSum,
    #[serde(rename = "MAXIMAL_SIDE")]
    MaximalSide,
    #[serde(rename = "NET_SUM")]
    NetSum,
}

impl From<&PositionAggregationMode> for PositionAggregationMode {
    fn from(value: &PositionAggregationMode) -> Self {
        value.clone()
    }
}

impl ToString for PositionAggregationMode {
    fn to_string(&self) -> String {
        match *self {
            Self::AbsoluteSum => "ABSOLUTE_SUM".to_string(),
            Self::MaximalSide => "MAXIMAL_SIDE".to_string(),
            Self::NetSum => "NET_SUM".to_string(),
        }
    }
}

impl std::str::FromStr for PositionAggregationMode {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "ABSOLUTE_SUM" => Ok(Self::AbsoluteSum),
            "MAXIMAL_SIDE" => Ok(Self::MaximalSide),
            "NET_SUM" => Ok(Self::NetSum),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for PositionAggregationMode {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for PositionAggregationMode {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for PositionAggregationMode {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The representation of an instrument's position book at a point in time
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The representation of an instrument's position book at
/// a point in time",
///  "type": "object",
///  "properties": {
///    "bucketWidth": {
///      "description": "The price width for each bucket. Each bucket covers
/// the price range from the bucket's price to the bucket's price +
/// bucketWidth.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "buckets": {
///      "description": "The partitioned position book, divided into buckets
/// using a default bucket width. These buckets are only provided for price
/// ranges which actually contain order or position data.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/PositionBookBucket"
///      }
///    },
///    "instrument": {
///      "description": "The position book's instrument",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "price": {
///      "description": "The price (midpoint) for the position book's
/// instrument at the time of the position book snapshot",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "time": {
///      "description": "The time when the position book snapshot was
/// created",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct PositionBook {
    ///The price width for each bucket. Each bucket covers the price range
    /// from the bucket's price to the bucket's price + bucketWidth.
    #[serde(
        rename = "bucketWidth",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub bucket_width: Option<String>,
    ///The partitioned position book, divided into buckets using a default
    /// bucket width. These buckets are only provided for price ranges which
    /// actually contain order or position data.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub buckets: Vec<PositionBookBucket>,
    ///The position book's instrument
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    ///The price (midpoint) for the position book's instrument at the time
    /// of the position book snapshot
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The time when the position book snapshot was created
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
}

impl From<&PositionBook> for PositionBook {
    fn from(value: &PositionBook) -> Self {
        value.clone()
    }
}

impl PositionBook {
    pub fn builder() -> builder::PositionBook {
        Default::default()
    }
}

///The position book data for a partition of the instrument's prices.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The position book data for a partition of the
/// instrument's prices.",
///  "type": "object",
///  "properties": {
///    "longCountPercent": {
///      "description": "The percentage of the total number of positions
/// represented by the long positions found in this bucket.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "price": {
///      "description": "The lowest price (inclusive) covered by the bucket.
/// The bucket covers the price range from the price to price + the position
/// book's bucketWidth.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "shortCountPercent": {
///      "description": "The percentage of the total number of positions
/// represented by the short positions found in this bucket.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct PositionBookBucket {
    ///The percentage of the total number of positions represented by the
    /// long positions found in this bucket.
    #[serde(
        rename = "longCountPercent",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub long_count_percent: Option<String>,
    ///The lowest price (inclusive) covered by the bucket. The bucket
    /// covers the price range from the price to price + the position book's
    /// bucketWidth.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The percentage of the total number of positions represented by the
    /// short positions found in this bucket.
    #[serde(
        rename = "shortCountPercent",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub short_count_percent: Option<String>,
}

impl From<&PositionBookBucket> for PositionBookBucket {
    fn from(value: &PositionBookBucket) -> Self {
        value.clone()
    }
}

impl PositionBookBucket {
    pub fn builder() -> builder::PositionBookBucket {
        Default::default()
    }
}

///OpenTradeFinancing is used to pay/collect daily financing charge for a
/// Position within an Account
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "OpenTradeFinancing is used to pay/collect daily
/// financing charge for a Position within an Account",
///  "type": "object",
///  "properties": {
///    "financing": {
///      "description": "The amount of financing paid/collected for the
/// Position.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "instrument": {
///      "description": "The instrument of the Position that financing is
/// being paid/collected for.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "openTradeFinancings": {
///      "description": "The financing paid/collecte for each open Trade
/// within the Position.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/OpenTradeFinancing"
///      }
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct PositionFinancing {
    ///The amount of financing paid/collected for the Position.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub financing: Option<String>,
    ///The instrument of the Position that financing is being
    /// paid/collected for.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    ///The financing paid/collecte for each open Trade within the Position.
    #[serde(
        rename = "openTradeFinancings",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub open_trade_financings: Vec<OpenTradeFinancing>,
}

impl From<&PositionFinancing> for PositionFinancing {
    fn from(value: &PositionFinancing) -> Self {
        value.clone()
    }
}

impl PositionFinancing {
    pub fn builder() -> builder::PositionFinancing {
        Default::default()
    }
}

///The representation of a Position for a single direction (long or short).
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The representation of a Position for a single direction
/// (long or short).",
///  "type": "object",
///  "properties": {
///    "averagePrice": {
///      "description": "Volume-weighted average of the underlying Trade
/// open prices for the Position.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "financing": {
///      "description": "The total amount of financing paid/collected for
/// this PositionSide over the lifetime of the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "guaranteedExecutionFees": {
///      "description": "The total amount of fees charged over the lifetime
/// of the Account for the execution of guaranteed Stop Loss Orders attached
/// to Trades for this PositionSide.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "pl": {
///      "description": "Profit/loss realized by the PositionSide over the
/// lifetime of the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "resettablePL": {
///      "description": "Profit/loss realized by the PositionSide since the
/// Account's resettablePL was last reset by the client.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "tradeIDs": {
///      "description": "List of the open Trade IDs which contribute to the
/// open Position.",
///      "type": "array",
///      "items": {
///        "description": "The Trade's identifier, unique within the Trade's
/// Account.",
///        "type": "string",
///        "format": "The string representation of the OANDA-assigned
/// TradeID. OANDA-assigned TradeIDs are positive integers, and are derived
/// from the TransactionID of the Transaction that opened the Trade."
///      }
///    },
///    "units": {
///      "description": "Number of units in the position (negative value
/// indicates short position, positive indicates long position).",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "unrealizedPL": {
///      "description": "The unrealized profit/loss of all open Trades that
/// contribute to this PositionSide.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct PositionSide {
    ///Volume-weighted average of the underlying Trade open prices for the
    /// Position.
    #[serde(
        rename = "averagePrice",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub average_price: Option<String>,
    ///The total amount of financing paid/collected for this PositionSide
    /// over the lifetime of the Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub financing: Option<String>,
    ///The total amount of fees charged over the lifetime of the Account
    /// for the execution of guaranteed Stop Loss Orders attached to Trades
    /// for this PositionSide.
    #[serde(
        rename = "guaranteedExecutionFees",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub guaranteed_execution_fees: Option<String>,
    ///Profit/loss realized by the PositionSide over the lifetime of the
    /// Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pl: Option<String>,
    ///Profit/loss realized by the PositionSide since the Account's
    /// resettablePL was last reset by the client.
    #[serde(
        rename = "resettablePL",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub resettable_pl: Option<String>,
    ///List of the open Trade IDs which contribute to the open Position.
    #[serde(rename = "tradeIDs", default, skip_serializing_if = "Vec::is_empty")]
    pub trade_i_ds: Vec<String>,
    ///Number of units in the position (negative value indicates short
    /// position, positive indicates long position).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<String>,
    ///The unrealized profit/loss of all open Trades that contribute to
    /// this PositionSide.
    #[serde(
        rename = "unrealizedPL",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub unrealized_pl: Option<String>,
}

impl From<&PositionSide> for PositionSide {
    fn from(value: &PositionSide) -> Self {
        value.clone()
    }
}

impl PositionSide {
    pub fn builder() -> builder::PositionSide {
        Default::default()
    }
}

///The Price representation
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Price representation",
///  "type": "object",
///  "properties": {
///    "asks": {
///      "description": "The list of prices and liquidity available on the
/// Instrument's ask side. It is possible for this list to be empty if there
/// is no ask liquidity currently available for the Instrument in the
/// Account.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/PriceBucket"
///      }
///    },
///    "baseAsk": {
///      "description": "The base ask price as calculated by pricing.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "baseBid": {
///      "description": "The base bid price as calculated by pricing.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "bids": {
///      "description": "The list of prices and liquidity available on the
/// Instrument's bid side. It is possible for this list to be empty if there
/// is no bid liquidity currently available for the Instrument in the
/// Account.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/PriceBucket"
///      }
///    },
///    "closeoutAsk": {
///      "description": "The closeout ask price. This price is used when an
/// ask is required to closeout a Position (margin closeout or manual) yet
/// there is no ask liquidity. The closeout ask is never used to open a new
/// position.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "closeoutBid": {
///      "description": "The closeout bid price. This price is used when a
/// bid is required to closeout a Position (margin closeout or manual) yet
/// there is no bid liquidity. The closeout bid is never used to open a new
/// position.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "instrument": {
///      "description": "The Price's Instrument.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "timestamp": {
///      "description": "The date/time when the Price was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "tradeable": {
///      "description": "Flag indicating if the Price is tradeable or not",
///      "type": "boolean"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Price {
    ///The list of prices and liquidity available on the Instrument's ask
    /// side. It is possible for this list to be empty if there is no ask
    /// liquidity currently available for the Instrument in the Account.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub asks: Vec<PriceBucket>,
    ///The base ask price as calculated by pricing.
    #[serde(rename = "baseAsk", default, skip_serializing_if = "Option::is_none")]
    pub base_ask: Option<String>,
    ///The base bid price as calculated by pricing.
    #[serde(rename = "baseBid", default, skip_serializing_if = "Option::is_none")]
    pub base_bid: Option<String>,
    ///The list of prices and liquidity available on the Instrument's bid
    /// side. It is possible for this list to be empty if there is no bid
    /// liquidity currently available for the Instrument in the Account.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub bids: Vec<PriceBucket>,
    ///The closeout ask price. This price is used when an ask is required
    /// to closeout a Position (margin closeout or manual) yet there is no
    /// ask liquidity. The closeout ask is never used to open a new
    /// position.
    #[serde(
        rename = "closeoutAsk",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub closeout_ask: Option<String>,
    ///The closeout bid price. This price is used when a bid is required to
    /// closeout a Position (margin closeout or manual) yet there is no bid
    /// liquidity. The closeout bid is never used to open a new position.
    #[serde(
        rename = "closeoutBid",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub closeout_bid: Option<String>,
    ///The Price's Instrument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    ///The date/time when the Price was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<String>,
    ///Flag indicating if the Price is tradeable or not
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tradeable: Option<bool>,
}

impl From<&Price> for Price {
    fn from(value: &Price) -> Self {
        value.clone()
    }
}

impl Price {
    pub fn builder() -> builder::Price {
        Default::default()
    }
}

///A Price Bucket represents a price available for an amount of liquidity
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A Price Bucket represents a price available for an
/// amount of liquidity",
///  "type": "object",
///  "properties": {
///    "liquidity": {
///      "description": "The amount of liquidity offered by the
/// PriceBucket",
///      "type": "integer"
///    },
///    "price": {
///      "description": "The Price offered by the PriceBucket",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct PriceBucket {
    ///The amount of liquidity offered by the PriceBucket
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub liquidity: Option<i64>,
    ///The Price offered by the PriceBucket
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
}

impl From<&PriceBucket> for PriceBucket {
    fn from(value: &PriceBucket) -> Self {
        value.clone()
    }
}

impl PriceBucket {
    pub fn builder() -> builder::PriceBucket {
        Default::default()
    }
}

///The status of the Price.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The status of the Price.",
///  "type": "string",
///  "enum": [
///    "tradeable",
///    "non-tradeable",
///    "invalid"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PriceStatus {
    #[serde(rename = "tradeable")]
    Tradeable,
    #[serde(rename = "non-tradeable")]
    NonTradeable,
    #[serde(rename = "invalid")]
    Invalid,
}

impl From<&PriceStatus> for PriceStatus {
    fn from(value: &PriceStatus) -> Self {
        value.clone()
    }
}

impl ToString for PriceStatus {
    fn to_string(&self) -> String {
        match *self {
            Self::Tradeable => "tradeable".to_string(),
            Self::NonTradeable => "non-tradeable".to_string(),
            Self::Invalid => "invalid".to_string(),
        }
    }
}

impl std::str::FromStr for PriceStatus {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "tradeable" => Ok(Self::Tradeable),
            "non-tradeable" => Ok(Self::NonTradeable),
            "invalid" => Ok(Self::Invalid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for PriceStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for PriceStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for PriceStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The string representation of a Price for a Bucket.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The string representation of a Price for a Bucket.",
///  "type": "string",
///  "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct PriceValue(pub String);
impl std::ops::Deref for PriceValue {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl From<PriceValue> for String {
    fn from(value: PriceValue) -> Self {
        value.0
    }
}

impl From<&PriceValue> for PriceValue {
    fn from(value: &PriceValue) -> Self {
        value.clone()
    }
}

impl From<String> for PriceValue {
    fn from(value: String) -> Self {
        Self(value)
    }
}

impl std::str::FromStr for PriceValue {
    type Err = std::convert::Infallible;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}

impl ToString for PriceValue {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

///A PricingHeartbeat object is injected into the Pricing stream to ensure
/// that the HTTP connection remains active.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A PricingHeartbeat object is injected into the Pricing
/// stream to ensure that the HTTP connection remains active.",
///  "type": "object",
///  "properties": {
///    "time": {
///      "description": "The date/time when the Heartbeat was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "type": {
///      "description": "The string \"HEARTBEAT\"",
///      "type": "string"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct PricingHeartbeat {
    ///The date/time when the Heartbeat was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The string "HEARTBEAT"
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
}

impl From<&PricingHeartbeat> for PricingHeartbeat {
    fn from(value: &PricingHeartbeat) -> Self {
        value.clone()
    }
}

impl PricingHeartbeat {
    pub fn builder() -> builder::PricingHeartbeat {
        Default::default()
    }
}

///QuoteHomeConversionFactors represents the factors that can be used used
/// to convert quantities of a Price's Instrument's quote currency into the
/// Account's home currency.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "QuoteHomeConversionFactors represents the factors that
/// can be used used to convert quantities of a Price's Instrument's quote
/// currency into the Account's home currency.",
///  "type": "object",
///  "properties": {
///    "negativeUnits": {
///      "description": "The factor used to convert a negative amount of the
/// Price's Instrument's quote currency into a negative amount of the
/// Account's home currency.  Conversion is performed by multiplying the
/// quote units by the conversion factor.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "positiveUnits": {
///      "description": "The factor used to convert a positive amount of the
/// Price's Instrument's quote currency into a positive amount of the
/// Account's home currency.  Conversion is performed by multiplying the
/// quote units by the conversion factor.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct QuoteHomeConversionFactors {
    ///The factor used to convert a negative amount of the Price's
    /// Instrument's quote currency into a negative amount of the Account's
    /// home currency.  Conversion is performed by multiplying the quote
    /// units by the conversion factor.
    #[serde(
        rename = "negativeUnits",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub negative_units: Option<String>,
    ///The factor used to convert a positive amount of the Price's
    /// Instrument's quote currency into a positive amount of the Account's
    /// home currency.  Conversion is performed by multiplying the quote
    /// units by the conversion factor.
    #[serde(
        rename = "positiveUnits",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub positive_units: Option<String>,
}

impl From<&QuoteHomeConversionFactors> for QuoteHomeConversionFactors {
    fn from(value: &QuoteHomeConversionFactors) -> Self {
        value.clone()
    }
}

impl QuoteHomeConversionFactors {
    pub fn builder() -> builder::QuoteHomeConversionFactors {
        Default::default()
    }
}

///A ReopenTransaction represents the re-opening of a closed Account.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A ReopenTransaction represents the re-opening of a
/// closed Account.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"REOPEN\" in a ReopenTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ReopenTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The Type of the Transaction. Always set to "REOPEN" in a
    /// ReopenTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<ReopenTransactionType>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&ReopenTransaction> for ReopenTransaction {
    fn from(value: &ReopenTransaction) -> Self {
        value.clone()
    }
}

impl ReopenTransaction {
    pub fn builder() -> builder::ReopenTransaction {
        Default::default()
    }
}

///The Type of the Transaction. Always set to "REOPEN" in a
/// ReopenTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to \"REOPEN\"
/// in a ReopenTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ReopenTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&ReopenTransactionType> for ReopenTransactionType {
    fn from(value: &ReopenTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for ReopenTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for ReopenTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for ReopenTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for ReopenTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for ReopenTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///ReplaceOrderBody
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "order": {
///      "$ref": "#/components/schemas/OrderRequest"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ReplaceOrderBody {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub order: Option<OrderRequest>,
}

impl From<&ReplaceOrderBody> for ReplaceOrderBody {
    fn from(value: &ReplaceOrderBody) -> Self {
        value.clone()
    }
}

impl ReplaceOrderBody {
    pub fn builder() -> builder::ReplaceOrderBody {
        Default::default()
    }
}

///ReplaceOrderResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "lastTransactionID": {
///      "description": "The ID of the most recent Transaction created for
/// the Account",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "orderCancelTransaction": {
///      "$ref": "#/components/schemas/OrderCancelTransaction"
///    },
///    "orderCreateTransaction": {
///      "$ref": "#/components/schemas/Transaction"
///    },
///    "orderFillTransaction": {
///      "$ref": "#/components/schemas/OrderFillTransaction"
///    },
///    "orderReissueRejectTransaction": {
///      "$ref": "#/components/schemas/Transaction"
///    },
///    "orderReissueTransaction": {
///      "$ref": "#/components/schemas/Transaction"
///    },
///    "relatedTransactionIDs": {
///      "description": "The IDs of all Transactions that were created while
/// satisfying the request.",
///      "type": "array",
///      "items": {
///        "description": "The unique Transaction identifier within each
/// Account.",
///        "type": "string",
///        "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///      }
///    },
///    "replacingOrderCancelTransaction": {
///      "$ref": "#/components/schemas/OrderCancelTransaction"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ReplaceOrderResponse {
    ///The ID of the most recent Transaction created for the Account
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
    #[serde(
        rename = "orderCancelTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub order_cancel_transaction: Option<OrderCancelTransaction>,
    #[serde(
        rename = "orderCreateTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub order_create_transaction: Option<Transaction>,
    #[serde(
        rename = "orderFillTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub order_fill_transaction: Option<OrderFillTransaction>,
    #[serde(
        rename = "orderReissueRejectTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub order_reissue_reject_transaction: Option<Transaction>,
    #[serde(
        rename = "orderReissueTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub order_reissue_transaction: Option<Transaction>,
    ///The IDs of all Transactions that were created while satisfying the
    /// request.
    #[serde(
        rename = "relatedTransactionIDs",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub related_transaction_i_ds: Vec<String>,
    #[serde(
        rename = "replacingOrderCancelTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub replacing_order_cancel_transaction: Option<OrderCancelTransaction>,
}

impl From<&ReplaceOrderResponse> for ReplaceOrderResponse {
    fn from(value: &ReplaceOrderResponse) -> Self {
        value.clone()
    }
}

impl ReplaceOrderResponse {
    pub fn builder() -> builder::ReplaceOrderResponse {
        Default::default()
    }
}

///The request identifier.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The request identifier.",
///  "type": "string"
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct RequestId(pub String);
impl std::ops::Deref for RequestId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl From<RequestId> for String {
    fn from(value: RequestId) -> Self {
        value.0
    }
}

impl From<&RequestId> for RequestId {
    fn from(value: &RequestId) -> Self {
        value.clone()
    }
}

impl From<String> for RequestId {
    fn from(value: String) -> Self {
        Self(value)
    }
}

impl std::str::FromStr for RequestId {
    type Err = std::convert::Infallible;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}

impl ToString for RequestId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

///A ResetResettablePLTransaction represents the resetting of the Account's
/// resettable PL counters.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A ResetResettablePLTransaction represents the resetting
/// of the Account's resettable PL counters.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"RESET_RESETTABLE_PL\" for a ResetResettablePLTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ResetResettablePlTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The Type of the Transaction. Always set to "RESET_RESETTABLE_PL" for
    /// a ResetResettablePLTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<ResetResettablePlTransactionType>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&ResetResettablePlTransaction> for ResetResettablePlTransaction {
    fn from(value: &ResetResettablePlTransaction) -> Self {
        value.clone()
    }
}

impl ResetResettablePlTransaction {
    pub fn builder() -> builder::ResetResettablePlTransaction {
        Default::default()
    }
}

///The Type of the Transaction. Always set to "RESET_RESETTABLE_PL" for a
/// ResetResettablePLTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"RESET_RESETTABLE_PL\" for a ResetResettablePLTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ResetResettablePlTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&ResetResettablePlTransactionType> for ResetResettablePlTransactionType {
    fn from(value: &ResetResettablePlTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for ResetResettablePlTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for ResetResettablePlTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for ResetResettablePlTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for ResetResettablePlTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for ResetResettablePlTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///SetOrderClientExtensionsBody
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "tradeClientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct SetOrderClientExtensionsBody {
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    #[serde(
        rename = "tradeClientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,
}

impl From<&SetOrderClientExtensionsBody> for SetOrderClientExtensionsBody {
    fn from(value: &SetOrderClientExtensionsBody) -> Self {
        value.clone()
    }
}

impl SetOrderClientExtensionsBody {
    pub fn builder() -> builder::SetOrderClientExtensionsBody {
        Default::default()
    }
}

///SetOrderClientExtensionsResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "lastTransactionID": {
///      "description": "The ID of the most recent Transaction created for
/// the Account",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "orderClientExtensionsModifyTransaction": {
///      "$ref":
/// "#/components/schemas/OrderClientExtensionsModifyTransaction"
///    },
///    "relatedTransactionIDs": {
///      "description": "The IDs of all Transactions that were created while
/// satisfying the request.",
///      "type": "array",
///      "items": {
///        "description": "The unique Transaction identifier within each
/// Account.",
///        "type": "string",
///        "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///      }
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct SetOrderClientExtensionsResponse {
    ///The ID of the most recent Transaction created for the Account
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
    #[serde(
        rename = "orderClientExtensionsModifyTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub order_client_extensions_modify_transaction: Option<OrderClientExtensionsModifyTransaction>,
    ///The IDs of all Transactions that were created while satisfying the
    /// request.
    #[serde(
        rename = "relatedTransactionIDs",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub related_transaction_i_ds: Vec<String>,
}

impl From<&SetOrderClientExtensionsResponse> for SetOrderClientExtensionsResponse {
    fn from(value: &SetOrderClientExtensionsResponse) -> Self {
        value.clone()
    }
}

impl SetOrderClientExtensionsResponse {
    pub fn builder() -> builder::SetOrderClientExtensionsResponse {
        Default::default()
    }
}

///SetTradeClientExtensionsBody
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct SetTradeClientExtensionsBody {
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
}

impl From<&SetTradeClientExtensionsBody> for SetTradeClientExtensionsBody {
    fn from(value: &SetTradeClientExtensionsBody) -> Self {
        value.clone()
    }
}

impl SetTradeClientExtensionsBody {
    pub fn builder() -> builder::SetTradeClientExtensionsBody {
        Default::default()
    }
}

///SetTradeClientExtensionsResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "lastTransactionID": {
///      "description": "The ID of the most recent Transaction created for
/// the Account",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "relatedTransactionIDs": {
///      "description": "The IDs of all Transactions that were created while
/// satisfying the request.",
///      "type": "array",
///      "items": {
///        "description": "The unique Transaction identifier within each
/// Account.",
///        "type": "string",
///        "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///      }
///    },
///    "tradeClientExtensionsModifyTransaction": {
///      "$ref":
/// "#/components/schemas/TradeClientExtensionsModifyTransaction"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct SetTradeClientExtensionsResponse {
    ///The ID of the most recent Transaction created for the Account
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
    ///The IDs of all Transactions that were created while satisfying the
    /// request.
    #[serde(
        rename = "relatedTransactionIDs",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub related_transaction_i_ds: Vec<String>,
    #[serde(
        rename = "tradeClientExtensionsModifyTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions_modify_transaction: Option<TradeClientExtensionsModifyTransaction>,
}

impl From<&SetTradeClientExtensionsResponse> for SetTradeClientExtensionsResponse {
    fn from(value: &SetTradeClientExtensionsResponse) -> Self {
        value.clone()
    }
}

impl SetTradeClientExtensionsResponse {
    pub fn builder() -> builder::SetTradeClientExtensionsResponse {
        Default::default()
    }
}

///SetTradeDependentOrdersBody
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "stopLoss": {
///      "$ref": "#/components/schemas/StopLossDetails"
///    },
///    "takeProfit": {
///      "$ref": "#/components/schemas/TakeProfitDetails"
///    },
///    "trailingStopLoss": {
///      "$ref": "#/components/schemas/TrailingStopLossDetails"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct SetTradeDependentOrdersBody {
    #[serde(rename = "stopLoss", default, skip_serializing_if = "Option::is_none")]
    pub stop_loss: Option<StopLossDetails>,
    #[serde(
        rename = "takeProfit",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub take_profit: Option<TakeProfitDetails>,
    #[serde(
        rename = "trailingStopLoss",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss: Option<TrailingStopLossDetails>,
}

impl From<&SetTradeDependentOrdersBody> for SetTradeDependentOrdersBody {
    fn from(value: &SetTradeDependentOrdersBody) -> Self {
        value.clone()
    }
}

impl SetTradeDependentOrdersBody {
    pub fn builder() -> builder::SetTradeDependentOrdersBody {
        Default::default()
    }
}

///SetTradeDependentOrdersResponse
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "lastTransactionID": {
///      "description": "The ID of the most recent Transaction created for
/// the Account",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "relatedTransactionIDs": {
///      "description": "The IDs of all Transactions that were created while
/// satisfying the request.",
///      "type": "array",
///      "items": {
///        "description": "The unique Transaction identifier within each
/// Account.",
///        "type": "string",
///        "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///      }
///    },
///    "stopLossOrderCancelTransaction": {
///      "$ref": "#/components/schemas/OrderCancelTransaction"
///    },
///    "stopLossOrderCreatedCancelTransaction": {
///      "$ref": "#/components/schemas/OrderCancelTransaction"
///    },
///    "stopLossOrderFillTransaction": {
///      "$ref": "#/components/schemas/OrderFillTransaction"
///    },
///    "stopLossOrderTransaction": {
///      "$ref": "#/components/schemas/StopLossOrderTransaction"
///    },
///    "takeProfitOrderCancelTransaction": {
///      "$ref": "#/components/schemas/OrderCancelTransaction"
///    },
///    "takeProfitOrderCreatedCancelTransaction": {
///      "$ref": "#/components/schemas/OrderCancelTransaction"
///    },
///    "takeProfitOrderFillTransaction": {
///      "$ref": "#/components/schemas/OrderFillTransaction"
///    },
///    "takeProfitOrderTransaction": {
///      "$ref": "#/components/schemas/TakeProfitOrderTransaction"
///    },
///    "trailingStopLossOrderCancelTransaction": {
///      "$ref": "#/components/schemas/OrderCancelTransaction"
///    },
///    "trailingStopLossOrderTransaction": {
///      "$ref": "#/components/schemas/TrailingStopLossOrderTransaction"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct SetTradeDependentOrdersResponse {
    ///The ID of the most recent Transaction created for the Account
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
    ///The IDs of all Transactions that were created while satisfying the
    /// request.
    #[serde(
        rename = "relatedTransactionIDs",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub related_transaction_i_ds: Vec<String>,
    #[serde(
        rename = "stopLossOrderCancelTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stop_loss_order_cancel_transaction: Option<OrderCancelTransaction>,
    #[serde(
        rename = "stopLossOrderCreatedCancelTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stop_loss_order_created_cancel_transaction: Option<OrderCancelTransaction>,
    #[serde(
        rename = "stopLossOrderFillTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stop_loss_order_fill_transaction: Option<OrderFillTransaction>,
    #[serde(
        rename = "stopLossOrderTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stop_loss_order_transaction: Option<StopLossOrderTransaction>,
    #[serde(
        rename = "takeProfitOrderCancelTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub take_profit_order_cancel_transaction: Option<OrderCancelTransaction>,
    #[serde(
        rename = "takeProfitOrderCreatedCancelTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub take_profit_order_created_cancel_transaction: Option<OrderCancelTransaction>,
    #[serde(
        rename = "takeProfitOrderFillTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub take_profit_order_fill_transaction: Option<OrderFillTransaction>,
    #[serde(
        rename = "takeProfitOrderTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub take_profit_order_transaction: Option<TakeProfitOrderTransaction>,
    #[serde(
        rename = "trailingStopLossOrderCancelTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_order_cancel_transaction: Option<OrderCancelTransaction>,
    #[serde(
        rename = "trailingStopLossOrderTransaction",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_order_transaction: Option<TrailingStopLossOrderTransaction>,
}

impl From<&SetTradeDependentOrdersResponse> for SetTradeDependentOrdersResponse {
    fn from(value: &SetTradeDependentOrdersResponse) -> Self {
        value.clone()
    }
}

impl SetTradeDependentOrdersResponse {
    pub fn builder() -> builder::SetTradeDependentOrdersResponse {
        Default::default()
    }
}

///The year that a Yearly Account Statement is generated for.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The year that a Yearly Account Statement is generated
/// for.",
///  "type": "integer"
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StatementYear(pub i64);
impl std::ops::Deref for StatementYear {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}

impl From<StatementYear> for i64 {
    fn from(value: StatementYear) -> Self {
        value.0
    }
}

impl From<&StatementYear> for StatementYear {
    fn from(value: &StatementYear) -> Self {
        value.clone()
    }
}

impl From<i64> for StatementYear {
    fn from(value: i64) -> Self {
        Self(value)
    }
}

impl std::str::FromStr for StatementYear {
    type Err = <i64 as std::str::FromStr>::Err;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Ok(Self(value.parse()?))
    }
}

impl std::convert::TryFrom<&str> for StatementYear {
    type Error = <i64 as std::str::FromStr>::Err;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StatementYear {
    type Error = <i64 as std::str::FromStr>::Err;
    fn try_from(value: &String) -> Result<Self, Self::Error> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StatementYear {
    type Error = <i64 as std::str::FromStr>::Err;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        value.parse()
    }
}

impl ToString for StatementYear {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

///StopLossDetails specifies the details of a Stop Loss Order to be created
/// on behalf of a client. This may happen when an Order is filled that
/// opens a Trade requiring a Stop Loss, or when a Trade's dependent Stop
/// Loss Order is modified directly through the Trade.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "StopLossDetails specifies the details of a Stop Loss
/// Order to be created on behalf of a client. This may happen when an Order
/// is filled that opens a Trade requiring a Stop Loss, or when a Trade's
/// dependent Stop Loss Order is modified directly through the Trade.",
///  "type": "object",
///  "properties": {
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "distance": {
///      "description": "Specifies the distance (in price units) from the
/// Trade's open price to use as the Stop Loss Order price. Only one of the
/// distance and price fields may be specified.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "gtdTime": {
///      "description": "The date when the Stop Loss Order will be cancelled
/// on if timeInForce is GTD.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "guaranteed": {
///      "description": "Flag indicating that the price for the Stop Loss Order is guaranteed. The default value depends on the GuaranteedStopLossOrderMode of the account, if it is REQUIRED, the default will be true, for DISABLED or ENABLED the default is false.",
///      "type": "boolean"
///    },
///    "price": {
///      "description": "The price that the Stop Loss Order will be
/// triggered at. Only one of the price and distance fields may be
/// specified.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "timeInForce": {
///      "description": "The time in force for the created Stop Loss Order.
/// This may only be GTC, GTD or GFD.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StopLossDetails {
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///Specifies the distance (in price units) from the Trade's open price
    /// to use as the Stop Loss Order price. Only one of the distance and
    /// price fields may be specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distance: Option<String>,
    ///The date when the Stop Loss Order will be cancelled on if
    /// timeInForce is GTD.
    #[serde(rename = "gtdTime", default, skip_serializing_if = "Option::is_none")]
    pub gtd_time: Option<String>,
    ///Flag indicating that the price for the Stop Loss Order is
    /// guaranteed. The default value depends on the
    /// GuaranteedStopLossOrderMode of the account, if it is REQUIRED, the
    /// default will be true, for DISABLED or ENABLED the default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub guaranteed: Option<bool>,
    ///The price that the Stop Loss Order will be triggered at. Only one of
    /// the price and distance fields may be specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The time in force for the created Stop Loss Order. This may only be
    /// GTC, GTD or GFD.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<StopLossDetailsTimeInForce>,
}

impl From<&StopLossDetails> for StopLossDetails {
    fn from(value: &StopLossDetails) -> Self {
        value.clone()
    }
}

impl StopLossDetails {
    pub fn builder() -> builder::StopLossDetails {
        Default::default()
    }
}

///The time in force for the created Stop Loss Order. This may only be GTC,
/// GTD or GFD.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time in force for the created Stop Loss Order. This
/// may only be GTC, GTD or GFD.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopLossDetailsTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&StopLossDetailsTimeInForce> for StopLossDetailsTimeInForce {
    fn from(value: &StopLossDetailsTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for StopLossDetailsTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for StopLossDetailsTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopLossDetailsTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopLossDetailsTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopLossDetailsTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A StopLossOrder is an order that is linked to an open Trade and created
/// with a price threshold. The Order will be filled (closing the Trade) by
/// the first price that is equal to or worse than the threshold. A
/// StopLossOrder cannot be used to open a new Position.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A StopLossOrder is an order that is linked to an open Trade and created with a price threshold. The Order will be filled (closing the Trade) by the first price that is equal to or worse than the threshold. A StopLossOrder cannot be used to open a new Position.",
///  "type": "object",
///  "properties": {
///    "cancelledTime": {
///      "description": "Date/time when the Order was cancelled (only
/// provided when the state of the Order is CANCELLED)",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "cancellingTransactionID": {
///      "description": "ID of the Transaction that cancelled the Order
/// (only provided when the Order's state is CANCELLED)",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "clientTradeID": {
///      "description": "The client ID of the Trade to be closed when the
/// price threshold is breached.",
///      "type": "string"
///    },
///    "createTime": {
///      "description": "The time when the Order was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "distance": {
///      "description": "Specifies the distance (in price units) from the
/// Account's current price to use as the Stop Loss Order price. If the
/// Trade is short the Instrument's bid price is used, and for long Trades
/// the ask is used.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "filledTime": {
///      "description": "Date/time when the Order was filled (only provided
/// when the Order's state is FILLED)",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "fillingTransactionID": {
///      "description": "ID of the Transaction that filled this Order (only
/// provided when the Order's state is FILLED)",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "gtdTime": {
///      "description": "The date/time when the StopLoss Order will be
/// cancelled if its timeInForce is \"GTD\".",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "guaranteed": {
///      "description": "Flag indicating that the Stop Loss Order is
/// guaranteed. The default value depends on the GuaranteedStopLossOrderMode
/// of the account, if it is REQUIRED, the default will be true, for
/// DISABLED or ENABLED the default is false.",
///      "type": "boolean"
///    },
///    "guaranteedExecutionPremium": {
///      "description": "The premium that will be charged if the Stop Loss
/// Order is guaranteed and the Order is filled at the guaranteed price. It
/// is in price units and is charged for each unit of the Trade.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "id": {
///      "description": "The Order's identifier, unique within the Order's
/// Account.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "price": {
///      "description": "The price threshold specified for the Stop Loss Order. If the guaranteed flag is false, the associated Trade will be closed by a market price that is equal to or worse than this threshold. If the flag is true the associated Trade will be closed at this price.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "replacedByOrderID": {
///      "description": "The ID of the Order that replaced this Order (only
/// provided if this Order was cancelled as part of a cancel/replace).",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "replacesOrderID": {
///      "description": "The ID of the Order that was replaced by this Order (only provided if this Order was created as part of a cancel/replace).",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "state": {
///      "description": "The current state of the Order.",
///      "type": "string",
///      "enum": [
///        "PENDING",
///        "FILLED",
///        "TRIGGERED",
///        "CANCELLED"
///      ]
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the StopLoss Order.
/// Restricted to \"GTC\", \"GFD\" and \"GTD\" for StopLoss Orders.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeClosedIDs": {
///      "description": "Trade IDs of Trades closed when the Order was
/// filled (only provided when the Order's state is FILLED and one or more
/// Trades were closed as a result of the fill)",
///      "type": "array",
///      "items": {
///        "description": "The Trade's identifier, unique within the Trade's
/// Account.",
///        "type": "string",
///        "format": "The string representation of the OANDA-assigned
/// TradeID. OANDA-assigned TradeIDs are positive integers, and are derived
/// from the TransactionID of the Transaction that opened the Trade."
///      }
///    },
///    "tradeID": {
///      "description": "The ID of the Trade to close when the price
/// threshold is breached.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "tradeOpenedID": {
///      "description": "Trade ID of Trade opened when the Order was filled
/// (only provided when the Order's state is FILLED and a Trade was opened
/// as a result of the fill)",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "tradeReducedID": {
///      "description": "Trade ID of Trade reduced when the Order was filled
/// (only provided when the Order's state is FILLED and a Trade was reduced
/// as a result of the fill)",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "triggerCondition": {
///      "description": "Specification of which price component should be
/// used when determining if an Order should be triggered and filled. This
/// allows Orders to be triggered based on the bid, ask, mid, default (ask
/// for buy, bid for sell) or inverse (ask for sell, bid for buy) price
/// depending on the desired behaviour. Orders are always filled using their
/// default price component.\nThis feature is only provided through the REST
/// API. Clients who choose to specify a non-default trigger condition will
/// not see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///      "type": "string",
///      "enum": [
///        "DEFAULT",
///        "INVERSE",
///        "BID",
///        "ASK",
///        "MID"
///      ]
///    },
///    "type": {
///      "description": "The type of the Order. Always set to \"STOP_LOSS\"
/// for Stop Loss Orders.",
///      "type": "string",
///      "enum": [
///        "MARKET",
///        "LIMIT",
///        "STOP",
///        "MARKET_IF_TOUCHED",
///        "TAKE_PROFIT",
///        "STOP_LOSS",
///        "TRAILING_STOP_LOSS",
///        "FIXED_PRICE"
///      ]
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StopLossOrder {
    ///Date/time when the Order was cancelled (only provided when the state
    /// of the Order is CANCELLED)
    #[serde(
        rename = "cancelledTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelled_time: Option<String>,
    ///ID of the Transaction that cancelled the Order (only provided when
    /// the Order's state is CANCELLED)
    #[serde(
        rename = "cancellingTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The client ID of the Trade to be closed when the price threshold is
    /// breached.
    #[serde(
        rename = "clientTradeID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_trade_id: Option<String>,
    ///The time when the Order was created.
    #[serde(
        rename = "createTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub create_time: Option<String>,
    ///Specifies the distance (in price units) from the Account's current
    /// price to use as the Stop Loss Order price. If the Trade is short the
    /// Instrument's bid price is used, and for long Trades the ask is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distance: Option<String>,
    ///Date/time when the Order was filled (only provided when the Order's
    /// state is FILLED)
    #[serde(
        rename = "filledTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub filled_time: Option<String>,
    ///ID of the Transaction that filled this Order (only provided when the
    /// Order's state is FILLED)
    #[serde(
        rename = "fillingTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub filling_transaction_id: Option<String>,
    ///The date/time when the StopLoss Order will be cancelled if its
    /// timeInForce is "GTD".
    #[serde(rename = "gtdTime", default, skip_serializing_if = "Option::is_none")]
    pub gtd_time: Option<String>,
    ///Flag indicating that the Stop Loss Order is guaranteed. The default
    /// value depends on the GuaranteedStopLossOrderMode of the account, if
    /// it is REQUIRED, the default will be true, for DISABLED or ENABLED
    /// the default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub guaranteed: Option<bool>,
    ///The premium that will be charged if the Stop Loss Order is
    /// guaranteed and the Order is filled at the guaranteed price. It is in
    /// price units and is charged for each unit of the Trade.
    #[serde(
        rename = "guaranteedExecutionPremium",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub guaranteed_execution_premium: Option<String>,
    ///The Order's identifier, unique within the Order's Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The price threshold specified for the Stop Loss Order. If the
    /// guaranteed flag is false, the associated Trade will be closed by a
    /// market price that is equal to or worse than this threshold. If the
    /// flag is true the associated Trade will be closed at this price.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The ID of the Order that replaced this Order (only provided if this
    /// Order was cancelled as part of a cancel/replace).
    #[serde(
        rename = "replacedByOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub replaced_by_order_id: Option<String>,
    ///The ID of the Order that was replaced by this Order (only provided
    /// if this Order was created as part of a cancel/replace).
    #[serde(
        rename = "replacesOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub replaces_order_id: Option<String>,
    ///The current state of the Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<StopLossOrderState>,
    ///The time-in-force requested for the StopLoss Order. Restricted to
    /// "GTC", "GFD" and "GTD" for StopLoss Orders.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<StopLossOrderTimeInForce>,
    ///Trade IDs of Trades closed when the Order was filled (only provided
    /// when the Order's state is FILLED and one or more Trades were closed
    /// as a result of the fill)
    #[serde(
        rename = "tradeClosedIDs",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub trade_closed_i_ds: Vec<String>,
    ///The ID of the Trade to close when the price threshold is breached.
    #[serde(rename = "tradeID", default, skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,
    ///Trade ID of Trade opened when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was opened as a result
    /// of the fill)
    #[serde(
        rename = "tradeOpenedID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_opened_id: Option<String>,
    ///Trade ID of Trade reduced when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was reduced as a result
    /// of the fill)
    #[serde(
        rename = "tradeReducedID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_reduced_id: Option<String>,
    ///Specification of which price component should be used when
    /// determining if an Order should be triggered and filled. This allows
    /// Orders to be triggered based on the bid, ask, mid, default (ask for
    /// buy, bid for sell) or inverse (ask for sell, bid for buy) price
    /// depending on the desired behaviour. Orders are always filled using
    /// their default price component. This feature is only provided
    /// through the REST API. Clients who choose to specify a non-default
    /// trigger condition will not see it reflected in any of OANDA's
    /// proprietary or partner trading platforms, their transaction history
    /// or their account statements. OANDA platforms always assume that an
    /// Order's trigger condition is set to the default value when
    /// indicating the distance from an Order's trigger price, and will
    /// always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when
    /// creating a guaranteed Stop Loss Order. In this case the
    /// TriggerCondition value must either be "DEFAULT", or the "natural"
    /// trigger side "DEFAULT" results in. So for a Stop Loss Order for a
    /// long trade valid values are "DEFAULT" and "BID", and for short
    /// trades "DEFAULT" and "ASK" are valid.
    #[serde(
        rename = "triggerCondition",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trigger_condition: Option<StopLossOrderTriggerCondition>,
    ///The type of the Order. Always set to "STOP_LOSS" for Stop Loss
    /// Orders.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<StopLossOrderType>,
}

impl From<&StopLossOrder> for StopLossOrder {
    fn from(value: &StopLossOrder) -> Self {
        value.clone()
    }
}

impl StopLossOrder {
    pub fn builder() -> builder::StopLossOrder {
        Default::default()
    }
}

///The reason that the Stop Loss Order was initiated
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Stop Loss Order was initiated",
///  "type": "string",
///  "enum": [
///    "CLIENT_ORDER",
///    "REPLACEMENT",
///    "ON_FILL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopLossOrderReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "REPLACEMENT")]
    Replacement,
    #[serde(rename = "ON_FILL")]
    OnFill,
}

impl From<&StopLossOrderReason> for StopLossOrderReason {
    fn from(value: &StopLossOrderReason) -> Self {
        value.clone()
    }
}

impl ToString for StopLossOrderReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ClientOrder => "CLIENT_ORDER".to_string(),
            Self::Replacement => "REPLACEMENT".to_string(),
            Self::OnFill => "ON_FILL".to_string(),
        }
    }
}

impl std::str::FromStr for StopLossOrderReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CLIENT_ORDER" => Ok(Self::ClientOrder),
            "REPLACEMENT" => Ok(Self::Replacement),
            "ON_FILL" => Ok(Self::OnFill),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopLossOrderReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopLossOrderReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopLossOrderReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A StopLossOrderRejectTransaction represents the rejection of the
/// creation of a StopLoss Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A StopLossOrderRejectTransaction represents the
/// rejection of the creation of a StopLoss Order.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "clientTradeID": {
///      "description": "The client ID of the Trade to be closed when the
/// price threshold is breached.",
///      "type": "string"
///    },
///    "distance": {
///      "description": "Specifies the distance (in price units) from the
/// Account's current price to use as the Stop Loss Order price. If the
/// Trade is short the Instrument's bid price is used, and for long Trades
/// the ask is used.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "gtdTime": {
///      "description": "The date/time when the StopLoss Order will be
/// cancelled if its timeInForce is \"GTD\".",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "guaranteed": {
///      "description": "Flag indicating that the Stop Loss Order is
/// guaranteed. The default value depends on the GuaranteedStopLossOrderMode
/// of the account, if it is REQUIRED, the default will be true, for
/// DISABLED or ENABLED the default is false.",
///      "type": "boolean"
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "intendedReplacesOrderID": {
///      "description": "The ID of the Order that this Order was intended to
/// replace (only provided if this Order was intended to replace an existing
/// Order).",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "orderFillTransactionID": {
///      "description": "The ID of the OrderFill Transaction that caused
/// this Order to be created (only provided if this Order was created
/// automatically when another Order was filled).",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "price": {
///      "description": "The price threshold specified for the Stop Loss Order. If the guaranteed flag is false, the associated Trade will be closed by a market price that is equal to or worse than this threshold. If the flag is true the associated Trade will be closed at this price.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "reason": {
///      "description": "The reason that the Stop Loss Order was initiated",
///      "type": "string",
///      "enum": [
///        "CLIENT_ORDER",
///        "REPLACEMENT",
///        "ON_FILL"
///      ]
///    },
///    "rejectReason": {
///      "description": "The reason that the Reject Transaction was
/// created",
///      "type": "string",
///      "enum": [
///        "INTERNAL_SERVER_ERROR",
///        "INSTRUMENT_PRICE_UNKNOWN",
///        "ACCOUNT_NOT_ACTIVE",
///        "ACCOUNT_LOCKED",
///        "ACCOUNT_ORDER_CREATION_LOCKED",
///        "ACCOUNT_CONFIGURATION_LOCKED",
///        "ACCOUNT_DEPOSIT_LOCKED",
///        "ACCOUNT_WITHDRAWAL_LOCKED",
///        "ACCOUNT_ORDER_CANCEL_LOCKED",
///        "INSTRUMENT_NOT_TRADEABLE",
///        "PENDING_ORDERS_ALLOWED_EXCEEDED",
///        "ORDER_ID_UNSPECIFIED",
///        "ORDER_DOESNT_EXIST",
///        "ORDER_IDENTIFIER_INCONSISTENCY",
///        "TRADE_ID_UNSPECIFIED",
///        "TRADE_DOESNT_EXIST",
///        "TRADE_IDENTIFIER_INCONSISTENCY",
///        "INSUFFICIENT_MARGIN",
///        "INSTRUMENT_MISSING",
///        "INSTRUMENT_UNKNOWN",
///        "UNITS_MISSING",
///        "UNITS_INVALID",
///        "UNITS_PRECISION_EXCEEDED",
///        "UNITS_LIMIT_EXCEEDED",
///        "UNITS_MIMIMUM_NOT_MET",
///        "PRICE_MISSING",
///        "PRICE_INVALID",
///        "PRICE_PRECISION_EXCEEDED",
///        "PRICE_DISTANCE_MISSING",
///        "PRICE_DISTANCE_INVALID",
///        "PRICE_DISTANCE_PRECISION_EXCEEDED",
///        "PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "PRICE_DISTANCE_MINIMUM_NOT_MET",
///        "TIME_IN_FORCE_MISSING",
///        "TIME_IN_FORCE_INVALID",
///        "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING",
///        "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST",
///        "PRICE_BOUND_INVALID",
///        "PRICE_BOUND_PRECISION_EXCEEDED",
///        "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS",
///        "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED",
///        "CLIENT_ORDER_ID_INVALID",
///        "CLIENT_ORDER_ID_ALREADY_EXISTS",
///        "CLIENT_ORDER_TAG_INVALID",
///        "CLIENT_ORDER_COMMENT_INVALID",
///        "CLIENT_TRADE_ID_INVALID",
///        "CLIENT_TRADE_ID_ALREADY_EXISTS",
///        "CLIENT_TRADE_TAG_INVALID",
///        "CLIENT_TRADE_COMMENT_INVALID",
///        "ORDER_FILL_POSITION_ACTION_MISSING",
///        "ORDER_FILL_POSITION_ACTION_INVALID",
///        "TRIGGER_CONDITION_MISSING",
///        "TRIGGER_CONDITION_INVALID",
///        "ORDER_PARTIAL_FILL_OPTION_MISSING",
///        "ORDER_PARTIAL_FILL_OPTION_INVALID",
///        "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL",
///        "TAKE_PROFIT_ORDER_ALREADY_EXISTS",
///        "TAKE_PROFIT_ON_FILL_PRICE_MISSING",
///        "TAKE_PROFIT_ON_FILL_PRICE_INVALID",
///        "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED",
///        "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING",
///        "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID",
///        "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "STOP_LOSS_ORDER_ALREADY_EXISTS",
///        "STOP_LOSS_ORDER_GUARANTEED_REQUIRED",
///        "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD",
///        "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED",
///        "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION",
///        "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION",
///        "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED",
///        "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///        "STOP_LOSS_ORDER_NOT_CANCELABLE",
///        "STOP_LOSS_ORDER_NOT_REPLACEABLE",
///        "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///        "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///        "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING",
///        "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER",
///        "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///        "STOP_LOSS_ON_FILL_PRICE_MISSING",
///        "STOP_LOSS_ON_FILL_PRICE_INVALID",
///        "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///        "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_DISTANCE_INVALID",
///        "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///        "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING",
///        "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///        "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///        "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET",
///        "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED",
///        "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "CLOSE_TRADE_TYPE_MISSING",
///        "CLOSE_TRADE_PARTIAL_UNITS_MISSING",
///        "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE",
///        "CLOSEOUT_POSITION_DOESNT_EXIST",
///        "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION",
///        "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE",
///        "CLOSEOUT_POSITION_REJECT",
///        "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING",
///        "MARKUP_GROUP_ID_INVALID",
///        "POSITION_AGGREGATION_MODE_INVALID",
///        "ADMIN_CONFIGURE_DATA_MISSING",
///        "MARGIN_RATE_INVALID",
///        "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT",
///        "ALIAS_INVALID",
///        "CLIENT_CONFIGURE_DATA_MISSING",
///        "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL",
///        "AMOUNT_INVALID",
///        "INSUFFICIENT_FUNDS",
///        "AMOUNT_MISSING",
///        "FUNDING_REASON_MISSING",
///        "CLIENT_EXTENSIONS_DATA_MISSING",
///        "REPLACING_ORDER_INVALID",
///        "REPLACING_TRADE_ID_INVALID"
///      ]
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the StopLoss Order.
/// Restricted to \"GTC\", \"GFD\" and \"GTD\" for StopLoss Orders.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeID": {
///      "description": "The ID of the Trade to close when the price
/// threshold is breached.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "triggerCondition": {
///      "description": "Specification of which price component should be
/// used when determining if an Order should be triggered and filled. This
/// allows Orders to be triggered based on the bid, ask, mid, default (ask
/// for buy, bid for sell) or inverse (ask for sell, bid for buy) price
/// depending on the desired behaviour. Orders are always filled using their
/// default price component.\nThis feature is only provided through the REST
/// API. Clients who choose to specify a non-default trigger condition will
/// not see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///      "type": "string",
///      "enum": [
///        "DEFAULT",
///        "INVERSE",
///        "BID",
///        "ASK",
///        "MID"
///      ]
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"STOP_LOSS_ORDER_REJECT\" in a StopLossOrderRejectTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StopLossOrderRejectTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The client ID of the Trade to be closed when the price threshold is
    /// breached.
    #[serde(
        rename = "clientTradeID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_trade_id: Option<String>,
    ///Specifies the distance (in price units) from the Account's current
    /// price to use as the Stop Loss Order price. If the Trade is short the
    /// Instrument's bid price is used, and for long Trades the ask is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distance: Option<String>,
    ///The date/time when the StopLoss Order will be cancelled if its
    /// timeInForce is "GTD".
    #[serde(rename = "gtdTime", default, skip_serializing_if = "Option::is_none")]
    pub gtd_time: Option<String>,
    ///Flag indicating that the Stop Loss Order is guaranteed. The default
    /// value depends on the GuaranteedStopLossOrderMode of the account, if
    /// it is REQUIRED, the default will be true, for DISABLED or ENABLED
    /// the default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub guaranteed: Option<bool>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The ID of the Order that this Order was intended to replace (only
    /// provided if this Order was intended to replace an existing Order).
    #[serde(
        rename = "intendedReplacesOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub intended_replaces_order_id: Option<String>,
    ///The ID of the OrderFill Transaction that caused this Order to be
    /// created (only provided if this Order was created automatically when
    /// another Order was filled).
    #[serde(
        rename = "orderFillTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub order_fill_transaction_id: Option<String>,
    ///The price threshold specified for the Stop Loss Order. If the
    /// guaranteed flag is false, the associated Trade will be closed by a
    /// market price that is equal to or worse than this threshold. If the
    /// flag is true the associated Trade will be closed at this price.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The reason that the Stop Loss Order was initiated
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<StopLossOrderRejectTransactionReason>,
    ///The reason that the Reject Transaction was created
    #[serde(
        rename = "rejectReason",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub reject_reason: Option<StopLossOrderRejectTransactionRejectReason>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The time-in-force requested for the StopLoss Order. Restricted to
    /// "GTC", "GFD" and "GTD" for StopLoss Orders.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<StopLossOrderRejectTransactionTimeInForce>,
    ///The ID of the Trade to close when the price threshold is breached.
    #[serde(rename = "tradeID", default, skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,
    ///Specification of which price component should be used when
    /// determining if an Order should be triggered and filled. This allows
    /// Orders to be triggered based on the bid, ask, mid, default (ask for
    /// buy, bid for sell) or inverse (ask for sell, bid for buy) price
    /// depending on the desired behaviour. Orders are always filled using
    /// their default price component. This feature is only provided
    /// through the REST API. Clients who choose to specify a non-default
    /// trigger condition will not see it reflected in any of OANDA's
    /// proprietary or partner trading platforms, their transaction history
    /// or their account statements. OANDA platforms always assume that an
    /// Order's trigger condition is set to the default value when
    /// indicating the distance from an Order's trigger price, and will
    /// always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when
    /// creating a guaranteed Stop Loss Order. In this case the
    /// TriggerCondition value must either be "DEFAULT", or the "natural"
    /// trigger side "DEFAULT" results in. So for a Stop Loss Order for a
    /// long trade valid values are "DEFAULT" and "BID", and for short
    /// trades "DEFAULT" and "ASK" are valid.
    #[serde(
        rename = "triggerCondition",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trigger_condition: Option<StopLossOrderRejectTransactionTriggerCondition>,
    ///The Type of the Transaction. Always set to "STOP_LOSS_ORDER_REJECT"
    /// in a StopLossOrderRejectTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<StopLossOrderRejectTransactionType>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&StopLossOrderRejectTransaction> for StopLossOrderRejectTransaction {
    fn from(value: &StopLossOrderRejectTransaction) -> Self {
        value.clone()
    }
}

impl StopLossOrderRejectTransaction {
    pub fn builder() -> builder::StopLossOrderRejectTransaction {
        Default::default()
    }
}

///The reason that the Stop Loss Order was initiated
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Stop Loss Order was initiated",
///  "type": "string",
///  "enum": [
///    "CLIENT_ORDER",
///    "REPLACEMENT",
///    "ON_FILL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopLossOrderRejectTransactionReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "REPLACEMENT")]
    Replacement,
    #[serde(rename = "ON_FILL")]
    OnFill,
}

impl From<&StopLossOrderRejectTransactionReason> for StopLossOrderRejectTransactionReason {
    fn from(value: &StopLossOrderRejectTransactionReason) -> Self {
        value.clone()
    }
}

impl ToString for StopLossOrderRejectTransactionReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ClientOrder => "CLIENT_ORDER".to_string(),
            Self::Replacement => "REPLACEMENT".to_string(),
            Self::OnFill => "ON_FILL".to_string(),
        }
    }
}

impl std::str::FromStr for StopLossOrderRejectTransactionReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CLIENT_ORDER" => Ok(Self::ClientOrder),
            "REPLACEMENT" => Ok(Self::Replacement),
            "ON_FILL" => Ok(Self::OnFill),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopLossOrderRejectTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopLossOrderRejectTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopLossOrderRejectTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The reason that the Reject Transaction was created
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Reject Transaction was created",
///  "type": "string",
///  "enum": [
///    "INTERNAL_SERVER_ERROR",
///    "INSTRUMENT_PRICE_UNKNOWN",
///    "ACCOUNT_NOT_ACTIVE",
///    "ACCOUNT_LOCKED",
///    "ACCOUNT_ORDER_CREATION_LOCKED",
///    "ACCOUNT_CONFIGURATION_LOCKED",
///    "ACCOUNT_DEPOSIT_LOCKED",
///    "ACCOUNT_WITHDRAWAL_LOCKED",
///    "ACCOUNT_ORDER_CANCEL_LOCKED",
///    "INSTRUMENT_NOT_TRADEABLE",
///    "PENDING_ORDERS_ALLOWED_EXCEEDED",
///    "ORDER_ID_UNSPECIFIED",
///    "ORDER_DOESNT_EXIST",
///    "ORDER_IDENTIFIER_INCONSISTENCY",
///    "TRADE_ID_UNSPECIFIED",
///    "TRADE_DOESNT_EXIST",
///    "TRADE_IDENTIFIER_INCONSISTENCY",
///    "INSUFFICIENT_MARGIN",
///    "INSTRUMENT_MISSING",
///    "INSTRUMENT_UNKNOWN",
///    "UNITS_MISSING",
///    "UNITS_INVALID",
///    "UNITS_PRECISION_EXCEEDED",
///    "UNITS_LIMIT_EXCEEDED",
///    "UNITS_MIMIMUM_NOT_MET",
///    "PRICE_MISSING",
///    "PRICE_INVALID",
///    "PRICE_PRECISION_EXCEEDED",
///    "PRICE_DISTANCE_MISSING",
///    "PRICE_DISTANCE_INVALID",
///    "PRICE_DISTANCE_PRECISION_EXCEEDED",
///    "PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "PRICE_DISTANCE_MINIMUM_NOT_MET",
///    "TIME_IN_FORCE_MISSING",
///    "TIME_IN_FORCE_INVALID",
///    "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING",
///    "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST",
///    "PRICE_BOUND_INVALID",
///    "PRICE_BOUND_PRECISION_EXCEEDED",
///    "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS",
///    "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED",
///    "CLIENT_ORDER_ID_INVALID",
///    "CLIENT_ORDER_ID_ALREADY_EXISTS",
///    "CLIENT_ORDER_TAG_INVALID",
///    "CLIENT_ORDER_COMMENT_INVALID",
///    "CLIENT_TRADE_ID_INVALID",
///    "CLIENT_TRADE_ID_ALREADY_EXISTS",
///    "CLIENT_TRADE_TAG_INVALID",
///    "CLIENT_TRADE_COMMENT_INVALID",
///    "ORDER_FILL_POSITION_ACTION_MISSING",
///    "ORDER_FILL_POSITION_ACTION_INVALID",
///    "TRIGGER_CONDITION_MISSING",
///    "TRIGGER_CONDITION_INVALID",
///    "ORDER_PARTIAL_FILL_OPTION_MISSING",
///    "ORDER_PARTIAL_FILL_OPTION_INVALID",
///    "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL",
///    "TAKE_PROFIT_ORDER_ALREADY_EXISTS",
///    "TAKE_PROFIT_ON_FILL_PRICE_MISSING",
///    "TAKE_PROFIT_ON_FILL_PRICE_INVALID",
///    "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED",
///    "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING",
///    "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "STOP_LOSS_ORDER_ALREADY_EXISTS",
///    "STOP_LOSS_ORDER_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD",
///    "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION",
///    "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION",
///    "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED",
///    "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ORDER_NOT_CANCELABLE",
///    "STOP_LOSS_ORDER_NOT_REPLACEABLE",
///    "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///    "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING",
///    "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER",
///    "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ON_FILL_PRICE_MISSING",
///    "STOP_LOSS_ON_FILL_PRICE_INVALID",
///    "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_DISTANCE_INVALID",
///    "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///    "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET",
///    "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED",
///    "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "CLOSE_TRADE_TYPE_MISSING",
///    "CLOSE_TRADE_PARTIAL_UNITS_MISSING",
///    "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE",
///    "CLOSEOUT_POSITION_DOESNT_EXIST",
///    "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION",
///    "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE",
///    "CLOSEOUT_POSITION_REJECT",
///    "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING",
///    "MARKUP_GROUP_ID_INVALID",
///    "POSITION_AGGREGATION_MODE_INVALID",
///    "ADMIN_CONFIGURE_DATA_MISSING",
///    "MARGIN_RATE_INVALID",
///    "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT",
///    "ALIAS_INVALID",
///    "CLIENT_CONFIGURE_DATA_MISSING",
///    "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL",
///    "AMOUNT_INVALID",
///    "INSUFFICIENT_FUNDS",
///    "AMOUNT_MISSING",
///    "FUNDING_REASON_MISSING",
///    "CLIENT_EXTENSIONS_DATA_MISSING",
///    "REPLACING_ORDER_INVALID",
///    "REPLACING_TRADE_ID_INVALID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopLossOrderRejectTransactionRejectReason {
    #[serde(rename = "INTERNAL_SERVER_ERROR")]
    InternalServerError,
    #[serde(rename = "INSTRUMENT_PRICE_UNKNOWN")]
    InstrumentPriceUnknown,
    #[serde(rename = "ACCOUNT_NOT_ACTIVE")]
    AccountNotActive,
    #[serde(rename = "ACCOUNT_LOCKED")]
    AccountLocked,
    #[serde(rename = "ACCOUNT_ORDER_CREATION_LOCKED")]
    AccountOrderCreationLocked,
    #[serde(rename = "ACCOUNT_CONFIGURATION_LOCKED")]
    AccountConfigurationLocked,
    #[serde(rename = "ACCOUNT_DEPOSIT_LOCKED")]
    AccountDepositLocked,
    #[serde(rename = "ACCOUNT_WITHDRAWAL_LOCKED")]
    AccountWithdrawalLocked,
    #[serde(rename = "ACCOUNT_ORDER_CANCEL_LOCKED")]
    AccountOrderCancelLocked,
    #[serde(rename = "INSTRUMENT_NOT_TRADEABLE")]
    InstrumentNotTradeable,
    #[serde(rename = "PENDING_ORDERS_ALLOWED_EXCEEDED")]
    PendingOrdersAllowedExceeded,
    #[serde(rename = "ORDER_ID_UNSPECIFIED")]
    OrderIdUnspecified,
    #[serde(rename = "ORDER_DOESNT_EXIST")]
    OrderDoesntExist,
    #[serde(rename = "ORDER_IDENTIFIER_INCONSISTENCY")]
    OrderIdentifierInconsistency,
    #[serde(rename = "TRADE_ID_UNSPECIFIED")]
    TradeIdUnspecified,
    #[serde(rename = "TRADE_DOESNT_EXIST")]
    TradeDoesntExist,
    #[serde(rename = "TRADE_IDENTIFIER_INCONSISTENCY")]
    TradeIdentifierInconsistency,
    #[serde(rename = "INSUFFICIENT_MARGIN")]
    InsufficientMargin,
    #[serde(rename = "INSTRUMENT_MISSING")]
    InstrumentMissing,
    #[serde(rename = "INSTRUMENT_UNKNOWN")]
    InstrumentUnknown,
    #[serde(rename = "UNITS_MISSING")]
    UnitsMissing,
    #[serde(rename = "UNITS_INVALID")]
    UnitsInvalid,
    #[serde(rename = "UNITS_PRECISION_EXCEEDED")]
    UnitsPrecisionExceeded,
    #[serde(rename = "UNITS_LIMIT_EXCEEDED")]
    UnitsLimitExceeded,
    #[serde(rename = "UNITS_MIMIMUM_NOT_MET")]
    UnitsMimimumNotMet,
    #[serde(rename = "PRICE_MISSING")]
    PriceMissing,
    #[serde(rename = "PRICE_INVALID")]
    PriceInvalid,
    #[serde(rename = "PRICE_PRECISION_EXCEEDED")]
    PricePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MISSING")]
    PriceDistanceMissing,
    #[serde(rename = "PRICE_DISTANCE_INVALID")]
    PriceDistanceInvalid,
    #[serde(rename = "PRICE_DISTANCE_PRECISION_EXCEEDED")]
    PriceDistancePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    PriceDistanceMaximumExceeded,
    #[serde(rename = "PRICE_DISTANCE_MINIMUM_NOT_MET")]
    PriceDistanceMinimumNotMet,
    #[serde(rename = "TIME_IN_FORCE_MISSING")]
    TimeInForceMissing,
    #[serde(rename = "TIME_IN_FORCE_INVALID")]
    TimeInForceInvalid,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING")]
    TimeInForceGtdTimestampMissing,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST")]
    TimeInForceGtdTimestampInPast,
    #[serde(rename = "PRICE_BOUND_INVALID")]
    PriceBoundInvalid,
    #[serde(rename = "PRICE_BOUND_PRECISION_EXCEEDED")]
    PriceBoundPrecisionExceeded,
    #[serde(rename = "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS")]
    OrdersOnFillDuplicateClientOrderIds,
    #[serde(rename = "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED")]
    TradeOnFillClientExtensionsNotSupported,
    #[serde(rename = "CLIENT_ORDER_ID_INVALID")]
    ClientOrderIdInvalid,
    #[serde(rename = "CLIENT_ORDER_ID_ALREADY_EXISTS")]
    ClientOrderIdAlreadyExists,
    #[serde(rename = "CLIENT_ORDER_TAG_INVALID")]
    ClientOrderTagInvalid,
    #[serde(rename = "CLIENT_ORDER_COMMENT_INVALID")]
    ClientOrderCommentInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_INVALID")]
    ClientTradeIdInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_ALREADY_EXISTS")]
    ClientTradeIdAlreadyExists,
    #[serde(rename = "CLIENT_TRADE_TAG_INVALID")]
    ClientTradeTagInvalid,
    #[serde(rename = "CLIENT_TRADE_COMMENT_INVALID")]
    ClientTradeCommentInvalid,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_MISSING")]
    OrderFillPositionActionMissing,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_INVALID")]
    OrderFillPositionActionInvalid,
    #[serde(rename = "TRIGGER_CONDITION_MISSING")]
    TriggerConditionMissing,
    #[serde(rename = "TRIGGER_CONDITION_INVALID")]
    TriggerConditionInvalid,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_MISSING")]
    OrderPartialFillOptionMissing,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_INVALID")]
    OrderPartialFillOptionInvalid,
    #[serde(rename = "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL")]
    InvalidReissueImmediatePartialFill,
    #[serde(rename = "TAKE_PROFIT_ORDER_ALREADY_EXISTS")]
    TakeProfitOrderAlreadyExists,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_MISSING")]
    TakeProfitOnFillPriceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_INVALID")]
    TakeProfitOnFillPriceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    TakeProfitOnFillPricePrecisionExceeded,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING")]
    TakeProfitOnFillTimeInForceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID")]
    TakeProfitOnFillTimeInForceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TakeProfitOnFillGtdTimestampMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TakeProfitOnFillGtdTimestampInPast,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TakeProfitOnFillClientOrderIdInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TakeProfitOnFillClientOrderTagInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TakeProfitOnFillClientOrderCommentInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TakeProfitOnFillTriggerConditionMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TakeProfitOnFillTriggerConditionInvalid,
    #[serde(rename = "STOP_LOSS_ORDER_ALREADY_EXISTS")]
    StopLossOrderAlreadyExists,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_REQUIRED")]
    StopLossOrderGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD")]
    StopLossOrderGuaranteedPriceWithinSpread,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED")]
    StopLossOrderGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION")]
    StopLossOrderGuaranteedHaltedCreateViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION")]
    StopLossOrderGuaranteedHaltedTightenViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED")]
    StopLossOrderGuaranteedHedgingNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOrderGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_CANCELABLE")]
    StopLossOrderNotCancelable,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_REPLACEABLE")]
    StopLossOrderNotReplaceable,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOrderGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOrderPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOrderPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER")]
    StopLossOnFillRequiredForPendingOrder,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED")]
    StopLossOnFillGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED")]
    StopLossOnFillGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_MISSING")]
    StopLossOnFillPriceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_INVALID")]
    StopLossOnFillPriceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    StopLossOnFillPricePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOnFillGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOnFillGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_INVALID")]
    StopLossOnFillDistanceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    StopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED")]
    StopLossOnFillDistancePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOnFillPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOnFillPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    StopLossOnFillTimeInForceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    StopLossOnFillTimeInForceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    StopLossOnFillGtdTimestampMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    StopLossOnFillGtdTimestampInPast,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    StopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    StopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    StopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    StopLossOnFillTriggerConditionMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    StopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS")]
    TrailingStopLossOrderAlreadyExists,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING")]
    TrailingStopLossOnFillPriceDistanceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID")]
    TrailingStopLossOnFillPriceDistanceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED")]
    TrailingStopLossOnFillPriceDistancePrecisionExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    TrailingStopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET")]
    TrailingStopLossOnFillPriceDistanceMinimumNotMet,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    TrailingStopLossOnFillTimeInForceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    TrailingStopLossOnFillTimeInForceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TrailingStopLossOnFillGtdTimestampMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TrailingStopLossOnFillGtdTimestampInPast,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TrailingStopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TrailingStopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TrailingStopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED")]
    TrailingStopLossOrdersNotSupported,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TrailingStopLossOnFillTriggerConditionMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TrailingStopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "CLOSE_TRADE_TYPE_MISSING")]
    CloseTradeTypeMissing,
    #[serde(rename = "CLOSE_TRADE_PARTIAL_UNITS_MISSING")]
    CloseTradePartialUnitsMissing,
    #[serde(rename = "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE")]
    CloseTradeUnitsExceedTradeSize,
    #[serde(rename = "CLOSEOUT_POSITION_DOESNT_EXIST")]
    CloseoutPositionDoesntExist,
    #[serde(rename = "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION")]
    CloseoutPositionIncompleteSpecification,
    #[serde(rename = "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE")]
    CloseoutPositionUnitsExceedPositionSize,
    #[serde(rename = "CLOSEOUT_POSITION_REJECT")]
    CloseoutPositionReject,
    #[serde(rename = "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING")]
    CloseoutPositionPartialUnitsMissing,
    #[serde(rename = "MARKUP_GROUP_ID_INVALID")]
    MarkupGroupIdInvalid,
    #[serde(rename = "POSITION_AGGREGATION_MODE_INVALID")]
    PositionAggregationModeInvalid,
    #[serde(rename = "ADMIN_CONFIGURE_DATA_MISSING")]
    AdminConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_INVALID")]
    MarginRateInvalid,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT")]
    MarginRateWouldTriggerCloseout,
    #[serde(rename = "ALIAS_INVALID")]
    AliasInvalid,
    #[serde(rename = "CLIENT_CONFIGURE_DATA_MISSING")]
    ClientConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL")]
    MarginRateWouldTriggerMarginCall,
    #[serde(rename = "AMOUNT_INVALID")]
    AmountInvalid,
    #[serde(rename = "INSUFFICIENT_FUNDS")]
    InsufficientFunds,
    #[serde(rename = "AMOUNT_MISSING")]
    AmountMissing,
    #[serde(rename = "FUNDING_REASON_MISSING")]
    FundingReasonMissing,
    #[serde(rename = "CLIENT_EXTENSIONS_DATA_MISSING")]
    ClientExtensionsDataMissing,
    #[serde(rename = "REPLACING_ORDER_INVALID")]
    ReplacingOrderInvalid,
    #[serde(rename = "REPLACING_TRADE_ID_INVALID")]
    ReplacingTradeIdInvalid,
}

impl From<&StopLossOrderRejectTransactionRejectReason>
    for StopLossOrderRejectTransactionRejectReason
{
    fn from(value: &StopLossOrderRejectTransactionRejectReason) -> Self {
        value.clone()
    }
}

impl ToString for StopLossOrderRejectTransactionRejectReason {
    fn to_string(&self) -> String {
        match *self {
            Self::InternalServerError => "INTERNAL_SERVER_ERROR".to_string(),
            Self::InstrumentPriceUnknown => "INSTRUMENT_PRICE_UNKNOWN".to_string(),
            Self::AccountNotActive => "ACCOUNT_NOT_ACTIVE".to_string(),
            Self::AccountLocked => "ACCOUNT_LOCKED".to_string(),
            Self::AccountOrderCreationLocked => "ACCOUNT_ORDER_CREATION_LOCKED".to_string(),
            Self::AccountConfigurationLocked => "ACCOUNT_CONFIGURATION_LOCKED".to_string(),
            Self::AccountDepositLocked => "ACCOUNT_DEPOSIT_LOCKED".to_string(),
            Self::AccountWithdrawalLocked => "ACCOUNT_WITHDRAWAL_LOCKED".to_string(),
            Self::AccountOrderCancelLocked => "ACCOUNT_ORDER_CANCEL_LOCKED".to_string(),
            Self::InstrumentNotTradeable => "INSTRUMENT_NOT_TRADEABLE".to_string(),
            Self::PendingOrdersAllowedExceeded => "PENDING_ORDERS_ALLOWED_EXCEEDED".to_string(),
            Self::OrderIdUnspecified => "ORDER_ID_UNSPECIFIED".to_string(),
            Self::OrderDoesntExist => "ORDER_DOESNT_EXIST".to_string(),
            Self::OrderIdentifierInconsistency => "ORDER_IDENTIFIER_INCONSISTENCY".to_string(),
            Self::TradeIdUnspecified => "TRADE_ID_UNSPECIFIED".to_string(),
            Self::TradeDoesntExist => "TRADE_DOESNT_EXIST".to_string(),
            Self::TradeIdentifierInconsistency => "TRADE_IDENTIFIER_INCONSISTENCY".to_string(),
            Self::InsufficientMargin => "INSUFFICIENT_MARGIN".to_string(),
            Self::InstrumentMissing => "INSTRUMENT_MISSING".to_string(),
            Self::InstrumentUnknown => "INSTRUMENT_UNKNOWN".to_string(),
            Self::UnitsMissing => "UNITS_MISSING".to_string(),
            Self::UnitsInvalid => "UNITS_INVALID".to_string(),
            Self::UnitsPrecisionExceeded => "UNITS_PRECISION_EXCEEDED".to_string(),
            Self::UnitsLimitExceeded => "UNITS_LIMIT_EXCEEDED".to_string(),
            Self::UnitsMimimumNotMet => "UNITS_MIMIMUM_NOT_MET".to_string(),
            Self::PriceMissing => "PRICE_MISSING".to_string(),
            Self::PriceInvalid => "PRICE_INVALID".to_string(),
            Self::PricePrecisionExceeded => "PRICE_PRECISION_EXCEEDED".to_string(),
            Self::PriceDistanceMissing => "PRICE_DISTANCE_MISSING".to_string(),
            Self::PriceDistanceInvalid => "PRICE_DISTANCE_INVALID".to_string(),
            Self::PriceDistancePrecisionExceeded => "PRICE_DISTANCE_PRECISION_EXCEEDED".to_string(),
            Self::PriceDistanceMaximumExceeded => "PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string(),
            Self::PriceDistanceMinimumNotMet => "PRICE_DISTANCE_MINIMUM_NOT_MET".to_string(),
            Self::TimeInForceMissing => "TIME_IN_FORCE_MISSING".to_string(),
            Self::TimeInForceInvalid => "TIME_IN_FORCE_INVALID".to_string(),
            Self::TimeInForceGtdTimestampMissing => {
                "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TimeInForceGtdTimestampInPast => {
                "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::PriceBoundInvalid => "PRICE_BOUND_INVALID".to_string(),
            Self::PriceBoundPrecisionExceeded => "PRICE_BOUND_PRECISION_EXCEEDED".to_string(),
            Self::OrdersOnFillDuplicateClientOrderIds => {
                "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS".to_string()
            }
            Self::TradeOnFillClientExtensionsNotSupported => {
                "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED".to_string()
            }
            Self::ClientOrderIdInvalid => "CLIENT_ORDER_ID_INVALID".to_string(),
            Self::ClientOrderIdAlreadyExists => "CLIENT_ORDER_ID_ALREADY_EXISTS".to_string(),
            Self::ClientOrderTagInvalid => "CLIENT_ORDER_TAG_INVALID".to_string(),
            Self::ClientOrderCommentInvalid => "CLIENT_ORDER_COMMENT_INVALID".to_string(),
            Self::ClientTradeIdInvalid => "CLIENT_TRADE_ID_INVALID".to_string(),
            Self::ClientTradeIdAlreadyExists => "CLIENT_TRADE_ID_ALREADY_EXISTS".to_string(),
            Self::ClientTradeTagInvalid => "CLIENT_TRADE_TAG_INVALID".to_string(),
            Self::ClientTradeCommentInvalid => "CLIENT_TRADE_COMMENT_INVALID".to_string(),
            Self::OrderFillPositionActionMissing => {
                "ORDER_FILL_POSITION_ACTION_MISSING".to_string()
            }
            Self::OrderFillPositionActionInvalid => {
                "ORDER_FILL_POSITION_ACTION_INVALID".to_string()
            }
            Self::TriggerConditionMissing => "TRIGGER_CONDITION_MISSING".to_string(),
            Self::TriggerConditionInvalid => "TRIGGER_CONDITION_INVALID".to_string(),
            Self::OrderPartialFillOptionMissing => "ORDER_PARTIAL_FILL_OPTION_MISSING".to_string(),
            Self::OrderPartialFillOptionInvalid => "ORDER_PARTIAL_FILL_OPTION_INVALID".to_string(),
            Self::InvalidReissueImmediatePartialFill => {
                "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL".to_string()
            }
            Self::TakeProfitOrderAlreadyExists => "TAKE_PROFIT_ORDER_ALREADY_EXISTS".to_string(),
            Self::TakeProfitOnFillPriceMissing => "TAKE_PROFIT_ON_FILL_PRICE_MISSING".to_string(),
            Self::TakeProfitOnFillPriceInvalid => "TAKE_PROFIT_ON_FILL_PRICE_INVALID".to_string(),
            Self::TakeProfitOnFillPricePrecisionExceeded => {
                "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED".to_string()
            }
            Self::TakeProfitOnFillTimeInForceMissing => {
                "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::TakeProfitOnFillTimeInForceInvalid => {
                "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::TakeProfitOnFillGtdTimestampMissing => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TakeProfitOnFillGtdTimestampInPast => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TakeProfitOnFillClientOrderIdInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::TakeProfitOnFillClientOrderTagInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::TakeProfitOnFillClientOrderCommentInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::TakeProfitOnFillTriggerConditionMissing => {
                "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::TakeProfitOnFillTriggerConditionInvalid => {
                "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::StopLossOrderAlreadyExists => "STOP_LOSS_ORDER_ALREADY_EXISTS".to_string(),
            Self::StopLossOrderGuaranteedRequired => {
                "STOP_LOSS_ORDER_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOrderGuaranteedPriceWithinSpread => {
                "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD".to_string()
            }
            Self::StopLossOrderGuaranteedNotAllowed => {
                "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOrderGuaranteedHaltedCreateViolation => {
                "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION".to_string()
            }
            Self::StopLossOrderGuaranteedHaltedTightenViolation => {
                "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION".to_string()
            }
            Self::StopLossOrderGuaranteedHedgingNotAllowed => {
                "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED".to_string()
            }
            Self::StopLossOrderGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOrderNotCancelable => "STOP_LOSS_ORDER_NOT_CANCELABLE".to_string(),
            Self::StopLossOrderNotReplaceable => "STOP_LOSS_ORDER_NOT_REPLACEABLE".to_string(),
            Self::StopLossOrderGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOrderPriceAndDistanceBothSpecified => {
                "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED".to_string()
            }
            Self::StopLossOrderPriceAndDistanceBothMissing => {
                "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING".to_string()
            }
            Self::StopLossOnFillRequiredForPendingOrder => {
                "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER".to_string()
            }
            Self::StopLossOnFillGuaranteedNotAllowed => {
                "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOnFillGuaranteedRequired => {
                "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOnFillPriceMissing => "STOP_LOSS_ON_FILL_PRICE_MISSING".to_string(),
            Self::StopLossOnFillPriceInvalid => "STOP_LOSS_ON_FILL_PRICE_INVALID".to_string(),
            Self::StopLossOnFillPricePrecisionExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOnFillGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillDistanceInvalid => "STOP_LOSS_ON_FILL_DISTANCE_INVALID".to_string(),
            Self::StopLossOnFillPriceDistanceMaximumExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::StopLossOnFillDistancePrecisionExceeded => {
                "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillPriceAndDistanceBothSpecified => {
                "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED".to_string()
            }
            Self::StopLossOnFillPriceAndDistanceBothMissing => {
                "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING".to_string()
            }
            Self::StopLossOnFillTimeInForceMissing => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::StopLossOnFillTimeInForceInvalid => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::StopLossOnFillGtdTimestampMissing => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::StopLossOnFillGtdTimestampInPast => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::StopLossOnFillClientOrderIdInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::StopLossOnFillClientOrderTagInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::StopLossOnFillClientOrderCommentInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::StopLossOnFillTriggerConditionMissing => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::StopLossOnFillTriggerConditionInvalid => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::TrailingStopLossOrderAlreadyExists => {
                "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistancePrecisionExceeded => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMaximumExceeded => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMinimumNotMet => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET".to_string()
            }
            Self::TrailingStopLossOnFillTimeInForceMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillTimeInForceInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampInPast => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderIdInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderTagInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderCommentInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::TrailingStopLossOrdersNotSupported => {
                "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED".to_string()
            }
            Self::TrailingStopLossOnFillTriggerConditionMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillTriggerConditionInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::CloseTradeTypeMissing => "CLOSE_TRADE_TYPE_MISSING".to_string(),
            Self::CloseTradePartialUnitsMissing => "CLOSE_TRADE_PARTIAL_UNITS_MISSING".to_string(),
            Self::CloseTradeUnitsExceedTradeSize => {
                "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE".to_string()
            }
            Self::CloseoutPositionDoesntExist => "CLOSEOUT_POSITION_DOESNT_EXIST".to_string(),
            Self::CloseoutPositionIncompleteSpecification => {
                "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION".to_string()
            }
            Self::CloseoutPositionUnitsExceedPositionSize => {
                "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE".to_string()
            }
            Self::CloseoutPositionReject => "CLOSEOUT_POSITION_REJECT".to_string(),
            Self::CloseoutPositionPartialUnitsMissing => {
                "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING".to_string()
            }
            Self::MarkupGroupIdInvalid => "MARKUP_GROUP_ID_INVALID".to_string(),
            Self::PositionAggregationModeInvalid => "POSITION_AGGREGATION_MODE_INVALID".to_string(),
            Self::AdminConfigureDataMissing => "ADMIN_CONFIGURE_DATA_MISSING".to_string(),
            Self::MarginRateInvalid => "MARGIN_RATE_INVALID".to_string(),
            Self::MarginRateWouldTriggerCloseout => {
                "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT".to_string()
            }
            Self::AliasInvalid => "ALIAS_INVALID".to_string(),
            Self::ClientConfigureDataMissing => "CLIENT_CONFIGURE_DATA_MISSING".to_string(),
            Self::MarginRateWouldTriggerMarginCall => {
                "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL".to_string()
            }
            Self::AmountInvalid => "AMOUNT_INVALID".to_string(),
            Self::InsufficientFunds => "INSUFFICIENT_FUNDS".to_string(),
            Self::AmountMissing => "AMOUNT_MISSING".to_string(),
            Self::FundingReasonMissing => "FUNDING_REASON_MISSING".to_string(),
            Self::ClientExtensionsDataMissing => "CLIENT_EXTENSIONS_DATA_MISSING".to_string(),
            Self::ReplacingOrderInvalid => "REPLACING_ORDER_INVALID".to_string(),
            Self::ReplacingTradeIdInvalid => "REPLACING_TRADE_ID_INVALID".to_string(),
        }
    }
}

impl std::str::FromStr for StopLossOrderRejectTransactionRejectReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "INTERNAL_SERVER_ERROR" => Ok(Self::InternalServerError),
            "INSTRUMENT_PRICE_UNKNOWN" => Ok(Self::InstrumentPriceUnknown),
            "ACCOUNT_NOT_ACTIVE" => Ok(Self::AccountNotActive),
            "ACCOUNT_LOCKED" => Ok(Self::AccountLocked),
            "ACCOUNT_ORDER_CREATION_LOCKED" => Ok(Self::AccountOrderCreationLocked),
            "ACCOUNT_CONFIGURATION_LOCKED" => Ok(Self::AccountConfigurationLocked),
            "ACCOUNT_DEPOSIT_LOCKED" => Ok(Self::AccountDepositLocked),
            "ACCOUNT_WITHDRAWAL_LOCKED" => Ok(Self::AccountWithdrawalLocked),
            "ACCOUNT_ORDER_CANCEL_LOCKED" => Ok(Self::AccountOrderCancelLocked),
            "INSTRUMENT_NOT_TRADEABLE" => Ok(Self::InstrumentNotTradeable),
            "PENDING_ORDERS_ALLOWED_EXCEEDED" => Ok(Self::PendingOrdersAllowedExceeded),
            "ORDER_ID_UNSPECIFIED" => Ok(Self::OrderIdUnspecified),
            "ORDER_DOESNT_EXIST" => Ok(Self::OrderDoesntExist),
            "ORDER_IDENTIFIER_INCONSISTENCY" => Ok(Self::OrderIdentifierInconsistency),
            "TRADE_ID_UNSPECIFIED" => Ok(Self::TradeIdUnspecified),
            "TRADE_DOESNT_EXIST" => Ok(Self::TradeDoesntExist),
            "TRADE_IDENTIFIER_INCONSISTENCY" => Ok(Self::TradeIdentifierInconsistency),
            "INSUFFICIENT_MARGIN" => Ok(Self::InsufficientMargin),
            "INSTRUMENT_MISSING" => Ok(Self::InstrumentMissing),
            "INSTRUMENT_UNKNOWN" => Ok(Self::InstrumentUnknown),
            "UNITS_MISSING" => Ok(Self::UnitsMissing),
            "UNITS_INVALID" => Ok(Self::UnitsInvalid),
            "UNITS_PRECISION_EXCEEDED" => Ok(Self::UnitsPrecisionExceeded),
            "UNITS_LIMIT_EXCEEDED" => Ok(Self::UnitsLimitExceeded),
            "UNITS_MIMIMUM_NOT_MET" => Ok(Self::UnitsMimimumNotMet),
            "PRICE_MISSING" => Ok(Self::PriceMissing),
            "PRICE_INVALID" => Ok(Self::PriceInvalid),
            "PRICE_PRECISION_EXCEEDED" => Ok(Self::PricePrecisionExceeded),
            "PRICE_DISTANCE_MISSING" => Ok(Self::PriceDistanceMissing),
            "PRICE_DISTANCE_INVALID" => Ok(Self::PriceDistanceInvalid),
            "PRICE_DISTANCE_PRECISION_EXCEEDED" => Ok(Self::PriceDistancePrecisionExceeded),
            "PRICE_DISTANCE_MAXIMUM_EXCEEDED" => Ok(Self::PriceDistanceMaximumExceeded),
            "PRICE_DISTANCE_MINIMUM_NOT_MET" => Ok(Self::PriceDistanceMinimumNotMet),
            "TIME_IN_FORCE_MISSING" => Ok(Self::TimeInForceMissing),
            "TIME_IN_FORCE_INVALID" => Ok(Self::TimeInForceInvalid),
            "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING" => Ok(Self::TimeInForceGtdTimestampMissing),
            "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST" => Ok(Self::TimeInForceGtdTimestampInPast),
            "PRICE_BOUND_INVALID" => Ok(Self::PriceBoundInvalid),
            "PRICE_BOUND_PRECISION_EXCEEDED" => Ok(Self::PriceBoundPrecisionExceeded),
            "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS" => {
                Ok(Self::OrdersOnFillDuplicateClientOrderIds)
            }
            "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED" => {
                Ok(Self::TradeOnFillClientExtensionsNotSupported)
            }
            "CLIENT_ORDER_ID_INVALID" => Ok(Self::ClientOrderIdInvalid),
            "CLIENT_ORDER_ID_ALREADY_EXISTS" => Ok(Self::ClientOrderIdAlreadyExists),
            "CLIENT_ORDER_TAG_INVALID" => Ok(Self::ClientOrderTagInvalid),
            "CLIENT_ORDER_COMMENT_INVALID" => Ok(Self::ClientOrderCommentInvalid),
            "CLIENT_TRADE_ID_INVALID" => Ok(Self::ClientTradeIdInvalid),
            "CLIENT_TRADE_ID_ALREADY_EXISTS" => Ok(Self::ClientTradeIdAlreadyExists),
            "CLIENT_TRADE_TAG_INVALID" => Ok(Self::ClientTradeTagInvalid),
            "CLIENT_TRADE_COMMENT_INVALID" => Ok(Self::ClientTradeCommentInvalid),
            "ORDER_FILL_POSITION_ACTION_MISSING" => Ok(Self::OrderFillPositionActionMissing),
            "ORDER_FILL_POSITION_ACTION_INVALID" => Ok(Self::OrderFillPositionActionInvalid),
            "TRIGGER_CONDITION_MISSING" => Ok(Self::TriggerConditionMissing),
            "TRIGGER_CONDITION_INVALID" => Ok(Self::TriggerConditionInvalid),
            "ORDER_PARTIAL_FILL_OPTION_MISSING" => Ok(Self::OrderPartialFillOptionMissing),
            "ORDER_PARTIAL_FILL_OPTION_INVALID" => Ok(Self::OrderPartialFillOptionInvalid),
            "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL" => {
                Ok(Self::InvalidReissueImmediatePartialFill)
            }
            "TAKE_PROFIT_ORDER_ALREADY_EXISTS" => Ok(Self::TakeProfitOrderAlreadyExists),
            "TAKE_PROFIT_ON_FILL_PRICE_MISSING" => Ok(Self::TakeProfitOnFillPriceMissing),
            "TAKE_PROFIT_ON_FILL_PRICE_INVALID" => Ok(Self::TakeProfitOnFillPriceInvalid),
            "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(Self::TakeProfitOnFillPricePrecisionExceeded)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(Self::TakeProfitOnFillTimeInForceMissing)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(Self::TakeProfitOnFillTimeInForceInvalid)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::TakeProfitOnFillGtdTimestampMissing)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TakeProfitOnFillGtdTimestampInPast)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderIdInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderTagInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderCommentInvalid)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::TakeProfitOnFillTriggerConditionMissing)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::TakeProfitOnFillTriggerConditionInvalid)
            }
            "STOP_LOSS_ORDER_ALREADY_EXISTS" => Ok(Self::StopLossOrderAlreadyExists),
            "STOP_LOSS_ORDER_GUARANTEED_REQUIRED" => Ok(Self::StopLossOrderGuaranteedRequired),
            "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD" => {
                Ok(Self::StopLossOrderGuaranteedPriceWithinSpread)
            }
            "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED" => Ok(Self::StopLossOrderGuaranteedNotAllowed),
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION" => {
                Ok(Self::StopLossOrderGuaranteedHaltedCreateViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION" => {
                Ok(Self::StopLossOrderGuaranteedHaltedTightenViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED" => {
                Ok(Self::StopLossOrderGuaranteedHedgingNotAllowed)
            }
            "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOrderGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ORDER_NOT_CANCELABLE" => Ok(Self::StopLossOrderNotCancelable),
            "STOP_LOSS_ORDER_NOT_REPLACEABLE" => Ok(Self::StopLossOrderNotReplaceable),
            "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOrderGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(Self::StopLossOrderPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(Self::StopLossOrderPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER" => {
                Ok(Self::StopLossOnFillRequiredForPendingOrder)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED" => {
                Ok(Self::StopLossOnFillGuaranteedNotAllowed)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED" => Ok(Self::StopLossOnFillGuaranteedRequired),
            "STOP_LOSS_ON_FILL_PRICE_MISSING" => Ok(Self::StopLossOnFillPriceMissing),
            "STOP_LOSS_ON_FILL_PRICE_INVALID" => Ok(Self::StopLossOnFillPriceInvalid),
            "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(Self::StopLossOnFillPricePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOnFillGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOnFillGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_INVALID" => Ok(Self::StopLossOnFillDistanceInvalid),
            "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::StopLossOnFillPriceDistanceMaximumExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(Self::StopLossOnFillDistancePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(Self::StopLossOnFillPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(Self::StopLossOnFillPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => Ok(Self::StopLossOnFillTimeInForceMissing),
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => Ok(Self::StopLossOnFillTimeInForceInvalid),
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::StopLossOnFillGtdTimestampMissing)
            }
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => Ok(Self::StopLossOnFillGtdTimestampInPast),
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderIdInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderTagInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderCommentInvalid)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::StopLossOnFillTriggerConditionMissing)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::StopLossOnFillTriggerConditionInvalid)
            }
            "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS" => {
                Ok(Self::TrailingStopLossOrderAlreadyExists)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(Self::TrailingStopLossOnFillPriceDistancePrecisionExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMaximumExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMinimumNotMet)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(Self::TrailingStopLossOnFillTimeInForceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(Self::TrailingStopLossOnFillTimeInForceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampInPast)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderIdInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderTagInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderCommentInvalid)
            }
            "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED" => {
                Ok(Self::TrailingStopLossOrdersNotSupported)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::TrailingStopLossOnFillTriggerConditionMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::TrailingStopLossOnFillTriggerConditionInvalid)
            }
            "CLOSE_TRADE_TYPE_MISSING" => Ok(Self::CloseTradeTypeMissing),
            "CLOSE_TRADE_PARTIAL_UNITS_MISSING" => Ok(Self::CloseTradePartialUnitsMissing),
            "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE" => Ok(Self::CloseTradeUnitsExceedTradeSize),
            "CLOSEOUT_POSITION_DOESNT_EXIST" => Ok(Self::CloseoutPositionDoesntExist),
            "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION" => {
                Ok(Self::CloseoutPositionIncompleteSpecification)
            }
            "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE" => {
                Ok(Self::CloseoutPositionUnitsExceedPositionSize)
            }
            "CLOSEOUT_POSITION_REJECT" => Ok(Self::CloseoutPositionReject),
            "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING" => {
                Ok(Self::CloseoutPositionPartialUnitsMissing)
            }
            "MARKUP_GROUP_ID_INVALID" => Ok(Self::MarkupGroupIdInvalid),
            "POSITION_AGGREGATION_MODE_INVALID" => Ok(Self::PositionAggregationModeInvalid),
            "ADMIN_CONFIGURE_DATA_MISSING" => Ok(Self::AdminConfigureDataMissing),
            "MARGIN_RATE_INVALID" => Ok(Self::MarginRateInvalid),
            "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT" => Ok(Self::MarginRateWouldTriggerCloseout),
            "ALIAS_INVALID" => Ok(Self::AliasInvalid),
            "CLIENT_CONFIGURE_DATA_MISSING" => Ok(Self::ClientConfigureDataMissing),
            "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL" => Ok(Self::MarginRateWouldTriggerMarginCall),
            "AMOUNT_INVALID" => Ok(Self::AmountInvalid),
            "INSUFFICIENT_FUNDS" => Ok(Self::InsufficientFunds),
            "AMOUNT_MISSING" => Ok(Self::AmountMissing),
            "FUNDING_REASON_MISSING" => Ok(Self::FundingReasonMissing),
            "CLIENT_EXTENSIONS_DATA_MISSING" => Ok(Self::ClientExtensionsDataMissing),
            "REPLACING_ORDER_INVALID" => Ok(Self::ReplacingOrderInvalid),
            "REPLACING_TRADE_ID_INVALID" => Ok(Self::ReplacingTradeIdInvalid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopLossOrderRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopLossOrderRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopLossOrderRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The time-in-force requested for the StopLoss Order. Restricted to "GTC",
/// "GFD" and "GTD" for StopLoss Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the StopLoss Order.
/// Restricted to \"GTC\", \"GFD\" and \"GTD\" for StopLoss Orders.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopLossOrderRejectTransactionTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&StopLossOrderRejectTransactionTimeInForce>
    for StopLossOrderRejectTransactionTimeInForce
{
    fn from(value: &StopLossOrderRejectTransactionTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for StopLossOrderRejectTransactionTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for StopLossOrderRejectTransactionTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopLossOrderRejectTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopLossOrderRejectTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopLossOrderRejectTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///Specification of which price component should be used when determining
/// if an Order should be triggered and filled. This allows Orders to be
/// triggered based on the bid, ask, mid, default (ask for buy, bid for
/// sell) or inverse (ask for sell, bid for buy) price depending on the
/// desired behaviour. Orders are always filled using their default price
/// component. This feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order. A special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
/// results in. So for a Stop Loss Order for a long trade valid values are
/// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are valid.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of which price component should be used
/// when determining if an Order should be triggered and filled. This allows
/// Orders to be triggered based on the bid, ask, mid, default (ask for buy,
/// bid for sell) or inverse (ask for sell, bid for buy) price depending on
/// the desired behaviour. Orders are always filled using their default
/// price component.\nThis feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///  "type": "string",
///  "enum": [
///    "DEFAULT",
///    "INVERSE",
///    "BID",
///    "ASK",
///    "MID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopLossOrderRejectTransactionTriggerCondition {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "INVERSE")]
    Inverse,
    #[serde(rename = "BID")]
    Bid,
    #[serde(rename = "ASK")]
    Ask,
    #[serde(rename = "MID")]
    Mid,
}

impl From<&StopLossOrderRejectTransactionTriggerCondition>
    for StopLossOrderRejectTransactionTriggerCondition
{
    fn from(value: &StopLossOrderRejectTransactionTriggerCondition) -> Self {
        value.clone()
    }
}

impl ToString for StopLossOrderRejectTransactionTriggerCondition {
    fn to_string(&self) -> String {
        match *self {
            Self::Default => "DEFAULT".to_string(),
            Self::Inverse => "INVERSE".to_string(),
            Self::Bid => "BID".to_string(),
            Self::Ask => "ASK".to_string(),
            Self::Mid => "MID".to_string(),
        }
    }
}

impl std::str::FromStr for StopLossOrderRejectTransactionTriggerCondition {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DEFAULT" => Ok(Self::Default),
            "INVERSE" => Ok(Self::Inverse),
            "BID" => Ok(Self::Bid),
            "ASK" => Ok(Self::Ask),
            "MID" => Ok(Self::Mid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopLossOrderRejectTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopLossOrderRejectTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopLossOrderRejectTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Type of the Transaction. Always set to "STOP_LOSS_ORDER_REJECT" in a
/// StopLossOrderRejectTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"STOP_LOSS_ORDER_REJECT\" in a StopLossOrderRejectTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopLossOrderRejectTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&StopLossOrderRejectTransactionType> for StopLossOrderRejectTransactionType {
    fn from(value: &StopLossOrderRejectTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for StopLossOrderRejectTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for StopLossOrderRejectTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopLossOrderRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopLossOrderRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopLossOrderRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A StopLossOrderRequest specifies the parameters that may be set when
/// creating a Stop Loss Order. Only one of the price and distance fields
/// may be specified.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A StopLossOrderRequest specifies the parameters that
/// may be set when creating a Stop Loss Order. Only one of the price and
/// distance fields may be specified.",
///  "type": "object",
///  "properties": {
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "clientTradeID": {
///      "description": "The client ID of the Trade to be closed when the
/// price threshold is breached.",
///      "type": "string"
///    },
///    "distance": {
///      "description": "Specifies the distance (in price units) from the
/// Account's current price to use as the Stop Loss Order price. If the
/// Trade is short the Instrument's bid price is used, and for long Trades
/// the ask is used.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "gtdTime": {
///      "description": "The date/time when the StopLoss Order will be
/// cancelled if its timeInForce is \"GTD\".",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "guaranteed": {
///      "description": "Flag indicating that the Stop Loss Order is
/// guaranteed. The default value depends on the GuaranteedStopLossOrderMode
/// of the account, if it is REQUIRED, the default will be true, for
/// DISABLED or ENABLED the default is false.",
///      "type": "boolean"
///    },
///    "price": {
///      "description": "The price threshold specified for the Stop Loss Order. If the guaranteed flag is false, the associated Trade will be closed by a market price that is equal to or worse than this threshold. If the flag is true the associated Trade will be closed at this price.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the StopLoss Order.
/// Restricted to \"GTC\", \"GFD\" and \"GTD\" for StopLoss Orders.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeID": {
///      "description": "The ID of the Trade to close when the price
/// threshold is breached.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "triggerCondition": {
///      "description": "Specification of which price component should be
/// used when determining if an Order should be triggered and filled. This
/// allows Orders to be triggered based on the bid, ask, mid, default (ask
/// for buy, bid for sell) or inverse (ask for sell, bid for buy) price
/// depending on the desired behaviour. Orders are always filled using their
/// default price component.\nThis feature is only provided through the REST
/// API. Clients who choose to specify a non-default trigger condition will
/// not see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///      "type": "string",
///      "enum": [
///        "DEFAULT",
///        "INVERSE",
///        "BID",
///        "ASK",
///        "MID"
///      ]
///    },
///    "type": {
///      "description": "The type of the Order to Create. Must be set to
/// \"STOP_LOSS\" when creating a Stop Loss Order.",
///      "type": "string",
///      "enum": [
///        "MARKET",
///        "LIMIT",
///        "STOP",
///        "MARKET_IF_TOUCHED",
///        "TAKE_PROFIT",
///        "STOP_LOSS",
///        "TRAILING_STOP_LOSS",
///        "FIXED_PRICE"
///      ]
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StopLossOrderRequest {
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The client ID of the Trade to be closed when the price threshold is
    /// breached.
    #[serde(
        rename = "clientTradeID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_trade_id: Option<String>,
    ///Specifies the distance (in price units) from the Account's current
    /// price to use as the Stop Loss Order price. If the Trade is short the
    /// Instrument's bid price is used, and for long Trades the ask is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distance: Option<String>,
    ///The date/time when the StopLoss Order will be cancelled if its
    /// timeInForce is "GTD".
    #[serde(rename = "gtdTime", default, skip_serializing_if = "Option::is_none")]
    pub gtd_time: Option<String>,
    ///Flag indicating that the Stop Loss Order is guaranteed. The default
    /// value depends on the GuaranteedStopLossOrderMode of the account, if
    /// it is REQUIRED, the default will be true, for DISABLED or ENABLED
    /// the default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub guaranteed: Option<bool>,
    ///The price threshold specified for the Stop Loss Order. If the
    /// guaranteed flag is false, the associated Trade will be closed by a
    /// market price that is equal to or worse than this threshold. If the
    /// flag is true the associated Trade will be closed at this price.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The time-in-force requested for the StopLoss Order. Restricted to
    /// "GTC", "GFD" and "GTD" for StopLoss Orders.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<StopLossOrderRequestTimeInForce>,
    ///The ID of the Trade to close when the price threshold is breached.
    #[serde(rename = "tradeID", default, skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,
    ///Specification of which price component should be used when
    /// determining if an Order should be triggered and filled. This allows
    /// Orders to be triggered based on the bid, ask, mid, default (ask for
    /// buy, bid for sell) or inverse (ask for sell, bid for buy) price
    /// depending on the desired behaviour. Orders are always filled using
    /// their default price component. This feature is only provided
    /// through the REST API. Clients who choose to specify a non-default
    /// trigger condition will not see it reflected in any of OANDA's
    /// proprietary or partner trading platforms, their transaction history
    /// or their account statements. OANDA platforms always assume that an
    /// Order's trigger condition is set to the default value when
    /// indicating the distance from an Order's trigger price, and will
    /// always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when
    /// creating a guaranteed Stop Loss Order. In this case the
    /// TriggerCondition value must either be "DEFAULT", or the "natural"
    /// trigger side "DEFAULT" results in. So for a Stop Loss Order for a
    /// long trade valid values are "DEFAULT" and "BID", and for short
    /// trades "DEFAULT" and "ASK" are valid.
    #[serde(
        rename = "triggerCondition",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trigger_condition: Option<StopLossOrderRequestTriggerCondition>,
    ///The type of the Order to Create. Must be set to "STOP_LOSS" when
    /// creating a Stop Loss Order.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<StopLossOrderRequestType>,
}

impl From<&StopLossOrderRequest> for StopLossOrderRequest {
    fn from(value: &StopLossOrderRequest) -> Self {
        value.clone()
    }
}

impl StopLossOrderRequest {
    pub fn builder() -> builder::StopLossOrderRequest {
        Default::default()
    }
}

///The time-in-force requested for the StopLoss Order. Restricted to "GTC",
/// "GFD" and "GTD" for StopLoss Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the StopLoss Order.
/// Restricted to \"GTC\", \"GFD\" and \"GTD\" for StopLoss Orders.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopLossOrderRequestTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&StopLossOrderRequestTimeInForce> for StopLossOrderRequestTimeInForce {
    fn from(value: &StopLossOrderRequestTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for StopLossOrderRequestTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for StopLossOrderRequestTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopLossOrderRequestTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopLossOrderRequestTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopLossOrderRequestTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///Specification of which price component should be used when determining
/// if an Order should be triggered and filled. This allows Orders to be
/// triggered based on the bid, ask, mid, default (ask for buy, bid for
/// sell) or inverse (ask for sell, bid for buy) price depending on the
/// desired behaviour. Orders are always filled using their default price
/// component. This feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order. A special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
/// results in. So for a Stop Loss Order for a long trade valid values are
/// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are valid.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of which price component should be used
/// when determining if an Order should be triggered and filled. This allows
/// Orders to be triggered based on the bid, ask, mid, default (ask for buy,
/// bid for sell) or inverse (ask for sell, bid for buy) price depending on
/// the desired behaviour. Orders are always filled using their default
/// price component.\nThis feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///  "type": "string",
///  "enum": [
///    "DEFAULT",
///    "INVERSE",
///    "BID",
///    "ASK",
///    "MID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopLossOrderRequestTriggerCondition {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "INVERSE")]
    Inverse,
    #[serde(rename = "BID")]
    Bid,
    #[serde(rename = "ASK")]
    Ask,
    #[serde(rename = "MID")]
    Mid,
}

impl From<&StopLossOrderRequestTriggerCondition> for StopLossOrderRequestTriggerCondition {
    fn from(value: &StopLossOrderRequestTriggerCondition) -> Self {
        value.clone()
    }
}

impl ToString for StopLossOrderRequestTriggerCondition {
    fn to_string(&self) -> String {
        match *self {
            Self::Default => "DEFAULT".to_string(),
            Self::Inverse => "INVERSE".to_string(),
            Self::Bid => "BID".to_string(),
            Self::Ask => "ASK".to_string(),
            Self::Mid => "MID".to_string(),
        }
    }
}

impl std::str::FromStr for StopLossOrderRequestTriggerCondition {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DEFAULT" => Ok(Self::Default),
            "INVERSE" => Ok(Self::Inverse),
            "BID" => Ok(Self::Bid),
            "ASK" => Ok(Self::Ask),
            "MID" => Ok(Self::Mid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopLossOrderRequestTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopLossOrderRequestTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopLossOrderRequestTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The type of the Order to Create. Must be set to "STOP_LOSS" when
/// creating a Stop Loss Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The type of the Order to Create. Must be set to
/// \"STOP_LOSS\" when creating a Stop Loss Order.",
///  "type": "string",
///  "enum": [
///    "MARKET",
///    "LIMIT",
///    "STOP",
///    "MARKET_IF_TOUCHED",
///    "TAKE_PROFIT",
///    "STOP_LOSS",
///    "TRAILING_STOP_LOSS",
///    "FIXED_PRICE"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopLossOrderRequestType {
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "STOP")]
    Stop,
    #[serde(rename = "MARKET_IF_TOUCHED")]
    MarketIfTouched,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "STOP_LOSS")]
    StopLoss,
    #[serde(rename = "TRAILING_STOP_LOSS")]
    TrailingStopLoss,
    #[serde(rename = "FIXED_PRICE")]
    FixedPrice,
}

impl From<&StopLossOrderRequestType> for StopLossOrderRequestType {
    fn from(value: &StopLossOrderRequestType) -> Self {
        value.clone()
    }
}

impl ToString for StopLossOrderRequestType {
    fn to_string(&self) -> String {
        match *self {
            Self::Market => "MARKET".to_string(),
            Self::Limit => "LIMIT".to_string(),
            Self::Stop => "STOP".to_string(),
            Self::MarketIfTouched => "MARKET_IF_TOUCHED".to_string(),
            Self::TakeProfit => "TAKE_PROFIT".to_string(),
            Self::StopLoss => "STOP_LOSS".to_string(),
            Self::TrailingStopLoss => "TRAILING_STOP_LOSS".to_string(),
            Self::FixedPrice => "FIXED_PRICE".to_string(),
        }
    }
}

impl std::str::FromStr for StopLossOrderRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "MARKET" => Ok(Self::Market),
            "LIMIT" => Ok(Self::Limit),
            "STOP" => Ok(Self::Stop),
            "MARKET_IF_TOUCHED" => Ok(Self::MarketIfTouched),
            "TAKE_PROFIT" => Ok(Self::TakeProfit),
            "STOP_LOSS" => Ok(Self::StopLoss),
            "TRAILING_STOP_LOSS" => Ok(Self::TrailingStopLoss),
            "FIXED_PRICE" => Ok(Self::FixedPrice),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopLossOrderRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopLossOrderRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopLossOrderRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The current state of the Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The current state of the Order.",
///  "type": "string",
///  "enum": [
///    "PENDING",
///    "FILLED",
///    "TRIGGERED",
///    "CANCELLED"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopLossOrderState {
    #[serde(rename = "PENDING")]
    Pending,
    #[serde(rename = "FILLED")]
    Filled,
    #[serde(rename = "TRIGGERED")]
    Triggered,
    #[serde(rename = "CANCELLED")]
    Cancelled,
}

impl From<&StopLossOrderState> for StopLossOrderState {
    fn from(value: &StopLossOrderState) -> Self {
        value.clone()
    }
}

impl ToString for StopLossOrderState {
    fn to_string(&self) -> String {
        match *self {
            Self::Pending => "PENDING".to_string(),
            Self::Filled => "FILLED".to_string(),
            Self::Triggered => "TRIGGERED".to_string(),
            Self::Cancelled => "CANCELLED".to_string(),
        }
    }
}

impl std::str::FromStr for StopLossOrderState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "PENDING" => Ok(Self::Pending),
            "FILLED" => Ok(Self::Filled),
            "TRIGGERED" => Ok(Self::Triggered),
            "CANCELLED" => Ok(Self::Cancelled),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopLossOrderState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopLossOrderState {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopLossOrderState {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The time-in-force requested for the StopLoss Order. Restricted to "GTC",
/// "GFD" and "GTD" for StopLoss Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the StopLoss Order.
/// Restricted to \"GTC\", \"GFD\" and \"GTD\" for StopLoss Orders.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopLossOrderTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&StopLossOrderTimeInForce> for StopLossOrderTimeInForce {
    fn from(value: &StopLossOrderTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for StopLossOrderTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for StopLossOrderTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopLossOrderTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopLossOrderTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopLossOrderTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A StopLossOrderTransaction represents the creation of a StopLoss Order
/// in the user's Account.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A StopLossOrderTransaction represents the creation of a
/// StopLoss Order in the user's Account.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "cancellingTransactionID": {
///      "description": "The ID of the Transaction that cancels the replaced
/// Order (only provided if this Order replaces an existing Order).",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "clientTradeID": {
///      "description": "The client ID of the Trade to be closed when the
/// price threshold is breached.",
///      "type": "string"
///    },
///    "distance": {
///      "description": "Specifies the distance (in price units) from the
/// Account's current price to use as the Stop Loss Order price. If the
/// Trade is short the Instrument's bid price is used, and for long Trades
/// the ask is used.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "gtdTime": {
///      "description": "The date/time when the StopLoss Order will be
/// cancelled if its timeInForce is \"GTD\".",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "guaranteed": {
///      "description": "Flag indicating that the Stop Loss Order is
/// guaranteed. The default value depends on the GuaranteedStopLossOrderMode
/// of the account, if it is REQUIRED, the default will be true, for
/// DISABLED or ENABLED the default is false.",
///      "type": "boolean"
///    },
///    "guaranteedExecutionPremium": {
///      "description": "The fee that will be charged if the Stop Loss Order
/// is guaranteed and the Order is filled at the guaranteed price. The value
/// is determined at Order creation time. It is in price units and is
/// charged for each unit of the Trade.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "orderFillTransactionID": {
///      "description": "The ID of the OrderFill Transaction that caused
/// this Order to be created (only provided if this Order was created
/// automatically when another Order was filled).",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "price": {
///      "description": "The price threshold specified for the Stop Loss Order. If the guaranteed flag is false, the associated Trade will be closed by a market price that is equal to or worse than this threshold. If the flag is true the associated Trade will be closed at this price.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "reason": {
///      "description": "The reason that the Stop Loss Order was initiated",
///      "type": "string",
///      "enum": [
///        "CLIENT_ORDER",
///        "REPLACEMENT",
///        "ON_FILL"
///      ]
///    },
///    "replacesOrderID": {
///      "description": "The ID of the Order that this Order replaces (only
/// provided if this Order replaces an existing Order).",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the StopLoss Order.
/// Restricted to \"GTC\", \"GFD\" and \"GTD\" for StopLoss Orders.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeID": {
///      "description": "The ID of the Trade to close when the price
/// threshold is breached.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "triggerCondition": {
///      "description": "Specification of which price component should be
/// used when determining if an Order should be triggered and filled. This
/// allows Orders to be triggered based on the bid, ask, mid, default (ask
/// for buy, bid for sell) or inverse (ask for sell, bid for buy) price
/// depending on the desired behaviour. Orders are always filled using their
/// default price component.\nThis feature is only provided through the REST
/// API. Clients who choose to specify a non-default trigger condition will
/// not see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///      "type": "string",
///      "enum": [
///        "DEFAULT",
///        "INVERSE",
///        "BID",
///        "ASK",
///        "MID"
///      ]
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"STOP_LOSS_ORDER\" in a StopLossOrderTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StopLossOrderTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    ///The ID of the Transaction that cancels the replaced Order (only
    /// provided if this Order replaces an existing Order).
    #[serde(
        rename = "cancellingTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The client ID of the Trade to be closed when the price threshold is
    /// breached.
    #[serde(
        rename = "clientTradeID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_trade_id: Option<String>,
    ///Specifies the distance (in price units) from the Account's current
    /// price to use as the Stop Loss Order price. If the Trade is short the
    /// Instrument's bid price is used, and for long Trades the ask is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distance: Option<String>,
    ///The date/time when the StopLoss Order will be cancelled if its
    /// timeInForce is "GTD".
    #[serde(rename = "gtdTime", default, skip_serializing_if = "Option::is_none")]
    pub gtd_time: Option<String>,
    ///Flag indicating that the Stop Loss Order is guaranteed. The default
    /// value depends on the GuaranteedStopLossOrderMode of the account, if
    /// it is REQUIRED, the default will be true, for DISABLED or ENABLED
    /// the default is false.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub guaranteed: Option<bool>,
    ///The fee that will be charged if the Stop Loss Order is guaranteed
    /// and the Order is filled at the guaranteed price. The value is
    /// determined at Order creation time. It is in price units and is
    /// charged for each unit of the Trade.
    #[serde(
        rename = "guaranteedExecutionPremium",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub guaranteed_execution_premium: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The ID of the OrderFill Transaction that caused this Order to be
    /// created (only provided if this Order was created automatically when
    /// another Order was filled).
    #[serde(
        rename = "orderFillTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub order_fill_transaction_id: Option<String>,
    ///The price threshold specified for the Stop Loss Order. If the
    /// guaranteed flag is false, the associated Trade will be closed by a
    /// market price that is equal to or worse than this threshold. If the
    /// flag is true the associated Trade will be closed at this price.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The reason that the Stop Loss Order was initiated
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<StopLossOrderTransactionReason>,
    ///The ID of the Order that this Order replaces (only provided if this
    /// Order replaces an existing Order).
    #[serde(
        rename = "replacesOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub replaces_order_id: Option<String>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The time-in-force requested for the StopLoss Order. Restricted to
    /// "GTC", "GFD" and "GTD" for StopLoss Orders.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<StopLossOrderTransactionTimeInForce>,
    ///The ID of the Trade to close when the price threshold is breached.
    #[serde(rename = "tradeID", default, skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,
    ///Specification of which price component should be used when
    /// determining if an Order should be triggered and filled. This allows
    /// Orders to be triggered based on the bid, ask, mid, default (ask for
    /// buy, bid for sell) or inverse (ask for sell, bid for buy) price
    /// depending on the desired behaviour. Orders are always filled using
    /// their default price component. This feature is only provided
    /// through the REST API. Clients who choose to specify a non-default
    /// trigger condition will not see it reflected in any of OANDA's
    /// proprietary or partner trading platforms, their transaction history
    /// or their account statements. OANDA platforms always assume that an
    /// Order's trigger condition is set to the default value when
    /// indicating the distance from an Order's trigger price, and will
    /// always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when
    /// creating a guaranteed Stop Loss Order. In this case the
    /// TriggerCondition value must either be "DEFAULT", or the "natural"
    /// trigger side "DEFAULT" results in. So for a Stop Loss Order for a
    /// long trade valid values are "DEFAULT" and "BID", and for short
    /// trades "DEFAULT" and "ASK" are valid.
    #[serde(
        rename = "triggerCondition",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trigger_condition: Option<StopLossOrderTransactionTriggerCondition>,
    ///The Type of the Transaction. Always set to "STOP_LOSS_ORDER" in a
    /// StopLossOrderTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<StopLossOrderTransactionType>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&StopLossOrderTransaction> for StopLossOrderTransaction {
    fn from(value: &StopLossOrderTransaction) -> Self {
        value.clone()
    }
}

impl StopLossOrderTransaction {
    pub fn builder() -> builder::StopLossOrderTransaction {
        Default::default()
    }
}

///The reason that the Stop Loss Order was initiated
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Stop Loss Order was initiated",
///  "type": "string",
///  "enum": [
///    "CLIENT_ORDER",
///    "REPLACEMENT",
///    "ON_FILL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopLossOrderTransactionReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "REPLACEMENT")]
    Replacement,
    #[serde(rename = "ON_FILL")]
    OnFill,
}

impl From<&StopLossOrderTransactionReason> for StopLossOrderTransactionReason {
    fn from(value: &StopLossOrderTransactionReason) -> Self {
        value.clone()
    }
}

impl ToString for StopLossOrderTransactionReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ClientOrder => "CLIENT_ORDER".to_string(),
            Self::Replacement => "REPLACEMENT".to_string(),
            Self::OnFill => "ON_FILL".to_string(),
        }
    }
}

impl std::str::FromStr for StopLossOrderTransactionReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CLIENT_ORDER" => Ok(Self::ClientOrder),
            "REPLACEMENT" => Ok(Self::Replacement),
            "ON_FILL" => Ok(Self::OnFill),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopLossOrderTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopLossOrderTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopLossOrderTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The time-in-force requested for the StopLoss Order. Restricted to "GTC",
/// "GFD" and "GTD" for StopLoss Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the StopLoss Order.
/// Restricted to \"GTC\", \"GFD\" and \"GTD\" for StopLoss Orders.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopLossOrderTransactionTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&StopLossOrderTransactionTimeInForce> for StopLossOrderTransactionTimeInForce {
    fn from(value: &StopLossOrderTransactionTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for StopLossOrderTransactionTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for StopLossOrderTransactionTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopLossOrderTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopLossOrderTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopLossOrderTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///Specification of which price component should be used when determining
/// if an Order should be triggered and filled. This allows Orders to be
/// triggered based on the bid, ask, mid, default (ask for buy, bid for
/// sell) or inverse (ask for sell, bid for buy) price depending on the
/// desired behaviour. Orders are always filled using their default price
/// component. This feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order. A special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
/// results in. So for a Stop Loss Order for a long trade valid values are
/// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are valid.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of which price component should be used
/// when determining if an Order should be triggered and filled. This allows
/// Orders to be triggered based on the bid, ask, mid, default (ask for buy,
/// bid for sell) or inverse (ask for sell, bid for buy) price depending on
/// the desired behaviour. Orders are always filled using their default
/// price component.\nThis feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///  "type": "string",
///  "enum": [
///    "DEFAULT",
///    "INVERSE",
///    "BID",
///    "ASK",
///    "MID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopLossOrderTransactionTriggerCondition {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "INVERSE")]
    Inverse,
    #[serde(rename = "BID")]
    Bid,
    #[serde(rename = "ASK")]
    Ask,
    #[serde(rename = "MID")]
    Mid,
}

impl From<&StopLossOrderTransactionTriggerCondition> for StopLossOrderTransactionTriggerCondition {
    fn from(value: &StopLossOrderTransactionTriggerCondition) -> Self {
        value.clone()
    }
}

impl ToString for StopLossOrderTransactionTriggerCondition {
    fn to_string(&self) -> String {
        match *self {
            Self::Default => "DEFAULT".to_string(),
            Self::Inverse => "INVERSE".to_string(),
            Self::Bid => "BID".to_string(),
            Self::Ask => "ASK".to_string(),
            Self::Mid => "MID".to_string(),
        }
    }
}

impl std::str::FromStr for StopLossOrderTransactionTriggerCondition {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DEFAULT" => Ok(Self::Default),
            "INVERSE" => Ok(Self::Inverse),
            "BID" => Ok(Self::Bid),
            "ASK" => Ok(Self::Ask),
            "MID" => Ok(Self::Mid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopLossOrderTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopLossOrderTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopLossOrderTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Type of the Transaction. Always set to "STOP_LOSS_ORDER" in a
/// StopLossOrderTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"STOP_LOSS_ORDER\" in a StopLossOrderTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopLossOrderTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&StopLossOrderTransactionType> for StopLossOrderTransactionType {
    fn from(value: &StopLossOrderTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for StopLossOrderTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for StopLossOrderTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopLossOrderTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopLossOrderTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopLossOrderTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///Specification of which price component should be used when determining
/// if an Order should be triggered and filled. This allows Orders to be
/// triggered based on the bid, ask, mid, default (ask for buy, bid for
/// sell) or inverse (ask for sell, bid for buy) price depending on the
/// desired behaviour. Orders are always filled using their default price
/// component. This feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order. A special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
/// results in. So for a Stop Loss Order for a long trade valid values are
/// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are valid.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of which price component should be used
/// when determining if an Order should be triggered and filled. This allows
/// Orders to be triggered based on the bid, ask, mid, default (ask for buy,
/// bid for sell) or inverse (ask for sell, bid for buy) price depending on
/// the desired behaviour. Orders are always filled using their default
/// price component.\nThis feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///  "type": "string",
///  "enum": [
///    "DEFAULT",
///    "INVERSE",
///    "BID",
///    "ASK",
///    "MID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopLossOrderTriggerCondition {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "INVERSE")]
    Inverse,
    #[serde(rename = "BID")]
    Bid,
    #[serde(rename = "ASK")]
    Ask,
    #[serde(rename = "MID")]
    Mid,
}

impl From<&StopLossOrderTriggerCondition> for StopLossOrderTriggerCondition {
    fn from(value: &StopLossOrderTriggerCondition) -> Self {
        value.clone()
    }
}

impl ToString for StopLossOrderTriggerCondition {
    fn to_string(&self) -> String {
        match *self {
            Self::Default => "DEFAULT".to_string(),
            Self::Inverse => "INVERSE".to_string(),
            Self::Bid => "BID".to_string(),
            Self::Ask => "ASK".to_string(),
            Self::Mid => "MID".to_string(),
        }
    }
}

impl std::str::FromStr for StopLossOrderTriggerCondition {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DEFAULT" => Ok(Self::Default),
            "INVERSE" => Ok(Self::Inverse),
            "BID" => Ok(Self::Bid),
            "ASK" => Ok(Self::Ask),
            "MID" => Ok(Self::Mid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopLossOrderTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopLossOrderTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopLossOrderTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The type of the Order. Always set to "STOP_LOSS" for Stop Loss Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The type of the Order. Always set to \"STOP_LOSS\" for
/// Stop Loss Orders.",
///  "type": "string",
///  "enum": [
///    "MARKET",
///    "LIMIT",
///    "STOP",
///    "MARKET_IF_TOUCHED",
///    "TAKE_PROFIT",
///    "STOP_LOSS",
///    "TRAILING_STOP_LOSS",
///    "FIXED_PRICE"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopLossOrderType {
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "STOP")]
    Stop,
    #[serde(rename = "MARKET_IF_TOUCHED")]
    MarketIfTouched,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "STOP_LOSS")]
    StopLoss,
    #[serde(rename = "TRAILING_STOP_LOSS")]
    TrailingStopLoss,
    #[serde(rename = "FIXED_PRICE")]
    FixedPrice,
}

impl From<&StopLossOrderType> for StopLossOrderType {
    fn from(value: &StopLossOrderType) -> Self {
        value.clone()
    }
}

impl ToString for StopLossOrderType {
    fn to_string(&self) -> String {
        match *self {
            Self::Market => "MARKET".to_string(),
            Self::Limit => "LIMIT".to_string(),
            Self::Stop => "STOP".to_string(),
            Self::MarketIfTouched => "MARKET_IF_TOUCHED".to_string(),
            Self::TakeProfit => "TAKE_PROFIT".to_string(),
            Self::StopLoss => "STOP_LOSS".to_string(),
            Self::TrailingStopLoss => "TRAILING_STOP_LOSS".to_string(),
            Self::FixedPrice => "FIXED_PRICE".to_string(),
        }
    }
}

impl std::str::FromStr for StopLossOrderType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "MARKET" => Ok(Self::Market),
            "LIMIT" => Ok(Self::Limit),
            "STOP" => Ok(Self::Stop),
            "MARKET_IF_TOUCHED" => Ok(Self::MarketIfTouched),
            "TAKE_PROFIT" => Ok(Self::TakeProfit),
            "STOP_LOSS" => Ok(Self::StopLoss),
            "TRAILING_STOP_LOSS" => Ok(Self::TrailingStopLoss),
            "FIXED_PRICE" => Ok(Self::FixedPrice),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopLossOrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopLossOrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopLossOrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A StopOrder is an order that is created with a price threshold, and will
/// only be filled by a price that is equal to or worse than the threshold.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A StopOrder is an order that is created with a price
/// threshold, and will only be filled by a price that is equal to or worse
/// than the threshold.",
///  "type": "object",
///  "properties": {
///    "cancelledTime": {
///      "description": "Date/time when the Order was cancelled (only
/// provided when the state of the Order is CANCELLED)",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "cancellingTransactionID": {
///      "description": "ID of the Transaction that cancelled the Order
/// (only provided when the Order's state is CANCELLED)",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "createTime": {
///      "description": "The time when the Order was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "filledTime": {
///      "description": "Date/time when the Order was filled (only provided
/// when the Order's state is FILLED)",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "fillingTransactionID": {
///      "description": "ID of the Transaction that filled this Order (only
/// provided when the Order's state is FILLED)",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "gtdTime": {
///      "description": "The date/time when the Stop Order will be cancelled
/// if its timeInForce is \"GTD\".",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "id": {
///      "description": "The Order's identifier, unique within the Order's
/// Account.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "instrument": {
///      "description": "The Stop Order's Instrument.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "positionFill": {
///      "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///      "type": "string",
///      "enum": [
///        "OPEN_ONLY",
///        "REDUCE_FIRST",
///        "REDUCE_ONLY",
///        "DEFAULT"
///      ]
///    },
///    "price": {
///      "description": "The price threshold specified for the Stop Order.
/// The Stop Order will only be filled by a market price that is equal to or
/// worse than this price.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "priceBound": {
///      "description": "The worst market price that may be used to fill
/// this Stop Order. If the market gaps and crosses through both the price
/// and the priceBound, the Stop Order will be cancelled instead of being
/// filled.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "replacedByOrderID": {
///      "description": "The ID of the Order that replaced this Order (only
/// provided if this Order was cancelled as part of a cancel/replace).",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "replacesOrderID": {
///      "description": "The ID of the Order that was replaced by this Order (only provided if this Order was created as part of a cancel/replace).",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "state": {
///      "description": "The current state of the Order.",
///      "type": "string",
///      "enum": [
///        "PENDING",
///        "FILLED",
///        "TRIGGERED",
///        "CANCELLED"
///      ]
///    },
///    "stopLossOnFill": {
///      "$ref": "#/components/schemas/StopLossDetails"
///    },
///    "takeProfitOnFill": {
///      "$ref": "#/components/schemas/TakeProfitDetails"
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the Stop Order.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeClientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "tradeClosedIDs": {
///      "description": "Trade IDs of Trades closed when the Order was
/// filled (only provided when the Order's state is FILLED and one or more
/// Trades were closed as a result of the fill)",
///      "type": "array",
///      "items": {
///        "description": "The Trade's identifier, unique within the Trade's
/// Account.",
///        "type": "string",
///        "format": "The string representation of the OANDA-assigned
/// TradeID. OANDA-assigned TradeIDs are positive integers, and are derived
/// from the TransactionID of the Transaction that opened the Trade."
///      }
///    },
///    "tradeOpenedID": {
///      "description": "Trade ID of Trade opened when the Order was filled
/// (only provided when the Order's state is FILLED and a Trade was opened
/// as a result of the fill)",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "tradeReducedID": {
///      "description": "Trade ID of Trade reduced when the Order was filled
/// (only provided when the Order's state is FILLED and a Trade was reduced
/// as a result of the fill)",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "trailingStopLossOnFill": {
///      "$ref": "#/components/schemas/TrailingStopLossDetails"
///    },
///    "triggerCondition": {
///      "description": "Specification of which price component should be
/// used when determining if an Order should be triggered and filled. This
/// allows Orders to be triggered based on the bid, ask, mid, default (ask
/// for buy, bid for sell) or inverse (ask for sell, bid for buy) price
/// depending on the desired behaviour. Orders are always filled using their
/// default price component.\nThis feature is only provided through the REST
/// API. Clients who choose to specify a non-default trigger condition will
/// not see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///      "type": "string",
///      "enum": [
///        "DEFAULT",
///        "INVERSE",
///        "BID",
///        "ASK",
///        "MID"
///      ]
///    },
///    "type": {
///      "description": "The type of the Order. Always set to \"STOP\" for
/// Stop Orders.",
///      "type": "string",
///      "enum": [
///        "MARKET",
///        "LIMIT",
///        "STOP",
///        "MARKET_IF_TOUCHED",
///        "TAKE_PROFIT",
///        "STOP_LOSS",
///        "TRAILING_STOP_LOSS",
///        "FIXED_PRICE"
///      ]
///    },
///    "units": {
///      "description": "The quantity requested to be filled by the Stop
/// Order. A posititive number of units results in a long Order, and a
/// negative number of units results in a short Order.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StopOrder {
    ///Date/time when the Order was cancelled (only provided when the state
    /// of the Order is CANCELLED)
    #[serde(
        rename = "cancelledTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelled_time: Option<String>,
    ///ID of the Transaction that cancelled the Order (only provided when
    /// the Order's state is CANCELLED)
    #[serde(
        rename = "cancellingTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The time when the Order was created.
    #[serde(
        rename = "createTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub create_time: Option<String>,
    ///Date/time when the Order was filled (only provided when the Order's
    /// state is FILLED)
    #[serde(
        rename = "filledTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub filled_time: Option<String>,
    ///ID of the Transaction that filled this Order (only provided when the
    /// Order's state is FILLED)
    #[serde(
        rename = "fillingTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub filling_transaction_id: Option<String>,
    ///The date/time when the Stop Order will be cancelled if its
    /// timeInForce is "GTD".
    #[serde(rename = "gtdTime", default, skip_serializing_if = "Option::is_none")]
    pub gtd_time: Option<String>,
    ///The Order's identifier, unique within the Order's Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The Stop Order's Instrument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    ///Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(
        rename = "positionFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub position_fill: Option<StopOrderPositionFill>,
    ///The price threshold specified for the Stop Order. The Stop Order
    /// will only be filled by a market price that is equal to or worse than
    /// this price.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The worst market price that may be used to fill this Stop Order. If
    /// the market gaps and crosses through both the price and the
    /// priceBound, the Stop Order will be cancelled instead of being
    /// filled.
    #[serde(
        rename = "priceBound",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub price_bound: Option<String>,
    ///The ID of the Order that replaced this Order (only provided if this
    /// Order was cancelled as part of a cancel/replace).
    #[serde(
        rename = "replacedByOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub replaced_by_order_id: Option<String>,
    ///The ID of the Order that was replaced by this Order (only provided
    /// if this Order was created as part of a cancel/replace).
    #[serde(
        rename = "replacesOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub replaces_order_id: Option<String>,
    ///The current state of the Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<StopOrderState>,
    #[serde(
        rename = "stopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stop_loss_on_fill: Option<StopLossDetails>,
    #[serde(
        rename = "takeProfitOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub take_profit_on_fill: Option<TakeProfitDetails>,
    ///The time-in-force requested for the Stop Order.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<StopOrderTimeInForce>,
    #[serde(
        rename = "tradeClientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,
    ///Trade IDs of Trades closed when the Order was filled (only provided
    /// when the Order's state is FILLED and one or more Trades were closed
    /// as a result of the fill)
    #[serde(
        rename = "tradeClosedIDs",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub trade_closed_i_ds: Vec<String>,
    ///Trade ID of Trade opened when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was opened as a result
    /// of the fill)
    #[serde(
        rename = "tradeOpenedID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_opened_id: Option<String>,
    ///Trade ID of Trade reduced when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was reduced as a result
    /// of the fill)
    #[serde(
        rename = "tradeReducedID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_reduced_id: Option<String>,
    #[serde(
        rename = "trailingStopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,
    ///Specification of which price component should be used when
    /// determining if an Order should be triggered and filled. This allows
    /// Orders to be triggered based on the bid, ask, mid, default (ask for
    /// buy, bid for sell) or inverse (ask for sell, bid for buy) price
    /// depending on the desired behaviour. Orders are always filled using
    /// their default price component. This feature is only provided
    /// through the REST API. Clients who choose to specify a non-default
    /// trigger condition will not see it reflected in any of OANDA's
    /// proprietary or partner trading platforms, their transaction history
    /// or their account statements. OANDA platforms always assume that an
    /// Order's trigger condition is set to the default value when
    /// indicating the distance from an Order's trigger price, and will
    /// always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when
    /// creating a guaranteed Stop Loss Order. In this case the
    /// TriggerCondition value must either be "DEFAULT", or the "natural"
    /// trigger side "DEFAULT" results in. So for a Stop Loss Order for a
    /// long trade valid values are "DEFAULT" and "BID", and for short
    /// trades "DEFAULT" and "ASK" are valid.
    #[serde(
        rename = "triggerCondition",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trigger_condition: Option<StopOrderTriggerCondition>,
    ///The type of the Order. Always set to "STOP" for Stop Orders.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<StopOrderType>,
    ///The quantity requested to be filled by the Stop Order. A posititive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<String>,
}

impl From<&StopOrder> for StopOrder {
    fn from(value: &StopOrder) -> Self {
        value.clone()
    }
}

impl StopOrder {
    pub fn builder() -> builder::StopOrder {
        Default::default()
    }
}

///Specification of how Positions in the Account are modified when the
/// Order is filled.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///  "type": "string",
///  "enum": [
///    "OPEN_ONLY",
///    "REDUCE_FIRST",
///    "REDUCE_ONLY",
///    "DEFAULT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopOrderPositionFill {
    #[serde(rename = "OPEN_ONLY")]
    OpenOnly,
    #[serde(rename = "REDUCE_FIRST")]
    ReduceFirst,
    #[serde(rename = "REDUCE_ONLY")]
    ReduceOnly,
    #[serde(rename = "DEFAULT")]
    Default,
}

impl From<&StopOrderPositionFill> for StopOrderPositionFill {
    fn from(value: &StopOrderPositionFill) -> Self {
        value.clone()
    }
}

impl ToString for StopOrderPositionFill {
    fn to_string(&self) -> String {
        match *self {
            Self::OpenOnly => "OPEN_ONLY".to_string(),
            Self::ReduceFirst => "REDUCE_FIRST".to_string(),
            Self::ReduceOnly => "REDUCE_ONLY".to_string(),
            Self::Default => "DEFAULT".to_string(),
        }
    }
}

impl std::str::FromStr for StopOrderPositionFill {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "OPEN_ONLY" => Ok(Self::OpenOnly),
            "REDUCE_FIRST" => Ok(Self::ReduceFirst),
            "REDUCE_ONLY" => Ok(Self::ReduceOnly),
            "DEFAULT" => Ok(Self::Default),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopOrderPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopOrderPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopOrderPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The reason that the Stop Order was initiated
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Stop Order was initiated",
///  "type": "string",
///  "enum": [
///    "CLIENT_ORDER",
///    "REPLACEMENT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopOrderReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "REPLACEMENT")]
    Replacement,
}

impl From<&StopOrderReason> for StopOrderReason {
    fn from(value: &StopOrderReason) -> Self {
        value.clone()
    }
}

impl ToString for StopOrderReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ClientOrder => "CLIENT_ORDER".to_string(),
            Self::Replacement => "REPLACEMENT".to_string(),
        }
    }
}

impl std::str::FromStr for StopOrderReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CLIENT_ORDER" => Ok(Self::ClientOrder),
            "REPLACEMENT" => Ok(Self::Replacement),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopOrderReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopOrderReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopOrderReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A StopOrderRejectTransaction represents the rejection of the creation of
/// a Stop Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A StopOrderRejectTransaction represents the rejection
/// of the creation of a Stop Order.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "gtdTime": {
///      "description": "The date/time when the Stop Order will be cancelled
/// if its timeInForce is \"GTD\".",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "instrument": {
///      "description": "The Stop Order's Instrument.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "intendedReplacesOrderID": {
///      "description": "The ID of the Order that this Order was intended to
/// replace (only provided if this Order was intended to replace an existing
/// Order).",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "positionFill": {
///      "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///      "type": "string",
///      "enum": [
///        "OPEN_ONLY",
///        "REDUCE_FIRST",
///        "REDUCE_ONLY",
///        "DEFAULT"
///      ]
///    },
///    "price": {
///      "description": "The price threshold specified for the Stop Order.
/// The Stop Order will only be filled by a market price that is equal to or
/// worse than this price.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "priceBound": {
///      "description": "The worst market price that may be used to fill
/// this Stop Order. If the market gaps and crosses through both the price
/// and the priceBound, the Stop Order will be cancelled instead of being
/// filled.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "reason": {
///      "description": "The reason that the Stop Order was initiated",
///      "type": "string",
///      "enum": [
///        "CLIENT_ORDER",
///        "REPLACEMENT"
///      ]
///    },
///    "rejectReason": {
///      "description": "The reason that the Reject Transaction was
/// created",
///      "type": "string",
///      "enum": [
///        "INTERNAL_SERVER_ERROR",
///        "INSTRUMENT_PRICE_UNKNOWN",
///        "ACCOUNT_NOT_ACTIVE",
///        "ACCOUNT_LOCKED",
///        "ACCOUNT_ORDER_CREATION_LOCKED",
///        "ACCOUNT_CONFIGURATION_LOCKED",
///        "ACCOUNT_DEPOSIT_LOCKED",
///        "ACCOUNT_WITHDRAWAL_LOCKED",
///        "ACCOUNT_ORDER_CANCEL_LOCKED",
///        "INSTRUMENT_NOT_TRADEABLE",
///        "PENDING_ORDERS_ALLOWED_EXCEEDED",
///        "ORDER_ID_UNSPECIFIED",
///        "ORDER_DOESNT_EXIST",
///        "ORDER_IDENTIFIER_INCONSISTENCY",
///        "TRADE_ID_UNSPECIFIED",
///        "TRADE_DOESNT_EXIST",
///        "TRADE_IDENTIFIER_INCONSISTENCY",
///        "INSUFFICIENT_MARGIN",
///        "INSTRUMENT_MISSING",
///        "INSTRUMENT_UNKNOWN",
///        "UNITS_MISSING",
///        "UNITS_INVALID",
///        "UNITS_PRECISION_EXCEEDED",
///        "UNITS_LIMIT_EXCEEDED",
///        "UNITS_MIMIMUM_NOT_MET",
///        "PRICE_MISSING",
///        "PRICE_INVALID",
///        "PRICE_PRECISION_EXCEEDED",
///        "PRICE_DISTANCE_MISSING",
///        "PRICE_DISTANCE_INVALID",
///        "PRICE_DISTANCE_PRECISION_EXCEEDED",
///        "PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "PRICE_DISTANCE_MINIMUM_NOT_MET",
///        "TIME_IN_FORCE_MISSING",
///        "TIME_IN_FORCE_INVALID",
///        "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING",
///        "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST",
///        "PRICE_BOUND_INVALID",
///        "PRICE_BOUND_PRECISION_EXCEEDED",
///        "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS",
///        "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED",
///        "CLIENT_ORDER_ID_INVALID",
///        "CLIENT_ORDER_ID_ALREADY_EXISTS",
///        "CLIENT_ORDER_TAG_INVALID",
///        "CLIENT_ORDER_COMMENT_INVALID",
///        "CLIENT_TRADE_ID_INVALID",
///        "CLIENT_TRADE_ID_ALREADY_EXISTS",
///        "CLIENT_TRADE_TAG_INVALID",
///        "CLIENT_TRADE_COMMENT_INVALID",
///        "ORDER_FILL_POSITION_ACTION_MISSING",
///        "ORDER_FILL_POSITION_ACTION_INVALID",
///        "TRIGGER_CONDITION_MISSING",
///        "TRIGGER_CONDITION_INVALID",
///        "ORDER_PARTIAL_FILL_OPTION_MISSING",
///        "ORDER_PARTIAL_FILL_OPTION_INVALID",
///        "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL",
///        "TAKE_PROFIT_ORDER_ALREADY_EXISTS",
///        "TAKE_PROFIT_ON_FILL_PRICE_MISSING",
///        "TAKE_PROFIT_ON_FILL_PRICE_INVALID",
///        "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED",
///        "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING",
///        "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID",
///        "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "STOP_LOSS_ORDER_ALREADY_EXISTS",
///        "STOP_LOSS_ORDER_GUARANTEED_REQUIRED",
///        "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD",
///        "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED",
///        "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION",
///        "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION",
///        "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED",
///        "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///        "STOP_LOSS_ORDER_NOT_CANCELABLE",
///        "STOP_LOSS_ORDER_NOT_REPLACEABLE",
///        "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///        "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///        "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING",
///        "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER",
///        "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///        "STOP_LOSS_ON_FILL_PRICE_MISSING",
///        "STOP_LOSS_ON_FILL_PRICE_INVALID",
///        "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///        "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_DISTANCE_INVALID",
///        "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///        "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING",
///        "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///        "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///        "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET",
///        "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED",
///        "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "CLOSE_TRADE_TYPE_MISSING",
///        "CLOSE_TRADE_PARTIAL_UNITS_MISSING",
///        "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE",
///        "CLOSEOUT_POSITION_DOESNT_EXIST",
///        "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION",
///        "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE",
///        "CLOSEOUT_POSITION_REJECT",
///        "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING",
///        "MARKUP_GROUP_ID_INVALID",
///        "POSITION_AGGREGATION_MODE_INVALID",
///        "ADMIN_CONFIGURE_DATA_MISSING",
///        "MARGIN_RATE_INVALID",
///        "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT",
///        "ALIAS_INVALID",
///        "CLIENT_CONFIGURE_DATA_MISSING",
///        "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL",
///        "AMOUNT_INVALID",
///        "INSUFFICIENT_FUNDS",
///        "AMOUNT_MISSING",
///        "FUNDING_REASON_MISSING",
///        "CLIENT_EXTENSIONS_DATA_MISSING",
///        "REPLACING_ORDER_INVALID",
///        "REPLACING_TRADE_ID_INVALID"
///      ]
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "stopLossOnFill": {
///      "$ref": "#/components/schemas/StopLossDetails"
///    },
///    "takeProfitOnFill": {
///      "$ref": "#/components/schemas/TakeProfitDetails"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the Stop Order.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeClientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "trailingStopLossOnFill": {
///      "$ref": "#/components/schemas/TrailingStopLossDetails"
///    },
///    "triggerCondition": {
///      "description": "Specification of which price component should be
/// used when determining if an Order should be triggered and filled. This
/// allows Orders to be triggered based on the bid, ask, mid, default (ask
/// for buy, bid for sell) or inverse (ask for sell, bid for buy) price
/// depending on the desired behaviour. Orders are always filled using their
/// default price component.\nThis feature is only provided through the REST
/// API. Clients who choose to specify a non-default trigger condition will
/// not see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///      "type": "string",
///      "enum": [
///        "DEFAULT",
///        "INVERSE",
///        "BID",
///        "ASK",
///        "MID"
///      ]
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"STOP_ORDER_REJECT\" in a StopOrderRejectTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "units": {
///      "description": "The quantity requested to be filled by the Stop
/// Order. A posititive number of units results in a long Order, and a
/// negative number of units results in a short Order.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StopOrderRejectTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The date/time when the Stop Order will be cancelled if its
    /// timeInForce is "GTD".
    #[serde(rename = "gtdTime", default, skip_serializing_if = "Option::is_none")]
    pub gtd_time: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The Stop Order's Instrument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    ///The ID of the Order that this Order was intended to replace (only
    /// provided if this Order was intended to replace an existing Order).
    #[serde(
        rename = "intendedReplacesOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub intended_replaces_order_id: Option<String>,
    ///Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(
        rename = "positionFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub position_fill: Option<StopOrderRejectTransactionPositionFill>,
    ///The price threshold specified for the Stop Order. The Stop Order
    /// will only be filled by a market price that is equal to or worse than
    /// this price.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The worst market price that may be used to fill this Stop Order. If
    /// the market gaps and crosses through both the price and the
    /// priceBound, the Stop Order will be cancelled instead of being
    /// filled.
    #[serde(
        rename = "priceBound",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub price_bound: Option<String>,
    ///The reason that the Stop Order was initiated
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<StopOrderRejectTransactionReason>,
    ///The reason that the Reject Transaction was created
    #[serde(
        rename = "rejectReason",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub reject_reason: Option<StopOrderRejectTransactionRejectReason>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    #[serde(
        rename = "stopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stop_loss_on_fill: Option<StopLossDetails>,
    #[serde(
        rename = "takeProfitOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub take_profit_on_fill: Option<TakeProfitDetails>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The time-in-force requested for the Stop Order.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<StopOrderRejectTransactionTimeInForce>,
    #[serde(
        rename = "tradeClientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,
    #[serde(
        rename = "trailingStopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,
    ///Specification of which price component should be used when
    /// determining if an Order should be triggered and filled. This allows
    /// Orders to be triggered based on the bid, ask, mid, default (ask for
    /// buy, bid for sell) or inverse (ask for sell, bid for buy) price
    /// depending on the desired behaviour. Orders are always filled using
    /// their default price component. This feature is only provided
    /// through the REST API. Clients who choose to specify a non-default
    /// trigger condition will not see it reflected in any of OANDA's
    /// proprietary or partner trading platforms, their transaction history
    /// or their account statements. OANDA platforms always assume that an
    /// Order's trigger condition is set to the default value when
    /// indicating the distance from an Order's trigger price, and will
    /// always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when
    /// creating a guaranteed Stop Loss Order. In this case the
    /// TriggerCondition value must either be "DEFAULT", or the "natural"
    /// trigger side "DEFAULT" results in. So for a Stop Loss Order for a
    /// long trade valid values are "DEFAULT" and "BID", and for short
    /// trades "DEFAULT" and "ASK" are valid.
    #[serde(
        rename = "triggerCondition",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trigger_condition: Option<StopOrderRejectTransactionTriggerCondition>,
    ///The Type of the Transaction. Always set to "STOP_ORDER_REJECT" in a
    /// StopOrderRejectTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<StopOrderRejectTransactionType>,
    ///The quantity requested to be filled by the Stop Order. A posititive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<String>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&StopOrderRejectTransaction> for StopOrderRejectTransaction {
    fn from(value: &StopOrderRejectTransaction) -> Self {
        value.clone()
    }
}

impl StopOrderRejectTransaction {
    pub fn builder() -> builder::StopOrderRejectTransaction {
        Default::default()
    }
}

///Specification of how Positions in the Account are modified when the
/// Order is filled.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///  "type": "string",
///  "enum": [
///    "OPEN_ONLY",
///    "REDUCE_FIRST",
///    "REDUCE_ONLY",
///    "DEFAULT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopOrderRejectTransactionPositionFill {
    #[serde(rename = "OPEN_ONLY")]
    OpenOnly,
    #[serde(rename = "REDUCE_FIRST")]
    ReduceFirst,
    #[serde(rename = "REDUCE_ONLY")]
    ReduceOnly,
    #[serde(rename = "DEFAULT")]
    Default,
}

impl From<&StopOrderRejectTransactionPositionFill> for StopOrderRejectTransactionPositionFill {
    fn from(value: &StopOrderRejectTransactionPositionFill) -> Self {
        value.clone()
    }
}

impl ToString for StopOrderRejectTransactionPositionFill {
    fn to_string(&self) -> String {
        match *self {
            Self::OpenOnly => "OPEN_ONLY".to_string(),
            Self::ReduceFirst => "REDUCE_FIRST".to_string(),
            Self::ReduceOnly => "REDUCE_ONLY".to_string(),
            Self::Default => "DEFAULT".to_string(),
        }
    }
}

impl std::str::FromStr for StopOrderRejectTransactionPositionFill {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "OPEN_ONLY" => Ok(Self::OpenOnly),
            "REDUCE_FIRST" => Ok(Self::ReduceFirst),
            "REDUCE_ONLY" => Ok(Self::ReduceOnly),
            "DEFAULT" => Ok(Self::Default),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopOrderRejectTransactionPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopOrderRejectTransactionPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopOrderRejectTransactionPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The reason that the Stop Order was initiated
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Stop Order was initiated",
///  "type": "string",
///  "enum": [
///    "CLIENT_ORDER",
///    "REPLACEMENT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopOrderRejectTransactionReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "REPLACEMENT")]
    Replacement,
}

impl From<&StopOrderRejectTransactionReason> for StopOrderRejectTransactionReason {
    fn from(value: &StopOrderRejectTransactionReason) -> Self {
        value.clone()
    }
}

impl ToString for StopOrderRejectTransactionReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ClientOrder => "CLIENT_ORDER".to_string(),
            Self::Replacement => "REPLACEMENT".to_string(),
        }
    }
}

impl std::str::FromStr for StopOrderRejectTransactionReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CLIENT_ORDER" => Ok(Self::ClientOrder),
            "REPLACEMENT" => Ok(Self::Replacement),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopOrderRejectTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopOrderRejectTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopOrderRejectTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The reason that the Reject Transaction was created
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Reject Transaction was created",
///  "type": "string",
///  "enum": [
///    "INTERNAL_SERVER_ERROR",
///    "INSTRUMENT_PRICE_UNKNOWN",
///    "ACCOUNT_NOT_ACTIVE",
///    "ACCOUNT_LOCKED",
///    "ACCOUNT_ORDER_CREATION_LOCKED",
///    "ACCOUNT_CONFIGURATION_LOCKED",
///    "ACCOUNT_DEPOSIT_LOCKED",
///    "ACCOUNT_WITHDRAWAL_LOCKED",
///    "ACCOUNT_ORDER_CANCEL_LOCKED",
///    "INSTRUMENT_NOT_TRADEABLE",
///    "PENDING_ORDERS_ALLOWED_EXCEEDED",
///    "ORDER_ID_UNSPECIFIED",
///    "ORDER_DOESNT_EXIST",
///    "ORDER_IDENTIFIER_INCONSISTENCY",
///    "TRADE_ID_UNSPECIFIED",
///    "TRADE_DOESNT_EXIST",
///    "TRADE_IDENTIFIER_INCONSISTENCY",
///    "INSUFFICIENT_MARGIN",
///    "INSTRUMENT_MISSING",
///    "INSTRUMENT_UNKNOWN",
///    "UNITS_MISSING",
///    "UNITS_INVALID",
///    "UNITS_PRECISION_EXCEEDED",
///    "UNITS_LIMIT_EXCEEDED",
///    "UNITS_MIMIMUM_NOT_MET",
///    "PRICE_MISSING",
///    "PRICE_INVALID",
///    "PRICE_PRECISION_EXCEEDED",
///    "PRICE_DISTANCE_MISSING",
///    "PRICE_DISTANCE_INVALID",
///    "PRICE_DISTANCE_PRECISION_EXCEEDED",
///    "PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "PRICE_DISTANCE_MINIMUM_NOT_MET",
///    "TIME_IN_FORCE_MISSING",
///    "TIME_IN_FORCE_INVALID",
///    "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING",
///    "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST",
///    "PRICE_BOUND_INVALID",
///    "PRICE_BOUND_PRECISION_EXCEEDED",
///    "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS",
///    "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED",
///    "CLIENT_ORDER_ID_INVALID",
///    "CLIENT_ORDER_ID_ALREADY_EXISTS",
///    "CLIENT_ORDER_TAG_INVALID",
///    "CLIENT_ORDER_COMMENT_INVALID",
///    "CLIENT_TRADE_ID_INVALID",
///    "CLIENT_TRADE_ID_ALREADY_EXISTS",
///    "CLIENT_TRADE_TAG_INVALID",
///    "CLIENT_TRADE_COMMENT_INVALID",
///    "ORDER_FILL_POSITION_ACTION_MISSING",
///    "ORDER_FILL_POSITION_ACTION_INVALID",
///    "TRIGGER_CONDITION_MISSING",
///    "TRIGGER_CONDITION_INVALID",
///    "ORDER_PARTIAL_FILL_OPTION_MISSING",
///    "ORDER_PARTIAL_FILL_OPTION_INVALID",
///    "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL",
///    "TAKE_PROFIT_ORDER_ALREADY_EXISTS",
///    "TAKE_PROFIT_ON_FILL_PRICE_MISSING",
///    "TAKE_PROFIT_ON_FILL_PRICE_INVALID",
///    "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED",
///    "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING",
///    "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "STOP_LOSS_ORDER_ALREADY_EXISTS",
///    "STOP_LOSS_ORDER_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD",
///    "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION",
///    "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION",
///    "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED",
///    "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ORDER_NOT_CANCELABLE",
///    "STOP_LOSS_ORDER_NOT_REPLACEABLE",
///    "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///    "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING",
///    "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER",
///    "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ON_FILL_PRICE_MISSING",
///    "STOP_LOSS_ON_FILL_PRICE_INVALID",
///    "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_DISTANCE_INVALID",
///    "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///    "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET",
///    "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED",
///    "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "CLOSE_TRADE_TYPE_MISSING",
///    "CLOSE_TRADE_PARTIAL_UNITS_MISSING",
///    "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE",
///    "CLOSEOUT_POSITION_DOESNT_EXIST",
///    "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION",
///    "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE",
///    "CLOSEOUT_POSITION_REJECT",
///    "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING",
///    "MARKUP_GROUP_ID_INVALID",
///    "POSITION_AGGREGATION_MODE_INVALID",
///    "ADMIN_CONFIGURE_DATA_MISSING",
///    "MARGIN_RATE_INVALID",
///    "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT",
///    "ALIAS_INVALID",
///    "CLIENT_CONFIGURE_DATA_MISSING",
///    "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL",
///    "AMOUNT_INVALID",
///    "INSUFFICIENT_FUNDS",
///    "AMOUNT_MISSING",
///    "FUNDING_REASON_MISSING",
///    "CLIENT_EXTENSIONS_DATA_MISSING",
///    "REPLACING_ORDER_INVALID",
///    "REPLACING_TRADE_ID_INVALID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopOrderRejectTransactionRejectReason {
    #[serde(rename = "INTERNAL_SERVER_ERROR")]
    InternalServerError,
    #[serde(rename = "INSTRUMENT_PRICE_UNKNOWN")]
    InstrumentPriceUnknown,
    #[serde(rename = "ACCOUNT_NOT_ACTIVE")]
    AccountNotActive,
    #[serde(rename = "ACCOUNT_LOCKED")]
    AccountLocked,
    #[serde(rename = "ACCOUNT_ORDER_CREATION_LOCKED")]
    AccountOrderCreationLocked,
    #[serde(rename = "ACCOUNT_CONFIGURATION_LOCKED")]
    AccountConfigurationLocked,
    #[serde(rename = "ACCOUNT_DEPOSIT_LOCKED")]
    AccountDepositLocked,
    #[serde(rename = "ACCOUNT_WITHDRAWAL_LOCKED")]
    AccountWithdrawalLocked,
    #[serde(rename = "ACCOUNT_ORDER_CANCEL_LOCKED")]
    AccountOrderCancelLocked,
    #[serde(rename = "INSTRUMENT_NOT_TRADEABLE")]
    InstrumentNotTradeable,
    #[serde(rename = "PENDING_ORDERS_ALLOWED_EXCEEDED")]
    PendingOrdersAllowedExceeded,
    #[serde(rename = "ORDER_ID_UNSPECIFIED")]
    OrderIdUnspecified,
    #[serde(rename = "ORDER_DOESNT_EXIST")]
    OrderDoesntExist,
    #[serde(rename = "ORDER_IDENTIFIER_INCONSISTENCY")]
    OrderIdentifierInconsistency,
    #[serde(rename = "TRADE_ID_UNSPECIFIED")]
    TradeIdUnspecified,
    #[serde(rename = "TRADE_DOESNT_EXIST")]
    TradeDoesntExist,
    #[serde(rename = "TRADE_IDENTIFIER_INCONSISTENCY")]
    TradeIdentifierInconsistency,
    #[serde(rename = "INSUFFICIENT_MARGIN")]
    InsufficientMargin,
    #[serde(rename = "INSTRUMENT_MISSING")]
    InstrumentMissing,
    #[serde(rename = "INSTRUMENT_UNKNOWN")]
    InstrumentUnknown,
    #[serde(rename = "UNITS_MISSING")]
    UnitsMissing,
    #[serde(rename = "UNITS_INVALID")]
    UnitsInvalid,
    #[serde(rename = "UNITS_PRECISION_EXCEEDED")]
    UnitsPrecisionExceeded,
    #[serde(rename = "UNITS_LIMIT_EXCEEDED")]
    UnitsLimitExceeded,
    #[serde(rename = "UNITS_MIMIMUM_NOT_MET")]
    UnitsMimimumNotMet,
    #[serde(rename = "PRICE_MISSING")]
    PriceMissing,
    #[serde(rename = "PRICE_INVALID")]
    PriceInvalid,
    #[serde(rename = "PRICE_PRECISION_EXCEEDED")]
    PricePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MISSING")]
    PriceDistanceMissing,
    #[serde(rename = "PRICE_DISTANCE_INVALID")]
    PriceDistanceInvalid,
    #[serde(rename = "PRICE_DISTANCE_PRECISION_EXCEEDED")]
    PriceDistancePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    PriceDistanceMaximumExceeded,
    #[serde(rename = "PRICE_DISTANCE_MINIMUM_NOT_MET")]
    PriceDistanceMinimumNotMet,
    #[serde(rename = "TIME_IN_FORCE_MISSING")]
    TimeInForceMissing,
    #[serde(rename = "TIME_IN_FORCE_INVALID")]
    TimeInForceInvalid,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING")]
    TimeInForceGtdTimestampMissing,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST")]
    TimeInForceGtdTimestampInPast,
    #[serde(rename = "PRICE_BOUND_INVALID")]
    PriceBoundInvalid,
    #[serde(rename = "PRICE_BOUND_PRECISION_EXCEEDED")]
    PriceBoundPrecisionExceeded,
    #[serde(rename = "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS")]
    OrdersOnFillDuplicateClientOrderIds,
    #[serde(rename = "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED")]
    TradeOnFillClientExtensionsNotSupported,
    #[serde(rename = "CLIENT_ORDER_ID_INVALID")]
    ClientOrderIdInvalid,
    #[serde(rename = "CLIENT_ORDER_ID_ALREADY_EXISTS")]
    ClientOrderIdAlreadyExists,
    #[serde(rename = "CLIENT_ORDER_TAG_INVALID")]
    ClientOrderTagInvalid,
    #[serde(rename = "CLIENT_ORDER_COMMENT_INVALID")]
    ClientOrderCommentInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_INVALID")]
    ClientTradeIdInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_ALREADY_EXISTS")]
    ClientTradeIdAlreadyExists,
    #[serde(rename = "CLIENT_TRADE_TAG_INVALID")]
    ClientTradeTagInvalid,
    #[serde(rename = "CLIENT_TRADE_COMMENT_INVALID")]
    ClientTradeCommentInvalid,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_MISSING")]
    OrderFillPositionActionMissing,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_INVALID")]
    OrderFillPositionActionInvalid,
    #[serde(rename = "TRIGGER_CONDITION_MISSING")]
    TriggerConditionMissing,
    #[serde(rename = "TRIGGER_CONDITION_INVALID")]
    TriggerConditionInvalid,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_MISSING")]
    OrderPartialFillOptionMissing,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_INVALID")]
    OrderPartialFillOptionInvalid,
    #[serde(rename = "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL")]
    InvalidReissueImmediatePartialFill,
    #[serde(rename = "TAKE_PROFIT_ORDER_ALREADY_EXISTS")]
    TakeProfitOrderAlreadyExists,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_MISSING")]
    TakeProfitOnFillPriceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_INVALID")]
    TakeProfitOnFillPriceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    TakeProfitOnFillPricePrecisionExceeded,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING")]
    TakeProfitOnFillTimeInForceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID")]
    TakeProfitOnFillTimeInForceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TakeProfitOnFillGtdTimestampMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TakeProfitOnFillGtdTimestampInPast,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TakeProfitOnFillClientOrderIdInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TakeProfitOnFillClientOrderTagInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TakeProfitOnFillClientOrderCommentInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TakeProfitOnFillTriggerConditionMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TakeProfitOnFillTriggerConditionInvalid,
    #[serde(rename = "STOP_LOSS_ORDER_ALREADY_EXISTS")]
    StopLossOrderAlreadyExists,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_REQUIRED")]
    StopLossOrderGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD")]
    StopLossOrderGuaranteedPriceWithinSpread,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED")]
    StopLossOrderGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION")]
    StopLossOrderGuaranteedHaltedCreateViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION")]
    StopLossOrderGuaranteedHaltedTightenViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED")]
    StopLossOrderGuaranteedHedgingNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOrderGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_CANCELABLE")]
    StopLossOrderNotCancelable,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_REPLACEABLE")]
    StopLossOrderNotReplaceable,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOrderGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOrderPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOrderPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER")]
    StopLossOnFillRequiredForPendingOrder,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED")]
    StopLossOnFillGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED")]
    StopLossOnFillGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_MISSING")]
    StopLossOnFillPriceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_INVALID")]
    StopLossOnFillPriceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    StopLossOnFillPricePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOnFillGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOnFillGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_INVALID")]
    StopLossOnFillDistanceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    StopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED")]
    StopLossOnFillDistancePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOnFillPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOnFillPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    StopLossOnFillTimeInForceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    StopLossOnFillTimeInForceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    StopLossOnFillGtdTimestampMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    StopLossOnFillGtdTimestampInPast,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    StopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    StopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    StopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    StopLossOnFillTriggerConditionMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    StopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS")]
    TrailingStopLossOrderAlreadyExists,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING")]
    TrailingStopLossOnFillPriceDistanceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID")]
    TrailingStopLossOnFillPriceDistanceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED")]
    TrailingStopLossOnFillPriceDistancePrecisionExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    TrailingStopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET")]
    TrailingStopLossOnFillPriceDistanceMinimumNotMet,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    TrailingStopLossOnFillTimeInForceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    TrailingStopLossOnFillTimeInForceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TrailingStopLossOnFillGtdTimestampMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TrailingStopLossOnFillGtdTimestampInPast,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TrailingStopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TrailingStopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TrailingStopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED")]
    TrailingStopLossOrdersNotSupported,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TrailingStopLossOnFillTriggerConditionMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TrailingStopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "CLOSE_TRADE_TYPE_MISSING")]
    CloseTradeTypeMissing,
    #[serde(rename = "CLOSE_TRADE_PARTIAL_UNITS_MISSING")]
    CloseTradePartialUnitsMissing,
    #[serde(rename = "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE")]
    CloseTradeUnitsExceedTradeSize,
    #[serde(rename = "CLOSEOUT_POSITION_DOESNT_EXIST")]
    CloseoutPositionDoesntExist,
    #[serde(rename = "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION")]
    CloseoutPositionIncompleteSpecification,
    #[serde(rename = "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE")]
    CloseoutPositionUnitsExceedPositionSize,
    #[serde(rename = "CLOSEOUT_POSITION_REJECT")]
    CloseoutPositionReject,
    #[serde(rename = "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING")]
    CloseoutPositionPartialUnitsMissing,
    #[serde(rename = "MARKUP_GROUP_ID_INVALID")]
    MarkupGroupIdInvalid,
    #[serde(rename = "POSITION_AGGREGATION_MODE_INVALID")]
    PositionAggregationModeInvalid,
    #[serde(rename = "ADMIN_CONFIGURE_DATA_MISSING")]
    AdminConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_INVALID")]
    MarginRateInvalid,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT")]
    MarginRateWouldTriggerCloseout,
    #[serde(rename = "ALIAS_INVALID")]
    AliasInvalid,
    #[serde(rename = "CLIENT_CONFIGURE_DATA_MISSING")]
    ClientConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL")]
    MarginRateWouldTriggerMarginCall,
    #[serde(rename = "AMOUNT_INVALID")]
    AmountInvalid,
    #[serde(rename = "INSUFFICIENT_FUNDS")]
    InsufficientFunds,
    #[serde(rename = "AMOUNT_MISSING")]
    AmountMissing,
    #[serde(rename = "FUNDING_REASON_MISSING")]
    FundingReasonMissing,
    #[serde(rename = "CLIENT_EXTENSIONS_DATA_MISSING")]
    ClientExtensionsDataMissing,
    #[serde(rename = "REPLACING_ORDER_INVALID")]
    ReplacingOrderInvalid,
    #[serde(rename = "REPLACING_TRADE_ID_INVALID")]
    ReplacingTradeIdInvalid,
}

impl From<&StopOrderRejectTransactionRejectReason> for StopOrderRejectTransactionRejectReason {
    fn from(value: &StopOrderRejectTransactionRejectReason) -> Self {
        value.clone()
    }
}

impl ToString for StopOrderRejectTransactionRejectReason {
    fn to_string(&self) -> String {
        match *self {
            Self::InternalServerError => "INTERNAL_SERVER_ERROR".to_string(),
            Self::InstrumentPriceUnknown => "INSTRUMENT_PRICE_UNKNOWN".to_string(),
            Self::AccountNotActive => "ACCOUNT_NOT_ACTIVE".to_string(),
            Self::AccountLocked => "ACCOUNT_LOCKED".to_string(),
            Self::AccountOrderCreationLocked => "ACCOUNT_ORDER_CREATION_LOCKED".to_string(),
            Self::AccountConfigurationLocked => "ACCOUNT_CONFIGURATION_LOCKED".to_string(),
            Self::AccountDepositLocked => "ACCOUNT_DEPOSIT_LOCKED".to_string(),
            Self::AccountWithdrawalLocked => "ACCOUNT_WITHDRAWAL_LOCKED".to_string(),
            Self::AccountOrderCancelLocked => "ACCOUNT_ORDER_CANCEL_LOCKED".to_string(),
            Self::InstrumentNotTradeable => "INSTRUMENT_NOT_TRADEABLE".to_string(),
            Self::PendingOrdersAllowedExceeded => "PENDING_ORDERS_ALLOWED_EXCEEDED".to_string(),
            Self::OrderIdUnspecified => "ORDER_ID_UNSPECIFIED".to_string(),
            Self::OrderDoesntExist => "ORDER_DOESNT_EXIST".to_string(),
            Self::OrderIdentifierInconsistency => "ORDER_IDENTIFIER_INCONSISTENCY".to_string(),
            Self::TradeIdUnspecified => "TRADE_ID_UNSPECIFIED".to_string(),
            Self::TradeDoesntExist => "TRADE_DOESNT_EXIST".to_string(),
            Self::TradeIdentifierInconsistency => "TRADE_IDENTIFIER_INCONSISTENCY".to_string(),
            Self::InsufficientMargin => "INSUFFICIENT_MARGIN".to_string(),
            Self::InstrumentMissing => "INSTRUMENT_MISSING".to_string(),
            Self::InstrumentUnknown => "INSTRUMENT_UNKNOWN".to_string(),
            Self::UnitsMissing => "UNITS_MISSING".to_string(),
            Self::UnitsInvalid => "UNITS_INVALID".to_string(),
            Self::UnitsPrecisionExceeded => "UNITS_PRECISION_EXCEEDED".to_string(),
            Self::UnitsLimitExceeded => "UNITS_LIMIT_EXCEEDED".to_string(),
            Self::UnitsMimimumNotMet => "UNITS_MIMIMUM_NOT_MET".to_string(),
            Self::PriceMissing => "PRICE_MISSING".to_string(),
            Self::PriceInvalid => "PRICE_INVALID".to_string(),
            Self::PricePrecisionExceeded => "PRICE_PRECISION_EXCEEDED".to_string(),
            Self::PriceDistanceMissing => "PRICE_DISTANCE_MISSING".to_string(),
            Self::PriceDistanceInvalid => "PRICE_DISTANCE_INVALID".to_string(),
            Self::PriceDistancePrecisionExceeded => "PRICE_DISTANCE_PRECISION_EXCEEDED".to_string(),
            Self::PriceDistanceMaximumExceeded => "PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string(),
            Self::PriceDistanceMinimumNotMet => "PRICE_DISTANCE_MINIMUM_NOT_MET".to_string(),
            Self::TimeInForceMissing => "TIME_IN_FORCE_MISSING".to_string(),
            Self::TimeInForceInvalid => "TIME_IN_FORCE_INVALID".to_string(),
            Self::TimeInForceGtdTimestampMissing => {
                "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TimeInForceGtdTimestampInPast => {
                "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::PriceBoundInvalid => "PRICE_BOUND_INVALID".to_string(),
            Self::PriceBoundPrecisionExceeded => "PRICE_BOUND_PRECISION_EXCEEDED".to_string(),
            Self::OrdersOnFillDuplicateClientOrderIds => {
                "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS".to_string()
            }
            Self::TradeOnFillClientExtensionsNotSupported => {
                "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED".to_string()
            }
            Self::ClientOrderIdInvalid => "CLIENT_ORDER_ID_INVALID".to_string(),
            Self::ClientOrderIdAlreadyExists => "CLIENT_ORDER_ID_ALREADY_EXISTS".to_string(),
            Self::ClientOrderTagInvalid => "CLIENT_ORDER_TAG_INVALID".to_string(),
            Self::ClientOrderCommentInvalid => "CLIENT_ORDER_COMMENT_INVALID".to_string(),
            Self::ClientTradeIdInvalid => "CLIENT_TRADE_ID_INVALID".to_string(),
            Self::ClientTradeIdAlreadyExists => "CLIENT_TRADE_ID_ALREADY_EXISTS".to_string(),
            Self::ClientTradeTagInvalid => "CLIENT_TRADE_TAG_INVALID".to_string(),
            Self::ClientTradeCommentInvalid => "CLIENT_TRADE_COMMENT_INVALID".to_string(),
            Self::OrderFillPositionActionMissing => {
                "ORDER_FILL_POSITION_ACTION_MISSING".to_string()
            }
            Self::OrderFillPositionActionInvalid => {
                "ORDER_FILL_POSITION_ACTION_INVALID".to_string()
            }
            Self::TriggerConditionMissing => "TRIGGER_CONDITION_MISSING".to_string(),
            Self::TriggerConditionInvalid => "TRIGGER_CONDITION_INVALID".to_string(),
            Self::OrderPartialFillOptionMissing => "ORDER_PARTIAL_FILL_OPTION_MISSING".to_string(),
            Self::OrderPartialFillOptionInvalid => "ORDER_PARTIAL_FILL_OPTION_INVALID".to_string(),
            Self::InvalidReissueImmediatePartialFill => {
                "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL".to_string()
            }
            Self::TakeProfitOrderAlreadyExists => "TAKE_PROFIT_ORDER_ALREADY_EXISTS".to_string(),
            Self::TakeProfitOnFillPriceMissing => "TAKE_PROFIT_ON_FILL_PRICE_MISSING".to_string(),
            Self::TakeProfitOnFillPriceInvalid => "TAKE_PROFIT_ON_FILL_PRICE_INVALID".to_string(),
            Self::TakeProfitOnFillPricePrecisionExceeded => {
                "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED".to_string()
            }
            Self::TakeProfitOnFillTimeInForceMissing => {
                "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::TakeProfitOnFillTimeInForceInvalid => {
                "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::TakeProfitOnFillGtdTimestampMissing => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TakeProfitOnFillGtdTimestampInPast => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TakeProfitOnFillClientOrderIdInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::TakeProfitOnFillClientOrderTagInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::TakeProfitOnFillClientOrderCommentInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::TakeProfitOnFillTriggerConditionMissing => {
                "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::TakeProfitOnFillTriggerConditionInvalid => {
                "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::StopLossOrderAlreadyExists => "STOP_LOSS_ORDER_ALREADY_EXISTS".to_string(),
            Self::StopLossOrderGuaranteedRequired => {
                "STOP_LOSS_ORDER_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOrderGuaranteedPriceWithinSpread => {
                "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD".to_string()
            }
            Self::StopLossOrderGuaranteedNotAllowed => {
                "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOrderGuaranteedHaltedCreateViolation => {
                "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION".to_string()
            }
            Self::StopLossOrderGuaranteedHaltedTightenViolation => {
                "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION".to_string()
            }
            Self::StopLossOrderGuaranteedHedgingNotAllowed => {
                "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED".to_string()
            }
            Self::StopLossOrderGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOrderNotCancelable => "STOP_LOSS_ORDER_NOT_CANCELABLE".to_string(),
            Self::StopLossOrderNotReplaceable => "STOP_LOSS_ORDER_NOT_REPLACEABLE".to_string(),
            Self::StopLossOrderGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOrderPriceAndDistanceBothSpecified => {
                "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED".to_string()
            }
            Self::StopLossOrderPriceAndDistanceBothMissing => {
                "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING".to_string()
            }
            Self::StopLossOnFillRequiredForPendingOrder => {
                "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER".to_string()
            }
            Self::StopLossOnFillGuaranteedNotAllowed => {
                "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOnFillGuaranteedRequired => {
                "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOnFillPriceMissing => "STOP_LOSS_ON_FILL_PRICE_MISSING".to_string(),
            Self::StopLossOnFillPriceInvalid => "STOP_LOSS_ON_FILL_PRICE_INVALID".to_string(),
            Self::StopLossOnFillPricePrecisionExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOnFillGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillDistanceInvalid => "STOP_LOSS_ON_FILL_DISTANCE_INVALID".to_string(),
            Self::StopLossOnFillPriceDistanceMaximumExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::StopLossOnFillDistancePrecisionExceeded => {
                "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillPriceAndDistanceBothSpecified => {
                "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED".to_string()
            }
            Self::StopLossOnFillPriceAndDistanceBothMissing => {
                "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING".to_string()
            }
            Self::StopLossOnFillTimeInForceMissing => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::StopLossOnFillTimeInForceInvalid => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::StopLossOnFillGtdTimestampMissing => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::StopLossOnFillGtdTimestampInPast => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::StopLossOnFillClientOrderIdInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::StopLossOnFillClientOrderTagInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::StopLossOnFillClientOrderCommentInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::StopLossOnFillTriggerConditionMissing => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::StopLossOnFillTriggerConditionInvalid => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::TrailingStopLossOrderAlreadyExists => {
                "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistancePrecisionExceeded => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMaximumExceeded => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMinimumNotMet => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET".to_string()
            }
            Self::TrailingStopLossOnFillTimeInForceMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillTimeInForceInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampInPast => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderIdInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderTagInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderCommentInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::TrailingStopLossOrdersNotSupported => {
                "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED".to_string()
            }
            Self::TrailingStopLossOnFillTriggerConditionMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillTriggerConditionInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::CloseTradeTypeMissing => "CLOSE_TRADE_TYPE_MISSING".to_string(),
            Self::CloseTradePartialUnitsMissing => "CLOSE_TRADE_PARTIAL_UNITS_MISSING".to_string(),
            Self::CloseTradeUnitsExceedTradeSize => {
                "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE".to_string()
            }
            Self::CloseoutPositionDoesntExist => "CLOSEOUT_POSITION_DOESNT_EXIST".to_string(),
            Self::CloseoutPositionIncompleteSpecification => {
                "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION".to_string()
            }
            Self::CloseoutPositionUnitsExceedPositionSize => {
                "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE".to_string()
            }
            Self::CloseoutPositionReject => "CLOSEOUT_POSITION_REJECT".to_string(),
            Self::CloseoutPositionPartialUnitsMissing => {
                "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING".to_string()
            }
            Self::MarkupGroupIdInvalid => "MARKUP_GROUP_ID_INVALID".to_string(),
            Self::PositionAggregationModeInvalid => "POSITION_AGGREGATION_MODE_INVALID".to_string(),
            Self::AdminConfigureDataMissing => "ADMIN_CONFIGURE_DATA_MISSING".to_string(),
            Self::MarginRateInvalid => "MARGIN_RATE_INVALID".to_string(),
            Self::MarginRateWouldTriggerCloseout => {
                "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT".to_string()
            }
            Self::AliasInvalid => "ALIAS_INVALID".to_string(),
            Self::ClientConfigureDataMissing => "CLIENT_CONFIGURE_DATA_MISSING".to_string(),
            Self::MarginRateWouldTriggerMarginCall => {
                "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL".to_string()
            }
            Self::AmountInvalid => "AMOUNT_INVALID".to_string(),
            Self::InsufficientFunds => "INSUFFICIENT_FUNDS".to_string(),
            Self::AmountMissing => "AMOUNT_MISSING".to_string(),
            Self::FundingReasonMissing => "FUNDING_REASON_MISSING".to_string(),
            Self::ClientExtensionsDataMissing => "CLIENT_EXTENSIONS_DATA_MISSING".to_string(),
            Self::ReplacingOrderInvalid => "REPLACING_ORDER_INVALID".to_string(),
            Self::ReplacingTradeIdInvalid => "REPLACING_TRADE_ID_INVALID".to_string(),
        }
    }
}

impl std::str::FromStr for StopOrderRejectTransactionRejectReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "INTERNAL_SERVER_ERROR" => Ok(Self::InternalServerError),
            "INSTRUMENT_PRICE_UNKNOWN" => Ok(Self::InstrumentPriceUnknown),
            "ACCOUNT_NOT_ACTIVE" => Ok(Self::AccountNotActive),
            "ACCOUNT_LOCKED" => Ok(Self::AccountLocked),
            "ACCOUNT_ORDER_CREATION_LOCKED" => Ok(Self::AccountOrderCreationLocked),
            "ACCOUNT_CONFIGURATION_LOCKED" => Ok(Self::AccountConfigurationLocked),
            "ACCOUNT_DEPOSIT_LOCKED" => Ok(Self::AccountDepositLocked),
            "ACCOUNT_WITHDRAWAL_LOCKED" => Ok(Self::AccountWithdrawalLocked),
            "ACCOUNT_ORDER_CANCEL_LOCKED" => Ok(Self::AccountOrderCancelLocked),
            "INSTRUMENT_NOT_TRADEABLE" => Ok(Self::InstrumentNotTradeable),
            "PENDING_ORDERS_ALLOWED_EXCEEDED" => Ok(Self::PendingOrdersAllowedExceeded),
            "ORDER_ID_UNSPECIFIED" => Ok(Self::OrderIdUnspecified),
            "ORDER_DOESNT_EXIST" => Ok(Self::OrderDoesntExist),
            "ORDER_IDENTIFIER_INCONSISTENCY" => Ok(Self::OrderIdentifierInconsistency),
            "TRADE_ID_UNSPECIFIED" => Ok(Self::TradeIdUnspecified),
            "TRADE_DOESNT_EXIST" => Ok(Self::TradeDoesntExist),
            "TRADE_IDENTIFIER_INCONSISTENCY" => Ok(Self::TradeIdentifierInconsistency),
            "INSUFFICIENT_MARGIN" => Ok(Self::InsufficientMargin),
            "INSTRUMENT_MISSING" => Ok(Self::InstrumentMissing),
            "INSTRUMENT_UNKNOWN" => Ok(Self::InstrumentUnknown),
            "UNITS_MISSING" => Ok(Self::UnitsMissing),
            "UNITS_INVALID" => Ok(Self::UnitsInvalid),
            "UNITS_PRECISION_EXCEEDED" => Ok(Self::UnitsPrecisionExceeded),
            "UNITS_LIMIT_EXCEEDED" => Ok(Self::UnitsLimitExceeded),
            "UNITS_MIMIMUM_NOT_MET" => Ok(Self::UnitsMimimumNotMet),
            "PRICE_MISSING" => Ok(Self::PriceMissing),
            "PRICE_INVALID" => Ok(Self::PriceInvalid),
            "PRICE_PRECISION_EXCEEDED" => Ok(Self::PricePrecisionExceeded),
            "PRICE_DISTANCE_MISSING" => Ok(Self::PriceDistanceMissing),
            "PRICE_DISTANCE_INVALID" => Ok(Self::PriceDistanceInvalid),
            "PRICE_DISTANCE_PRECISION_EXCEEDED" => Ok(Self::PriceDistancePrecisionExceeded),
            "PRICE_DISTANCE_MAXIMUM_EXCEEDED" => Ok(Self::PriceDistanceMaximumExceeded),
            "PRICE_DISTANCE_MINIMUM_NOT_MET" => Ok(Self::PriceDistanceMinimumNotMet),
            "TIME_IN_FORCE_MISSING" => Ok(Self::TimeInForceMissing),
            "TIME_IN_FORCE_INVALID" => Ok(Self::TimeInForceInvalid),
            "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING" => Ok(Self::TimeInForceGtdTimestampMissing),
            "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST" => Ok(Self::TimeInForceGtdTimestampInPast),
            "PRICE_BOUND_INVALID" => Ok(Self::PriceBoundInvalid),
            "PRICE_BOUND_PRECISION_EXCEEDED" => Ok(Self::PriceBoundPrecisionExceeded),
            "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS" => {
                Ok(Self::OrdersOnFillDuplicateClientOrderIds)
            }
            "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED" => {
                Ok(Self::TradeOnFillClientExtensionsNotSupported)
            }
            "CLIENT_ORDER_ID_INVALID" => Ok(Self::ClientOrderIdInvalid),
            "CLIENT_ORDER_ID_ALREADY_EXISTS" => Ok(Self::ClientOrderIdAlreadyExists),
            "CLIENT_ORDER_TAG_INVALID" => Ok(Self::ClientOrderTagInvalid),
            "CLIENT_ORDER_COMMENT_INVALID" => Ok(Self::ClientOrderCommentInvalid),
            "CLIENT_TRADE_ID_INVALID" => Ok(Self::ClientTradeIdInvalid),
            "CLIENT_TRADE_ID_ALREADY_EXISTS" => Ok(Self::ClientTradeIdAlreadyExists),
            "CLIENT_TRADE_TAG_INVALID" => Ok(Self::ClientTradeTagInvalid),
            "CLIENT_TRADE_COMMENT_INVALID" => Ok(Self::ClientTradeCommentInvalid),
            "ORDER_FILL_POSITION_ACTION_MISSING" => Ok(Self::OrderFillPositionActionMissing),
            "ORDER_FILL_POSITION_ACTION_INVALID" => Ok(Self::OrderFillPositionActionInvalid),
            "TRIGGER_CONDITION_MISSING" => Ok(Self::TriggerConditionMissing),
            "TRIGGER_CONDITION_INVALID" => Ok(Self::TriggerConditionInvalid),
            "ORDER_PARTIAL_FILL_OPTION_MISSING" => Ok(Self::OrderPartialFillOptionMissing),
            "ORDER_PARTIAL_FILL_OPTION_INVALID" => Ok(Self::OrderPartialFillOptionInvalid),
            "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL" => {
                Ok(Self::InvalidReissueImmediatePartialFill)
            }
            "TAKE_PROFIT_ORDER_ALREADY_EXISTS" => Ok(Self::TakeProfitOrderAlreadyExists),
            "TAKE_PROFIT_ON_FILL_PRICE_MISSING" => Ok(Self::TakeProfitOnFillPriceMissing),
            "TAKE_PROFIT_ON_FILL_PRICE_INVALID" => Ok(Self::TakeProfitOnFillPriceInvalid),
            "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(Self::TakeProfitOnFillPricePrecisionExceeded)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(Self::TakeProfitOnFillTimeInForceMissing)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(Self::TakeProfitOnFillTimeInForceInvalid)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::TakeProfitOnFillGtdTimestampMissing)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TakeProfitOnFillGtdTimestampInPast)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderIdInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderTagInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderCommentInvalid)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::TakeProfitOnFillTriggerConditionMissing)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::TakeProfitOnFillTriggerConditionInvalid)
            }
            "STOP_LOSS_ORDER_ALREADY_EXISTS" => Ok(Self::StopLossOrderAlreadyExists),
            "STOP_LOSS_ORDER_GUARANTEED_REQUIRED" => Ok(Self::StopLossOrderGuaranteedRequired),
            "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD" => {
                Ok(Self::StopLossOrderGuaranteedPriceWithinSpread)
            }
            "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED" => Ok(Self::StopLossOrderGuaranteedNotAllowed),
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION" => {
                Ok(Self::StopLossOrderGuaranteedHaltedCreateViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION" => {
                Ok(Self::StopLossOrderGuaranteedHaltedTightenViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED" => {
                Ok(Self::StopLossOrderGuaranteedHedgingNotAllowed)
            }
            "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOrderGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ORDER_NOT_CANCELABLE" => Ok(Self::StopLossOrderNotCancelable),
            "STOP_LOSS_ORDER_NOT_REPLACEABLE" => Ok(Self::StopLossOrderNotReplaceable),
            "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOrderGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(Self::StopLossOrderPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(Self::StopLossOrderPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER" => {
                Ok(Self::StopLossOnFillRequiredForPendingOrder)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED" => {
                Ok(Self::StopLossOnFillGuaranteedNotAllowed)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED" => Ok(Self::StopLossOnFillGuaranteedRequired),
            "STOP_LOSS_ON_FILL_PRICE_MISSING" => Ok(Self::StopLossOnFillPriceMissing),
            "STOP_LOSS_ON_FILL_PRICE_INVALID" => Ok(Self::StopLossOnFillPriceInvalid),
            "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(Self::StopLossOnFillPricePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOnFillGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOnFillGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_INVALID" => Ok(Self::StopLossOnFillDistanceInvalid),
            "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::StopLossOnFillPriceDistanceMaximumExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(Self::StopLossOnFillDistancePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(Self::StopLossOnFillPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(Self::StopLossOnFillPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => Ok(Self::StopLossOnFillTimeInForceMissing),
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => Ok(Self::StopLossOnFillTimeInForceInvalid),
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::StopLossOnFillGtdTimestampMissing)
            }
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => Ok(Self::StopLossOnFillGtdTimestampInPast),
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderIdInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderTagInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderCommentInvalid)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::StopLossOnFillTriggerConditionMissing)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::StopLossOnFillTriggerConditionInvalid)
            }
            "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS" => {
                Ok(Self::TrailingStopLossOrderAlreadyExists)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(Self::TrailingStopLossOnFillPriceDistancePrecisionExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMaximumExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMinimumNotMet)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(Self::TrailingStopLossOnFillTimeInForceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(Self::TrailingStopLossOnFillTimeInForceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampInPast)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderIdInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderTagInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderCommentInvalid)
            }
            "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED" => {
                Ok(Self::TrailingStopLossOrdersNotSupported)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::TrailingStopLossOnFillTriggerConditionMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::TrailingStopLossOnFillTriggerConditionInvalid)
            }
            "CLOSE_TRADE_TYPE_MISSING" => Ok(Self::CloseTradeTypeMissing),
            "CLOSE_TRADE_PARTIAL_UNITS_MISSING" => Ok(Self::CloseTradePartialUnitsMissing),
            "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE" => Ok(Self::CloseTradeUnitsExceedTradeSize),
            "CLOSEOUT_POSITION_DOESNT_EXIST" => Ok(Self::CloseoutPositionDoesntExist),
            "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION" => {
                Ok(Self::CloseoutPositionIncompleteSpecification)
            }
            "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE" => {
                Ok(Self::CloseoutPositionUnitsExceedPositionSize)
            }
            "CLOSEOUT_POSITION_REJECT" => Ok(Self::CloseoutPositionReject),
            "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING" => {
                Ok(Self::CloseoutPositionPartialUnitsMissing)
            }
            "MARKUP_GROUP_ID_INVALID" => Ok(Self::MarkupGroupIdInvalid),
            "POSITION_AGGREGATION_MODE_INVALID" => Ok(Self::PositionAggregationModeInvalid),
            "ADMIN_CONFIGURE_DATA_MISSING" => Ok(Self::AdminConfigureDataMissing),
            "MARGIN_RATE_INVALID" => Ok(Self::MarginRateInvalid),
            "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT" => Ok(Self::MarginRateWouldTriggerCloseout),
            "ALIAS_INVALID" => Ok(Self::AliasInvalid),
            "CLIENT_CONFIGURE_DATA_MISSING" => Ok(Self::ClientConfigureDataMissing),
            "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL" => Ok(Self::MarginRateWouldTriggerMarginCall),
            "AMOUNT_INVALID" => Ok(Self::AmountInvalid),
            "INSUFFICIENT_FUNDS" => Ok(Self::InsufficientFunds),
            "AMOUNT_MISSING" => Ok(Self::AmountMissing),
            "FUNDING_REASON_MISSING" => Ok(Self::FundingReasonMissing),
            "CLIENT_EXTENSIONS_DATA_MISSING" => Ok(Self::ClientExtensionsDataMissing),
            "REPLACING_ORDER_INVALID" => Ok(Self::ReplacingOrderInvalid),
            "REPLACING_TRADE_ID_INVALID" => Ok(Self::ReplacingTradeIdInvalid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopOrderRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopOrderRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopOrderRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The time-in-force requested for the Stop Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the Stop Order.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopOrderRejectTransactionTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&StopOrderRejectTransactionTimeInForce> for StopOrderRejectTransactionTimeInForce {
    fn from(value: &StopOrderRejectTransactionTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for StopOrderRejectTransactionTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for StopOrderRejectTransactionTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopOrderRejectTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopOrderRejectTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopOrderRejectTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///Specification of which price component should be used when determining
/// if an Order should be triggered and filled. This allows Orders to be
/// triggered based on the bid, ask, mid, default (ask for buy, bid for
/// sell) or inverse (ask for sell, bid for buy) price depending on the
/// desired behaviour. Orders are always filled using their default price
/// component. This feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order. A special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
/// results in. So for a Stop Loss Order for a long trade valid values are
/// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are valid.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of which price component should be used
/// when determining if an Order should be triggered and filled. This allows
/// Orders to be triggered based on the bid, ask, mid, default (ask for buy,
/// bid for sell) or inverse (ask for sell, bid for buy) price depending on
/// the desired behaviour. Orders are always filled using their default
/// price component.\nThis feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///  "type": "string",
///  "enum": [
///    "DEFAULT",
///    "INVERSE",
///    "BID",
///    "ASK",
///    "MID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopOrderRejectTransactionTriggerCondition {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "INVERSE")]
    Inverse,
    #[serde(rename = "BID")]
    Bid,
    #[serde(rename = "ASK")]
    Ask,
    #[serde(rename = "MID")]
    Mid,
}

impl From<&StopOrderRejectTransactionTriggerCondition>
    for StopOrderRejectTransactionTriggerCondition
{
    fn from(value: &StopOrderRejectTransactionTriggerCondition) -> Self {
        value.clone()
    }
}

impl ToString for StopOrderRejectTransactionTriggerCondition {
    fn to_string(&self) -> String {
        match *self {
            Self::Default => "DEFAULT".to_string(),
            Self::Inverse => "INVERSE".to_string(),
            Self::Bid => "BID".to_string(),
            Self::Ask => "ASK".to_string(),
            Self::Mid => "MID".to_string(),
        }
    }
}

impl std::str::FromStr for StopOrderRejectTransactionTriggerCondition {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DEFAULT" => Ok(Self::Default),
            "INVERSE" => Ok(Self::Inverse),
            "BID" => Ok(Self::Bid),
            "ASK" => Ok(Self::Ask),
            "MID" => Ok(Self::Mid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopOrderRejectTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopOrderRejectTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopOrderRejectTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Type of the Transaction. Always set to "STOP_ORDER_REJECT" in a
/// StopOrderRejectTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"STOP_ORDER_REJECT\" in a StopOrderRejectTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopOrderRejectTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&StopOrderRejectTransactionType> for StopOrderRejectTransactionType {
    fn from(value: &StopOrderRejectTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for StopOrderRejectTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for StopOrderRejectTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopOrderRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopOrderRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopOrderRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A StopOrderRequest specifies the parameters that may be set when
/// creating a Stop Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A StopOrderRequest specifies the parameters that may be
/// set when creating a Stop Order.",
///  "type": "object",
///  "properties": {
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "gtdTime": {
///      "description": "The date/time when the Stop Order will be cancelled
/// if its timeInForce is \"GTD\".",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "instrument": {
///      "description": "The Stop Order's Instrument.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "positionFill": {
///      "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///      "type": "string",
///      "enum": [
///        "OPEN_ONLY",
///        "REDUCE_FIRST",
///        "REDUCE_ONLY",
///        "DEFAULT"
///      ]
///    },
///    "price": {
///      "description": "The price threshold specified for the Stop Order.
/// The Stop Order will only be filled by a market price that is equal to or
/// worse than this price.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "priceBound": {
///      "description": "The worst market price that may be used to fill
/// this Stop Order. If the market gaps and crosses through both the price
/// and the priceBound, the Stop Order will be cancelled instead of being
/// filled.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "stopLossOnFill": {
///      "$ref": "#/components/schemas/StopLossDetails"
///    },
///    "takeProfitOnFill": {
///      "$ref": "#/components/schemas/TakeProfitDetails"
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the Stop Order.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeClientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "trailingStopLossOnFill": {
///      "$ref": "#/components/schemas/TrailingStopLossDetails"
///    },
///    "triggerCondition": {
///      "description": "Specification of which price component should be
/// used when determining if an Order should be triggered and filled. This
/// allows Orders to be triggered based on the bid, ask, mid, default (ask
/// for buy, bid for sell) or inverse (ask for sell, bid for buy) price
/// depending on the desired behaviour. Orders are always filled using their
/// default price component.\nThis feature is only provided through the REST
/// API. Clients who choose to specify a non-default trigger condition will
/// not see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///      "type": "string",
///      "enum": [
///        "DEFAULT",
///        "INVERSE",
///        "BID",
///        "ASK",
///        "MID"
///      ]
///    },
///    "type": {
///      "description": "The type of the Order to Create. Must be set to
/// \"STOP\" when creating a Stop Order.",
///      "type": "string",
///      "enum": [
///        "MARKET",
///        "LIMIT",
///        "STOP",
///        "MARKET_IF_TOUCHED",
///        "TAKE_PROFIT",
///        "STOP_LOSS",
///        "TRAILING_STOP_LOSS",
///        "FIXED_PRICE"
///      ]
///    },
///    "units": {
///      "description": "The quantity requested to be filled by the Stop
/// Order. A posititive number of units results in a long Order, and a
/// negative number of units results in a short Order.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StopOrderRequest {
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The date/time when the Stop Order will be cancelled if its
    /// timeInForce is "GTD".
    #[serde(rename = "gtdTime", default, skip_serializing_if = "Option::is_none")]
    pub gtd_time: Option<String>,
    ///The Stop Order's Instrument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    ///Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(
        rename = "positionFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub position_fill: Option<StopOrderRequestPositionFill>,
    ///The price threshold specified for the Stop Order. The Stop Order
    /// will only be filled by a market price that is equal to or worse than
    /// this price.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The worst market price that may be used to fill this Stop Order. If
    /// the market gaps and crosses through both the price and the
    /// priceBound, the Stop Order will be cancelled instead of being
    /// filled.
    #[serde(
        rename = "priceBound",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub price_bound: Option<String>,
    #[serde(
        rename = "stopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stop_loss_on_fill: Option<StopLossDetails>,
    #[serde(
        rename = "takeProfitOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub take_profit_on_fill: Option<TakeProfitDetails>,
    ///The time-in-force requested for the Stop Order.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<StopOrderRequestTimeInForce>,
    #[serde(
        rename = "tradeClientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,
    #[serde(
        rename = "trailingStopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,
    ///Specification of which price component should be used when
    /// determining if an Order should be triggered and filled. This allows
    /// Orders to be triggered based on the bid, ask, mid, default (ask for
    /// buy, bid for sell) or inverse (ask for sell, bid for buy) price
    /// depending on the desired behaviour. Orders are always filled using
    /// their default price component. This feature is only provided
    /// through the REST API. Clients who choose to specify a non-default
    /// trigger condition will not see it reflected in any of OANDA's
    /// proprietary or partner trading platforms, their transaction history
    /// or their account statements. OANDA platforms always assume that an
    /// Order's trigger condition is set to the default value when
    /// indicating the distance from an Order's trigger price, and will
    /// always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when
    /// creating a guaranteed Stop Loss Order. In this case the
    /// TriggerCondition value must either be "DEFAULT", or the "natural"
    /// trigger side "DEFAULT" results in. So for a Stop Loss Order for a
    /// long trade valid values are "DEFAULT" and "BID", and for short
    /// trades "DEFAULT" and "ASK" are valid.
    #[serde(
        rename = "triggerCondition",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trigger_condition: Option<StopOrderRequestTriggerCondition>,
    ///The type of the Order to Create. Must be set to "STOP" when creating
    /// a Stop Order.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<StopOrderRequestType>,
    ///The quantity requested to be filled by the Stop Order. A posititive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<String>,
}

impl From<&StopOrderRequest> for StopOrderRequest {
    fn from(value: &StopOrderRequest) -> Self {
        value.clone()
    }
}

impl StopOrderRequest {
    pub fn builder() -> builder::StopOrderRequest {
        Default::default()
    }
}

///Specification of how Positions in the Account are modified when the
/// Order is filled.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///  "type": "string",
///  "enum": [
///    "OPEN_ONLY",
///    "REDUCE_FIRST",
///    "REDUCE_ONLY",
///    "DEFAULT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopOrderRequestPositionFill {
    #[serde(rename = "OPEN_ONLY")]
    OpenOnly,
    #[serde(rename = "REDUCE_FIRST")]
    ReduceFirst,
    #[serde(rename = "REDUCE_ONLY")]
    ReduceOnly,
    #[serde(rename = "DEFAULT")]
    Default,
}

impl From<&StopOrderRequestPositionFill> for StopOrderRequestPositionFill {
    fn from(value: &StopOrderRequestPositionFill) -> Self {
        value.clone()
    }
}

impl ToString for StopOrderRequestPositionFill {
    fn to_string(&self) -> String {
        match *self {
            Self::OpenOnly => "OPEN_ONLY".to_string(),
            Self::ReduceFirst => "REDUCE_FIRST".to_string(),
            Self::ReduceOnly => "REDUCE_ONLY".to_string(),
            Self::Default => "DEFAULT".to_string(),
        }
    }
}

impl std::str::FromStr for StopOrderRequestPositionFill {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "OPEN_ONLY" => Ok(Self::OpenOnly),
            "REDUCE_FIRST" => Ok(Self::ReduceFirst),
            "REDUCE_ONLY" => Ok(Self::ReduceOnly),
            "DEFAULT" => Ok(Self::Default),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopOrderRequestPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopOrderRequestPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopOrderRequestPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The time-in-force requested for the Stop Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the Stop Order.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopOrderRequestTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&StopOrderRequestTimeInForce> for StopOrderRequestTimeInForce {
    fn from(value: &StopOrderRequestTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for StopOrderRequestTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for StopOrderRequestTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopOrderRequestTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopOrderRequestTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopOrderRequestTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///Specification of which price component should be used when determining
/// if an Order should be triggered and filled. This allows Orders to be
/// triggered based on the bid, ask, mid, default (ask for buy, bid for
/// sell) or inverse (ask for sell, bid for buy) price depending on the
/// desired behaviour. Orders are always filled using their default price
/// component. This feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order. A special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
/// results in. So for a Stop Loss Order for a long trade valid values are
/// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are valid.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of which price component should be used
/// when determining if an Order should be triggered and filled. This allows
/// Orders to be triggered based on the bid, ask, mid, default (ask for buy,
/// bid for sell) or inverse (ask for sell, bid for buy) price depending on
/// the desired behaviour. Orders are always filled using their default
/// price component.\nThis feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///  "type": "string",
///  "enum": [
///    "DEFAULT",
///    "INVERSE",
///    "BID",
///    "ASK",
///    "MID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopOrderRequestTriggerCondition {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "INVERSE")]
    Inverse,
    #[serde(rename = "BID")]
    Bid,
    #[serde(rename = "ASK")]
    Ask,
    #[serde(rename = "MID")]
    Mid,
}

impl From<&StopOrderRequestTriggerCondition> for StopOrderRequestTriggerCondition {
    fn from(value: &StopOrderRequestTriggerCondition) -> Self {
        value.clone()
    }
}

impl ToString for StopOrderRequestTriggerCondition {
    fn to_string(&self) -> String {
        match *self {
            Self::Default => "DEFAULT".to_string(),
            Self::Inverse => "INVERSE".to_string(),
            Self::Bid => "BID".to_string(),
            Self::Ask => "ASK".to_string(),
            Self::Mid => "MID".to_string(),
        }
    }
}

impl std::str::FromStr for StopOrderRequestTriggerCondition {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DEFAULT" => Ok(Self::Default),
            "INVERSE" => Ok(Self::Inverse),
            "BID" => Ok(Self::Bid),
            "ASK" => Ok(Self::Ask),
            "MID" => Ok(Self::Mid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopOrderRequestTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopOrderRequestTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopOrderRequestTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The type of the Order to Create. Must be set to "STOP" when creating a
/// Stop Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The type of the Order to Create. Must be set to
/// \"STOP\" when creating a Stop Order.",
///  "type": "string",
///  "enum": [
///    "MARKET",
///    "LIMIT",
///    "STOP",
///    "MARKET_IF_TOUCHED",
///    "TAKE_PROFIT",
///    "STOP_LOSS",
///    "TRAILING_STOP_LOSS",
///    "FIXED_PRICE"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopOrderRequestType {
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "STOP")]
    Stop,
    #[serde(rename = "MARKET_IF_TOUCHED")]
    MarketIfTouched,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "STOP_LOSS")]
    StopLoss,
    #[serde(rename = "TRAILING_STOP_LOSS")]
    TrailingStopLoss,
    #[serde(rename = "FIXED_PRICE")]
    FixedPrice,
}

impl From<&StopOrderRequestType> for StopOrderRequestType {
    fn from(value: &StopOrderRequestType) -> Self {
        value.clone()
    }
}

impl ToString for StopOrderRequestType {
    fn to_string(&self) -> String {
        match *self {
            Self::Market => "MARKET".to_string(),
            Self::Limit => "LIMIT".to_string(),
            Self::Stop => "STOP".to_string(),
            Self::MarketIfTouched => "MARKET_IF_TOUCHED".to_string(),
            Self::TakeProfit => "TAKE_PROFIT".to_string(),
            Self::StopLoss => "STOP_LOSS".to_string(),
            Self::TrailingStopLoss => "TRAILING_STOP_LOSS".to_string(),
            Self::FixedPrice => "FIXED_PRICE".to_string(),
        }
    }
}

impl std::str::FromStr for StopOrderRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "MARKET" => Ok(Self::Market),
            "LIMIT" => Ok(Self::Limit),
            "STOP" => Ok(Self::Stop),
            "MARKET_IF_TOUCHED" => Ok(Self::MarketIfTouched),
            "TAKE_PROFIT" => Ok(Self::TakeProfit),
            "STOP_LOSS" => Ok(Self::StopLoss),
            "TRAILING_STOP_LOSS" => Ok(Self::TrailingStopLoss),
            "FIXED_PRICE" => Ok(Self::FixedPrice),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopOrderRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopOrderRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopOrderRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The current state of the Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The current state of the Order.",
///  "type": "string",
///  "enum": [
///    "PENDING",
///    "FILLED",
///    "TRIGGERED",
///    "CANCELLED"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopOrderState {
    #[serde(rename = "PENDING")]
    Pending,
    #[serde(rename = "FILLED")]
    Filled,
    #[serde(rename = "TRIGGERED")]
    Triggered,
    #[serde(rename = "CANCELLED")]
    Cancelled,
}

impl From<&StopOrderState> for StopOrderState {
    fn from(value: &StopOrderState) -> Self {
        value.clone()
    }
}

impl ToString for StopOrderState {
    fn to_string(&self) -> String {
        match *self {
            Self::Pending => "PENDING".to_string(),
            Self::Filled => "FILLED".to_string(),
            Self::Triggered => "TRIGGERED".to_string(),
            Self::Cancelled => "CANCELLED".to_string(),
        }
    }
}

impl std::str::FromStr for StopOrderState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "PENDING" => Ok(Self::Pending),
            "FILLED" => Ok(Self::Filled),
            "TRIGGERED" => Ok(Self::Triggered),
            "CANCELLED" => Ok(Self::Cancelled),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopOrderState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopOrderState {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopOrderState {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The time-in-force requested for the Stop Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the Stop Order.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopOrderTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&StopOrderTimeInForce> for StopOrderTimeInForce {
    fn from(value: &StopOrderTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for StopOrderTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for StopOrderTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopOrderTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopOrderTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopOrderTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A StopOrderTransaction represents the creation of a Stop Order in the
/// user's Account.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A StopOrderTransaction represents the creation of a
/// Stop Order in the user's Account.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "cancellingTransactionID": {
///      "description": "The ID of the Transaction that cancels the replaced
/// Order (only provided if this Order replaces an existing Order).",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "gtdTime": {
///      "description": "The date/time when the Stop Order will be cancelled
/// if its timeInForce is \"GTD\".",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "instrument": {
///      "description": "The Stop Order's Instrument.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "positionFill": {
///      "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///      "type": "string",
///      "enum": [
///        "OPEN_ONLY",
///        "REDUCE_FIRST",
///        "REDUCE_ONLY",
///        "DEFAULT"
///      ]
///    },
///    "price": {
///      "description": "The price threshold specified for the Stop Order.
/// The Stop Order will only be filled by a market price that is equal to or
/// worse than this price.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "priceBound": {
///      "description": "The worst market price that may be used to fill
/// this Stop Order. If the market gaps and crosses through both the price
/// and the priceBound, the Stop Order will be cancelled instead of being
/// filled.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "reason": {
///      "description": "The reason that the Stop Order was initiated",
///      "type": "string",
///      "enum": [
///        "CLIENT_ORDER",
///        "REPLACEMENT"
///      ]
///    },
///    "replacesOrderID": {
///      "description": "The ID of the Order that this Order replaces (only
/// provided if this Order replaces an existing Order).",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "stopLossOnFill": {
///      "$ref": "#/components/schemas/StopLossDetails"
///    },
///    "takeProfitOnFill": {
///      "$ref": "#/components/schemas/TakeProfitDetails"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the Stop Order.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeClientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "trailingStopLossOnFill": {
///      "$ref": "#/components/schemas/TrailingStopLossDetails"
///    },
///    "triggerCondition": {
///      "description": "Specification of which price component should be
/// used when determining if an Order should be triggered and filled. This
/// allows Orders to be triggered based on the bid, ask, mid, default (ask
/// for buy, bid for sell) or inverse (ask for sell, bid for buy) price
/// depending on the desired behaviour. Orders are always filled using their
/// default price component.\nThis feature is only provided through the REST
/// API. Clients who choose to specify a non-default trigger condition will
/// not see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///      "type": "string",
///      "enum": [
///        "DEFAULT",
///        "INVERSE",
///        "BID",
///        "ASK",
///        "MID"
///      ]
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"STOP_ORDER\" in a StopOrderTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "units": {
///      "description": "The quantity requested to be filled by the Stop
/// Order. A posititive number of units results in a long Order, and a
/// negative number of units results in a short Order.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StopOrderTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    ///The ID of the Transaction that cancels the replaced Order (only
    /// provided if this Order replaces an existing Order).
    #[serde(
        rename = "cancellingTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The date/time when the Stop Order will be cancelled if its
    /// timeInForce is "GTD".
    #[serde(rename = "gtdTime", default, skip_serializing_if = "Option::is_none")]
    pub gtd_time: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The Stop Order's Instrument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    ///Specification of how Positions in the Account are modified when the
    /// Order is filled.
    #[serde(
        rename = "positionFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub position_fill: Option<StopOrderTransactionPositionFill>,
    ///The price threshold specified for the Stop Order. The Stop Order
    /// will only be filled by a market price that is equal to or worse than
    /// this price.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The worst market price that may be used to fill this Stop Order. If
    /// the market gaps and crosses through both the price and the
    /// priceBound, the Stop Order will be cancelled instead of being
    /// filled.
    #[serde(
        rename = "priceBound",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub price_bound: Option<String>,
    ///The reason that the Stop Order was initiated
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<StopOrderTransactionReason>,
    ///The ID of the Order that this Order replaces (only provided if this
    /// Order replaces an existing Order).
    #[serde(
        rename = "replacesOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub replaces_order_id: Option<String>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    #[serde(
        rename = "stopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stop_loss_on_fill: Option<StopLossDetails>,
    #[serde(
        rename = "takeProfitOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub take_profit_on_fill: Option<TakeProfitDetails>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The time-in-force requested for the Stop Order.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<StopOrderTransactionTimeInForce>,
    #[serde(
        rename = "tradeClientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions: Option<ClientExtensions>,
    #[serde(
        rename = "trailingStopLossOnFill",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_on_fill: Option<TrailingStopLossDetails>,
    ///Specification of which price component should be used when
    /// determining if an Order should be triggered and filled. This allows
    /// Orders to be triggered based on the bid, ask, mid, default (ask for
    /// buy, bid for sell) or inverse (ask for sell, bid for buy) price
    /// depending on the desired behaviour. Orders are always filled using
    /// their default price component. This feature is only provided
    /// through the REST API. Clients who choose to specify a non-default
    /// trigger condition will not see it reflected in any of OANDA's
    /// proprietary or partner trading platforms, their transaction history
    /// or their account statements. OANDA platforms always assume that an
    /// Order's trigger condition is set to the default value when
    /// indicating the distance from an Order's trigger price, and will
    /// always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when
    /// creating a guaranteed Stop Loss Order. In this case the
    /// TriggerCondition value must either be "DEFAULT", or the "natural"
    /// trigger side "DEFAULT" results in. So for a Stop Loss Order for a
    /// long trade valid values are "DEFAULT" and "BID", and for short
    /// trades "DEFAULT" and "ASK" are valid.
    #[serde(
        rename = "triggerCondition",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trigger_condition: Option<StopOrderTransactionTriggerCondition>,
    ///The Type of the Transaction. Always set to "STOP_ORDER" in a
    /// StopOrderTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<StopOrderTransactionType>,
    ///The quantity requested to be filled by the Stop Order. A posititive
    /// number of units results in a long Order, and a negative number of
    /// units results in a short Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<String>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&StopOrderTransaction> for StopOrderTransaction {
    fn from(value: &StopOrderTransaction) -> Self {
        value.clone()
    }
}

impl StopOrderTransaction {
    pub fn builder() -> builder::StopOrderTransaction {
        Default::default()
    }
}

///Specification of how Positions in the Account are modified when the
/// Order is filled.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of how Positions in the Account are
/// modified when the Order is filled.",
///  "type": "string",
///  "enum": [
///    "OPEN_ONLY",
///    "REDUCE_FIRST",
///    "REDUCE_ONLY",
///    "DEFAULT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopOrderTransactionPositionFill {
    #[serde(rename = "OPEN_ONLY")]
    OpenOnly,
    #[serde(rename = "REDUCE_FIRST")]
    ReduceFirst,
    #[serde(rename = "REDUCE_ONLY")]
    ReduceOnly,
    #[serde(rename = "DEFAULT")]
    Default,
}

impl From<&StopOrderTransactionPositionFill> for StopOrderTransactionPositionFill {
    fn from(value: &StopOrderTransactionPositionFill) -> Self {
        value.clone()
    }
}

impl ToString for StopOrderTransactionPositionFill {
    fn to_string(&self) -> String {
        match *self {
            Self::OpenOnly => "OPEN_ONLY".to_string(),
            Self::ReduceFirst => "REDUCE_FIRST".to_string(),
            Self::ReduceOnly => "REDUCE_ONLY".to_string(),
            Self::Default => "DEFAULT".to_string(),
        }
    }
}

impl std::str::FromStr for StopOrderTransactionPositionFill {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "OPEN_ONLY" => Ok(Self::OpenOnly),
            "REDUCE_FIRST" => Ok(Self::ReduceFirst),
            "REDUCE_ONLY" => Ok(Self::ReduceOnly),
            "DEFAULT" => Ok(Self::Default),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopOrderTransactionPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopOrderTransactionPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopOrderTransactionPositionFill {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The reason that the Stop Order was initiated
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Stop Order was initiated",
///  "type": "string",
///  "enum": [
///    "CLIENT_ORDER",
///    "REPLACEMENT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopOrderTransactionReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "REPLACEMENT")]
    Replacement,
}

impl From<&StopOrderTransactionReason> for StopOrderTransactionReason {
    fn from(value: &StopOrderTransactionReason) -> Self {
        value.clone()
    }
}

impl ToString for StopOrderTransactionReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ClientOrder => "CLIENT_ORDER".to_string(),
            Self::Replacement => "REPLACEMENT".to_string(),
        }
    }
}

impl std::str::FromStr for StopOrderTransactionReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CLIENT_ORDER" => Ok(Self::ClientOrder),
            "REPLACEMENT" => Ok(Self::Replacement),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopOrderTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopOrderTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopOrderTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The time-in-force requested for the Stop Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the Stop Order.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopOrderTransactionTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&StopOrderTransactionTimeInForce> for StopOrderTransactionTimeInForce {
    fn from(value: &StopOrderTransactionTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for StopOrderTransactionTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for StopOrderTransactionTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopOrderTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopOrderTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopOrderTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///Specification of which price component should be used when determining
/// if an Order should be triggered and filled. This allows Orders to be
/// triggered based on the bid, ask, mid, default (ask for buy, bid for
/// sell) or inverse (ask for sell, bid for buy) price depending on the
/// desired behaviour. Orders are always filled using their default price
/// component. This feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order. A special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
/// results in. So for a Stop Loss Order for a long trade valid values are
/// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are valid.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of which price component should be used
/// when determining if an Order should be triggered and filled. This allows
/// Orders to be triggered based on the bid, ask, mid, default (ask for buy,
/// bid for sell) or inverse (ask for sell, bid for buy) price depending on
/// the desired behaviour. Orders are always filled using their default
/// price component.\nThis feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///  "type": "string",
///  "enum": [
///    "DEFAULT",
///    "INVERSE",
///    "BID",
///    "ASK",
///    "MID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopOrderTransactionTriggerCondition {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "INVERSE")]
    Inverse,
    #[serde(rename = "BID")]
    Bid,
    #[serde(rename = "ASK")]
    Ask,
    #[serde(rename = "MID")]
    Mid,
}

impl From<&StopOrderTransactionTriggerCondition> for StopOrderTransactionTriggerCondition {
    fn from(value: &StopOrderTransactionTriggerCondition) -> Self {
        value.clone()
    }
}

impl ToString for StopOrderTransactionTriggerCondition {
    fn to_string(&self) -> String {
        match *self {
            Self::Default => "DEFAULT".to_string(),
            Self::Inverse => "INVERSE".to_string(),
            Self::Bid => "BID".to_string(),
            Self::Ask => "ASK".to_string(),
            Self::Mid => "MID".to_string(),
        }
    }
}

impl std::str::FromStr for StopOrderTransactionTriggerCondition {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DEFAULT" => Ok(Self::Default),
            "INVERSE" => Ok(Self::Inverse),
            "BID" => Ok(Self::Bid),
            "ASK" => Ok(Self::Ask),
            "MID" => Ok(Self::Mid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopOrderTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopOrderTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopOrderTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Type of the Transaction. Always set to "STOP_ORDER" in a
/// StopOrderTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"STOP_ORDER\" in a StopOrderTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopOrderTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&StopOrderTransactionType> for StopOrderTransactionType {
    fn from(value: &StopOrderTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for StopOrderTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for StopOrderTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopOrderTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopOrderTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopOrderTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///Specification of which price component should be used when determining
/// if an Order should be triggered and filled. This allows Orders to be
/// triggered based on the bid, ask, mid, default (ask for buy, bid for
/// sell) or inverse (ask for sell, bid for buy) price depending on the
/// desired behaviour. Orders are always filled using their default price
/// component. This feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order. A special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
/// results in. So for a Stop Loss Order for a long trade valid values are
/// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are valid.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of which price component should be used
/// when determining if an Order should be triggered and filled. This allows
/// Orders to be triggered based on the bid, ask, mid, default (ask for buy,
/// bid for sell) or inverse (ask for sell, bid for buy) price depending on
/// the desired behaviour. Orders are always filled using their default
/// price component.\nThis feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///  "type": "string",
///  "enum": [
///    "DEFAULT",
///    "INVERSE",
///    "BID",
///    "ASK",
///    "MID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopOrderTriggerCondition {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "INVERSE")]
    Inverse,
    #[serde(rename = "BID")]
    Bid,
    #[serde(rename = "ASK")]
    Ask,
    #[serde(rename = "MID")]
    Mid,
}

impl From<&StopOrderTriggerCondition> for StopOrderTriggerCondition {
    fn from(value: &StopOrderTriggerCondition) -> Self {
        value.clone()
    }
}

impl ToString for StopOrderTriggerCondition {
    fn to_string(&self) -> String {
        match *self {
            Self::Default => "DEFAULT".to_string(),
            Self::Inverse => "INVERSE".to_string(),
            Self::Bid => "BID".to_string(),
            Self::Ask => "ASK".to_string(),
            Self::Mid => "MID".to_string(),
        }
    }
}

impl std::str::FromStr for StopOrderTriggerCondition {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DEFAULT" => Ok(Self::Default),
            "INVERSE" => Ok(Self::Inverse),
            "BID" => Ok(Self::Bid),
            "ASK" => Ok(Self::Ask),
            "MID" => Ok(Self::Mid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopOrderTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopOrderTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopOrderTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The type of the Order. Always set to "STOP" for Stop Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The type of the Order. Always set to \"STOP\" for Stop
/// Orders.",
///  "type": "string",
///  "enum": [
///    "MARKET",
///    "LIMIT",
///    "STOP",
///    "MARKET_IF_TOUCHED",
///    "TAKE_PROFIT",
///    "STOP_LOSS",
///    "TRAILING_STOP_LOSS",
///    "FIXED_PRICE"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StopOrderType {
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "STOP")]
    Stop,
    #[serde(rename = "MARKET_IF_TOUCHED")]
    MarketIfTouched,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "STOP_LOSS")]
    StopLoss,
    #[serde(rename = "TRAILING_STOP_LOSS")]
    TrailingStopLoss,
    #[serde(rename = "FIXED_PRICE")]
    FixedPrice,
}

impl From<&StopOrderType> for StopOrderType {
    fn from(value: &StopOrderType) -> Self {
        value.clone()
    }
}

impl ToString for StopOrderType {
    fn to_string(&self) -> String {
        match *self {
            Self::Market => "MARKET".to_string(),
            Self::Limit => "LIMIT".to_string(),
            Self::Stop => "STOP".to_string(),
            Self::MarketIfTouched => "MARKET_IF_TOUCHED".to_string(),
            Self::TakeProfit => "TAKE_PROFIT".to_string(),
            Self::StopLoss => "STOP_LOSS".to_string(),
            Self::TrailingStopLoss => "TRAILING_STOP_LOSS".to_string(),
            Self::FixedPrice => "FIXED_PRICE".to_string(),
        }
    }
}

impl std::str::FromStr for StopOrderType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "MARKET" => Ok(Self::Market),
            "LIMIT" => Ok(Self::Limit),
            "STOP" => Ok(Self::Stop),
            "MARKET_IF_TOUCHED" => Ok(Self::MarketIfTouched),
            "TAKE_PROFIT" => Ok(Self::TakeProfit),
            "STOP_LOSS" => Ok(Self::StopLoss),
            "TRAILING_STOP_LOSS" => Ok(Self::TrailingStopLoss),
            "FIXED_PRICE" => Ok(Self::FixedPrice),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for StopOrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for StopOrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for StopOrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The response body for the Pricing Stream uses chunked transfer encoding.
/// Each chunk contains Price and/or PricingHeartbeat objects encoded as
/// JSON.  Each JSON object is serialized into a single line of text, and
/// multiple objects found in the same chunk are separated by newlines.
/// Heartbeats are sent every 5 seconds.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The response body for the Pricing Stream uses chunked
/// transfer encoding.  Each chunk contains Price and/or PricingHeartbeat
/// objects encoded as JSON.  Each JSON object is serialized into a single
/// line of text, and multiple objects found in the same chunk are separated
/// by newlines.\nHeartbeats are sent every 5 seconds.",
///  "type": "object",
///  "properties": {
///    "heartbeat": {
///      "$ref": "#/components/schemas/PricingHeartbeat"
///    },
///    "price": {
///      "$ref": "#/components/schemas/ClientPrice"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StreamPricingResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub heartbeat: Option<PricingHeartbeat>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<ClientPrice>,
}

impl From<&StreamPricingResponse> for StreamPricingResponse {
    fn from(value: &StreamPricingResponse) -> Self {
        value.clone()
    }
}

impl StreamPricingResponse {
    pub fn builder() -> builder::StreamPricingResponse {
        Default::default()
    }
}

///The response body for the Transaction Stream uses chunked transfer
/// encoding.  Each chunk contains Transaction and/or TransactionHeartbeat
/// objects encoded as JSON.  Each JSON object is serialized into a single
/// line of text, and multiple objects found in the same chunk are separated
/// by newlines. TransactionHeartbeats are sent every 5 seconds.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The response body for the Transaction Stream uses
/// chunked transfer encoding.  Each chunk contains Transaction and/or
/// TransactionHeartbeat objects encoded as JSON.  Each JSON object is
/// serialized into a single line of text, and multiple objects found in the
/// same chunk are separated by newlines.\nTransactionHeartbeats are sent
/// every 5 seconds.",
///  "type": "object",
///  "properties": {
///    "heartbeat": {
///      "$ref": "#/components/schemas/TransactionHeartbeat"
///    },
///    "transaction": {
///      "$ref": "#/components/schemas/Transaction"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StreamTransactionsResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub heartbeat: Option<TransactionHeartbeat>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub transaction: Option<Transaction>,
}

impl From<&StreamTransactionsResponse> for StreamTransactionsResponse {
    fn from(value: &StreamTransactionsResponse) -> Self {
        value.clone()
    }
}

impl StreamTransactionsResponse {
    pub fn builder() -> builder::StreamTransactionsResponse {
        Default::default()
    }
}

///TakeProfitDetails specifies the details of a Take Profit Order to be
/// created on behalf of a client. This may happen when an Order is filled
/// that opens a Trade requiring a Take Profit, or when a Trade's dependent
/// Take Profit Order is modified directly through the Trade.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "TakeProfitDetails specifies the details of a Take
/// Profit Order to be created on behalf of a client. This may happen when
/// an Order is filled that opens a Trade requiring a Take Profit, or when a
/// Trade's dependent Take Profit Order is modified directly through the
/// Trade.",
///  "type": "object",
///  "properties": {
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "gtdTime": {
///      "description": "The date when the Take Profit Order will be
/// cancelled on if timeInForce is GTD.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "price": {
///      "description": "The price that the Take Profit Order will be
/// triggered at. Only one of the price and distance fields may be
/// specified.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "timeInForce": {
///      "description": "The time in force for the created Take Profit
/// Order. This may only be GTC, GTD or GFD.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TakeProfitDetails {
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The date when the Take Profit Order will be cancelled on if
    /// timeInForce is GTD.
    #[serde(rename = "gtdTime", default, skip_serializing_if = "Option::is_none")]
    pub gtd_time: Option<String>,
    ///The price that the Take Profit Order will be triggered at. Only one
    /// of the price and distance fields may be specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The time in force for the created Take Profit Order. This may only
    /// be GTC, GTD or GFD.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<TakeProfitDetailsTimeInForce>,
}

impl From<&TakeProfitDetails> for TakeProfitDetails {
    fn from(value: &TakeProfitDetails) -> Self {
        value.clone()
    }
}

impl TakeProfitDetails {
    pub fn builder() -> builder::TakeProfitDetails {
        Default::default()
    }
}

///The time in force for the created Take Profit Order. This may only be
/// GTC, GTD or GFD.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time in force for the created Take Profit Order.
/// This may only be GTC, GTD or GFD.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TakeProfitDetailsTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&TakeProfitDetailsTimeInForce> for TakeProfitDetailsTimeInForce {
    fn from(value: &TakeProfitDetailsTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for TakeProfitDetailsTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for TakeProfitDetailsTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TakeProfitDetailsTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TakeProfitDetailsTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TakeProfitDetailsTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A TakeProfitOrder is an order that is linked to an open Trade and
/// created with a price threshold. The Order will be filled (closing the
/// Trade) by the first price that is equal to or better than the threshold.
/// A TakeProfitOrder cannot be used to open a new Position.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A TakeProfitOrder is an order that is linked to an open
/// Trade and created with a price threshold. The Order will be filled
/// (closing the Trade) by the first price that is equal to or better than
/// the threshold. A TakeProfitOrder cannot be used to open a new
/// Position.",
///  "type": "object",
///  "properties": {
///    "cancelledTime": {
///      "description": "Date/time when the Order was cancelled (only
/// provided when the state of the Order is CANCELLED)",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "cancellingTransactionID": {
///      "description": "ID of the Transaction that cancelled the Order
/// (only provided when the Order's state is CANCELLED)",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "clientTradeID": {
///      "description": "The client ID of the Trade to be closed when the
/// price threshold is breached.",
///      "type": "string"
///    },
///    "createTime": {
///      "description": "The time when the Order was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "filledTime": {
///      "description": "Date/time when the Order was filled (only provided
/// when the Order's state is FILLED)",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "fillingTransactionID": {
///      "description": "ID of the Transaction that filled this Order (only
/// provided when the Order's state is FILLED)",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "gtdTime": {
///      "description": "The date/time when the TakeProfit Order will be
/// cancelled if its timeInForce is \"GTD\".",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "id": {
///      "description": "The Order's identifier, unique within the Order's
/// Account.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "price": {
///      "description": "The price threshold specified for the TakeProfit
/// Order. The associated Trade will be closed by a market price that is
/// equal to or better than this threshold.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "replacedByOrderID": {
///      "description": "The ID of the Order that replaced this Order (only
/// provided if this Order was cancelled as part of a cancel/replace).",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "replacesOrderID": {
///      "description": "The ID of the Order that was replaced by this Order (only provided if this Order was created as part of a cancel/replace).",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "state": {
///      "description": "The current state of the Order.",
///      "type": "string",
///      "enum": [
///        "PENDING",
///        "FILLED",
///        "TRIGGERED",
///        "CANCELLED"
///      ]
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the TakeProfit
/// Order. Restricted to \"GTC\", \"GFD\" and \"GTD\" for TakeProfit
/// Orders.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeClosedIDs": {
///      "description": "Trade IDs of Trades closed when the Order was
/// filled (only provided when the Order's state is FILLED and one or more
/// Trades were closed as a result of the fill)",
///      "type": "array",
///      "items": {
///        "description": "The Trade's identifier, unique within the Trade's
/// Account.",
///        "type": "string",
///        "format": "The string representation of the OANDA-assigned
/// TradeID. OANDA-assigned TradeIDs are positive integers, and are derived
/// from the TransactionID of the Transaction that opened the Trade."
///      }
///    },
///    "tradeID": {
///      "description": "The ID of the Trade to close when the price
/// threshold is breached.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "tradeOpenedID": {
///      "description": "Trade ID of Trade opened when the Order was filled
/// (only provided when the Order's state is FILLED and a Trade was opened
/// as a result of the fill)",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "tradeReducedID": {
///      "description": "Trade ID of Trade reduced when the Order was filled
/// (only provided when the Order's state is FILLED and a Trade was reduced
/// as a result of the fill)",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "triggerCondition": {
///      "description": "Specification of which price component should be
/// used when determining if an Order should be triggered and filled. This
/// allows Orders to be triggered based on the bid, ask, mid, default (ask
/// for buy, bid for sell) or inverse (ask for sell, bid for buy) price
/// depending on the desired behaviour. Orders are always filled using their
/// default price component.\nThis feature is only provided through the REST
/// API. Clients who choose to specify a non-default trigger condition will
/// not see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///      "type": "string",
///      "enum": [
///        "DEFAULT",
///        "INVERSE",
///        "BID",
///        "ASK",
///        "MID"
///      ]
///    },
///    "type": {
///      "description": "The type of the Order. Always set to
/// \"TAKE_PROFIT\" for Take Profit Orders.",
///      "type": "string",
///      "enum": [
///        "MARKET",
///        "LIMIT",
///        "STOP",
///        "MARKET_IF_TOUCHED",
///        "TAKE_PROFIT",
///        "STOP_LOSS",
///        "TRAILING_STOP_LOSS",
///        "FIXED_PRICE"
///      ]
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TakeProfitOrder {
    ///Date/time when the Order was cancelled (only provided when the state
    /// of the Order is CANCELLED)
    #[serde(
        rename = "cancelledTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelled_time: Option<String>,
    ///ID of the Transaction that cancelled the Order (only provided when
    /// the Order's state is CANCELLED)
    #[serde(
        rename = "cancellingTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The client ID of the Trade to be closed when the price threshold is
    /// breached.
    #[serde(
        rename = "clientTradeID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_trade_id: Option<String>,
    ///The time when the Order was created.
    #[serde(
        rename = "createTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub create_time: Option<String>,
    ///Date/time when the Order was filled (only provided when the Order's
    /// state is FILLED)
    #[serde(
        rename = "filledTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub filled_time: Option<String>,
    ///ID of the Transaction that filled this Order (only provided when the
    /// Order's state is FILLED)
    #[serde(
        rename = "fillingTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub filling_transaction_id: Option<String>,
    ///The date/time when the TakeProfit Order will be cancelled if its
    /// timeInForce is "GTD".
    #[serde(rename = "gtdTime", default, skip_serializing_if = "Option::is_none")]
    pub gtd_time: Option<String>,
    ///The Order's identifier, unique within the Order's Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The price threshold specified for the TakeProfit Order. The
    /// associated Trade will be closed by a market price that is equal to
    /// or better than this threshold.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The ID of the Order that replaced this Order (only provided if this
    /// Order was cancelled as part of a cancel/replace).
    #[serde(
        rename = "replacedByOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub replaced_by_order_id: Option<String>,
    ///The ID of the Order that was replaced by this Order (only provided
    /// if this Order was created as part of a cancel/replace).
    #[serde(
        rename = "replacesOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub replaces_order_id: Option<String>,
    ///The current state of the Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<TakeProfitOrderState>,
    ///The time-in-force requested for the TakeProfit Order. Restricted to
    /// "GTC", "GFD" and "GTD" for TakeProfit Orders.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<TakeProfitOrderTimeInForce>,
    ///Trade IDs of Trades closed when the Order was filled (only provided
    /// when the Order's state is FILLED and one or more Trades were closed
    /// as a result of the fill)
    #[serde(
        rename = "tradeClosedIDs",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub trade_closed_i_ds: Vec<String>,
    ///The ID of the Trade to close when the price threshold is breached.
    #[serde(rename = "tradeID", default, skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,
    ///Trade ID of Trade opened when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was opened as a result
    /// of the fill)
    #[serde(
        rename = "tradeOpenedID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_opened_id: Option<String>,
    ///Trade ID of Trade reduced when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was reduced as a result
    /// of the fill)
    #[serde(
        rename = "tradeReducedID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_reduced_id: Option<String>,
    ///Specification of which price component should be used when
    /// determining if an Order should be triggered and filled. This allows
    /// Orders to be triggered based on the bid, ask, mid, default (ask for
    /// buy, bid for sell) or inverse (ask for sell, bid for buy) price
    /// depending on the desired behaviour. Orders are always filled using
    /// their default price component. This feature is only provided
    /// through the REST API. Clients who choose to specify a non-default
    /// trigger condition will not see it reflected in any of OANDA's
    /// proprietary or partner trading platforms, their transaction history
    /// or their account statements. OANDA platforms always assume that an
    /// Order's trigger condition is set to the default value when
    /// indicating the distance from an Order's trigger price, and will
    /// always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when
    /// creating a guaranteed Stop Loss Order. In this case the
    /// TriggerCondition value must either be "DEFAULT", or the "natural"
    /// trigger side "DEFAULT" results in. So for a Stop Loss Order for a
    /// long trade valid values are "DEFAULT" and "BID", and for short
    /// trades "DEFAULT" and "ASK" are valid.
    #[serde(
        rename = "triggerCondition",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trigger_condition: Option<TakeProfitOrderTriggerCondition>,
    ///The type of the Order. Always set to "TAKE_PROFIT" for Take Profit
    /// Orders.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<TakeProfitOrderType>,
}

impl From<&TakeProfitOrder> for TakeProfitOrder {
    fn from(value: &TakeProfitOrder) -> Self {
        value.clone()
    }
}

impl TakeProfitOrder {
    pub fn builder() -> builder::TakeProfitOrder {
        Default::default()
    }
}

///The reason that the Take Profit Order was initiated
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Take Profit Order was initiated",
///  "type": "string",
///  "enum": [
///    "CLIENT_ORDER",
///    "REPLACEMENT",
///    "ON_FILL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TakeProfitOrderReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "REPLACEMENT")]
    Replacement,
    #[serde(rename = "ON_FILL")]
    OnFill,
}

impl From<&TakeProfitOrderReason> for TakeProfitOrderReason {
    fn from(value: &TakeProfitOrderReason) -> Self {
        value.clone()
    }
}

impl ToString for TakeProfitOrderReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ClientOrder => "CLIENT_ORDER".to_string(),
            Self::Replacement => "REPLACEMENT".to_string(),
            Self::OnFill => "ON_FILL".to_string(),
        }
    }
}

impl std::str::FromStr for TakeProfitOrderReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CLIENT_ORDER" => Ok(Self::ClientOrder),
            "REPLACEMENT" => Ok(Self::Replacement),
            "ON_FILL" => Ok(Self::OnFill),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TakeProfitOrderReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TakeProfitOrderReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TakeProfitOrderReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A TakeProfitOrderRejectTransaction represents the rejection of the
/// creation of a TakeProfit Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A TakeProfitOrderRejectTransaction represents the
/// rejection of the creation of a TakeProfit Order.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "clientTradeID": {
///      "description": "The client ID of the Trade to be closed when the
/// price threshold is breached.",
///      "type": "string"
///    },
///    "gtdTime": {
///      "description": "The date/time when the TakeProfit Order will be
/// cancelled if its timeInForce is \"GTD\".",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "intendedReplacesOrderID": {
///      "description": "The ID of the Order that this Order was intended to
/// replace (only provided if this Order was intended to replace an existing
/// Order).",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "orderFillTransactionID": {
///      "description": "The ID of the OrderFill Transaction that caused
/// this Order to be created (only provided if this Order was created
/// automatically when another Order was filled).",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "price": {
///      "description": "The price threshold specified for the TakeProfit
/// Order. The associated Trade will be closed by a market price that is
/// equal to or better than this threshold.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "reason": {
///      "description": "The reason that the Take Profit Order was
/// initiated",
///      "type": "string",
///      "enum": [
///        "CLIENT_ORDER",
///        "REPLACEMENT",
///        "ON_FILL"
///      ]
///    },
///    "rejectReason": {
///      "description": "The reason that the Reject Transaction was
/// created",
///      "type": "string",
///      "enum": [
///        "INTERNAL_SERVER_ERROR",
///        "INSTRUMENT_PRICE_UNKNOWN",
///        "ACCOUNT_NOT_ACTIVE",
///        "ACCOUNT_LOCKED",
///        "ACCOUNT_ORDER_CREATION_LOCKED",
///        "ACCOUNT_CONFIGURATION_LOCKED",
///        "ACCOUNT_DEPOSIT_LOCKED",
///        "ACCOUNT_WITHDRAWAL_LOCKED",
///        "ACCOUNT_ORDER_CANCEL_LOCKED",
///        "INSTRUMENT_NOT_TRADEABLE",
///        "PENDING_ORDERS_ALLOWED_EXCEEDED",
///        "ORDER_ID_UNSPECIFIED",
///        "ORDER_DOESNT_EXIST",
///        "ORDER_IDENTIFIER_INCONSISTENCY",
///        "TRADE_ID_UNSPECIFIED",
///        "TRADE_DOESNT_EXIST",
///        "TRADE_IDENTIFIER_INCONSISTENCY",
///        "INSUFFICIENT_MARGIN",
///        "INSTRUMENT_MISSING",
///        "INSTRUMENT_UNKNOWN",
///        "UNITS_MISSING",
///        "UNITS_INVALID",
///        "UNITS_PRECISION_EXCEEDED",
///        "UNITS_LIMIT_EXCEEDED",
///        "UNITS_MIMIMUM_NOT_MET",
///        "PRICE_MISSING",
///        "PRICE_INVALID",
///        "PRICE_PRECISION_EXCEEDED",
///        "PRICE_DISTANCE_MISSING",
///        "PRICE_DISTANCE_INVALID",
///        "PRICE_DISTANCE_PRECISION_EXCEEDED",
///        "PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "PRICE_DISTANCE_MINIMUM_NOT_MET",
///        "TIME_IN_FORCE_MISSING",
///        "TIME_IN_FORCE_INVALID",
///        "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING",
///        "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST",
///        "PRICE_BOUND_INVALID",
///        "PRICE_BOUND_PRECISION_EXCEEDED",
///        "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS",
///        "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED",
///        "CLIENT_ORDER_ID_INVALID",
///        "CLIENT_ORDER_ID_ALREADY_EXISTS",
///        "CLIENT_ORDER_TAG_INVALID",
///        "CLIENT_ORDER_COMMENT_INVALID",
///        "CLIENT_TRADE_ID_INVALID",
///        "CLIENT_TRADE_ID_ALREADY_EXISTS",
///        "CLIENT_TRADE_TAG_INVALID",
///        "CLIENT_TRADE_COMMENT_INVALID",
///        "ORDER_FILL_POSITION_ACTION_MISSING",
///        "ORDER_FILL_POSITION_ACTION_INVALID",
///        "TRIGGER_CONDITION_MISSING",
///        "TRIGGER_CONDITION_INVALID",
///        "ORDER_PARTIAL_FILL_OPTION_MISSING",
///        "ORDER_PARTIAL_FILL_OPTION_INVALID",
///        "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL",
///        "TAKE_PROFIT_ORDER_ALREADY_EXISTS",
///        "TAKE_PROFIT_ON_FILL_PRICE_MISSING",
///        "TAKE_PROFIT_ON_FILL_PRICE_INVALID",
///        "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED",
///        "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING",
///        "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID",
///        "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "STOP_LOSS_ORDER_ALREADY_EXISTS",
///        "STOP_LOSS_ORDER_GUARANTEED_REQUIRED",
///        "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD",
///        "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED",
///        "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION",
///        "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION",
///        "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED",
///        "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///        "STOP_LOSS_ORDER_NOT_CANCELABLE",
///        "STOP_LOSS_ORDER_NOT_REPLACEABLE",
///        "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///        "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///        "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING",
///        "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER",
///        "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///        "STOP_LOSS_ON_FILL_PRICE_MISSING",
///        "STOP_LOSS_ON_FILL_PRICE_INVALID",
///        "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///        "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_DISTANCE_INVALID",
///        "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///        "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING",
///        "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///        "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///        "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET",
///        "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED",
///        "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "CLOSE_TRADE_TYPE_MISSING",
///        "CLOSE_TRADE_PARTIAL_UNITS_MISSING",
///        "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE",
///        "CLOSEOUT_POSITION_DOESNT_EXIST",
///        "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION",
///        "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE",
///        "CLOSEOUT_POSITION_REJECT",
///        "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING",
///        "MARKUP_GROUP_ID_INVALID",
///        "POSITION_AGGREGATION_MODE_INVALID",
///        "ADMIN_CONFIGURE_DATA_MISSING",
///        "MARGIN_RATE_INVALID",
///        "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT",
///        "ALIAS_INVALID",
///        "CLIENT_CONFIGURE_DATA_MISSING",
///        "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL",
///        "AMOUNT_INVALID",
///        "INSUFFICIENT_FUNDS",
///        "AMOUNT_MISSING",
///        "FUNDING_REASON_MISSING",
///        "CLIENT_EXTENSIONS_DATA_MISSING",
///        "REPLACING_ORDER_INVALID",
///        "REPLACING_TRADE_ID_INVALID"
///      ]
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the TakeProfit
/// Order. Restricted to \"GTC\", \"GFD\" and \"GTD\" for TakeProfit
/// Orders.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeID": {
///      "description": "The ID of the Trade to close when the price
/// threshold is breached.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "triggerCondition": {
///      "description": "Specification of which price component should be
/// used when determining if an Order should be triggered and filled. This
/// allows Orders to be triggered based on the bid, ask, mid, default (ask
/// for buy, bid for sell) or inverse (ask for sell, bid for buy) price
/// depending on the desired behaviour. Orders are always filled using their
/// default price component.\nThis feature is only provided through the REST
/// API. Clients who choose to specify a non-default trigger condition will
/// not see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///      "type": "string",
///      "enum": [
///        "DEFAULT",
///        "INVERSE",
///        "BID",
///        "ASK",
///        "MID"
///      ]
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to \"TAKE_PROFIT_ORDER_REJECT\" in a TakeProfitOrderRejectTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TakeProfitOrderRejectTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The client ID of the Trade to be closed when the price threshold is
    /// breached.
    #[serde(
        rename = "clientTradeID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_trade_id: Option<String>,
    ///The date/time when the TakeProfit Order will be cancelled if its
    /// timeInForce is "GTD".
    #[serde(rename = "gtdTime", default, skip_serializing_if = "Option::is_none")]
    pub gtd_time: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The ID of the Order that this Order was intended to replace (only
    /// provided if this Order was intended to replace an existing Order).
    #[serde(
        rename = "intendedReplacesOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub intended_replaces_order_id: Option<String>,
    ///The ID of the OrderFill Transaction that caused this Order to be
    /// created (only provided if this Order was created automatically when
    /// another Order was filled).
    #[serde(
        rename = "orderFillTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub order_fill_transaction_id: Option<String>,
    ///The price threshold specified for the TakeProfit Order. The
    /// associated Trade will be closed by a market price that is equal to
    /// or better than this threshold.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The reason that the Take Profit Order was initiated
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<TakeProfitOrderRejectTransactionReason>,
    ///The reason that the Reject Transaction was created
    #[serde(
        rename = "rejectReason",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub reject_reason: Option<TakeProfitOrderRejectTransactionRejectReason>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The time-in-force requested for the TakeProfit Order. Restricted to
    /// "GTC", "GFD" and "GTD" for TakeProfit Orders.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<TakeProfitOrderRejectTransactionTimeInForce>,
    ///The ID of the Trade to close when the price threshold is breached.
    #[serde(rename = "tradeID", default, skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,
    ///Specification of which price component should be used when
    /// determining if an Order should be triggered and filled. This allows
    /// Orders to be triggered based on the bid, ask, mid, default (ask for
    /// buy, bid for sell) or inverse (ask for sell, bid for buy) price
    /// depending on the desired behaviour. Orders are always filled using
    /// their default price component. This feature is only provided
    /// through the REST API. Clients who choose to specify a non-default
    /// trigger condition will not see it reflected in any of OANDA's
    /// proprietary or partner trading platforms, their transaction history
    /// or their account statements. OANDA platforms always assume that an
    /// Order's trigger condition is set to the default value when
    /// indicating the distance from an Order's trigger price, and will
    /// always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when
    /// creating a guaranteed Stop Loss Order. In this case the
    /// TriggerCondition value must either be "DEFAULT", or the "natural"
    /// trigger side "DEFAULT" results in. So for a Stop Loss Order for a
    /// long trade valid values are "DEFAULT" and "BID", and for short
    /// trades "DEFAULT" and "ASK" are valid.
    #[serde(
        rename = "triggerCondition",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trigger_condition: Option<TakeProfitOrderRejectTransactionTriggerCondition>,
    ///The Type of the Transaction. Always set to
    /// "TAKE_PROFIT_ORDER_REJECT" in a TakeProfitOrderRejectTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<TakeProfitOrderRejectTransactionType>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&TakeProfitOrderRejectTransaction> for TakeProfitOrderRejectTransaction {
    fn from(value: &TakeProfitOrderRejectTransaction) -> Self {
        value.clone()
    }
}

impl TakeProfitOrderRejectTransaction {
    pub fn builder() -> builder::TakeProfitOrderRejectTransaction {
        Default::default()
    }
}

///The reason that the Take Profit Order was initiated
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Take Profit Order was initiated",
///  "type": "string",
///  "enum": [
///    "CLIENT_ORDER",
///    "REPLACEMENT",
///    "ON_FILL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TakeProfitOrderRejectTransactionReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "REPLACEMENT")]
    Replacement,
    #[serde(rename = "ON_FILL")]
    OnFill,
}

impl From<&TakeProfitOrderRejectTransactionReason> for TakeProfitOrderRejectTransactionReason {
    fn from(value: &TakeProfitOrderRejectTransactionReason) -> Self {
        value.clone()
    }
}

impl ToString for TakeProfitOrderRejectTransactionReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ClientOrder => "CLIENT_ORDER".to_string(),
            Self::Replacement => "REPLACEMENT".to_string(),
            Self::OnFill => "ON_FILL".to_string(),
        }
    }
}

impl std::str::FromStr for TakeProfitOrderRejectTransactionReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CLIENT_ORDER" => Ok(Self::ClientOrder),
            "REPLACEMENT" => Ok(Self::Replacement),
            "ON_FILL" => Ok(Self::OnFill),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TakeProfitOrderRejectTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TakeProfitOrderRejectTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TakeProfitOrderRejectTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The reason that the Reject Transaction was created
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Reject Transaction was created",
///  "type": "string",
///  "enum": [
///    "INTERNAL_SERVER_ERROR",
///    "INSTRUMENT_PRICE_UNKNOWN",
///    "ACCOUNT_NOT_ACTIVE",
///    "ACCOUNT_LOCKED",
///    "ACCOUNT_ORDER_CREATION_LOCKED",
///    "ACCOUNT_CONFIGURATION_LOCKED",
///    "ACCOUNT_DEPOSIT_LOCKED",
///    "ACCOUNT_WITHDRAWAL_LOCKED",
///    "ACCOUNT_ORDER_CANCEL_LOCKED",
///    "INSTRUMENT_NOT_TRADEABLE",
///    "PENDING_ORDERS_ALLOWED_EXCEEDED",
///    "ORDER_ID_UNSPECIFIED",
///    "ORDER_DOESNT_EXIST",
///    "ORDER_IDENTIFIER_INCONSISTENCY",
///    "TRADE_ID_UNSPECIFIED",
///    "TRADE_DOESNT_EXIST",
///    "TRADE_IDENTIFIER_INCONSISTENCY",
///    "INSUFFICIENT_MARGIN",
///    "INSTRUMENT_MISSING",
///    "INSTRUMENT_UNKNOWN",
///    "UNITS_MISSING",
///    "UNITS_INVALID",
///    "UNITS_PRECISION_EXCEEDED",
///    "UNITS_LIMIT_EXCEEDED",
///    "UNITS_MIMIMUM_NOT_MET",
///    "PRICE_MISSING",
///    "PRICE_INVALID",
///    "PRICE_PRECISION_EXCEEDED",
///    "PRICE_DISTANCE_MISSING",
///    "PRICE_DISTANCE_INVALID",
///    "PRICE_DISTANCE_PRECISION_EXCEEDED",
///    "PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "PRICE_DISTANCE_MINIMUM_NOT_MET",
///    "TIME_IN_FORCE_MISSING",
///    "TIME_IN_FORCE_INVALID",
///    "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING",
///    "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST",
///    "PRICE_BOUND_INVALID",
///    "PRICE_BOUND_PRECISION_EXCEEDED",
///    "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS",
///    "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED",
///    "CLIENT_ORDER_ID_INVALID",
///    "CLIENT_ORDER_ID_ALREADY_EXISTS",
///    "CLIENT_ORDER_TAG_INVALID",
///    "CLIENT_ORDER_COMMENT_INVALID",
///    "CLIENT_TRADE_ID_INVALID",
///    "CLIENT_TRADE_ID_ALREADY_EXISTS",
///    "CLIENT_TRADE_TAG_INVALID",
///    "CLIENT_TRADE_COMMENT_INVALID",
///    "ORDER_FILL_POSITION_ACTION_MISSING",
///    "ORDER_FILL_POSITION_ACTION_INVALID",
///    "TRIGGER_CONDITION_MISSING",
///    "TRIGGER_CONDITION_INVALID",
///    "ORDER_PARTIAL_FILL_OPTION_MISSING",
///    "ORDER_PARTIAL_FILL_OPTION_INVALID",
///    "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL",
///    "TAKE_PROFIT_ORDER_ALREADY_EXISTS",
///    "TAKE_PROFIT_ON_FILL_PRICE_MISSING",
///    "TAKE_PROFIT_ON_FILL_PRICE_INVALID",
///    "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED",
///    "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING",
///    "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "STOP_LOSS_ORDER_ALREADY_EXISTS",
///    "STOP_LOSS_ORDER_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD",
///    "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION",
///    "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION",
///    "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED",
///    "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ORDER_NOT_CANCELABLE",
///    "STOP_LOSS_ORDER_NOT_REPLACEABLE",
///    "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///    "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING",
///    "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER",
///    "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ON_FILL_PRICE_MISSING",
///    "STOP_LOSS_ON_FILL_PRICE_INVALID",
///    "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_DISTANCE_INVALID",
///    "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///    "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET",
///    "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED",
///    "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "CLOSE_TRADE_TYPE_MISSING",
///    "CLOSE_TRADE_PARTIAL_UNITS_MISSING",
///    "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE",
///    "CLOSEOUT_POSITION_DOESNT_EXIST",
///    "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION",
///    "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE",
///    "CLOSEOUT_POSITION_REJECT",
///    "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING",
///    "MARKUP_GROUP_ID_INVALID",
///    "POSITION_AGGREGATION_MODE_INVALID",
///    "ADMIN_CONFIGURE_DATA_MISSING",
///    "MARGIN_RATE_INVALID",
///    "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT",
///    "ALIAS_INVALID",
///    "CLIENT_CONFIGURE_DATA_MISSING",
///    "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL",
///    "AMOUNT_INVALID",
///    "INSUFFICIENT_FUNDS",
///    "AMOUNT_MISSING",
///    "FUNDING_REASON_MISSING",
///    "CLIENT_EXTENSIONS_DATA_MISSING",
///    "REPLACING_ORDER_INVALID",
///    "REPLACING_TRADE_ID_INVALID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TakeProfitOrderRejectTransactionRejectReason {
    #[serde(rename = "INTERNAL_SERVER_ERROR")]
    InternalServerError,
    #[serde(rename = "INSTRUMENT_PRICE_UNKNOWN")]
    InstrumentPriceUnknown,
    #[serde(rename = "ACCOUNT_NOT_ACTIVE")]
    AccountNotActive,
    #[serde(rename = "ACCOUNT_LOCKED")]
    AccountLocked,
    #[serde(rename = "ACCOUNT_ORDER_CREATION_LOCKED")]
    AccountOrderCreationLocked,
    #[serde(rename = "ACCOUNT_CONFIGURATION_LOCKED")]
    AccountConfigurationLocked,
    #[serde(rename = "ACCOUNT_DEPOSIT_LOCKED")]
    AccountDepositLocked,
    #[serde(rename = "ACCOUNT_WITHDRAWAL_LOCKED")]
    AccountWithdrawalLocked,
    #[serde(rename = "ACCOUNT_ORDER_CANCEL_LOCKED")]
    AccountOrderCancelLocked,
    #[serde(rename = "INSTRUMENT_NOT_TRADEABLE")]
    InstrumentNotTradeable,
    #[serde(rename = "PENDING_ORDERS_ALLOWED_EXCEEDED")]
    PendingOrdersAllowedExceeded,
    #[serde(rename = "ORDER_ID_UNSPECIFIED")]
    OrderIdUnspecified,
    #[serde(rename = "ORDER_DOESNT_EXIST")]
    OrderDoesntExist,
    #[serde(rename = "ORDER_IDENTIFIER_INCONSISTENCY")]
    OrderIdentifierInconsistency,
    #[serde(rename = "TRADE_ID_UNSPECIFIED")]
    TradeIdUnspecified,
    #[serde(rename = "TRADE_DOESNT_EXIST")]
    TradeDoesntExist,
    #[serde(rename = "TRADE_IDENTIFIER_INCONSISTENCY")]
    TradeIdentifierInconsistency,
    #[serde(rename = "INSUFFICIENT_MARGIN")]
    InsufficientMargin,
    #[serde(rename = "INSTRUMENT_MISSING")]
    InstrumentMissing,
    #[serde(rename = "INSTRUMENT_UNKNOWN")]
    InstrumentUnknown,
    #[serde(rename = "UNITS_MISSING")]
    UnitsMissing,
    #[serde(rename = "UNITS_INVALID")]
    UnitsInvalid,
    #[serde(rename = "UNITS_PRECISION_EXCEEDED")]
    UnitsPrecisionExceeded,
    #[serde(rename = "UNITS_LIMIT_EXCEEDED")]
    UnitsLimitExceeded,
    #[serde(rename = "UNITS_MIMIMUM_NOT_MET")]
    UnitsMimimumNotMet,
    #[serde(rename = "PRICE_MISSING")]
    PriceMissing,
    #[serde(rename = "PRICE_INVALID")]
    PriceInvalid,
    #[serde(rename = "PRICE_PRECISION_EXCEEDED")]
    PricePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MISSING")]
    PriceDistanceMissing,
    #[serde(rename = "PRICE_DISTANCE_INVALID")]
    PriceDistanceInvalid,
    #[serde(rename = "PRICE_DISTANCE_PRECISION_EXCEEDED")]
    PriceDistancePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    PriceDistanceMaximumExceeded,
    #[serde(rename = "PRICE_DISTANCE_MINIMUM_NOT_MET")]
    PriceDistanceMinimumNotMet,
    #[serde(rename = "TIME_IN_FORCE_MISSING")]
    TimeInForceMissing,
    #[serde(rename = "TIME_IN_FORCE_INVALID")]
    TimeInForceInvalid,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING")]
    TimeInForceGtdTimestampMissing,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST")]
    TimeInForceGtdTimestampInPast,
    #[serde(rename = "PRICE_BOUND_INVALID")]
    PriceBoundInvalid,
    #[serde(rename = "PRICE_BOUND_PRECISION_EXCEEDED")]
    PriceBoundPrecisionExceeded,
    #[serde(rename = "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS")]
    OrdersOnFillDuplicateClientOrderIds,
    #[serde(rename = "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED")]
    TradeOnFillClientExtensionsNotSupported,
    #[serde(rename = "CLIENT_ORDER_ID_INVALID")]
    ClientOrderIdInvalid,
    #[serde(rename = "CLIENT_ORDER_ID_ALREADY_EXISTS")]
    ClientOrderIdAlreadyExists,
    #[serde(rename = "CLIENT_ORDER_TAG_INVALID")]
    ClientOrderTagInvalid,
    #[serde(rename = "CLIENT_ORDER_COMMENT_INVALID")]
    ClientOrderCommentInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_INVALID")]
    ClientTradeIdInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_ALREADY_EXISTS")]
    ClientTradeIdAlreadyExists,
    #[serde(rename = "CLIENT_TRADE_TAG_INVALID")]
    ClientTradeTagInvalid,
    #[serde(rename = "CLIENT_TRADE_COMMENT_INVALID")]
    ClientTradeCommentInvalid,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_MISSING")]
    OrderFillPositionActionMissing,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_INVALID")]
    OrderFillPositionActionInvalid,
    #[serde(rename = "TRIGGER_CONDITION_MISSING")]
    TriggerConditionMissing,
    #[serde(rename = "TRIGGER_CONDITION_INVALID")]
    TriggerConditionInvalid,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_MISSING")]
    OrderPartialFillOptionMissing,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_INVALID")]
    OrderPartialFillOptionInvalid,
    #[serde(rename = "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL")]
    InvalidReissueImmediatePartialFill,
    #[serde(rename = "TAKE_PROFIT_ORDER_ALREADY_EXISTS")]
    TakeProfitOrderAlreadyExists,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_MISSING")]
    TakeProfitOnFillPriceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_INVALID")]
    TakeProfitOnFillPriceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    TakeProfitOnFillPricePrecisionExceeded,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING")]
    TakeProfitOnFillTimeInForceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID")]
    TakeProfitOnFillTimeInForceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TakeProfitOnFillGtdTimestampMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TakeProfitOnFillGtdTimestampInPast,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TakeProfitOnFillClientOrderIdInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TakeProfitOnFillClientOrderTagInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TakeProfitOnFillClientOrderCommentInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TakeProfitOnFillTriggerConditionMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TakeProfitOnFillTriggerConditionInvalid,
    #[serde(rename = "STOP_LOSS_ORDER_ALREADY_EXISTS")]
    StopLossOrderAlreadyExists,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_REQUIRED")]
    StopLossOrderGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD")]
    StopLossOrderGuaranteedPriceWithinSpread,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED")]
    StopLossOrderGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION")]
    StopLossOrderGuaranteedHaltedCreateViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION")]
    StopLossOrderGuaranteedHaltedTightenViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED")]
    StopLossOrderGuaranteedHedgingNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOrderGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_CANCELABLE")]
    StopLossOrderNotCancelable,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_REPLACEABLE")]
    StopLossOrderNotReplaceable,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOrderGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOrderPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOrderPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER")]
    StopLossOnFillRequiredForPendingOrder,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED")]
    StopLossOnFillGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED")]
    StopLossOnFillGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_MISSING")]
    StopLossOnFillPriceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_INVALID")]
    StopLossOnFillPriceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    StopLossOnFillPricePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOnFillGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOnFillGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_INVALID")]
    StopLossOnFillDistanceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    StopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED")]
    StopLossOnFillDistancePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOnFillPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOnFillPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    StopLossOnFillTimeInForceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    StopLossOnFillTimeInForceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    StopLossOnFillGtdTimestampMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    StopLossOnFillGtdTimestampInPast,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    StopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    StopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    StopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    StopLossOnFillTriggerConditionMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    StopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS")]
    TrailingStopLossOrderAlreadyExists,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING")]
    TrailingStopLossOnFillPriceDistanceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID")]
    TrailingStopLossOnFillPriceDistanceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED")]
    TrailingStopLossOnFillPriceDistancePrecisionExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    TrailingStopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET")]
    TrailingStopLossOnFillPriceDistanceMinimumNotMet,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    TrailingStopLossOnFillTimeInForceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    TrailingStopLossOnFillTimeInForceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TrailingStopLossOnFillGtdTimestampMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TrailingStopLossOnFillGtdTimestampInPast,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TrailingStopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TrailingStopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TrailingStopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED")]
    TrailingStopLossOrdersNotSupported,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TrailingStopLossOnFillTriggerConditionMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TrailingStopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "CLOSE_TRADE_TYPE_MISSING")]
    CloseTradeTypeMissing,
    #[serde(rename = "CLOSE_TRADE_PARTIAL_UNITS_MISSING")]
    CloseTradePartialUnitsMissing,
    #[serde(rename = "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE")]
    CloseTradeUnitsExceedTradeSize,
    #[serde(rename = "CLOSEOUT_POSITION_DOESNT_EXIST")]
    CloseoutPositionDoesntExist,
    #[serde(rename = "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION")]
    CloseoutPositionIncompleteSpecification,
    #[serde(rename = "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE")]
    CloseoutPositionUnitsExceedPositionSize,
    #[serde(rename = "CLOSEOUT_POSITION_REJECT")]
    CloseoutPositionReject,
    #[serde(rename = "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING")]
    CloseoutPositionPartialUnitsMissing,
    #[serde(rename = "MARKUP_GROUP_ID_INVALID")]
    MarkupGroupIdInvalid,
    #[serde(rename = "POSITION_AGGREGATION_MODE_INVALID")]
    PositionAggregationModeInvalid,
    #[serde(rename = "ADMIN_CONFIGURE_DATA_MISSING")]
    AdminConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_INVALID")]
    MarginRateInvalid,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT")]
    MarginRateWouldTriggerCloseout,
    #[serde(rename = "ALIAS_INVALID")]
    AliasInvalid,
    #[serde(rename = "CLIENT_CONFIGURE_DATA_MISSING")]
    ClientConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL")]
    MarginRateWouldTriggerMarginCall,
    #[serde(rename = "AMOUNT_INVALID")]
    AmountInvalid,
    #[serde(rename = "INSUFFICIENT_FUNDS")]
    InsufficientFunds,
    #[serde(rename = "AMOUNT_MISSING")]
    AmountMissing,
    #[serde(rename = "FUNDING_REASON_MISSING")]
    FundingReasonMissing,
    #[serde(rename = "CLIENT_EXTENSIONS_DATA_MISSING")]
    ClientExtensionsDataMissing,
    #[serde(rename = "REPLACING_ORDER_INVALID")]
    ReplacingOrderInvalid,
    #[serde(rename = "REPLACING_TRADE_ID_INVALID")]
    ReplacingTradeIdInvalid,
}

impl From<&TakeProfitOrderRejectTransactionRejectReason>
    for TakeProfitOrderRejectTransactionRejectReason
{
    fn from(value: &TakeProfitOrderRejectTransactionRejectReason) -> Self {
        value.clone()
    }
}

impl ToString for TakeProfitOrderRejectTransactionRejectReason {
    fn to_string(&self) -> String {
        match *self {
            Self::InternalServerError => "INTERNAL_SERVER_ERROR".to_string(),
            Self::InstrumentPriceUnknown => "INSTRUMENT_PRICE_UNKNOWN".to_string(),
            Self::AccountNotActive => "ACCOUNT_NOT_ACTIVE".to_string(),
            Self::AccountLocked => "ACCOUNT_LOCKED".to_string(),
            Self::AccountOrderCreationLocked => "ACCOUNT_ORDER_CREATION_LOCKED".to_string(),
            Self::AccountConfigurationLocked => "ACCOUNT_CONFIGURATION_LOCKED".to_string(),
            Self::AccountDepositLocked => "ACCOUNT_DEPOSIT_LOCKED".to_string(),
            Self::AccountWithdrawalLocked => "ACCOUNT_WITHDRAWAL_LOCKED".to_string(),
            Self::AccountOrderCancelLocked => "ACCOUNT_ORDER_CANCEL_LOCKED".to_string(),
            Self::InstrumentNotTradeable => "INSTRUMENT_NOT_TRADEABLE".to_string(),
            Self::PendingOrdersAllowedExceeded => "PENDING_ORDERS_ALLOWED_EXCEEDED".to_string(),
            Self::OrderIdUnspecified => "ORDER_ID_UNSPECIFIED".to_string(),
            Self::OrderDoesntExist => "ORDER_DOESNT_EXIST".to_string(),
            Self::OrderIdentifierInconsistency => "ORDER_IDENTIFIER_INCONSISTENCY".to_string(),
            Self::TradeIdUnspecified => "TRADE_ID_UNSPECIFIED".to_string(),
            Self::TradeDoesntExist => "TRADE_DOESNT_EXIST".to_string(),
            Self::TradeIdentifierInconsistency => "TRADE_IDENTIFIER_INCONSISTENCY".to_string(),
            Self::InsufficientMargin => "INSUFFICIENT_MARGIN".to_string(),
            Self::InstrumentMissing => "INSTRUMENT_MISSING".to_string(),
            Self::InstrumentUnknown => "INSTRUMENT_UNKNOWN".to_string(),
            Self::UnitsMissing => "UNITS_MISSING".to_string(),
            Self::UnitsInvalid => "UNITS_INVALID".to_string(),
            Self::UnitsPrecisionExceeded => "UNITS_PRECISION_EXCEEDED".to_string(),
            Self::UnitsLimitExceeded => "UNITS_LIMIT_EXCEEDED".to_string(),
            Self::UnitsMimimumNotMet => "UNITS_MIMIMUM_NOT_MET".to_string(),
            Self::PriceMissing => "PRICE_MISSING".to_string(),
            Self::PriceInvalid => "PRICE_INVALID".to_string(),
            Self::PricePrecisionExceeded => "PRICE_PRECISION_EXCEEDED".to_string(),
            Self::PriceDistanceMissing => "PRICE_DISTANCE_MISSING".to_string(),
            Self::PriceDistanceInvalid => "PRICE_DISTANCE_INVALID".to_string(),
            Self::PriceDistancePrecisionExceeded => "PRICE_DISTANCE_PRECISION_EXCEEDED".to_string(),
            Self::PriceDistanceMaximumExceeded => "PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string(),
            Self::PriceDistanceMinimumNotMet => "PRICE_DISTANCE_MINIMUM_NOT_MET".to_string(),
            Self::TimeInForceMissing => "TIME_IN_FORCE_MISSING".to_string(),
            Self::TimeInForceInvalid => "TIME_IN_FORCE_INVALID".to_string(),
            Self::TimeInForceGtdTimestampMissing => {
                "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TimeInForceGtdTimestampInPast => {
                "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::PriceBoundInvalid => "PRICE_BOUND_INVALID".to_string(),
            Self::PriceBoundPrecisionExceeded => "PRICE_BOUND_PRECISION_EXCEEDED".to_string(),
            Self::OrdersOnFillDuplicateClientOrderIds => {
                "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS".to_string()
            }
            Self::TradeOnFillClientExtensionsNotSupported => {
                "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED".to_string()
            }
            Self::ClientOrderIdInvalid => "CLIENT_ORDER_ID_INVALID".to_string(),
            Self::ClientOrderIdAlreadyExists => "CLIENT_ORDER_ID_ALREADY_EXISTS".to_string(),
            Self::ClientOrderTagInvalid => "CLIENT_ORDER_TAG_INVALID".to_string(),
            Self::ClientOrderCommentInvalid => "CLIENT_ORDER_COMMENT_INVALID".to_string(),
            Self::ClientTradeIdInvalid => "CLIENT_TRADE_ID_INVALID".to_string(),
            Self::ClientTradeIdAlreadyExists => "CLIENT_TRADE_ID_ALREADY_EXISTS".to_string(),
            Self::ClientTradeTagInvalid => "CLIENT_TRADE_TAG_INVALID".to_string(),
            Self::ClientTradeCommentInvalid => "CLIENT_TRADE_COMMENT_INVALID".to_string(),
            Self::OrderFillPositionActionMissing => {
                "ORDER_FILL_POSITION_ACTION_MISSING".to_string()
            }
            Self::OrderFillPositionActionInvalid => {
                "ORDER_FILL_POSITION_ACTION_INVALID".to_string()
            }
            Self::TriggerConditionMissing => "TRIGGER_CONDITION_MISSING".to_string(),
            Self::TriggerConditionInvalid => "TRIGGER_CONDITION_INVALID".to_string(),
            Self::OrderPartialFillOptionMissing => "ORDER_PARTIAL_FILL_OPTION_MISSING".to_string(),
            Self::OrderPartialFillOptionInvalid => "ORDER_PARTIAL_FILL_OPTION_INVALID".to_string(),
            Self::InvalidReissueImmediatePartialFill => {
                "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL".to_string()
            }
            Self::TakeProfitOrderAlreadyExists => "TAKE_PROFIT_ORDER_ALREADY_EXISTS".to_string(),
            Self::TakeProfitOnFillPriceMissing => "TAKE_PROFIT_ON_FILL_PRICE_MISSING".to_string(),
            Self::TakeProfitOnFillPriceInvalid => "TAKE_PROFIT_ON_FILL_PRICE_INVALID".to_string(),
            Self::TakeProfitOnFillPricePrecisionExceeded => {
                "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED".to_string()
            }
            Self::TakeProfitOnFillTimeInForceMissing => {
                "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::TakeProfitOnFillTimeInForceInvalid => {
                "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::TakeProfitOnFillGtdTimestampMissing => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TakeProfitOnFillGtdTimestampInPast => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TakeProfitOnFillClientOrderIdInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::TakeProfitOnFillClientOrderTagInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::TakeProfitOnFillClientOrderCommentInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::TakeProfitOnFillTriggerConditionMissing => {
                "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::TakeProfitOnFillTriggerConditionInvalid => {
                "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::StopLossOrderAlreadyExists => "STOP_LOSS_ORDER_ALREADY_EXISTS".to_string(),
            Self::StopLossOrderGuaranteedRequired => {
                "STOP_LOSS_ORDER_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOrderGuaranteedPriceWithinSpread => {
                "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD".to_string()
            }
            Self::StopLossOrderGuaranteedNotAllowed => {
                "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOrderGuaranteedHaltedCreateViolation => {
                "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION".to_string()
            }
            Self::StopLossOrderGuaranteedHaltedTightenViolation => {
                "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION".to_string()
            }
            Self::StopLossOrderGuaranteedHedgingNotAllowed => {
                "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED".to_string()
            }
            Self::StopLossOrderGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOrderNotCancelable => "STOP_LOSS_ORDER_NOT_CANCELABLE".to_string(),
            Self::StopLossOrderNotReplaceable => "STOP_LOSS_ORDER_NOT_REPLACEABLE".to_string(),
            Self::StopLossOrderGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOrderPriceAndDistanceBothSpecified => {
                "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED".to_string()
            }
            Self::StopLossOrderPriceAndDistanceBothMissing => {
                "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING".to_string()
            }
            Self::StopLossOnFillRequiredForPendingOrder => {
                "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER".to_string()
            }
            Self::StopLossOnFillGuaranteedNotAllowed => {
                "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOnFillGuaranteedRequired => {
                "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOnFillPriceMissing => "STOP_LOSS_ON_FILL_PRICE_MISSING".to_string(),
            Self::StopLossOnFillPriceInvalid => "STOP_LOSS_ON_FILL_PRICE_INVALID".to_string(),
            Self::StopLossOnFillPricePrecisionExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOnFillGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillDistanceInvalid => "STOP_LOSS_ON_FILL_DISTANCE_INVALID".to_string(),
            Self::StopLossOnFillPriceDistanceMaximumExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::StopLossOnFillDistancePrecisionExceeded => {
                "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillPriceAndDistanceBothSpecified => {
                "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED".to_string()
            }
            Self::StopLossOnFillPriceAndDistanceBothMissing => {
                "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING".to_string()
            }
            Self::StopLossOnFillTimeInForceMissing => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::StopLossOnFillTimeInForceInvalid => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::StopLossOnFillGtdTimestampMissing => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::StopLossOnFillGtdTimestampInPast => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::StopLossOnFillClientOrderIdInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::StopLossOnFillClientOrderTagInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::StopLossOnFillClientOrderCommentInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::StopLossOnFillTriggerConditionMissing => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::StopLossOnFillTriggerConditionInvalid => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::TrailingStopLossOrderAlreadyExists => {
                "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistancePrecisionExceeded => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMaximumExceeded => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMinimumNotMet => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET".to_string()
            }
            Self::TrailingStopLossOnFillTimeInForceMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillTimeInForceInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampInPast => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderIdInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderTagInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderCommentInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::TrailingStopLossOrdersNotSupported => {
                "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED".to_string()
            }
            Self::TrailingStopLossOnFillTriggerConditionMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillTriggerConditionInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::CloseTradeTypeMissing => "CLOSE_TRADE_TYPE_MISSING".to_string(),
            Self::CloseTradePartialUnitsMissing => "CLOSE_TRADE_PARTIAL_UNITS_MISSING".to_string(),
            Self::CloseTradeUnitsExceedTradeSize => {
                "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE".to_string()
            }
            Self::CloseoutPositionDoesntExist => "CLOSEOUT_POSITION_DOESNT_EXIST".to_string(),
            Self::CloseoutPositionIncompleteSpecification => {
                "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION".to_string()
            }
            Self::CloseoutPositionUnitsExceedPositionSize => {
                "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE".to_string()
            }
            Self::CloseoutPositionReject => "CLOSEOUT_POSITION_REJECT".to_string(),
            Self::CloseoutPositionPartialUnitsMissing => {
                "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING".to_string()
            }
            Self::MarkupGroupIdInvalid => "MARKUP_GROUP_ID_INVALID".to_string(),
            Self::PositionAggregationModeInvalid => "POSITION_AGGREGATION_MODE_INVALID".to_string(),
            Self::AdminConfigureDataMissing => "ADMIN_CONFIGURE_DATA_MISSING".to_string(),
            Self::MarginRateInvalid => "MARGIN_RATE_INVALID".to_string(),
            Self::MarginRateWouldTriggerCloseout => {
                "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT".to_string()
            }
            Self::AliasInvalid => "ALIAS_INVALID".to_string(),
            Self::ClientConfigureDataMissing => "CLIENT_CONFIGURE_DATA_MISSING".to_string(),
            Self::MarginRateWouldTriggerMarginCall => {
                "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL".to_string()
            }
            Self::AmountInvalid => "AMOUNT_INVALID".to_string(),
            Self::InsufficientFunds => "INSUFFICIENT_FUNDS".to_string(),
            Self::AmountMissing => "AMOUNT_MISSING".to_string(),
            Self::FundingReasonMissing => "FUNDING_REASON_MISSING".to_string(),
            Self::ClientExtensionsDataMissing => "CLIENT_EXTENSIONS_DATA_MISSING".to_string(),
            Self::ReplacingOrderInvalid => "REPLACING_ORDER_INVALID".to_string(),
            Self::ReplacingTradeIdInvalid => "REPLACING_TRADE_ID_INVALID".to_string(),
        }
    }
}

impl std::str::FromStr for TakeProfitOrderRejectTransactionRejectReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "INTERNAL_SERVER_ERROR" => Ok(Self::InternalServerError),
            "INSTRUMENT_PRICE_UNKNOWN" => Ok(Self::InstrumentPriceUnknown),
            "ACCOUNT_NOT_ACTIVE" => Ok(Self::AccountNotActive),
            "ACCOUNT_LOCKED" => Ok(Self::AccountLocked),
            "ACCOUNT_ORDER_CREATION_LOCKED" => Ok(Self::AccountOrderCreationLocked),
            "ACCOUNT_CONFIGURATION_LOCKED" => Ok(Self::AccountConfigurationLocked),
            "ACCOUNT_DEPOSIT_LOCKED" => Ok(Self::AccountDepositLocked),
            "ACCOUNT_WITHDRAWAL_LOCKED" => Ok(Self::AccountWithdrawalLocked),
            "ACCOUNT_ORDER_CANCEL_LOCKED" => Ok(Self::AccountOrderCancelLocked),
            "INSTRUMENT_NOT_TRADEABLE" => Ok(Self::InstrumentNotTradeable),
            "PENDING_ORDERS_ALLOWED_EXCEEDED" => Ok(Self::PendingOrdersAllowedExceeded),
            "ORDER_ID_UNSPECIFIED" => Ok(Self::OrderIdUnspecified),
            "ORDER_DOESNT_EXIST" => Ok(Self::OrderDoesntExist),
            "ORDER_IDENTIFIER_INCONSISTENCY" => Ok(Self::OrderIdentifierInconsistency),
            "TRADE_ID_UNSPECIFIED" => Ok(Self::TradeIdUnspecified),
            "TRADE_DOESNT_EXIST" => Ok(Self::TradeDoesntExist),
            "TRADE_IDENTIFIER_INCONSISTENCY" => Ok(Self::TradeIdentifierInconsistency),
            "INSUFFICIENT_MARGIN" => Ok(Self::InsufficientMargin),
            "INSTRUMENT_MISSING" => Ok(Self::InstrumentMissing),
            "INSTRUMENT_UNKNOWN" => Ok(Self::InstrumentUnknown),
            "UNITS_MISSING" => Ok(Self::UnitsMissing),
            "UNITS_INVALID" => Ok(Self::UnitsInvalid),
            "UNITS_PRECISION_EXCEEDED" => Ok(Self::UnitsPrecisionExceeded),
            "UNITS_LIMIT_EXCEEDED" => Ok(Self::UnitsLimitExceeded),
            "UNITS_MIMIMUM_NOT_MET" => Ok(Self::UnitsMimimumNotMet),
            "PRICE_MISSING" => Ok(Self::PriceMissing),
            "PRICE_INVALID" => Ok(Self::PriceInvalid),
            "PRICE_PRECISION_EXCEEDED" => Ok(Self::PricePrecisionExceeded),
            "PRICE_DISTANCE_MISSING" => Ok(Self::PriceDistanceMissing),
            "PRICE_DISTANCE_INVALID" => Ok(Self::PriceDistanceInvalid),
            "PRICE_DISTANCE_PRECISION_EXCEEDED" => Ok(Self::PriceDistancePrecisionExceeded),
            "PRICE_DISTANCE_MAXIMUM_EXCEEDED" => Ok(Self::PriceDistanceMaximumExceeded),
            "PRICE_DISTANCE_MINIMUM_NOT_MET" => Ok(Self::PriceDistanceMinimumNotMet),
            "TIME_IN_FORCE_MISSING" => Ok(Self::TimeInForceMissing),
            "TIME_IN_FORCE_INVALID" => Ok(Self::TimeInForceInvalid),
            "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING" => Ok(Self::TimeInForceGtdTimestampMissing),
            "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST" => Ok(Self::TimeInForceGtdTimestampInPast),
            "PRICE_BOUND_INVALID" => Ok(Self::PriceBoundInvalid),
            "PRICE_BOUND_PRECISION_EXCEEDED" => Ok(Self::PriceBoundPrecisionExceeded),
            "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS" => {
                Ok(Self::OrdersOnFillDuplicateClientOrderIds)
            }
            "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED" => {
                Ok(Self::TradeOnFillClientExtensionsNotSupported)
            }
            "CLIENT_ORDER_ID_INVALID" => Ok(Self::ClientOrderIdInvalid),
            "CLIENT_ORDER_ID_ALREADY_EXISTS" => Ok(Self::ClientOrderIdAlreadyExists),
            "CLIENT_ORDER_TAG_INVALID" => Ok(Self::ClientOrderTagInvalid),
            "CLIENT_ORDER_COMMENT_INVALID" => Ok(Self::ClientOrderCommentInvalid),
            "CLIENT_TRADE_ID_INVALID" => Ok(Self::ClientTradeIdInvalid),
            "CLIENT_TRADE_ID_ALREADY_EXISTS" => Ok(Self::ClientTradeIdAlreadyExists),
            "CLIENT_TRADE_TAG_INVALID" => Ok(Self::ClientTradeTagInvalid),
            "CLIENT_TRADE_COMMENT_INVALID" => Ok(Self::ClientTradeCommentInvalid),
            "ORDER_FILL_POSITION_ACTION_MISSING" => Ok(Self::OrderFillPositionActionMissing),
            "ORDER_FILL_POSITION_ACTION_INVALID" => Ok(Self::OrderFillPositionActionInvalid),
            "TRIGGER_CONDITION_MISSING" => Ok(Self::TriggerConditionMissing),
            "TRIGGER_CONDITION_INVALID" => Ok(Self::TriggerConditionInvalid),
            "ORDER_PARTIAL_FILL_OPTION_MISSING" => Ok(Self::OrderPartialFillOptionMissing),
            "ORDER_PARTIAL_FILL_OPTION_INVALID" => Ok(Self::OrderPartialFillOptionInvalid),
            "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL" => {
                Ok(Self::InvalidReissueImmediatePartialFill)
            }
            "TAKE_PROFIT_ORDER_ALREADY_EXISTS" => Ok(Self::TakeProfitOrderAlreadyExists),
            "TAKE_PROFIT_ON_FILL_PRICE_MISSING" => Ok(Self::TakeProfitOnFillPriceMissing),
            "TAKE_PROFIT_ON_FILL_PRICE_INVALID" => Ok(Self::TakeProfitOnFillPriceInvalid),
            "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(Self::TakeProfitOnFillPricePrecisionExceeded)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(Self::TakeProfitOnFillTimeInForceMissing)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(Self::TakeProfitOnFillTimeInForceInvalid)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::TakeProfitOnFillGtdTimestampMissing)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TakeProfitOnFillGtdTimestampInPast)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderIdInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderTagInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderCommentInvalid)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::TakeProfitOnFillTriggerConditionMissing)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::TakeProfitOnFillTriggerConditionInvalid)
            }
            "STOP_LOSS_ORDER_ALREADY_EXISTS" => Ok(Self::StopLossOrderAlreadyExists),
            "STOP_LOSS_ORDER_GUARANTEED_REQUIRED" => Ok(Self::StopLossOrderGuaranteedRequired),
            "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD" => {
                Ok(Self::StopLossOrderGuaranteedPriceWithinSpread)
            }
            "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED" => Ok(Self::StopLossOrderGuaranteedNotAllowed),
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION" => {
                Ok(Self::StopLossOrderGuaranteedHaltedCreateViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION" => {
                Ok(Self::StopLossOrderGuaranteedHaltedTightenViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED" => {
                Ok(Self::StopLossOrderGuaranteedHedgingNotAllowed)
            }
            "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOrderGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ORDER_NOT_CANCELABLE" => Ok(Self::StopLossOrderNotCancelable),
            "STOP_LOSS_ORDER_NOT_REPLACEABLE" => Ok(Self::StopLossOrderNotReplaceable),
            "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOrderGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(Self::StopLossOrderPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(Self::StopLossOrderPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER" => {
                Ok(Self::StopLossOnFillRequiredForPendingOrder)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED" => {
                Ok(Self::StopLossOnFillGuaranteedNotAllowed)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED" => Ok(Self::StopLossOnFillGuaranteedRequired),
            "STOP_LOSS_ON_FILL_PRICE_MISSING" => Ok(Self::StopLossOnFillPriceMissing),
            "STOP_LOSS_ON_FILL_PRICE_INVALID" => Ok(Self::StopLossOnFillPriceInvalid),
            "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(Self::StopLossOnFillPricePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOnFillGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOnFillGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_INVALID" => Ok(Self::StopLossOnFillDistanceInvalid),
            "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::StopLossOnFillPriceDistanceMaximumExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(Self::StopLossOnFillDistancePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(Self::StopLossOnFillPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(Self::StopLossOnFillPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => Ok(Self::StopLossOnFillTimeInForceMissing),
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => Ok(Self::StopLossOnFillTimeInForceInvalid),
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::StopLossOnFillGtdTimestampMissing)
            }
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => Ok(Self::StopLossOnFillGtdTimestampInPast),
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderIdInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderTagInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderCommentInvalid)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::StopLossOnFillTriggerConditionMissing)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::StopLossOnFillTriggerConditionInvalid)
            }
            "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS" => {
                Ok(Self::TrailingStopLossOrderAlreadyExists)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(Self::TrailingStopLossOnFillPriceDistancePrecisionExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMaximumExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMinimumNotMet)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(Self::TrailingStopLossOnFillTimeInForceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(Self::TrailingStopLossOnFillTimeInForceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampInPast)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderIdInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderTagInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderCommentInvalid)
            }
            "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED" => {
                Ok(Self::TrailingStopLossOrdersNotSupported)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::TrailingStopLossOnFillTriggerConditionMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::TrailingStopLossOnFillTriggerConditionInvalid)
            }
            "CLOSE_TRADE_TYPE_MISSING" => Ok(Self::CloseTradeTypeMissing),
            "CLOSE_TRADE_PARTIAL_UNITS_MISSING" => Ok(Self::CloseTradePartialUnitsMissing),
            "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE" => Ok(Self::CloseTradeUnitsExceedTradeSize),
            "CLOSEOUT_POSITION_DOESNT_EXIST" => Ok(Self::CloseoutPositionDoesntExist),
            "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION" => {
                Ok(Self::CloseoutPositionIncompleteSpecification)
            }
            "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE" => {
                Ok(Self::CloseoutPositionUnitsExceedPositionSize)
            }
            "CLOSEOUT_POSITION_REJECT" => Ok(Self::CloseoutPositionReject),
            "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING" => {
                Ok(Self::CloseoutPositionPartialUnitsMissing)
            }
            "MARKUP_GROUP_ID_INVALID" => Ok(Self::MarkupGroupIdInvalid),
            "POSITION_AGGREGATION_MODE_INVALID" => Ok(Self::PositionAggregationModeInvalid),
            "ADMIN_CONFIGURE_DATA_MISSING" => Ok(Self::AdminConfigureDataMissing),
            "MARGIN_RATE_INVALID" => Ok(Self::MarginRateInvalid),
            "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT" => Ok(Self::MarginRateWouldTriggerCloseout),
            "ALIAS_INVALID" => Ok(Self::AliasInvalid),
            "CLIENT_CONFIGURE_DATA_MISSING" => Ok(Self::ClientConfigureDataMissing),
            "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL" => Ok(Self::MarginRateWouldTriggerMarginCall),
            "AMOUNT_INVALID" => Ok(Self::AmountInvalid),
            "INSUFFICIENT_FUNDS" => Ok(Self::InsufficientFunds),
            "AMOUNT_MISSING" => Ok(Self::AmountMissing),
            "FUNDING_REASON_MISSING" => Ok(Self::FundingReasonMissing),
            "CLIENT_EXTENSIONS_DATA_MISSING" => Ok(Self::ClientExtensionsDataMissing),
            "REPLACING_ORDER_INVALID" => Ok(Self::ReplacingOrderInvalid),
            "REPLACING_TRADE_ID_INVALID" => Ok(Self::ReplacingTradeIdInvalid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TakeProfitOrderRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TakeProfitOrderRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TakeProfitOrderRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The time-in-force requested for the TakeProfit Order. Restricted to
/// "GTC", "GFD" and "GTD" for TakeProfit Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the TakeProfit Order.
/// Restricted to \"GTC\", \"GFD\" and \"GTD\" for TakeProfit Orders.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TakeProfitOrderRejectTransactionTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&TakeProfitOrderRejectTransactionTimeInForce>
    for TakeProfitOrderRejectTransactionTimeInForce
{
    fn from(value: &TakeProfitOrderRejectTransactionTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for TakeProfitOrderRejectTransactionTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for TakeProfitOrderRejectTransactionTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TakeProfitOrderRejectTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TakeProfitOrderRejectTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TakeProfitOrderRejectTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///Specification of which price component should be used when determining
/// if an Order should be triggered and filled. This allows Orders to be
/// triggered based on the bid, ask, mid, default (ask for buy, bid for
/// sell) or inverse (ask for sell, bid for buy) price depending on the
/// desired behaviour. Orders are always filled using their default price
/// component. This feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order. A special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
/// results in. So for a Stop Loss Order for a long trade valid values are
/// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are valid.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of which price component should be used
/// when determining if an Order should be triggered and filled. This allows
/// Orders to be triggered based on the bid, ask, mid, default (ask for buy,
/// bid for sell) or inverse (ask for sell, bid for buy) price depending on
/// the desired behaviour. Orders are always filled using their default
/// price component.\nThis feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///  "type": "string",
///  "enum": [
///    "DEFAULT",
///    "INVERSE",
///    "BID",
///    "ASK",
///    "MID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TakeProfitOrderRejectTransactionTriggerCondition {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "INVERSE")]
    Inverse,
    #[serde(rename = "BID")]
    Bid,
    #[serde(rename = "ASK")]
    Ask,
    #[serde(rename = "MID")]
    Mid,
}

impl From<&TakeProfitOrderRejectTransactionTriggerCondition>
    for TakeProfitOrderRejectTransactionTriggerCondition
{
    fn from(value: &TakeProfitOrderRejectTransactionTriggerCondition) -> Self {
        value.clone()
    }
}

impl ToString for TakeProfitOrderRejectTransactionTriggerCondition {
    fn to_string(&self) -> String {
        match *self {
            Self::Default => "DEFAULT".to_string(),
            Self::Inverse => "INVERSE".to_string(),
            Self::Bid => "BID".to_string(),
            Self::Ask => "ASK".to_string(),
            Self::Mid => "MID".to_string(),
        }
    }
}

impl std::str::FromStr for TakeProfitOrderRejectTransactionTriggerCondition {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DEFAULT" => Ok(Self::Default),
            "INVERSE" => Ok(Self::Inverse),
            "BID" => Ok(Self::Bid),
            "ASK" => Ok(Self::Ask),
            "MID" => Ok(Self::Mid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TakeProfitOrderRejectTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TakeProfitOrderRejectTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TakeProfitOrderRejectTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Type of the Transaction. Always set to "TAKE_PROFIT_ORDER_REJECT" in
/// a TakeProfitOrderRejectTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to \"TAKE_PROFIT_ORDER_REJECT\" in a TakeProfitOrderRejectTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TakeProfitOrderRejectTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&TakeProfitOrderRejectTransactionType> for TakeProfitOrderRejectTransactionType {
    fn from(value: &TakeProfitOrderRejectTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for TakeProfitOrderRejectTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for TakeProfitOrderRejectTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TakeProfitOrderRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TakeProfitOrderRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TakeProfitOrderRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A TakeProfitOrderRequest specifies the parameters that may be set when
/// creating a Take Profit Order. Only one of the price and distance fields
/// may be specified.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A TakeProfitOrderRequest specifies the parameters that
/// may be set when creating a Take Profit Order. Only one of the price and
/// distance fields may be specified.",
///  "type": "object",
///  "properties": {
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "clientTradeID": {
///      "description": "The client ID of the Trade to be closed when the
/// price threshold is breached.",
///      "type": "string"
///    },
///    "gtdTime": {
///      "description": "The date/time when the TakeProfit Order will be
/// cancelled if its timeInForce is \"GTD\".",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "price": {
///      "description": "The price threshold specified for the TakeProfit
/// Order. The associated Trade will be closed by a market price that is
/// equal to or better than this threshold.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the TakeProfit
/// Order. Restricted to \"GTC\", \"GFD\" and \"GTD\" for TakeProfit
/// Orders.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeID": {
///      "description": "The ID of the Trade to close when the price
/// threshold is breached.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "triggerCondition": {
///      "description": "Specification of which price component should be
/// used when determining if an Order should be triggered and filled. This
/// allows Orders to be triggered based on the bid, ask, mid, default (ask
/// for buy, bid for sell) or inverse (ask for sell, bid for buy) price
/// depending on the desired behaviour. Orders are always filled using their
/// default price component.\nThis feature is only provided through the REST
/// API. Clients who choose to specify a non-default trigger condition will
/// not see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///      "type": "string",
///      "enum": [
///        "DEFAULT",
///        "INVERSE",
///        "BID",
///        "ASK",
///        "MID"
///      ]
///    },
///    "type": {
///      "description": "The type of the Order to Create. Must be set to
/// \"TAKE_PROFIT\" when creating a Take Profit Order.",
///      "type": "string",
///      "enum": [
///        "MARKET",
///        "LIMIT",
///        "STOP",
///        "MARKET_IF_TOUCHED",
///        "TAKE_PROFIT",
///        "STOP_LOSS",
///        "TRAILING_STOP_LOSS",
///        "FIXED_PRICE"
///      ]
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TakeProfitOrderRequest {
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The client ID of the Trade to be closed when the price threshold is
    /// breached.
    #[serde(
        rename = "clientTradeID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_trade_id: Option<String>,
    ///The date/time when the TakeProfit Order will be cancelled if its
    /// timeInForce is "GTD".
    #[serde(rename = "gtdTime", default, skip_serializing_if = "Option::is_none")]
    pub gtd_time: Option<String>,
    ///The price threshold specified for the TakeProfit Order. The
    /// associated Trade will be closed by a market price that is equal to
    /// or better than this threshold.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The time-in-force requested for the TakeProfit Order. Restricted to
    /// "GTC", "GFD" and "GTD" for TakeProfit Orders.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<TakeProfitOrderRequestTimeInForce>,
    ///The ID of the Trade to close when the price threshold is breached.
    #[serde(rename = "tradeID", default, skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,
    ///Specification of which price component should be used when
    /// determining if an Order should be triggered and filled. This allows
    /// Orders to be triggered based on the bid, ask, mid, default (ask for
    /// buy, bid for sell) or inverse (ask for sell, bid for buy) price
    /// depending on the desired behaviour. Orders are always filled using
    /// their default price component. This feature is only provided
    /// through the REST API. Clients who choose to specify a non-default
    /// trigger condition will not see it reflected in any of OANDA's
    /// proprietary or partner trading platforms, their transaction history
    /// or their account statements. OANDA platforms always assume that an
    /// Order's trigger condition is set to the default value when
    /// indicating the distance from an Order's trigger price, and will
    /// always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when
    /// creating a guaranteed Stop Loss Order. In this case the
    /// TriggerCondition value must either be "DEFAULT", or the "natural"
    /// trigger side "DEFAULT" results in. So for a Stop Loss Order for a
    /// long trade valid values are "DEFAULT" and "BID", and for short
    /// trades "DEFAULT" and "ASK" are valid.
    #[serde(
        rename = "triggerCondition",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trigger_condition: Option<TakeProfitOrderRequestTriggerCondition>,
    ///The type of the Order to Create. Must be set to "TAKE_PROFIT" when
    /// creating a Take Profit Order.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<TakeProfitOrderRequestType>,
}

impl From<&TakeProfitOrderRequest> for TakeProfitOrderRequest {
    fn from(value: &TakeProfitOrderRequest) -> Self {
        value.clone()
    }
}

impl TakeProfitOrderRequest {
    pub fn builder() -> builder::TakeProfitOrderRequest {
        Default::default()
    }
}

///The time-in-force requested for the TakeProfit Order. Restricted to
/// "GTC", "GFD" and "GTD" for TakeProfit Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the TakeProfit Order.
/// Restricted to \"GTC\", \"GFD\" and \"GTD\" for TakeProfit Orders.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TakeProfitOrderRequestTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&TakeProfitOrderRequestTimeInForce> for TakeProfitOrderRequestTimeInForce {
    fn from(value: &TakeProfitOrderRequestTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for TakeProfitOrderRequestTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for TakeProfitOrderRequestTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TakeProfitOrderRequestTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TakeProfitOrderRequestTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TakeProfitOrderRequestTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///Specification of which price component should be used when determining
/// if an Order should be triggered and filled. This allows Orders to be
/// triggered based on the bid, ask, mid, default (ask for buy, bid for
/// sell) or inverse (ask for sell, bid for buy) price depending on the
/// desired behaviour. Orders are always filled using their default price
/// component. This feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order. A special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
/// results in. So for a Stop Loss Order for a long trade valid values are
/// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are valid.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of which price component should be used
/// when determining if an Order should be triggered and filled. This allows
/// Orders to be triggered based on the bid, ask, mid, default (ask for buy,
/// bid for sell) or inverse (ask for sell, bid for buy) price depending on
/// the desired behaviour. Orders are always filled using their default
/// price component.\nThis feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///  "type": "string",
///  "enum": [
///    "DEFAULT",
///    "INVERSE",
///    "BID",
///    "ASK",
///    "MID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TakeProfitOrderRequestTriggerCondition {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "INVERSE")]
    Inverse,
    #[serde(rename = "BID")]
    Bid,
    #[serde(rename = "ASK")]
    Ask,
    #[serde(rename = "MID")]
    Mid,
}

impl From<&TakeProfitOrderRequestTriggerCondition> for TakeProfitOrderRequestTriggerCondition {
    fn from(value: &TakeProfitOrderRequestTriggerCondition) -> Self {
        value.clone()
    }
}

impl ToString for TakeProfitOrderRequestTriggerCondition {
    fn to_string(&self) -> String {
        match *self {
            Self::Default => "DEFAULT".to_string(),
            Self::Inverse => "INVERSE".to_string(),
            Self::Bid => "BID".to_string(),
            Self::Ask => "ASK".to_string(),
            Self::Mid => "MID".to_string(),
        }
    }
}

impl std::str::FromStr for TakeProfitOrderRequestTriggerCondition {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DEFAULT" => Ok(Self::Default),
            "INVERSE" => Ok(Self::Inverse),
            "BID" => Ok(Self::Bid),
            "ASK" => Ok(Self::Ask),
            "MID" => Ok(Self::Mid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TakeProfitOrderRequestTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TakeProfitOrderRequestTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TakeProfitOrderRequestTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The type of the Order to Create. Must be set to "TAKE_PROFIT" when
/// creating a Take Profit Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The type of the Order to Create. Must be set to
/// \"TAKE_PROFIT\" when creating a Take Profit Order.",
///  "type": "string",
///  "enum": [
///    "MARKET",
///    "LIMIT",
///    "STOP",
///    "MARKET_IF_TOUCHED",
///    "TAKE_PROFIT",
///    "STOP_LOSS",
///    "TRAILING_STOP_LOSS",
///    "FIXED_PRICE"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TakeProfitOrderRequestType {
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "STOP")]
    Stop,
    #[serde(rename = "MARKET_IF_TOUCHED")]
    MarketIfTouched,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "STOP_LOSS")]
    StopLoss,
    #[serde(rename = "TRAILING_STOP_LOSS")]
    TrailingStopLoss,
    #[serde(rename = "FIXED_PRICE")]
    FixedPrice,
}

impl From<&TakeProfitOrderRequestType> for TakeProfitOrderRequestType {
    fn from(value: &TakeProfitOrderRequestType) -> Self {
        value.clone()
    }
}

impl ToString for TakeProfitOrderRequestType {
    fn to_string(&self) -> String {
        match *self {
            Self::Market => "MARKET".to_string(),
            Self::Limit => "LIMIT".to_string(),
            Self::Stop => "STOP".to_string(),
            Self::MarketIfTouched => "MARKET_IF_TOUCHED".to_string(),
            Self::TakeProfit => "TAKE_PROFIT".to_string(),
            Self::StopLoss => "STOP_LOSS".to_string(),
            Self::TrailingStopLoss => "TRAILING_STOP_LOSS".to_string(),
            Self::FixedPrice => "FIXED_PRICE".to_string(),
        }
    }
}

impl std::str::FromStr for TakeProfitOrderRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "MARKET" => Ok(Self::Market),
            "LIMIT" => Ok(Self::Limit),
            "STOP" => Ok(Self::Stop),
            "MARKET_IF_TOUCHED" => Ok(Self::MarketIfTouched),
            "TAKE_PROFIT" => Ok(Self::TakeProfit),
            "STOP_LOSS" => Ok(Self::StopLoss),
            "TRAILING_STOP_LOSS" => Ok(Self::TrailingStopLoss),
            "FIXED_PRICE" => Ok(Self::FixedPrice),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TakeProfitOrderRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TakeProfitOrderRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TakeProfitOrderRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The current state of the Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The current state of the Order.",
///  "type": "string",
///  "enum": [
///    "PENDING",
///    "FILLED",
///    "TRIGGERED",
///    "CANCELLED"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TakeProfitOrderState {
    #[serde(rename = "PENDING")]
    Pending,
    #[serde(rename = "FILLED")]
    Filled,
    #[serde(rename = "TRIGGERED")]
    Triggered,
    #[serde(rename = "CANCELLED")]
    Cancelled,
}

impl From<&TakeProfitOrderState> for TakeProfitOrderState {
    fn from(value: &TakeProfitOrderState) -> Self {
        value.clone()
    }
}

impl ToString for TakeProfitOrderState {
    fn to_string(&self) -> String {
        match *self {
            Self::Pending => "PENDING".to_string(),
            Self::Filled => "FILLED".to_string(),
            Self::Triggered => "TRIGGERED".to_string(),
            Self::Cancelled => "CANCELLED".to_string(),
        }
    }
}

impl std::str::FromStr for TakeProfitOrderState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "PENDING" => Ok(Self::Pending),
            "FILLED" => Ok(Self::Filled),
            "TRIGGERED" => Ok(Self::Triggered),
            "CANCELLED" => Ok(Self::Cancelled),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TakeProfitOrderState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TakeProfitOrderState {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TakeProfitOrderState {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The time-in-force requested for the TakeProfit Order. Restricted to
/// "GTC", "GFD" and "GTD" for TakeProfit Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the TakeProfit Order.
/// Restricted to \"GTC\", \"GFD\" and \"GTD\" for TakeProfit Orders.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TakeProfitOrderTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&TakeProfitOrderTimeInForce> for TakeProfitOrderTimeInForce {
    fn from(value: &TakeProfitOrderTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for TakeProfitOrderTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for TakeProfitOrderTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TakeProfitOrderTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TakeProfitOrderTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TakeProfitOrderTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A TakeProfitOrderTransaction represents the creation of a TakeProfit
/// Order in the user's Account.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A TakeProfitOrderTransaction represents the creation of
/// a TakeProfit Order in the user's Account.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "cancellingTransactionID": {
///      "description": "The ID of the Transaction that cancels the replaced
/// Order (only provided if this Order replaces an existing Order).",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "clientTradeID": {
///      "description": "The client ID of the Trade to be closed when the
/// price threshold is breached.",
///      "type": "string"
///    },
///    "gtdTime": {
///      "description": "The date/time when the TakeProfit Order will be
/// cancelled if its timeInForce is \"GTD\".",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "orderFillTransactionID": {
///      "description": "The ID of the OrderFill Transaction that caused
/// this Order to be created (only provided if this Order was created
/// automatically when another Order was filled).",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "price": {
///      "description": "The price threshold specified for the TakeProfit
/// Order. The associated Trade will be closed by a market price that is
/// equal to or better than this threshold.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "reason": {
///      "description": "The reason that the Take Profit Order was
/// initiated",
///      "type": "string",
///      "enum": [
///        "CLIENT_ORDER",
///        "REPLACEMENT",
///        "ON_FILL"
///      ]
///    },
///    "replacesOrderID": {
///      "description": "The ID of the Order that this Order replaces (only
/// provided if this Order replaces an existing Order).",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the TakeProfit
/// Order. Restricted to \"GTC\", \"GFD\" and \"GTD\" for TakeProfit
/// Orders.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeID": {
///      "description": "The ID of the Trade to close when the price
/// threshold is breached.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "triggerCondition": {
///      "description": "Specification of which price component should be
/// used when determining if an Order should be triggered and filled. This
/// allows Orders to be triggered based on the bid, ask, mid, default (ask
/// for buy, bid for sell) or inverse (ask for sell, bid for buy) price
/// depending on the desired behaviour. Orders are always filled using their
/// default price component.\nThis feature is only provided through the REST
/// API. Clients who choose to specify a non-default trigger condition will
/// not see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///      "type": "string",
///      "enum": [
///        "DEFAULT",
///        "INVERSE",
///        "BID",
///        "ASK",
///        "MID"
///      ]
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"TAKE_PROFIT_ORDER\" in a TakeProfitOrderTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TakeProfitOrderTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    ///The ID of the Transaction that cancels the replaced Order (only
    /// provided if this Order replaces an existing Order).
    #[serde(
        rename = "cancellingTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The client ID of the Trade to be closed when the price threshold is
    /// breached.
    #[serde(
        rename = "clientTradeID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_trade_id: Option<String>,
    ///The date/time when the TakeProfit Order will be cancelled if its
    /// timeInForce is "GTD".
    #[serde(rename = "gtdTime", default, skip_serializing_if = "Option::is_none")]
    pub gtd_time: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The ID of the OrderFill Transaction that caused this Order to be
    /// created (only provided if this Order was created automatically when
    /// another Order was filled).
    #[serde(
        rename = "orderFillTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub order_fill_transaction_id: Option<String>,
    ///The price threshold specified for the TakeProfit Order. The
    /// associated Trade will be closed by a market price that is equal to
    /// or better than this threshold.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The reason that the Take Profit Order was initiated
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<TakeProfitOrderTransactionReason>,
    ///The ID of the Order that this Order replaces (only provided if this
    /// Order replaces an existing Order).
    #[serde(
        rename = "replacesOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub replaces_order_id: Option<String>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The time-in-force requested for the TakeProfit Order. Restricted to
    /// "GTC", "GFD" and "GTD" for TakeProfit Orders.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<TakeProfitOrderTransactionTimeInForce>,
    ///The ID of the Trade to close when the price threshold is breached.
    #[serde(rename = "tradeID", default, skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,
    ///Specification of which price component should be used when
    /// determining if an Order should be triggered and filled. This allows
    /// Orders to be triggered based on the bid, ask, mid, default (ask for
    /// buy, bid for sell) or inverse (ask for sell, bid for buy) price
    /// depending on the desired behaviour. Orders are always filled using
    /// their default price component. This feature is only provided
    /// through the REST API. Clients who choose to specify a non-default
    /// trigger condition will not see it reflected in any of OANDA's
    /// proprietary or partner trading platforms, their transaction history
    /// or their account statements. OANDA platforms always assume that an
    /// Order's trigger condition is set to the default value when
    /// indicating the distance from an Order's trigger price, and will
    /// always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when
    /// creating a guaranteed Stop Loss Order. In this case the
    /// TriggerCondition value must either be "DEFAULT", or the "natural"
    /// trigger side "DEFAULT" results in. So for a Stop Loss Order for a
    /// long trade valid values are "DEFAULT" and "BID", and for short
    /// trades "DEFAULT" and "ASK" are valid.
    #[serde(
        rename = "triggerCondition",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trigger_condition: Option<TakeProfitOrderTransactionTriggerCondition>,
    ///The Type of the Transaction. Always set to "TAKE_PROFIT_ORDER" in a
    /// TakeProfitOrderTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<TakeProfitOrderTransactionType>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&TakeProfitOrderTransaction> for TakeProfitOrderTransaction {
    fn from(value: &TakeProfitOrderTransaction) -> Self {
        value.clone()
    }
}

impl TakeProfitOrderTransaction {
    pub fn builder() -> builder::TakeProfitOrderTransaction {
        Default::default()
    }
}

///The reason that the Take Profit Order was initiated
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Take Profit Order was initiated",
///  "type": "string",
///  "enum": [
///    "CLIENT_ORDER",
///    "REPLACEMENT",
///    "ON_FILL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TakeProfitOrderTransactionReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "REPLACEMENT")]
    Replacement,
    #[serde(rename = "ON_FILL")]
    OnFill,
}

impl From<&TakeProfitOrderTransactionReason> for TakeProfitOrderTransactionReason {
    fn from(value: &TakeProfitOrderTransactionReason) -> Self {
        value.clone()
    }
}

impl ToString for TakeProfitOrderTransactionReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ClientOrder => "CLIENT_ORDER".to_string(),
            Self::Replacement => "REPLACEMENT".to_string(),
            Self::OnFill => "ON_FILL".to_string(),
        }
    }
}

impl std::str::FromStr for TakeProfitOrderTransactionReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CLIENT_ORDER" => Ok(Self::ClientOrder),
            "REPLACEMENT" => Ok(Self::Replacement),
            "ON_FILL" => Ok(Self::OnFill),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TakeProfitOrderTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TakeProfitOrderTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TakeProfitOrderTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The time-in-force requested for the TakeProfit Order. Restricted to
/// "GTC", "GFD" and "GTD" for TakeProfit Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the TakeProfit Order.
/// Restricted to \"GTC\", \"GFD\" and \"GTD\" for TakeProfit Orders.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TakeProfitOrderTransactionTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&TakeProfitOrderTransactionTimeInForce> for TakeProfitOrderTransactionTimeInForce {
    fn from(value: &TakeProfitOrderTransactionTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for TakeProfitOrderTransactionTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for TakeProfitOrderTransactionTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TakeProfitOrderTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TakeProfitOrderTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TakeProfitOrderTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///Specification of which price component should be used when determining
/// if an Order should be triggered and filled. This allows Orders to be
/// triggered based on the bid, ask, mid, default (ask for buy, bid for
/// sell) or inverse (ask for sell, bid for buy) price depending on the
/// desired behaviour. Orders are always filled using their default price
/// component. This feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order. A special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
/// results in. So for a Stop Loss Order for a long trade valid values are
/// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are valid.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of which price component should be used
/// when determining if an Order should be triggered and filled. This allows
/// Orders to be triggered based on the bid, ask, mid, default (ask for buy,
/// bid for sell) or inverse (ask for sell, bid for buy) price depending on
/// the desired behaviour. Orders are always filled using their default
/// price component.\nThis feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///  "type": "string",
///  "enum": [
///    "DEFAULT",
///    "INVERSE",
///    "BID",
///    "ASK",
///    "MID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TakeProfitOrderTransactionTriggerCondition {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "INVERSE")]
    Inverse,
    #[serde(rename = "BID")]
    Bid,
    #[serde(rename = "ASK")]
    Ask,
    #[serde(rename = "MID")]
    Mid,
}

impl From<&TakeProfitOrderTransactionTriggerCondition>
    for TakeProfitOrderTransactionTriggerCondition
{
    fn from(value: &TakeProfitOrderTransactionTriggerCondition) -> Self {
        value.clone()
    }
}

impl ToString for TakeProfitOrderTransactionTriggerCondition {
    fn to_string(&self) -> String {
        match *self {
            Self::Default => "DEFAULT".to_string(),
            Self::Inverse => "INVERSE".to_string(),
            Self::Bid => "BID".to_string(),
            Self::Ask => "ASK".to_string(),
            Self::Mid => "MID".to_string(),
        }
    }
}

impl std::str::FromStr for TakeProfitOrderTransactionTriggerCondition {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DEFAULT" => Ok(Self::Default),
            "INVERSE" => Ok(Self::Inverse),
            "BID" => Ok(Self::Bid),
            "ASK" => Ok(Self::Ask),
            "MID" => Ok(Self::Mid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TakeProfitOrderTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TakeProfitOrderTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TakeProfitOrderTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Type of the Transaction. Always set to "TAKE_PROFIT_ORDER" in a
/// TakeProfitOrderTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"TAKE_PROFIT_ORDER\" in a TakeProfitOrderTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TakeProfitOrderTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&TakeProfitOrderTransactionType> for TakeProfitOrderTransactionType {
    fn from(value: &TakeProfitOrderTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for TakeProfitOrderTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for TakeProfitOrderTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TakeProfitOrderTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TakeProfitOrderTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TakeProfitOrderTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///Specification of which price component should be used when determining
/// if an Order should be triggered and filled. This allows Orders to be
/// triggered based on the bid, ask, mid, default (ask for buy, bid for
/// sell) or inverse (ask for sell, bid for buy) price depending on the
/// desired behaviour. Orders are always filled using their default price
/// component. This feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order. A special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
/// results in. So for a Stop Loss Order for a long trade valid values are
/// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are valid.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of which price component should be used
/// when determining if an Order should be triggered and filled. This allows
/// Orders to be triggered based on the bid, ask, mid, default (ask for buy,
/// bid for sell) or inverse (ask for sell, bid for buy) price depending on
/// the desired behaviour. Orders are always filled using their default
/// price component.\nThis feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///  "type": "string",
///  "enum": [
///    "DEFAULT",
///    "INVERSE",
///    "BID",
///    "ASK",
///    "MID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TakeProfitOrderTriggerCondition {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "INVERSE")]
    Inverse,
    #[serde(rename = "BID")]
    Bid,
    #[serde(rename = "ASK")]
    Ask,
    #[serde(rename = "MID")]
    Mid,
}

impl From<&TakeProfitOrderTriggerCondition> for TakeProfitOrderTriggerCondition {
    fn from(value: &TakeProfitOrderTriggerCondition) -> Self {
        value.clone()
    }
}

impl ToString for TakeProfitOrderTriggerCondition {
    fn to_string(&self) -> String {
        match *self {
            Self::Default => "DEFAULT".to_string(),
            Self::Inverse => "INVERSE".to_string(),
            Self::Bid => "BID".to_string(),
            Self::Ask => "ASK".to_string(),
            Self::Mid => "MID".to_string(),
        }
    }
}

impl std::str::FromStr for TakeProfitOrderTriggerCondition {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DEFAULT" => Ok(Self::Default),
            "INVERSE" => Ok(Self::Inverse),
            "BID" => Ok(Self::Bid),
            "ASK" => Ok(Self::Ask),
            "MID" => Ok(Self::Mid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TakeProfitOrderTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TakeProfitOrderTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TakeProfitOrderTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The type of the Order. Always set to "TAKE_PROFIT" for Take Profit
/// Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The type of the Order. Always set to \"TAKE_PROFIT\"
/// for Take Profit Orders.",
///  "type": "string",
///  "enum": [
///    "MARKET",
///    "LIMIT",
///    "STOP",
///    "MARKET_IF_TOUCHED",
///    "TAKE_PROFIT",
///    "STOP_LOSS",
///    "TRAILING_STOP_LOSS",
///    "FIXED_PRICE"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TakeProfitOrderType {
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "STOP")]
    Stop,
    #[serde(rename = "MARKET_IF_TOUCHED")]
    MarketIfTouched,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "STOP_LOSS")]
    StopLoss,
    #[serde(rename = "TRAILING_STOP_LOSS")]
    TrailingStopLoss,
    #[serde(rename = "FIXED_PRICE")]
    FixedPrice,
}

impl From<&TakeProfitOrderType> for TakeProfitOrderType {
    fn from(value: &TakeProfitOrderType) -> Self {
        value.clone()
    }
}

impl ToString for TakeProfitOrderType {
    fn to_string(&self) -> String {
        match *self {
            Self::Market => "MARKET".to_string(),
            Self::Limit => "LIMIT".to_string(),
            Self::Stop => "STOP".to_string(),
            Self::MarketIfTouched => "MARKET_IF_TOUCHED".to_string(),
            Self::TakeProfit => "TAKE_PROFIT".to_string(),
            Self::StopLoss => "STOP_LOSS".to_string(),
            Self::TrailingStopLoss => "TRAILING_STOP_LOSS".to_string(),
            Self::FixedPrice => "FIXED_PRICE".to_string(),
        }
    }
}

impl std::str::FromStr for TakeProfitOrderType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "MARKET" => Ok(Self::Market),
            "LIMIT" => Ok(Self::Limit),
            "STOP" => Ok(Self::Stop),
            "MARKET_IF_TOUCHED" => Ok(Self::MarketIfTouched),
            "TAKE_PROFIT" => Ok(Self::TakeProfit),
            "STOP_LOSS" => Ok(Self::StopLoss),
            "TRAILING_STOP_LOSS" => Ok(Self::TrailingStopLoss),
            "FIXED_PRICE" => Ok(Self::FixedPrice),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TakeProfitOrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TakeProfitOrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TakeProfitOrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The time-in-force of an Order. TimeInForce describes how long an Order
/// should remain pending before being automatically cancelled by the
/// execution system.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force of an Order. TimeInForce describes
/// how long an Order should remain pending before being automatically
/// cancelled by the execution system.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&TimeInForce> for TimeInForce {
    fn from(value: &TimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for TimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for TimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The specification of a Trade within an Account. This includes the full
/// representation of the Trade's dependent Orders in addition to the IDs of
/// those Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The specification of a Trade within an Account. This
/// includes the full representation of the Trade's dependent Orders in
/// addition to the IDs of those Orders.",
///  "type": "object",
///  "properties": {
///    "averageClosePrice": {
///      "description": "The average closing price of the Trade. Only
/// present if the Trade has been closed or reduced at least once.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "closeTime": {
///      "description": "The date/time when the Trade was fully closed. Only
/// provided for Trades whose state is CLOSED.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "closingTransactionIDs": {
///      "description": "The IDs of the Transactions that have closed
/// portions of this Trade.",
///      "type": "array",
///      "items": {
///        "description": "The unique Transaction identifier within each
/// Account.",
///        "type": "string",
///        "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///      }
///    },
///    "currentUnits": {
///      "description": "The number of units currently open for the Trade.
/// This value is reduced to 0.0 as the Trade is closed.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "financing": {
///      "description": "The financing paid/collected for this Trade.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "id": {
///      "description": "The Trade's identifier, unique within the Trade's
/// Account.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "initialMarginRequired": {
///      "description": "The margin required at the time the Trade was
/// created. Note, this is the 'pure' margin required, it is not the
/// 'effective' margin used that factors in the trade risk if a GSLO is
/// attached to the trade.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "initialUnits": {
///      "description": "The initial size of the Trade. Negative values
/// indicate a short Trade, and positive values indicate a long Trade.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "instrument": {
///      "description": "The Trade's Instrument.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "marginUsed": {
///      "description": "Margin currently used by the Trade.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "openTime": {
///      "description": "The date/time when the Trade was opened.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "price": {
///      "description": "The execution price of the Trade.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "realizedPL": {
///      "description": "The total profit/loss realized on the closed
/// portion of the Trade.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "state": {
///      "description": "The current state of the Trade.",
///      "type": "string",
///      "enum": [
///        "OPEN",
///        "CLOSED",
///        "CLOSE_WHEN_TRADEABLE"
///      ]
///    },
///    "stopLossOrder": {
///      "$ref": "#/components/schemas/StopLossOrder"
///    },
///    "takeProfitOrder": {
///      "$ref": "#/components/schemas/TakeProfitOrder"
///    },
///    "trailingStopLossOrder": {
///      "$ref": "#/components/schemas/TrailingStopLossOrder"
///    },
///    "unrealizedPL": {
///      "description": "The unrealized profit/loss on the open portion of
/// the Trade.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Trade {
    ///The average closing price of the Trade. Only present if the Trade
    /// has been closed or reduced at least once.
    #[serde(
        rename = "averageClosePrice",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub average_close_price: Option<String>,
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The date/time when the Trade was fully closed. Only provided for
    /// Trades whose state is CLOSED.
    #[serde(rename = "closeTime", default, skip_serializing_if = "Option::is_none")]
    pub close_time: Option<String>,
    ///The IDs of the Transactions that have closed portions of this Trade.
    #[serde(
        rename = "closingTransactionIDs",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub closing_transaction_i_ds: Vec<String>,
    ///The number of units currently open for the Trade. This value is
    /// reduced to 0.0 as the Trade is closed.
    #[serde(
        rename = "currentUnits",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub current_units: Option<String>,
    ///The financing paid/collected for this Trade.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub financing: Option<String>,
    ///The Trade's identifier, unique within the Trade's Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The margin required at the time the Trade was created. Note, this is
    /// the 'pure' margin required, it is not the 'effective' margin used
    /// that factors in the trade risk if a GSLO is attached to the trade.
    #[serde(
        rename = "initialMarginRequired",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub initial_margin_required: Option<String>,
    ///The initial size of the Trade. Negative values indicate a short
    /// Trade, and positive values indicate a long Trade.
    #[serde(
        rename = "initialUnits",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub initial_units: Option<String>,
    ///The Trade's Instrument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    ///Margin currently used by the Trade.
    #[serde(
        rename = "marginUsed",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_used: Option<String>,
    ///The date/time when the Trade was opened.
    #[serde(rename = "openTime", default, skip_serializing_if = "Option::is_none")]
    pub open_time: Option<String>,
    ///The execution price of the Trade.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The total profit/loss realized on the closed portion of the Trade.
    #[serde(
        rename = "realizedPL",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub realized_pl: Option<String>,
    ///The current state of the Trade.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<TradeState>,
    #[serde(
        rename = "stopLossOrder",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stop_loss_order: Option<StopLossOrder>,
    #[serde(
        rename = "takeProfitOrder",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub take_profit_order: Option<TakeProfitOrder>,
    #[serde(
        rename = "trailingStopLossOrder",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_order: Option<TrailingStopLossOrder>,
    ///The unrealized profit/loss on the open portion of the Trade.
    #[serde(
        rename = "unrealizedPL",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub unrealized_pl: Option<String>,
}

impl From<&Trade> for Trade {
    fn from(value: &Trade) -> Self {
        value.clone()
    }
}

impl Trade {
    pub fn builder() -> builder::Trade {
        Default::default()
    }
}

///A TradeClientExtensionsModifyRejectTransaction represents the rejection
/// of the modification of a Trade's Client Extensions.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A TradeClientExtensionsModifyRejectTransaction
/// represents the rejection of the modification of a Trade's Client
/// Extensions.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientTradeID": {
///      "description": "The original Client ID of the Trade who's client
/// extensions are to be modified.",
///      "type": "string"
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "rejectReason": {
///      "description": "The reason that the Reject Transaction was
/// created",
///      "type": "string",
///      "enum": [
///        "INTERNAL_SERVER_ERROR",
///        "INSTRUMENT_PRICE_UNKNOWN",
///        "ACCOUNT_NOT_ACTIVE",
///        "ACCOUNT_LOCKED",
///        "ACCOUNT_ORDER_CREATION_LOCKED",
///        "ACCOUNT_CONFIGURATION_LOCKED",
///        "ACCOUNT_DEPOSIT_LOCKED",
///        "ACCOUNT_WITHDRAWAL_LOCKED",
///        "ACCOUNT_ORDER_CANCEL_LOCKED",
///        "INSTRUMENT_NOT_TRADEABLE",
///        "PENDING_ORDERS_ALLOWED_EXCEEDED",
///        "ORDER_ID_UNSPECIFIED",
///        "ORDER_DOESNT_EXIST",
///        "ORDER_IDENTIFIER_INCONSISTENCY",
///        "TRADE_ID_UNSPECIFIED",
///        "TRADE_DOESNT_EXIST",
///        "TRADE_IDENTIFIER_INCONSISTENCY",
///        "INSUFFICIENT_MARGIN",
///        "INSTRUMENT_MISSING",
///        "INSTRUMENT_UNKNOWN",
///        "UNITS_MISSING",
///        "UNITS_INVALID",
///        "UNITS_PRECISION_EXCEEDED",
///        "UNITS_LIMIT_EXCEEDED",
///        "UNITS_MIMIMUM_NOT_MET",
///        "PRICE_MISSING",
///        "PRICE_INVALID",
///        "PRICE_PRECISION_EXCEEDED",
///        "PRICE_DISTANCE_MISSING",
///        "PRICE_DISTANCE_INVALID",
///        "PRICE_DISTANCE_PRECISION_EXCEEDED",
///        "PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "PRICE_DISTANCE_MINIMUM_NOT_MET",
///        "TIME_IN_FORCE_MISSING",
///        "TIME_IN_FORCE_INVALID",
///        "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING",
///        "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST",
///        "PRICE_BOUND_INVALID",
///        "PRICE_BOUND_PRECISION_EXCEEDED",
///        "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS",
///        "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED",
///        "CLIENT_ORDER_ID_INVALID",
///        "CLIENT_ORDER_ID_ALREADY_EXISTS",
///        "CLIENT_ORDER_TAG_INVALID",
///        "CLIENT_ORDER_COMMENT_INVALID",
///        "CLIENT_TRADE_ID_INVALID",
///        "CLIENT_TRADE_ID_ALREADY_EXISTS",
///        "CLIENT_TRADE_TAG_INVALID",
///        "CLIENT_TRADE_COMMENT_INVALID",
///        "ORDER_FILL_POSITION_ACTION_MISSING",
///        "ORDER_FILL_POSITION_ACTION_INVALID",
///        "TRIGGER_CONDITION_MISSING",
///        "TRIGGER_CONDITION_INVALID",
///        "ORDER_PARTIAL_FILL_OPTION_MISSING",
///        "ORDER_PARTIAL_FILL_OPTION_INVALID",
///        "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL",
///        "TAKE_PROFIT_ORDER_ALREADY_EXISTS",
///        "TAKE_PROFIT_ON_FILL_PRICE_MISSING",
///        "TAKE_PROFIT_ON_FILL_PRICE_INVALID",
///        "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED",
///        "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING",
///        "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID",
///        "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "STOP_LOSS_ORDER_ALREADY_EXISTS",
///        "STOP_LOSS_ORDER_GUARANTEED_REQUIRED",
///        "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD",
///        "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED",
///        "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION",
///        "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION",
///        "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED",
///        "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///        "STOP_LOSS_ORDER_NOT_CANCELABLE",
///        "STOP_LOSS_ORDER_NOT_REPLACEABLE",
///        "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///        "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///        "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING",
///        "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER",
///        "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///        "STOP_LOSS_ON_FILL_PRICE_MISSING",
///        "STOP_LOSS_ON_FILL_PRICE_INVALID",
///        "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///        "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_DISTANCE_INVALID",
///        "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///        "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING",
///        "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///        "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///        "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET",
///        "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED",
///        "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "CLOSE_TRADE_TYPE_MISSING",
///        "CLOSE_TRADE_PARTIAL_UNITS_MISSING",
///        "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE",
///        "CLOSEOUT_POSITION_DOESNT_EXIST",
///        "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION",
///        "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE",
///        "CLOSEOUT_POSITION_REJECT",
///        "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING",
///        "MARKUP_GROUP_ID_INVALID",
///        "POSITION_AGGREGATION_MODE_INVALID",
///        "ADMIN_CONFIGURE_DATA_MISSING",
///        "MARGIN_RATE_INVALID",
///        "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT",
///        "ALIAS_INVALID",
///        "CLIENT_CONFIGURE_DATA_MISSING",
///        "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL",
///        "AMOUNT_INVALID",
///        "INSUFFICIENT_FUNDS",
///        "AMOUNT_MISSING",
///        "FUNDING_REASON_MISSING",
///        "CLIENT_EXTENSIONS_DATA_MISSING",
///        "REPLACING_ORDER_INVALID",
///        "REPLACING_TRADE_ID_INVALID"
///      ]
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "tradeClientExtensionsModify": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "tradeID": {
///      "description": "The ID of the Trade who's client extensions are to
/// be modified.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT\" for a
/// TradeClientExtensionsModifyRejectTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TradeClientExtensionsModifyRejectTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    ///The original Client ID of the Trade who's client extensions are to
    /// be modified.
    #[serde(
        rename = "clientTradeID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_trade_id: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The reason that the Reject Transaction was created
    #[serde(
        rename = "rejectReason",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub reject_reason: Option<TradeClientExtensionsModifyRejectTransactionRejectReason>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    #[serde(
        rename = "tradeClientExtensionsModify",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions_modify: Option<ClientExtensions>,
    ///The ID of the Trade who's client extensions are to be modified.
    #[serde(rename = "tradeID", default, skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,
    ///The Type of the Transaction. Always set to
    /// "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" for a
    /// TradeClientExtensionsModifyRejectTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<TradeClientExtensionsModifyRejectTransactionType>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&TradeClientExtensionsModifyRejectTransaction>
    for TradeClientExtensionsModifyRejectTransaction
{
    fn from(value: &TradeClientExtensionsModifyRejectTransaction) -> Self {
        value.clone()
    }
}

impl TradeClientExtensionsModifyRejectTransaction {
    pub fn builder() -> builder::TradeClientExtensionsModifyRejectTransaction {
        Default::default()
    }
}

///The reason that the Reject Transaction was created
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Reject Transaction was created",
///  "type": "string",
///  "enum": [
///    "INTERNAL_SERVER_ERROR",
///    "INSTRUMENT_PRICE_UNKNOWN",
///    "ACCOUNT_NOT_ACTIVE",
///    "ACCOUNT_LOCKED",
///    "ACCOUNT_ORDER_CREATION_LOCKED",
///    "ACCOUNT_CONFIGURATION_LOCKED",
///    "ACCOUNT_DEPOSIT_LOCKED",
///    "ACCOUNT_WITHDRAWAL_LOCKED",
///    "ACCOUNT_ORDER_CANCEL_LOCKED",
///    "INSTRUMENT_NOT_TRADEABLE",
///    "PENDING_ORDERS_ALLOWED_EXCEEDED",
///    "ORDER_ID_UNSPECIFIED",
///    "ORDER_DOESNT_EXIST",
///    "ORDER_IDENTIFIER_INCONSISTENCY",
///    "TRADE_ID_UNSPECIFIED",
///    "TRADE_DOESNT_EXIST",
///    "TRADE_IDENTIFIER_INCONSISTENCY",
///    "INSUFFICIENT_MARGIN",
///    "INSTRUMENT_MISSING",
///    "INSTRUMENT_UNKNOWN",
///    "UNITS_MISSING",
///    "UNITS_INVALID",
///    "UNITS_PRECISION_EXCEEDED",
///    "UNITS_LIMIT_EXCEEDED",
///    "UNITS_MIMIMUM_NOT_MET",
///    "PRICE_MISSING",
///    "PRICE_INVALID",
///    "PRICE_PRECISION_EXCEEDED",
///    "PRICE_DISTANCE_MISSING",
///    "PRICE_DISTANCE_INVALID",
///    "PRICE_DISTANCE_PRECISION_EXCEEDED",
///    "PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "PRICE_DISTANCE_MINIMUM_NOT_MET",
///    "TIME_IN_FORCE_MISSING",
///    "TIME_IN_FORCE_INVALID",
///    "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING",
///    "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST",
///    "PRICE_BOUND_INVALID",
///    "PRICE_BOUND_PRECISION_EXCEEDED",
///    "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS",
///    "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED",
///    "CLIENT_ORDER_ID_INVALID",
///    "CLIENT_ORDER_ID_ALREADY_EXISTS",
///    "CLIENT_ORDER_TAG_INVALID",
///    "CLIENT_ORDER_COMMENT_INVALID",
///    "CLIENT_TRADE_ID_INVALID",
///    "CLIENT_TRADE_ID_ALREADY_EXISTS",
///    "CLIENT_TRADE_TAG_INVALID",
///    "CLIENT_TRADE_COMMENT_INVALID",
///    "ORDER_FILL_POSITION_ACTION_MISSING",
///    "ORDER_FILL_POSITION_ACTION_INVALID",
///    "TRIGGER_CONDITION_MISSING",
///    "TRIGGER_CONDITION_INVALID",
///    "ORDER_PARTIAL_FILL_OPTION_MISSING",
///    "ORDER_PARTIAL_FILL_OPTION_INVALID",
///    "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL",
///    "TAKE_PROFIT_ORDER_ALREADY_EXISTS",
///    "TAKE_PROFIT_ON_FILL_PRICE_MISSING",
///    "TAKE_PROFIT_ON_FILL_PRICE_INVALID",
///    "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED",
///    "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING",
///    "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "STOP_LOSS_ORDER_ALREADY_EXISTS",
///    "STOP_LOSS_ORDER_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD",
///    "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION",
///    "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION",
///    "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED",
///    "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ORDER_NOT_CANCELABLE",
///    "STOP_LOSS_ORDER_NOT_REPLACEABLE",
///    "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///    "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING",
///    "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER",
///    "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ON_FILL_PRICE_MISSING",
///    "STOP_LOSS_ON_FILL_PRICE_INVALID",
///    "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_DISTANCE_INVALID",
///    "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///    "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET",
///    "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED",
///    "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "CLOSE_TRADE_TYPE_MISSING",
///    "CLOSE_TRADE_PARTIAL_UNITS_MISSING",
///    "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE",
///    "CLOSEOUT_POSITION_DOESNT_EXIST",
///    "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION",
///    "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE",
///    "CLOSEOUT_POSITION_REJECT",
///    "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING",
///    "MARKUP_GROUP_ID_INVALID",
///    "POSITION_AGGREGATION_MODE_INVALID",
///    "ADMIN_CONFIGURE_DATA_MISSING",
///    "MARGIN_RATE_INVALID",
///    "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT",
///    "ALIAS_INVALID",
///    "CLIENT_CONFIGURE_DATA_MISSING",
///    "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL",
///    "AMOUNT_INVALID",
///    "INSUFFICIENT_FUNDS",
///    "AMOUNT_MISSING",
///    "FUNDING_REASON_MISSING",
///    "CLIENT_EXTENSIONS_DATA_MISSING",
///    "REPLACING_ORDER_INVALID",
///    "REPLACING_TRADE_ID_INVALID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TradeClientExtensionsModifyRejectTransactionRejectReason {
    #[serde(rename = "INTERNAL_SERVER_ERROR")]
    InternalServerError,
    #[serde(rename = "INSTRUMENT_PRICE_UNKNOWN")]
    InstrumentPriceUnknown,
    #[serde(rename = "ACCOUNT_NOT_ACTIVE")]
    AccountNotActive,
    #[serde(rename = "ACCOUNT_LOCKED")]
    AccountLocked,
    #[serde(rename = "ACCOUNT_ORDER_CREATION_LOCKED")]
    AccountOrderCreationLocked,
    #[serde(rename = "ACCOUNT_CONFIGURATION_LOCKED")]
    AccountConfigurationLocked,
    #[serde(rename = "ACCOUNT_DEPOSIT_LOCKED")]
    AccountDepositLocked,
    #[serde(rename = "ACCOUNT_WITHDRAWAL_LOCKED")]
    AccountWithdrawalLocked,
    #[serde(rename = "ACCOUNT_ORDER_CANCEL_LOCKED")]
    AccountOrderCancelLocked,
    #[serde(rename = "INSTRUMENT_NOT_TRADEABLE")]
    InstrumentNotTradeable,
    #[serde(rename = "PENDING_ORDERS_ALLOWED_EXCEEDED")]
    PendingOrdersAllowedExceeded,
    #[serde(rename = "ORDER_ID_UNSPECIFIED")]
    OrderIdUnspecified,
    #[serde(rename = "ORDER_DOESNT_EXIST")]
    OrderDoesntExist,
    #[serde(rename = "ORDER_IDENTIFIER_INCONSISTENCY")]
    OrderIdentifierInconsistency,
    #[serde(rename = "TRADE_ID_UNSPECIFIED")]
    TradeIdUnspecified,
    #[serde(rename = "TRADE_DOESNT_EXIST")]
    TradeDoesntExist,
    #[serde(rename = "TRADE_IDENTIFIER_INCONSISTENCY")]
    TradeIdentifierInconsistency,
    #[serde(rename = "INSUFFICIENT_MARGIN")]
    InsufficientMargin,
    #[serde(rename = "INSTRUMENT_MISSING")]
    InstrumentMissing,
    #[serde(rename = "INSTRUMENT_UNKNOWN")]
    InstrumentUnknown,
    #[serde(rename = "UNITS_MISSING")]
    UnitsMissing,
    #[serde(rename = "UNITS_INVALID")]
    UnitsInvalid,
    #[serde(rename = "UNITS_PRECISION_EXCEEDED")]
    UnitsPrecisionExceeded,
    #[serde(rename = "UNITS_LIMIT_EXCEEDED")]
    UnitsLimitExceeded,
    #[serde(rename = "UNITS_MIMIMUM_NOT_MET")]
    UnitsMimimumNotMet,
    #[serde(rename = "PRICE_MISSING")]
    PriceMissing,
    #[serde(rename = "PRICE_INVALID")]
    PriceInvalid,
    #[serde(rename = "PRICE_PRECISION_EXCEEDED")]
    PricePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MISSING")]
    PriceDistanceMissing,
    #[serde(rename = "PRICE_DISTANCE_INVALID")]
    PriceDistanceInvalid,
    #[serde(rename = "PRICE_DISTANCE_PRECISION_EXCEEDED")]
    PriceDistancePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    PriceDistanceMaximumExceeded,
    #[serde(rename = "PRICE_DISTANCE_MINIMUM_NOT_MET")]
    PriceDistanceMinimumNotMet,
    #[serde(rename = "TIME_IN_FORCE_MISSING")]
    TimeInForceMissing,
    #[serde(rename = "TIME_IN_FORCE_INVALID")]
    TimeInForceInvalid,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING")]
    TimeInForceGtdTimestampMissing,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST")]
    TimeInForceGtdTimestampInPast,
    #[serde(rename = "PRICE_BOUND_INVALID")]
    PriceBoundInvalid,
    #[serde(rename = "PRICE_BOUND_PRECISION_EXCEEDED")]
    PriceBoundPrecisionExceeded,
    #[serde(rename = "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS")]
    OrdersOnFillDuplicateClientOrderIds,
    #[serde(rename = "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED")]
    TradeOnFillClientExtensionsNotSupported,
    #[serde(rename = "CLIENT_ORDER_ID_INVALID")]
    ClientOrderIdInvalid,
    #[serde(rename = "CLIENT_ORDER_ID_ALREADY_EXISTS")]
    ClientOrderIdAlreadyExists,
    #[serde(rename = "CLIENT_ORDER_TAG_INVALID")]
    ClientOrderTagInvalid,
    #[serde(rename = "CLIENT_ORDER_COMMENT_INVALID")]
    ClientOrderCommentInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_INVALID")]
    ClientTradeIdInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_ALREADY_EXISTS")]
    ClientTradeIdAlreadyExists,
    #[serde(rename = "CLIENT_TRADE_TAG_INVALID")]
    ClientTradeTagInvalid,
    #[serde(rename = "CLIENT_TRADE_COMMENT_INVALID")]
    ClientTradeCommentInvalid,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_MISSING")]
    OrderFillPositionActionMissing,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_INVALID")]
    OrderFillPositionActionInvalid,
    #[serde(rename = "TRIGGER_CONDITION_MISSING")]
    TriggerConditionMissing,
    #[serde(rename = "TRIGGER_CONDITION_INVALID")]
    TriggerConditionInvalid,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_MISSING")]
    OrderPartialFillOptionMissing,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_INVALID")]
    OrderPartialFillOptionInvalid,
    #[serde(rename = "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL")]
    InvalidReissueImmediatePartialFill,
    #[serde(rename = "TAKE_PROFIT_ORDER_ALREADY_EXISTS")]
    TakeProfitOrderAlreadyExists,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_MISSING")]
    TakeProfitOnFillPriceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_INVALID")]
    TakeProfitOnFillPriceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    TakeProfitOnFillPricePrecisionExceeded,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING")]
    TakeProfitOnFillTimeInForceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID")]
    TakeProfitOnFillTimeInForceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TakeProfitOnFillGtdTimestampMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TakeProfitOnFillGtdTimestampInPast,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TakeProfitOnFillClientOrderIdInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TakeProfitOnFillClientOrderTagInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TakeProfitOnFillClientOrderCommentInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TakeProfitOnFillTriggerConditionMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TakeProfitOnFillTriggerConditionInvalid,
    #[serde(rename = "STOP_LOSS_ORDER_ALREADY_EXISTS")]
    StopLossOrderAlreadyExists,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_REQUIRED")]
    StopLossOrderGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD")]
    StopLossOrderGuaranteedPriceWithinSpread,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED")]
    StopLossOrderGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION")]
    StopLossOrderGuaranteedHaltedCreateViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION")]
    StopLossOrderGuaranteedHaltedTightenViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED")]
    StopLossOrderGuaranteedHedgingNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOrderGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_CANCELABLE")]
    StopLossOrderNotCancelable,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_REPLACEABLE")]
    StopLossOrderNotReplaceable,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOrderGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOrderPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOrderPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER")]
    StopLossOnFillRequiredForPendingOrder,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED")]
    StopLossOnFillGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED")]
    StopLossOnFillGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_MISSING")]
    StopLossOnFillPriceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_INVALID")]
    StopLossOnFillPriceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    StopLossOnFillPricePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOnFillGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOnFillGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_INVALID")]
    StopLossOnFillDistanceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    StopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED")]
    StopLossOnFillDistancePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOnFillPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOnFillPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    StopLossOnFillTimeInForceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    StopLossOnFillTimeInForceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    StopLossOnFillGtdTimestampMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    StopLossOnFillGtdTimestampInPast,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    StopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    StopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    StopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    StopLossOnFillTriggerConditionMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    StopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS")]
    TrailingStopLossOrderAlreadyExists,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING")]
    TrailingStopLossOnFillPriceDistanceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID")]
    TrailingStopLossOnFillPriceDistanceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED")]
    TrailingStopLossOnFillPriceDistancePrecisionExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    TrailingStopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET")]
    TrailingStopLossOnFillPriceDistanceMinimumNotMet,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    TrailingStopLossOnFillTimeInForceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    TrailingStopLossOnFillTimeInForceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TrailingStopLossOnFillGtdTimestampMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TrailingStopLossOnFillGtdTimestampInPast,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TrailingStopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TrailingStopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TrailingStopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED")]
    TrailingStopLossOrdersNotSupported,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TrailingStopLossOnFillTriggerConditionMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TrailingStopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "CLOSE_TRADE_TYPE_MISSING")]
    CloseTradeTypeMissing,
    #[serde(rename = "CLOSE_TRADE_PARTIAL_UNITS_MISSING")]
    CloseTradePartialUnitsMissing,
    #[serde(rename = "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE")]
    CloseTradeUnitsExceedTradeSize,
    #[serde(rename = "CLOSEOUT_POSITION_DOESNT_EXIST")]
    CloseoutPositionDoesntExist,
    #[serde(rename = "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION")]
    CloseoutPositionIncompleteSpecification,
    #[serde(rename = "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE")]
    CloseoutPositionUnitsExceedPositionSize,
    #[serde(rename = "CLOSEOUT_POSITION_REJECT")]
    CloseoutPositionReject,
    #[serde(rename = "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING")]
    CloseoutPositionPartialUnitsMissing,
    #[serde(rename = "MARKUP_GROUP_ID_INVALID")]
    MarkupGroupIdInvalid,
    #[serde(rename = "POSITION_AGGREGATION_MODE_INVALID")]
    PositionAggregationModeInvalid,
    #[serde(rename = "ADMIN_CONFIGURE_DATA_MISSING")]
    AdminConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_INVALID")]
    MarginRateInvalid,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT")]
    MarginRateWouldTriggerCloseout,
    #[serde(rename = "ALIAS_INVALID")]
    AliasInvalid,
    #[serde(rename = "CLIENT_CONFIGURE_DATA_MISSING")]
    ClientConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL")]
    MarginRateWouldTriggerMarginCall,
    #[serde(rename = "AMOUNT_INVALID")]
    AmountInvalid,
    #[serde(rename = "INSUFFICIENT_FUNDS")]
    InsufficientFunds,
    #[serde(rename = "AMOUNT_MISSING")]
    AmountMissing,
    #[serde(rename = "FUNDING_REASON_MISSING")]
    FundingReasonMissing,
    #[serde(rename = "CLIENT_EXTENSIONS_DATA_MISSING")]
    ClientExtensionsDataMissing,
    #[serde(rename = "REPLACING_ORDER_INVALID")]
    ReplacingOrderInvalid,
    #[serde(rename = "REPLACING_TRADE_ID_INVALID")]
    ReplacingTradeIdInvalid,
}

impl From<&TradeClientExtensionsModifyRejectTransactionRejectReason>
    for TradeClientExtensionsModifyRejectTransactionRejectReason
{
    fn from(value: &TradeClientExtensionsModifyRejectTransactionRejectReason) -> Self {
        value.clone()
    }
}

impl ToString for TradeClientExtensionsModifyRejectTransactionRejectReason {
    fn to_string(&self) -> String {
        match *self {
            Self::InternalServerError => "INTERNAL_SERVER_ERROR".to_string(),
            Self::InstrumentPriceUnknown => "INSTRUMENT_PRICE_UNKNOWN".to_string(),
            Self::AccountNotActive => "ACCOUNT_NOT_ACTIVE".to_string(),
            Self::AccountLocked => "ACCOUNT_LOCKED".to_string(),
            Self::AccountOrderCreationLocked => "ACCOUNT_ORDER_CREATION_LOCKED".to_string(),
            Self::AccountConfigurationLocked => "ACCOUNT_CONFIGURATION_LOCKED".to_string(),
            Self::AccountDepositLocked => "ACCOUNT_DEPOSIT_LOCKED".to_string(),
            Self::AccountWithdrawalLocked => "ACCOUNT_WITHDRAWAL_LOCKED".to_string(),
            Self::AccountOrderCancelLocked => "ACCOUNT_ORDER_CANCEL_LOCKED".to_string(),
            Self::InstrumentNotTradeable => "INSTRUMENT_NOT_TRADEABLE".to_string(),
            Self::PendingOrdersAllowedExceeded => "PENDING_ORDERS_ALLOWED_EXCEEDED".to_string(),
            Self::OrderIdUnspecified => "ORDER_ID_UNSPECIFIED".to_string(),
            Self::OrderDoesntExist => "ORDER_DOESNT_EXIST".to_string(),
            Self::OrderIdentifierInconsistency => "ORDER_IDENTIFIER_INCONSISTENCY".to_string(),
            Self::TradeIdUnspecified => "TRADE_ID_UNSPECIFIED".to_string(),
            Self::TradeDoesntExist => "TRADE_DOESNT_EXIST".to_string(),
            Self::TradeIdentifierInconsistency => "TRADE_IDENTIFIER_INCONSISTENCY".to_string(),
            Self::InsufficientMargin => "INSUFFICIENT_MARGIN".to_string(),
            Self::InstrumentMissing => "INSTRUMENT_MISSING".to_string(),
            Self::InstrumentUnknown => "INSTRUMENT_UNKNOWN".to_string(),
            Self::UnitsMissing => "UNITS_MISSING".to_string(),
            Self::UnitsInvalid => "UNITS_INVALID".to_string(),
            Self::UnitsPrecisionExceeded => "UNITS_PRECISION_EXCEEDED".to_string(),
            Self::UnitsLimitExceeded => "UNITS_LIMIT_EXCEEDED".to_string(),
            Self::UnitsMimimumNotMet => "UNITS_MIMIMUM_NOT_MET".to_string(),
            Self::PriceMissing => "PRICE_MISSING".to_string(),
            Self::PriceInvalid => "PRICE_INVALID".to_string(),
            Self::PricePrecisionExceeded => "PRICE_PRECISION_EXCEEDED".to_string(),
            Self::PriceDistanceMissing => "PRICE_DISTANCE_MISSING".to_string(),
            Self::PriceDistanceInvalid => "PRICE_DISTANCE_INVALID".to_string(),
            Self::PriceDistancePrecisionExceeded => "PRICE_DISTANCE_PRECISION_EXCEEDED".to_string(),
            Self::PriceDistanceMaximumExceeded => "PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string(),
            Self::PriceDistanceMinimumNotMet => "PRICE_DISTANCE_MINIMUM_NOT_MET".to_string(),
            Self::TimeInForceMissing => "TIME_IN_FORCE_MISSING".to_string(),
            Self::TimeInForceInvalid => "TIME_IN_FORCE_INVALID".to_string(),
            Self::TimeInForceGtdTimestampMissing => {
                "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TimeInForceGtdTimestampInPast => {
                "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::PriceBoundInvalid => "PRICE_BOUND_INVALID".to_string(),
            Self::PriceBoundPrecisionExceeded => "PRICE_BOUND_PRECISION_EXCEEDED".to_string(),
            Self::OrdersOnFillDuplicateClientOrderIds => {
                "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS".to_string()
            }
            Self::TradeOnFillClientExtensionsNotSupported => {
                "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED".to_string()
            }
            Self::ClientOrderIdInvalid => "CLIENT_ORDER_ID_INVALID".to_string(),
            Self::ClientOrderIdAlreadyExists => "CLIENT_ORDER_ID_ALREADY_EXISTS".to_string(),
            Self::ClientOrderTagInvalid => "CLIENT_ORDER_TAG_INVALID".to_string(),
            Self::ClientOrderCommentInvalid => "CLIENT_ORDER_COMMENT_INVALID".to_string(),
            Self::ClientTradeIdInvalid => "CLIENT_TRADE_ID_INVALID".to_string(),
            Self::ClientTradeIdAlreadyExists => "CLIENT_TRADE_ID_ALREADY_EXISTS".to_string(),
            Self::ClientTradeTagInvalid => "CLIENT_TRADE_TAG_INVALID".to_string(),
            Self::ClientTradeCommentInvalid => "CLIENT_TRADE_COMMENT_INVALID".to_string(),
            Self::OrderFillPositionActionMissing => {
                "ORDER_FILL_POSITION_ACTION_MISSING".to_string()
            }
            Self::OrderFillPositionActionInvalid => {
                "ORDER_FILL_POSITION_ACTION_INVALID".to_string()
            }
            Self::TriggerConditionMissing => "TRIGGER_CONDITION_MISSING".to_string(),
            Self::TriggerConditionInvalid => "TRIGGER_CONDITION_INVALID".to_string(),
            Self::OrderPartialFillOptionMissing => "ORDER_PARTIAL_FILL_OPTION_MISSING".to_string(),
            Self::OrderPartialFillOptionInvalid => "ORDER_PARTIAL_FILL_OPTION_INVALID".to_string(),
            Self::InvalidReissueImmediatePartialFill => {
                "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL".to_string()
            }
            Self::TakeProfitOrderAlreadyExists => "TAKE_PROFIT_ORDER_ALREADY_EXISTS".to_string(),
            Self::TakeProfitOnFillPriceMissing => "TAKE_PROFIT_ON_FILL_PRICE_MISSING".to_string(),
            Self::TakeProfitOnFillPriceInvalid => "TAKE_PROFIT_ON_FILL_PRICE_INVALID".to_string(),
            Self::TakeProfitOnFillPricePrecisionExceeded => {
                "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED".to_string()
            }
            Self::TakeProfitOnFillTimeInForceMissing => {
                "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::TakeProfitOnFillTimeInForceInvalid => {
                "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::TakeProfitOnFillGtdTimestampMissing => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TakeProfitOnFillGtdTimestampInPast => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TakeProfitOnFillClientOrderIdInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::TakeProfitOnFillClientOrderTagInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::TakeProfitOnFillClientOrderCommentInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::TakeProfitOnFillTriggerConditionMissing => {
                "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::TakeProfitOnFillTriggerConditionInvalid => {
                "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::StopLossOrderAlreadyExists => "STOP_LOSS_ORDER_ALREADY_EXISTS".to_string(),
            Self::StopLossOrderGuaranteedRequired => {
                "STOP_LOSS_ORDER_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOrderGuaranteedPriceWithinSpread => {
                "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD".to_string()
            }
            Self::StopLossOrderGuaranteedNotAllowed => {
                "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOrderGuaranteedHaltedCreateViolation => {
                "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION".to_string()
            }
            Self::StopLossOrderGuaranteedHaltedTightenViolation => {
                "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION".to_string()
            }
            Self::StopLossOrderGuaranteedHedgingNotAllowed => {
                "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED".to_string()
            }
            Self::StopLossOrderGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOrderNotCancelable => "STOP_LOSS_ORDER_NOT_CANCELABLE".to_string(),
            Self::StopLossOrderNotReplaceable => "STOP_LOSS_ORDER_NOT_REPLACEABLE".to_string(),
            Self::StopLossOrderGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOrderPriceAndDistanceBothSpecified => {
                "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED".to_string()
            }
            Self::StopLossOrderPriceAndDistanceBothMissing => {
                "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING".to_string()
            }
            Self::StopLossOnFillRequiredForPendingOrder => {
                "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER".to_string()
            }
            Self::StopLossOnFillGuaranteedNotAllowed => {
                "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOnFillGuaranteedRequired => {
                "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOnFillPriceMissing => "STOP_LOSS_ON_FILL_PRICE_MISSING".to_string(),
            Self::StopLossOnFillPriceInvalid => "STOP_LOSS_ON_FILL_PRICE_INVALID".to_string(),
            Self::StopLossOnFillPricePrecisionExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOnFillGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillDistanceInvalid => "STOP_LOSS_ON_FILL_DISTANCE_INVALID".to_string(),
            Self::StopLossOnFillPriceDistanceMaximumExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::StopLossOnFillDistancePrecisionExceeded => {
                "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillPriceAndDistanceBothSpecified => {
                "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED".to_string()
            }
            Self::StopLossOnFillPriceAndDistanceBothMissing => {
                "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING".to_string()
            }
            Self::StopLossOnFillTimeInForceMissing => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::StopLossOnFillTimeInForceInvalid => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::StopLossOnFillGtdTimestampMissing => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::StopLossOnFillGtdTimestampInPast => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::StopLossOnFillClientOrderIdInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::StopLossOnFillClientOrderTagInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::StopLossOnFillClientOrderCommentInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::StopLossOnFillTriggerConditionMissing => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::StopLossOnFillTriggerConditionInvalid => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::TrailingStopLossOrderAlreadyExists => {
                "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistancePrecisionExceeded => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMaximumExceeded => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMinimumNotMet => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET".to_string()
            }
            Self::TrailingStopLossOnFillTimeInForceMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillTimeInForceInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampInPast => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderIdInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderTagInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderCommentInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::TrailingStopLossOrdersNotSupported => {
                "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED".to_string()
            }
            Self::TrailingStopLossOnFillTriggerConditionMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillTriggerConditionInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::CloseTradeTypeMissing => "CLOSE_TRADE_TYPE_MISSING".to_string(),
            Self::CloseTradePartialUnitsMissing => "CLOSE_TRADE_PARTIAL_UNITS_MISSING".to_string(),
            Self::CloseTradeUnitsExceedTradeSize => {
                "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE".to_string()
            }
            Self::CloseoutPositionDoesntExist => "CLOSEOUT_POSITION_DOESNT_EXIST".to_string(),
            Self::CloseoutPositionIncompleteSpecification => {
                "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION".to_string()
            }
            Self::CloseoutPositionUnitsExceedPositionSize => {
                "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE".to_string()
            }
            Self::CloseoutPositionReject => "CLOSEOUT_POSITION_REJECT".to_string(),
            Self::CloseoutPositionPartialUnitsMissing => {
                "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING".to_string()
            }
            Self::MarkupGroupIdInvalid => "MARKUP_GROUP_ID_INVALID".to_string(),
            Self::PositionAggregationModeInvalid => "POSITION_AGGREGATION_MODE_INVALID".to_string(),
            Self::AdminConfigureDataMissing => "ADMIN_CONFIGURE_DATA_MISSING".to_string(),
            Self::MarginRateInvalid => "MARGIN_RATE_INVALID".to_string(),
            Self::MarginRateWouldTriggerCloseout => {
                "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT".to_string()
            }
            Self::AliasInvalid => "ALIAS_INVALID".to_string(),
            Self::ClientConfigureDataMissing => "CLIENT_CONFIGURE_DATA_MISSING".to_string(),
            Self::MarginRateWouldTriggerMarginCall => {
                "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL".to_string()
            }
            Self::AmountInvalid => "AMOUNT_INVALID".to_string(),
            Self::InsufficientFunds => "INSUFFICIENT_FUNDS".to_string(),
            Self::AmountMissing => "AMOUNT_MISSING".to_string(),
            Self::FundingReasonMissing => "FUNDING_REASON_MISSING".to_string(),
            Self::ClientExtensionsDataMissing => "CLIENT_EXTENSIONS_DATA_MISSING".to_string(),
            Self::ReplacingOrderInvalid => "REPLACING_ORDER_INVALID".to_string(),
            Self::ReplacingTradeIdInvalid => "REPLACING_TRADE_ID_INVALID".to_string(),
        }
    }
}

impl std::str::FromStr for TradeClientExtensionsModifyRejectTransactionRejectReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "INTERNAL_SERVER_ERROR" => Ok(Self::InternalServerError),
            "INSTRUMENT_PRICE_UNKNOWN" => Ok(Self::InstrumentPriceUnknown),
            "ACCOUNT_NOT_ACTIVE" => Ok(Self::AccountNotActive),
            "ACCOUNT_LOCKED" => Ok(Self::AccountLocked),
            "ACCOUNT_ORDER_CREATION_LOCKED" => Ok(Self::AccountOrderCreationLocked),
            "ACCOUNT_CONFIGURATION_LOCKED" => Ok(Self::AccountConfigurationLocked),
            "ACCOUNT_DEPOSIT_LOCKED" => Ok(Self::AccountDepositLocked),
            "ACCOUNT_WITHDRAWAL_LOCKED" => Ok(Self::AccountWithdrawalLocked),
            "ACCOUNT_ORDER_CANCEL_LOCKED" => Ok(Self::AccountOrderCancelLocked),
            "INSTRUMENT_NOT_TRADEABLE" => Ok(Self::InstrumentNotTradeable),
            "PENDING_ORDERS_ALLOWED_EXCEEDED" => Ok(Self::PendingOrdersAllowedExceeded),
            "ORDER_ID_UNSPECIFIED" => Ok(Self::OrderIdUnspecified),
            "ORDER_DOESNT_EXIST" => Ok(Self::OrderDoesntExist),
            "ORDER_IDENTIFIER_INCONSISTENCY" => Ok(Self::OrderIdentifierInconsistency),
            "TRADE_ID_UNSPECIFIED" => Ok(Self::TradeIdUnspecified),
            "TRADE_DOESNT_EXIST" => Ok(Self::TradeDoesntExist),
            "TRADE_IDENTIFIER_INCONSISTENCY" => Ok(Self::TradeIdentifierInconsistency),
            "INSUFFICIENT_MARGIN" => Ok(Self::InsufficientMargin),
            "INSTRUMENT_MISSING" => Ok(Self::InstrumentMissing),
            "INSTRUMENT_UNKNOWN" => Ok(Self::InstrumentUnknown),
            "UNITS_MISSING" => Ok(Self::UnitsMissing),
            "UNITS_INVALID" => Ok(Self::UnitsInvalid),
            "UNITS_PRECISION_EXCEEDED" => Ok(Self::UnitsPrecisionExceeded),
            "UNITS_LIMIT_EXCEEDED" => Ok(Self::UnitsLimitExceeded),
            "UNITS_MIMIMUM_NOT_MET" => Ok(Self::UnitsMimimumNotMet),
            "PRICE_MISSING" => Ok(Self::PriceMissing),
            "PRICE_INVALID" => Ok(Self::PriceInvalid),
            "PRICE_PRECISION_EXCEEDED" => Ok(Self::PricePrecisionExceeded),
            "PRICE_DISTANCE_MISSING" => Ok(Self::PriceDistanceMissing),
            "PRICE_DISTANCE_INVALID" => Ok(Self::PriceDistanceInvalid),
            "PRICE_DISTANCE_PRECISION_EXCEEDED" => Ok(Self::PriceDistancePrecisionExceeded),
            "PRICE_DISTANCE_MAXIMUM_EXCEEDED" => Ok(Self::PriceDistanceMaximumExceeded),
            "PRICE_DISTANCE_MINIMUM_NOT_MET" => Ok(Self::PriceDistanceMinimumNotMet),
            "TIME_IN_FORCE_MISSING" => Ok(Self::TimeInForceMissing),
            "TIME_IN_FORCE_INVALID" => Ok(Self::TimeInForceInvalid),
            "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING" => Ok(Self::TimeInForceGtdTimestampMissing),
            "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST" => Ok(Self::TimeInForceGtdTimestampInPast),
            "PRICE_BOUND_INVALID" => Ok(Self::PriceBoundInvalid),
            "PRICE_BOUND_PRECISION_EXCEEDED" => Ok(Self::PriceBoundPrecisionExceeded),
            "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS" => {
                Ok(Self::OrdersOnFillDuplicateClientOrderIds)
            }
            "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED" => {
                Ok(Self::TradeOnFillClientExtensionsNotSupported)
            }
            "CLIENT_ORDER_ID_INVALID" => Ok(Self::ClientOrderIdInvalid),
            "CLIENT_ORDER_ID_ALREADY_EXISTS" => Ok(Self::ClientOrderIdAlreadyExists),
            "CLIENT_ORDER_TAG_INVALID" => Ok(Self::ClientOrderTagInvalid),
            "CLIENT_ORDER_COMMENT_INVALID" => Ok(Self::ClientOrderCommentInvalid),
            "CLIENT_TRADE_ID_INVALID" => Ok(Self::ClientTradeIdInvalid),
            "CLIENT_TRADE_ID_ALREADY_EXISTS" => Ok(Self::ClientTradeIdAlreadyExists),
            "CLIENT_TRADE_TAG_INVALID" => Ok(Self::ClientTradeTagInvalid),
            "CLIENT_TRADE_COMMENT_INVALID" => Ok(Self::ClientTradeCommentInvalid),
            "ORDER_FILL_POSITION_ACTION_MISSING" => Ok(Self::OrderFillPositionActionMissing),
            "ORDER_FILL_POSITION_ACTION_INVALID" => Ok(Self::OrderFillPositionActionInvalid),
            "TRIGGER_CONDITION_MISSING" => Ok(Self::TriggerConditionMissing),
            "TRIGGER_CONDITION_INVALID" => Ok(Self::TriggerConditionInvalid),
            "ORDER_PARTIAL_FILL_OPTION_MISSING" => Ok(Self::OrderPartialFillOptionMissing),
            "ORDER_PARTIAL_FILL_OPTION_INVALID" => Ok(Self::OrderPartialFillOptionInvalid),
            "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL" => {
                Ok(Self::InvalidReissueImmediatePartialFill)
            }
            "TAKE_PROFIT_ORDER_ALREADY_EXISTS" => Ok(Self::TakeProfitOrderAlreadyExists),
            "TAKE_PROFIT_ON_FILL_PRICE_MISSING" => Ok(Self::TakeProfitOnFillPriceMissing),
            "TAKE_PROFIT_ON_FILL_PRICE_INVALID" => Ok(Self::TakeProfitOnFillPriceInvalid),
            "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(Self::TakeProfitOnFillPricePrecisionExceeded)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(Self::TakeProfitOnFillTimeInForceMissing)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(Self::TakeProfitOnFillTimeInForceInvalid)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::TakeProfitOnFillGtdTimestampMissing)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TakeProfitOnFillGtdTimestampInPast)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderIdInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderTagInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderCommentInvalid)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::TakeProfitOnFillTriggerConditionMissing)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::TakeProfitOnFillTriggerConditionInvalid)
            }
            "STOP_LOSS_ORDER_ALREADY_EXISTS" => Ok(Self::StopLossOrderAlreadyExists),
            "STOP_LOSS_ORDER_GUARANTEED_REQUIRED" => Ok(Self::StopLossOrderGuaranteedRequired),
            "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD" => {
                Ok(Self::StopLossOrderGuaranteedPriceWithinSpread)
            }
            "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED" => Ok(Self::StopLossOrderGuaranteedNotAllowed),
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION" => {
                Ok(Self::StopLossOrderGuaranteedHaltedCreateViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION" => {
                Ok(Self::StopLossOrderGuaranteedHaltedTightenViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED" => {
                Ok(Self::StopLossOrderGuaranteedHedgingNotAllowed)
            }
            "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOrderGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ORDER_NOT_CANCELABLE" => Ok(Self::StopLossOrderNotCancelable),
            "STOP_LOSS_ORDER_NOT_REPLACEABLE" => Ok(Self::StopLossOrderNotReplaceable),
            "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOrderGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(Self::StopLossOrderPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(Self::StopLossOrderPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER" => {
                Ok(Self::StopLossOnFillRequiredForPendingOrder)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED" => {
                Ok(Self::StopLossOnFillGuaranteedNotAllowed)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED" => Ok(Self::StopLossOnFillGuaranteedRequired),
            "STOP_LOSS_ON_FILL_PRICE_MISSING" => Ok(Self::StopLossOnFillPriceMissing),
            "STOP_LOSS_ON_FILL_PRICE_INVALID" => Ok(Self::StopLossOnFillPriceInvalid),
            "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(Self::StopLossOnFillPricePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOnFillGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOnFillGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_INVALID" => Ok(Self::StopLossOnFillDistanceInvalid),
            "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::StopLossOnFillPriceDistanceMaximumExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(Self::StopLossOnFillDistancePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(Self::StopLossOnFillPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(Self::StopLossOnFillPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => Ok(Self::StopLossOnFillTimeInForceMissing),
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => Ok(Self::StopLossOnFillTimeInForceInvalid),
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::StopLossOnFillGtdTimestampMissing)
            }
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => Ok(Self::StopLossOnFillGtdTimestampInPast),
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderIdInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderTagInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderCommentInvalid)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::StopLossOnFillTriggerConditionMissing)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::StopLossOnFillTriggerConditionInvalid)
            }
            "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS" => {
                Ok(Self::TrailingStopLossOrderAlreadyExists)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(Self::TrailingStopLossOnFillPriceDistancePrecisionExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMaximumExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMinimumNotMet)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(Self::TrailingStopLossOnFillTimeInForceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(Self::TrailingStopLossOnFillTimeInForceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampInPast)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderIdInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderTagInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderCommentInvalid)
            }
            "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED" => {
                Ok(Self::TrailingStopLossOrdersNotSupported)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::TrailingStopLossOnFillTriggerConditionMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::TrailingStopLossOnFillTriggerConditionInvalid)
            }
            "CLOSE_TRADE_TYPE_MISSING" => Ok(Self::CloseTradeTypeMissing),
            "CLOSE_TRADE_PARTIAL_UNITS_MISSING" => Ok(Self::CloseTradePartialUnitsMissing),
            "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE" => Ok(Self::CloseTradeUnitsExceedTradeSize),
            "CLOSEOUT_POSITION_DOESNT_EXIST" => Ok(Self::CloseoutPositionDoesntExist),
            "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION" => {
                Ok(Self::CloseoutPositionIncompleteSpecification)
            }
            "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE" => {
                Ok(Self::CloseoutPositionUnitsExceedPositionSize)
            }
            "CLOSEOUT_POSITION_REJECT" => Ok(Self::CloseoutPositionReject),
            "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING" => {
                Ok(Self::CloseoutPositionPartialUnitsMissing)
            }
            "MARKUP_GROUP_ID_INVALID" => Ok(Self::MarkupGroupIdInvalid),
            "POSITION_AGGREGATION_MODE_INVALID" => Ok(Self::PositionAggregationModeInvalid),
            "ADMIN_CONFIGURE_DATA_MISSING" => Ok(Self::AdminConfigureDataMissing),
            "MARGIN_RATE_INVALID" => Ok(Self::MarginRateInvalid),
            "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT" => Ok(Self::MarginRateWouldTriggerCloseout),
            "ALIAS_INVALID" => Ok(Self::AliasInvalid),
            "CLIENT_CONFIGURE_DATA_MISSING" => Ok(Self::ClientConfigureDataMissing),
            "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL" => Ok(Self::MarginRateWouldTriggerMarginCall),
            "AMOUNT_INVALID" => Ok(Self::AmountInvalid),
            "INSUFFICIENT_FUNDS" => Ok(Self::InsufficientFunds),
            "AMOUNT_MISSING" => Ok(Self::AmountMissing),
            "FUNDING_REASON_MISSING" => Ok(Self::FundingReasonMissing),
            "CLIENT_EXTENSIONS_DATA_MISSING" => Ok(Self::ClientExtensionsDataMissing),
            "REPLACING_ORDER_INVALID" => Ok(Self::ReplacingOrderInvalid),
            "REPLACING_TRADE_ID_INVALID" => Ok(Self::ReplacingTradeIdInvalid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TradeClientExtensionsModifyRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TradeClientExtensionsModifyRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TradeClientExtensionsModifyRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Type of the Transaction. Always set to
/// "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" for a
/// TradeClientExtensionsModifyRejectTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT\" for a
/// TradeClientExtensionsModifyRejectTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TradeClientExtensionsModifyRejectTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&TradeClientExtensionsModifyRejectTransactionType>
    for TradeClientExtensionsModifyRejectTransactionType
{
    fn from(value: &TradeClientExtensionsModifyRejectTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for TradeClientExtensionsModifyRejectTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for TradeClientExtensionsModifyRejectTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TradeClientExtensionsModifyRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TradeClientExtensionsModifyRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TradeClientExtensionsModifyRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A TradeClientExtensionsModifyTransaction represents the modification of
/// a Trade's Client Extensions.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A TradeClientExtensionsModifyTransaction represents the
/// modification of a Trade's Client Extensions.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientTradeID": {
///      "description": "The original Client ID of the Trade who's client
/// extensions are to be modified.",
///      "type": "string"
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "tradeClientExtensionsModify": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "tradeID": {
///      "description": "The ID of the Trade who's client extensions are to
/// be modified.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"TRADE_CLIENT_EXTENSIONS_MODIFY\" for a
/// TradeClientExtensionsModifyTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TradeClientExtensionsModifyTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    ///The original Client ID of the Trade who's client extensions are to
    /// be modified.
    #[serde(
        rename = "clientTradeID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_trade_id: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    #[serde(
        rename = "tradeClientExtensionsModify",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_client_extensions_modify: Option<ClientExtensions>,
    ///The ID of the Trade who's client extensions are to be modified.
    #[serde(rename = "tradeID", default, skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,
    ///The Type of the Transaction. Always set to
    /// "TRADE_CLIENT_EXTENSIONS_MODIFY" for a
    /// TradeClientExtensionsModifyTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<TradeClientExtensionsModifyTransactionType>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&TradeClientExtensionsModifyTransaction> for TradeClientExtensionsModifyTransaction {
    fn from(value: &TradeClientExtensionsModifyTransaction) -> Self {
        value.clone()
    }
}

impl TradeClientExtensionsModifyTransaction {
    pub fn builder() -> builder::TradeClientExtensionsModifyTransaction {
        Default::default()
    }
}

///The Type of the Transaction. Always set to
/// "TRADE_CLIENT_EXTENSIONS_MODIFY" for a
/// TradeClientExtensionsModifyTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"TRADE_CLIENT_EXTENSIONS_MODIFY\" for a
/// TradeClientExtensionsModifyTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TradeClientExtensionsModifyTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&TradeClientExtensionsModifyTransactionType>
    for TradeClientExtensionsModifyTransactionType
{
    fn from(value: &TradeClientExtensionsModifyTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for TradeClientExtensionsModifyTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for TradeClientExtensionsModifyTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TradeClientExtensionsModifyTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TradeClientExtensionsModifyTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TradeClientExtensionsModifyTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Trade's identifier, unique within the Trade's Account.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Trade's identifier, unique within the Trade's
/// Account.",
///  "type": "string",
///  "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct TradeId(pub String);
impl std::ops::Deref for TradeId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl From<TradeId> for String {
    fn from(value: TradeId) -> Self {
        value.0
    }
}

impl From<&TradeId> for TradeId {
    fn from(value: &TradeId) -> Self {
        value.clone()
    }
}

impl From<String> for TradeId {
    fn from(value: String) -> Self {
        Self(value)
    }
}

impl std::str::FromStr for TradeId {
    type Err = std::convert::Infallible;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}

impl ToString for TradeId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

///A TradeOpen object represents a Trade for an instrument that was opened
/// in an Account. It is found embedded in Transactions that affect the
/// position of an instrument in the Account, specifically the OrderFill
/// Transaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A TradeOpen object represents a Trade for an instrument
/// that was opened in an Account. It is found embedded in Transactions that
/// affect the position of an instrument in the Account, specifically the
/// OrderFill Transaction.",
///  "type": "object",
///  "properties": {
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "guaranteedExecutionFee": {
///      "description": "This is the fee charged for opening the trade if it
/// has a guaranteed Stop Loss Order attached to it.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "halfSpreadCost": {
///      "description": "The half spread cost for the trade open. This can
/// be a positive or negative value and is represented in the home currency
/// of the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "initialMarginRequired": {
///      "description": "The margin required at the time the Trade was
/// created. Note, this is the 'pure' margin required, it is not the
/// 'effective' margin used that factors in the trade risk if a GSLO is
/// attached to the trade.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "price": {
///      "description": "The average price that the units were opened at.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "tradeID": {
///      "description": "The ID of the Trade that was opened",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "units": {
///      "description": "The number of units opened by the Trade",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TradeOpen {
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///This is the fee charged for opening the trade if it has a guaranteed
    /// Stop Loss Order attached to it.
    #[serde(
        rename = "guaranteedExecutionFee",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub guaranteed_execution_fee: Option<String>,
    ///The half spread cost for the trade open. This can be a positive or
    /// negative value and is represented in the home currency of the
    /// Account.
    #[serde(
        rename = "halfSpreadCost",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub half_spread_cost: Option<String>,
    ///The margin required at the time the Trade was created. Note, this is
    /// the 'pure' margin required, it is not the 'effective' margin used
    /// that factors in the trade risk if a GSLO is attached to the trade.
    #[serde(
        rename = "initialMarginRequired",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub initial_margin_required: Option<String>,
    ///The average price that the units were opened at.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The ID of the Trade that was opened
    #[serde(rename = "tradeID", default, skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,
    ///The number of units opened by the Trade
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<String>,
}

impl From<&TradeOpen> for TradeOpen {
    fn from(value: &TradeOpen) -> Self {
        value.clone()
    }
}

impl TradeOpen {
    pub fn builder() -> builder::TradeOpen {
        Default::default()
    }
}

///The classification of TradePLs.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The classification of TradePLs.",
///  "type": "string",
///  "enum": [
///    "POSITIVE",
///    "NEGATIVE",
///    "ZERO"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TradePl {
    #[serde(rename = "POSITIVE")]
    Positive,
    #[serde(rename = "NEGATIVE")]
    Negative,
    #[serde(rename = "ZERO")]
    Zero,
}

impl From<&TradePl> for TradePl {
    fn from(value: &TradePl) -> Self {
        value.clone()
    }
}

impl ToString for TradePl {
    fn to_string(&self) -> String {
        match *self {
            Self::Positive => "POSITIVE".to_string(),
            Self::Negative => "NEGATIVE".to_string(),
            Self::Zero => "ZERO".to_string(),
        }
    }
}

impl std::str::FromStr for TradePl {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "POSITIVE" => Ok(Self::Positive),
            "NEGATIVE" => Ok(Self::Negative),
            "ZERO" => Ok(Self::Zero),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TradePl {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TradePl {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TradePl {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A TradeReduce object represents a Trade for an instrument that was
/// reduced (either partially or fully) in an Account. It is found embedded
/// in Transactions that affect the position of an instrument in the
/// account, specifically the OrderFill Transaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A TradeReduce object represents a Trade for an
/// instrument that was reduced (either partially or fully) in an Account.
/// It is found embedded in Transactions that affect the position of an
/// instrument in the account, specifically the OrderFill Transaction.",
///  "type": "object",
///  "properties": {
///    "financing": {
///      "description": "The financing paid/collected when reducing the
/// Trade",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "guaranteedExecutionFee": {
///      "description": "This is the fee that is charged for closing the
/// Trade if it has a guaranteed Stop Loss Order attached to it.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "halfSpreadCost": {
///      "description": "The half spread cost for the trade reduce/close.
/// This can be a positive or negative value and is represented in the home
/// currency of the Account.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "price": {
///      "description": "The average price that the units were closed at.
/// This price may be clamped for guaranteed Stop Loss Orders.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "realizedPL": {
///      "description": "The PL realized when reducing the Trade",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "tradeID": {
///      "description": "The ID of the Trade that was reduced or closed",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "units": {
///      "description": "The number of units that the Trade was reduced by",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TradeReduce {
    ///The financing paid/collected when reducing the Trade
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub financing: Option<String>,
    ///This is the fee that is charged for closing the Trade if it has a
    /// guaranteed Stop Loss Order attached to it.
    #[serde(
        rename = "guaranteedExecutionFee",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub guaranteed_execution_fee: Option<String>,
    ///The half spread cost for the trade reduce/close. This can be a
    /// positive or negative value and is represented in the home currency
    /// of the Account.
    #[serde(
        rename = "halfSpreadCost",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub half_spread_cost: Option<String>,
    ///The average price that the units were closed at. This price may be
    /// clamped for guaranteed Stop Loss Orders.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The PL realized when reducing the Trade
    #[serde(
        rename = "realizedPL",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub realized_pl: Option<String>,
    ///The ID of the Trade that was reduced or closed
    #[serde(rename = "tradeID", default, skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,
    ///The number of units that the Trade was reduced by
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<String>,
}

impl From<&TradeReduce> for TradeReduce {
    fn from(value: &TradeReduce) -> Self {
        value.clone()
    }
}

impl TradeReduce {
    pub fn builder() -> builder::TradeReduce {
        Default::default()
    }
}

///The identification of a Trade as referred to by clients
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The identification of a Trade as referred to by
/// clients",
///  "type": "string",
///  "format": "Either the Trade's OANDA-assigned TradeID or the Trade's
/// client-provided ClientID prefixed by the \"@\" symbol"
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct TradeSpecifier(pub String);
impl std::ops::Deref for TradeSpecifier {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl From<TradeSpecifier> for String {
    fn from(value: TradeSpecifier) -> Self {
        value.0
    }
}

impl From<&TradeSpecifier> for TradeSpecifier {
    fn from(value: &TradeSpecifier) -> Self {
        value.clone()
    }
}

impl From<String> for TradeSpecifier {
    fn from(value: String) -> Self {
        Self(value)
    }
}

impl std::str::FromStr for TradeSpecifier {
    type Err = std::convert::Infallible;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}

impl ToString for TradeSpecifier {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

///The current state of the Trade.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The current state of the Trade.",
///  "type": "string",
///  "enum": [
///    "OPEN",
///    "CLOSED",
///    "CLOSE_WHEN_TRADEABLE"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TradeState {
    #[serde(rename = "OPEN")]
    Open,
    #[serde(rename = "CLOSED")]
    Closed,
    #[serde(rename = "CLOSE_WHEN_TRADEABLE")]
    CloseWhenTradeable,
}

impl From<&TradeState> for TradeState {
    fn from(value: &TradeState) -> Self {
        value.clone()
    }
}

impl ToString for TradeState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "OPEN".to_string(),
            Self::Closed => "CLOSED".to_string(),
            Self::CloseWhenTradeable => "CLOSE_WHEN_TRADEABLE".to_string(),
        }
    }
}

impl std::str::FromStr for TradeState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "OPEN" => Ok(Self::Open),
            "CLOSED" => Ok(Self::Closed),
            "CLOSE_WHEN_TRADEABLE" => Ok(Self::CloseWhenTradeable),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TradeState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TradeState {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TradeState {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The state to filter the Trades by
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The state to filter the Trades by",
///  "type": "string",
///  "enum": [
///    "OPEN",
///    "CLOSED",
///    "CLOSE_WHEN_TRADEABLE",
///    "ALL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TradeStateFilter {
    #[serde(rename = "OPEN")]
    Open,
    #[serde(rename = "CLOSED")]
    Closed,
    #[serde(rename = "CLOSE_WHEN_TRADEABLE")]
    CloseWhenTradeable,
    #[serde(rename = "ALL")]
    All,
}

impl From<&TradeStateFilter> for TradeStateFilter {
    fn from(value: &TradeStateFilter) -> Self {
        value.clone()
    }
}

impl ToString for TradeStateFilter {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "OPEN".to_string(),
            Self::Closed => "CLOSED".to_string(),
            Self::CloseWhenTradeable => "CLOSE_WHEN_TRADEABLE".to_string(),
            Self::All => "ALL".to_string(),
        }
    }
}

impl std::str::FromStr for TradeStateFilter {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "OPEN" => Ok(Self::Open),
            "CLOSED" => Ok(Self::Closed),
            "CLOSE_WHEN_TRADEABLE" => Ok(Self::CloseWhenTradeable),
            "ALL" => Ok(Self::All),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TradeStateFilter {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TradeStateFilter {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TradeStateFilter {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The summary of a Trade within an Account. This representation does not
/// provide the full details of the Trade's dependent Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The summary of a Trade within an Account. This
/// representation does not provide the full details of the Trade's
/// dependent Orders.",
///  "type": "object",
///  "properties": {
///    "averageClosePrice": {
///      "description": "The average closing price of the Trade. Only
/// present if the Trade has been closed or reduced at least once.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "closeTime": {
///      "description": "The date/time when the Trade was fully closed. Only
/// provided for Trades whose state is CLOSED.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "closingTransactionIDs": {
///      "description": "The IDs of the Transactions that have closed
/// portions of this Trade.",
///      "type": "array",
///      "items": {
///        "description": "The unique Transaction identifier within each
/// Account.",
///        "type": "string",
///        "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///      }
///    },
///    "currentUnits": {
///      "description": "The number of units currently open for the Trade.
/// This value is reduced to 0.0 as the Trade is closed.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "financing": {
///      "description": "The financing paid/collected for this Trade.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "id": {
///      "description": "The Trade's identifier, unique within the Trade's
/// Account.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "initialMarginRequired": {
///      "description": "The margin required at the time the Trade was
/// created. Note, this is the 'pure' margin required, it is not the
/// 'effective' margin used that factors in the trade risk if a GSLO is
/// attached to the trade.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "initialUnits": {
///      "description": "The initial size of the Trade. Negative values
/// indicate a short Trade, and positive values indicate a long Trade.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "instrument": {
///      "description": "The Trade's Instrument.",
///      "type": "string",
///      "format": "A string containing the base currency and quote currency
/// delimited by a \"_\"."
///    },
///    "marginUsed": {
///      "description": "Margin currently used by the Trade.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "openTime": {
///      "description": "The date/time when the Trade was opened.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "price": {
///      "description": "The execution price of the Trade.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "realizedPL": {
///      "description": "The total profit/loss realized on the closed
/// portion of the Trade.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "state": {
///      "description": "The current state of the Trade.",
///      "type": "string",
///      "enum": [
///        "OPEN",
///        "CLOSED",
///        "CLOSE_WHEN_TRADEABLE"
///      ]
///    },
///    "stopLossOrderID": {
///      "description": "ID of the Trade's Stop Loss Order, only provided if
/// such an Order exists.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "takeProfitOrderID": {
///      "description": "ID of the Trade's Take Profit Order, only provided
/// if such an Order exists.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "trailingStopLossOrderID": {
///      "description": "ID of the Trade's Trailing Stop Loss Order, only
/// provided if such an Order exists.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "unrealizedPL": {
///      "description": "The unrealized profit/loss on the open portion of
/// the Trade.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TradeSummary {
    ///The average closing price of the Trade. Only present if the Trade
    /// has been closed or reduced at least once.
    #[serde(
        rename = "averageClosePrice",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub average_close_price: Option<String>,
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The date/time when the Trade was fully closed. Only provided for
    /// Trades whose state is CLOSED.
    #[serde(rename = "closeTime", default, skip_serializing_if = "Option::is_none")]
    pub close_time: Option<String>,
    ///The IDs of the Transactions that have closed portions of this Trade.
    #[serde(
        rename = "closingTransactionIDs",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub closing_transaction_i_ds: Vec<String>,
    ///The number of units currently open for the Trade. This value is
    /// reduced to 0.0 as the Trade is closed.
    #[serde(
        rename = "currentUnits",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub current_units: Option<String>,
    ///The financing paid/collected for this Trade.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub financing: Option<String>,
    ///The Trade's identifier, unique within the Trade's Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The margin required at the time the Trade was created. Note, this is
    /// the 'pure' margin required, it is not the 'effective' margin used
    /// that factors in the trade risk if a GSLO is attached to the trade.
    #[serde(
        rename = "initialMarginRequired",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub initial_margin_required: Option<String>,
    ///The initial size of the Trade. Negative values indicate a short
    /// Trade, and positive values indicate a long Trade.
    #[serde(
        rename = "initialUnits",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub initial_units: Option<String>,
    ///The Trade's Instrument.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub instrument: Option<String>,
    ///Margin currently used by the Trade.
    #[serde(
        rename = "marginUsed",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub margin_used: Option<String>,
    ///The date/time when the Trade was opened.
    #[serde(rename = "openTime", default, skip_serializing_if = "Option::is_none")]
    pub open_time: Option<String>,
    ///The execution price of the Trade.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub price: Option<String>,
    ///The total profit/loss realized on the closed portion of the Trade.
    #[serde(
        rename = "realizedPL",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub realized_pl: Option<String>,
    ///The current state of the Trade.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<TradeSummaryState>,
    ///ID of the Trade's Stop Loss Order, only provided if such an Order
    /// exists.
    #[serde(
        rename = "stopLossOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stop_loss_order_id: Option<String>,
    ///ID of the Trade's Take Profit Order, only provided if such an Order
    /// exists.
    #[serde(
        rename = "takeProfitOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub take_profit_order_id: Option<String>,
    ///ID of the Trade's Trailing Stop Loss Order, only provided if such an
    /// Order exists.
    #[serde(
        rename = "trailingStopLossOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_loss_order_id: Option<String>,
    ///The unrealized profit/loss on the open portion of the Trade.
    #[serde(
        rename = "unrealizedPL",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub unrealized_pl: Option<String>,
}

impl From<&TradeSummary> for TradeSummary {
    fn from(value: &TradeSummary) -> Self {
        value.clone()
    }
}

impl TradeSummary {
    pub fn builder() -> builder::TradeSummary {
        Default::default()
    }
}

///The current state of the Trade.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The current state of the Trade.",
///  "type": "string",
///  "enum": [
///    "OPEN",
///    "CLOSED",
///    "CLOSE_WHEN_TRADEABLE"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TradeSummaryState {
    #[serde(rename = "OPEN")]
    Open,
    #[serde(rename = "CLOSED")]
    Closed,
    #[serde(rename = "CLOSE_WHEN_TRADEABLE")]
    CloseWhenTradeable,
}

impl From<&TradeSummaryState> for TradeSummaryState {
    fn from(value: &TradeSummaryState) -> Self {
        value.clone()
    }
}

impl ToString for TradeSummaryState {
    fn to_string(&self) -> String {
        match *self {
            Self::Open => "OPEN".to_string(),
            Self::Closed => "CLOSED".to_string(),
            Self::CloseWhenTradeable => "CLOSE_WHEN_TRADEABLE".to_string(),
        }
    }
}

impl std::str::FromStr for TradeSummaryState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "OPEN" => Ok(Self::Open),
            "CLOSED" => Ok(Self::Closed),
            "CLOSE_WHEN_TRADEABLE" => Ok(Self::CloseWhenTradeable),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TradeSummaryState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TradeSummaryState {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TradeSummaryState {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///TrailingStopLossDetails specifies the details of a Trailing Stop Loss
/// Order to be created on behalf of a client. This may happen when an Order
/// is filled that opens a Trade requiring a Trailing Stop Loss, or when a
/// Trade's dependent Trailing Stop Loss Order is modified directly through
/// the Trade.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "TrailingStopLossDetails specifies the details of a
/// Trailing Stop Loss Order to be created on behalf of a client. This may
/// happen when an Order is filled that opens a Trade requiring a Trailing
/// Stop Loss, or when a Trade's dependent Trailing Stop Loss Order is
/// modified directly through the Trade.",
///  "type": "object",
///  "properties": {
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "distance": {
///      "description": "The distance (in price units) from the Trade's fill
/// price that the Trailing Stop Loss Order will be triggered at.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "gtdTime": {
///      "description": "The date when the Trailing Stop Loss Order will be
/// cancelled on if timeInForce is GTD.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "timeInForce": {
///      "description": "The time in force for the created Trailing Stop
/// Loss Order. This may only be GTC, GTD or GFD.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TrailingStopLossDetails {
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The distance (in price units) from the Trade's fill price that the
    /// Trailing Stop Loss Order will be triggered at.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distance: Option<String>,
    ///The date when the Trailing Stop Loss Order will be cancelled on if
    /// timeInForce is GTD.
    #[serde(rename = "gtdTime", default, skip_serializing_if = "Option::is_none")]
    pub gtd_time: Option<String>,
    ///The time in force for the created Trailing Stop Loss Order. This may
    /// only be GTC, GTD or GFD.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<TrailingStopLossDetailsTimeInForce>,
}

impl From<&TrailingStopLossDetails> for TrailingStopLossDetails {
    fn from(value: &TrailingStopLossDetails) -> Self {
        value.clone()
    }
}

impl TrailingStopLossDetails {
    pub fn builder() -> builder::TrailingStopLossDetails {
        Default::default()
    }
}

///The time in force for the created Trailing Stop Loss Order. This may
/// only be GTC, GTD or GFD.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time in force for the created Trailing Stop Loss
/// Order. This may only be GTC, GTD or GFD.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TrailingStopLossDetailsTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&TrailingStopLossDetailsTimeInForce> for TrailingStopLossDetailsTimeInForce {
    fn from(value: &TrailingStopLossDetailsTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for TrailingStopLossDetailsTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for TrailingStopLossDetailsTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TrailingStopLossDetailsTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TrailingStopLossDetailsTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TrailingStopLossDetailsTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A TrailingStopLossOrder is an order that is linked to an open Trade and
/// created with a price distance. The price distance is used to calculate a
/// trailing stop value for the order that is in the losing direction from
/// the market price at the time of the order's creation. The trailing stop
/// value will follow the market price as it moves in the winning direction,
/// and the order will filled (closing the Trade) by the first price that is
/// equal to or worse than the trailing stop value. A TrailingStopLossOrder
/// cannot be used to open a new Position.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A TrailingStopLossOrder is an order that is linked to
/// an open Trade and created with a price distance. The price distance is
/// used to calculate a trailing stop value for the order that is in the
/// losing direction from the market price at the time of the order's
/// creation. The trailing stop value will follow the market price as it
/// moves in the winning direction, and the order will filled (closing the
/// Trade) by the first price that is equal to or worse than the trailing
/// stop value. A TrailingStopLossOrder cannot be used to open a new
/// Position.",
///  "type": "object",
///  "properties": {
///    "cancelledTime": {
///      "description": "Date/time when the Order was cancelled (only
/// provided when the state of the Order is CANCELLED)",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "cancellingTransactionID": {
///      "description": "ID of the Transaction that cancelled the Order
/// (only provided when the Order's state is CANCELLED)",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "clientTradeID": {
///      "description": "The client ID of the Trade to be closed when the
/// price threshold is breached.",
///      "type": "string"
///    },
///    "createTime": {
///      "description": "The time when the Order was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "distance": {
///      "description": "The price distance (in price units) specified for
/// the TrailingStopLoss Order.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "filledTime": {
///      "description": "Date/time when the Order was filled (only provided
/// when the Order's state is FILLED)",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "fillingTransactionID": {
///      "description": "ID of the Transaction that filled this Order (only
/// provided when the Order's state is FILLED)",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "gtdTime": {
///      "description": "The date/time when the StopLoss Order will be
/// cancelled if its timeInForce is \"GTD\".",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "id": {
///      "description": "The Order's identifier, unique within the Order's
/// Account.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "replacedByOrderID": {
///      "description": "The ID of the Order that replaced this Order (only
/// provided if this Order was cancelled as part of a cancel/replace).",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "replacesOrderID": {
///      "description": "The ID of the Order that was replaced by this Order (only provided if this Order was created as part of a cancel/replace).",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "state": {
///      "description": "The current state of the Order.",
///      "type": "string",
///      "enum": [
///        "PENDING",
///        "FILLED",
///        "TRIGGERED",
///        "CANCELLED"
///      ]
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the
/// TrailingStopLoss Order. Restricted to \"GTC\", \"GFD\" and \"GTD\" for
/// TrailingStopLoss Orders.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeClosedIDs": {
///      "description": "Trade IDs of Trades closed when the Order was
/// filled (only provided when the Order's state is FILLED and one or more
/// Trades were closed as a result of the fill)",
///      "type": "array",
///      "items": {
///        "description": "The Trade's identifier, unique within the Trade's
/// Account.",
///        "type": "string",
///        "format": "The string representation of the OANDA-assigned
/// TradeID. OANDA-assigned TradeIDs are positive integers, and are derived
/// from the TransactionID of the Transaction that opened the Trade."
///      }
///    },
///    "tradeID": {
///      "description": "The ID of the Trade to close when the price
/// threshold is breached.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "tradeOpenedID": {
///      "description": "Trade ID of Trade opened when the Order was filled
/// (only provided when the Order's state is FILLED and a Trade was opened
/// as a result of the fill)",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "tradeReducedID": {
///      "description": "Trade ID of Trade reduced when the Order was filled
/// (only provided when the Order's state is FILLED and a Trade was reduced
/// as a result of the fill)",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "trailingStopValue": {
///      "description": "The trigger price for the Trailing Stop Loss Order.
/// The trailing stop value will trail (follow) the market price by the TSL
/// order's configured \"distance\" as the market price moves in the winning
/// direction. If the market price moves to a level that is equal to or
/// worse than the trailing stop value, the order will be filled and the
/// Trade will be closed.",
///      "type": "string",
///      "format": "A decimal number encodes as a string. The amount of
/// precision provided depends on the Instrument."
///    },
///    "triggerCondition": {
///      "description": "Specification of which price component should be
/// used when determining if an Order should be triggered and filled. This
/// allows Orders to be triggered based on the bid, ask, mid, default (ask
/// for buy, bid for sell) or inverse (ask for sell, bid for buy) price
/// depending on the desired behaviour. Orders are always filled using their
/// default price component.\nThis feature is only provided through the REST
/// API. Clients who choose to specify a non-default trigger condition will
/// not see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///      "type": "string",
///      "enum": [
///        "DEFAULT",
///        "INVERSE",
///        "BID",
///        "ASK",
///        "MID"
///      ]
///    },
///    "type": {
///      "description": "The type of the Order. Always set to
/// \"TRAILING_STOP_LOSS\" for Trailing Stop Loss Orders.",
///      "type": "string",
///      "enum": [
///        "MARKET",
///        "LIMIT",
///        "STOP",
///        "MARKET_IF_TOUCHED",
///        "TAKE_PROFIT",
///        "STOP_LOSS",
///        "TRAILING_STOP_LOSS",
///        "FIXED_PRICE"
///      ]
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TrailingStopLossOrder {
    ///Date/time when the Order was cancelled (only provided when the state
    /// of the Order is CANCELLED)
    #[serde(
        rename = "cancelledTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelled_time: Option<String>,
    ///ID of the Transaction that cancelled the Order (only provided when
    /// the Order's state is CANCELLED)
    #[serde(
        rename = "cancellingTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The client ID of the Trade to be closed when the price threshold is
    /// breached.
    #[serde(
        rename = "clientTradeID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_trade_id: Option<String>,
    ///The time when the Order was created.
    #[serde(
        rename = "createTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub create_time: Option<String>,
    ///The price distance (in price units) specified for the
    /// TrailingStopLoss Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distance: Option<String>,
    ///Date/time when the Order was filled (only provided when the Order's
    /// state is FILLED)
    #[serde(
        rename = "filledTime",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub filled_time: Option<String>,
    ///ID of the Transaction that filled this Order (only provided when the
    /// Order's state is FILLED)
    #[serde(
        rename = "fillingTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub filling_transaction_id: Option<String>,
    ///The date/time when the StopLoss Order will be cancelled if its
    /// timeInForce is "GTD".
    #[serde(rename = "gtdTime", default, skip_serializing_if = "Option::is_none")]
    pub gtd_time: Option<String>,
    ///The Order's identifier, unique within the Order's Account.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The ID of the Order that replaced this Order (only provided if this
    /// Order was cancelled as part of a cancel/replace).
    #[serde(
        rename = "replacedByOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub replaced_by_order_id: Option<String>,
    ///The ID of the Order that was replaced by this Order (only provided
    /// if this Order was created as part of a cancel/replace).
    #[serde(
        rename = "replacesOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub replaces_order_id: Option<String>,
    ///The current state of the Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub state: Option<TrailingStopLossOrderState>,
    ///The time-in-force requested for the TrailingStopLoss Order.
    /// Restricted to "GTC", "GFD" and "GTD" for TrailingStopLoss Orders.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<TrailingStopLossOrderTimeInForce>,
    ///Trade IDs of Trades closed when the Order was filled (only provided
    /// when the Order's state is FILLED and one or more Trades were closed
    /// as a result of the fill)
    #[serde(
        rename = "tradeClosedIDs",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    pub trade_closed_i_ds: Vec<String>,
    ///The ID of the Trade to close when the price threshold is breached.
    #[serde(rename = "tradeID", default, skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,
    ///Trade ID of Trade opened when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was opened as a result
    /// of the fill)
    #[serde(
        rename = "tradeOpenedID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_opened_id: Option<String>,
    ///Trade ID of Trade reduced when the Order was filled (only provided
    /// when the Order's state is FILLED and a Trade was reduced as a result
    /// of the fill)
    #[serde(
        rename = "tradeReducedID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trade_reduced_id: Option<String>,
    ///The trigger price for the Trailing Stop Loss Order. The trailing
    /// stop value will trail (follow) the market price by the TSL order's
    /// configured "distance" as the market price moves in the winning
    /// direction. If the market price moves to a level that is equal to or
    /// worse than the trailing stop value, the order will be filled and the
    /// Trade will be closed.
    #[serde(
        rename = "trailingStopValue",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trailing_stop_value: Option<String>,
    ///Specification of which price component should be used when
    /// determining if an Order should be triggered and filled. This allows
    /// Orders to be triggered based on the bid, ask, mid, default (ask for
    /// buy, bid for sell) or inverse (ask for sell, bid for buy) price
    /// depending on the desired behaviour. Orders are always filled using
    /// their default price component. This feature is only provided
    /// through the REST API. Clients who choose to specify a non-default
    /// trigger condition will not see it reflected in any of OANDA's
    /// proprietary or partner trading platforms, their transaction history
    /// or their account statements. OANDA platforms always assume that an
    /// Order's trigger condition is set to the default value when
    /// indicating the distance from an Order's trigger price, and will
    /// always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when
    /// creating a guaranteed Stop Loss Order. In this case the
    /// TriggerCondition value must either be "DEFAULT", or the "natural"
    /// trigger side "DEFAULT" results in. So for a Stop Loss Order for a
    /// long trade valid values are "DEFAULT" and "BID", and for short
    /// trades "DEFAULT" and "ASK" are valid.
    #[serde(
        rename = "triggerCondition",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trigger_condition: Option<TrailingStopLossOrderTriggerCondition>,
    ///The type of the Order. Always set to "TRAILING_STOP_LOSS" for
    /// Trailing Stop Loss Orders.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<TrailingStopLossOrderType>,
}

impl From<&TrailingStopLossOrder> for TrailingStopLossOrder {
    fn from(value: &TrailingStopLossOrder) -> Self {
        value.clone()
    }
}

impl TrailingStopLossOrder {
    pub fn builder() -> builder::TrailingStopLossOrder {
        Default::default()
    }
}

///The reason that the Trailing Stop Loss Order was initiated
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Trailing Stop Loss Order was
/// initiated",
///  "type": "string",
///  "enum": [
///    "CLIENT_ORDER",
///    "REPLACEMENT",
///    "ON_FILL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TrailingStopLossOrderReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "REPLACEMENT")]
    Replacement,
    #[serde(rename = "ON_FILL")]
    OnFill,
}

impl From<&TrailingStopLossOrderReason> for TrailingStopLossOrderReason {
    fn from(value: &TrailingStopLossOrderReason) -> Self {
        value.clone()
    }
}

impl ToString for TrailingStopLossOrderReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ClientOrder => "CLIENT_ORDER".to_string(),
            Self::Replacement => "REPLACEMENT".to_string(),
            Self::OnFill => "ON_FILL".to_string(),
        }
    }
}

impl std::str::FromStr for TrailingStopLossOrderReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CLIENT_ORDER" => Ok(Self::ClientOrder),
            "REPLACEMENT" => Ok(Self::Replacement),
            "ON_FILL" => Ok(Self::OnFill),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TrailingStopLossOrderReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TrailingStopLossOrderReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TrailingStopLossOrderReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A TrailingStopLossOrderRejectTransaction represents the rejection of the
/// creation of a TrailingStopLoss Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A TrailingStopLossOrderRejectTransaction represents the
/// rejection of the creation of a TrailingStopLoss Order.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "clientTradeID": {
///      "description": "The client ID of the Trade to be closed when the
/// price threshold is breached.",
///      "type": "string"
///    },
///    "distance": {
///      "description": "The price distance (in price units) specified for
/// the TrailingStopLoss Order.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "gtdTime": {
///      "description": "The date/time when the StopLoss Order will be
/// cancelled if its timeInForce is \"GTD\".",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "intendedReplacesOrderID": {
///      "description": "The ID of the Order that this Order was intended to
/// replace (only provided if this Order was intended to replace an existing
/// Order).",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "orderFillTransactionID": {
///      "description": "The ID of the OrderFill Transaction that caused
/// this Order to be created (only provided if this Order was created
/// automatically when another Order was filled).",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "reason": {
///      "description": "The reason that the Trailing Stop Loss Order was
/// initiated",
///      "type": "string",
///      "enum": [
///        "CLIENT_ORDER",
///        "REPLACEMENT",
///        "ON_FILL"
///      ]
///    },
///    "rejectReason": {
///      "description": "The reason that the Reject Transaction was
/// created",
///      "type": "string",
///      "enum": [
///        "INTERNAL_SERVER_ERROR",
///        "INSTRUMENT_PRICE_UNKNOWN",
///        "ACCOUNT_NOT_ACTIVE",
///        "ACCOUNT_LOCKED",
///        "ACCOUNT_ORDER_CREATION_LOCKED",
///        "ACCOUNT_CONFIGURATION_LOCKED",
///        "ACCOUNT_DEPOSIT_LOCKED",
///        "ACCOUNT_WITHDRAWAL_LOCKED",
///        "ACCOUNT_ORDER_CANCEL_LOCKED",
///        "INSTRUMENT_NOT_TRADEABLE",
///        "PENDING_ORDERS_ALLOWED_EXCEEDED",
///        "ORDER_ID_UNSPECIFIED",
///        "ORDER_DOESNT_EXIST",
///        "ORDER_IDENTIFIER_INCONSISTENCY",
///        "TRADE_ID_UNSPECIFIED",
///        "TRADE_DOESNT_EXIST",
///        "TRADE_IDENTIFIER_INCONSISTENCY",
///        "INSUFFICIENT_MARGIN",
///        "INSTRUMENT_MISSING",
///        "INSTRUMENT_UNKNOWN",
///        "UNITS_MISSING",
///        "UNITS_INVALID",
///        "UNITS_PRECISION_EXCEEDED",
///        "UNITS_LIMIT_EXCEEDED",
///        "UNITS_MIMIMUM_NOT_MET",
///        "PRICE_MISSING",
///        "PRICE_INVALID",
///        "PRICE_PRECISION_EXCEEDED",
///        "PRICE_DISTANCE_MISSING",
///        "PRICE_DISTANCE_INVALID",
///        "PRICE_DISTANCE_PRECISION_EXCEEDED",
///        "PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "PRICE_DISTANCE_MINIMUM_NOT_MET",
///        "TIME_IN_FORCE_MISSING",
///        "TIME_IN_FORCE_INVALID",
///        "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING",
///        "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST",
///        "PRICE_BOUND_INVALID",
///        "PRICE_BOUND_PRECISION_EXCEEDED",
///        "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS",
///        "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED",
///        "CLIENT_ORDER_ID_INVALID",
///        "CLIENT_ORDER_ID_ALREADY_EXISTS",
///        "CLIENT_ORDER_TAG_INVALID",
///        "CLIENT_ORDER_COMMENT_INVALID",
///        "CLIENT_TRADE_ID_INVALID",
///        "CLIENT_TRADE_ID_ALREADY_EXISTS",
///        "CLIENT_TRADE_TAG_INVALID",
///        "CLIENT_TRADE_COMMENT_INVALID",
///        "ORDER_FILL_POSITION_ACTION_MISSING",
///        "ORDER_FILL_POSITION_ACTION_INVALID",
///        "TRIGGER_CONDITION_MISSING",
///        "TRIGGER_CONDITION_INVALID",
///        "ORDER_PARTIAL_FILL_OPTION_MISSING",
///        "ORDER_PARTIAL_FILL_OPTION_INVALID",
///        "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL",
///        "TAKE_PROFIT_ORDER_ALREADY_EXISTS",
///        "TAKE_PROFIT_ON_FILL_PRICE_MISSING",
///        "TAKE_PROFIT_ON_FILL_PRICE_INVALID",
///        "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED",
///        "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING",
///        "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID",
///        "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "STOP_LOSS_ORDER_ALREADY_EXISTS",
///        "STOP_LOSS_ORDER_GUARANTEED_REQUIRED",
///        "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD",
///        "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED",
///        "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION",
///        "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION",
///        "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED",
///        "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///        "STOP_LOSS_ORDER_NOT_CANCELABLE",
///        "STOP_LOSS_ORDER_NOT_REPLACEABLE",
///        "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///        "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///        "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING",
///        "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER",
///        "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///        "STOP_LOSS_ON_FILL_PRICE_MISSING",
///        "STOP_LOSS_ON_FILL_PRICE_INVALID",
///        "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///        "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_DISTANCE_INVALID",
///        "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///        "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING",
///        "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///        "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///        "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET",
///        "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED",
///        "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "CLOSE_TRADE_TYPE_MISSING",
///        "CLOSE_TRADE_PARTIAL_UNITS_MISSING",
///        "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE",
///        "CLOSEOUT_POSITION_DOESNT_EXIST",
///        "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION",
///        "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE",
///        "CLOSEOUT_POSITION_REJECT",
///        "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING",
///        "MARKUP_GROUP_ID_INVALID",
///        "POSITION_AGGREGATION_MODE_INVALID",
///        "ADMIN_CONFIGURE_DATA_MISSING",
///        "MARGIN_RATE_INVALID",
///        "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT",
///        "ALIAS_INVALID",
///        "CLIENT_CONFIGURE_DATA_MISSING",
///        "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL",
///        "AMOUNT_INVALID",
///        "INSUFFICIENT_FUNDS",
///        "AMOUNT_MISSING",
///        "FUNDING_REASON_MISSING",
///        "CLIENT_EXTENSIONS_DATA_MISSING",
///        "REPLACING_ORDER_INVALID",
///        "REPLACING_TRADE_ID_INVALID"
///      ]
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the
/// TrailingStopLoss Order. Restricted to \"GTC\", \"GFD\" and \"GTD\" for
/// TrailingStopLoss Orders.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeID": {
///      "description": "The ID of the Trade to close when the price
/// threshold is breached.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "triggerCondition": {
///      "description": "Specification of which price component should be
/// used when determining if an Order should be triggered and filled. This
/// allows Orders to be triggered based on the bid, ask, mid, default (ask
/// for buy, bid for sell) or inverse (ask for sell, bid for buy) price
/// depending on the desired behaviour. Orders are always filled using their
/// default price component.\nThis feature is only provided through the REST
/// API. Clients who choose to specify a non-default trigger condition will
/// not see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///      "type": "string",
///      "enum": [
///        "DEFAULT",
///        "INVERSE",
///        "BID",
///        "ASK",
///        "MID"
///      ]
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"TRAILING_STOP_LOSS_ORDER_REJECT\" in a
/// TrailingStopLossOrderRejectTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TrailingStopLossOrderRejectTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The client ID of the Trade to be closed when the price threshold is
    /// breached.
    #[serde(
        rename = "clientTradeID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_trade_id: Option<String>,
    ///The price distance (in price units) specified for the
    /// TrailingStopLoss Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distance: Option<String>,
    ///The date/time when the StopLoss Order will be cancelled if its
    /// timeInForce is "GTD".
    #[serde(rename = "gtdTime", default, skip_serializing_if = "Option::is_none")]
    pub gtd_time: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The ID of the Order that this Order was intended to replace (only
    /// provided if this Order was intended to replace an existing Order).
    #[serde(
        rename = "intendedReplacesOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub intended_replaces_order_id: Option<String>,
    ///The ID of the OrderFill Transaction that caused this Order to be
    /// created (only provided if this Order was created automatically when
    /// another Order was filled).
    #[serde(
        rename = "orderFillTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub order_fill_transaction_id: Option<String>,
    ///The reason that the Trailing Stop Loss Order was initiated
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<TrailingStopLossOrderRejectTransactionReason>,
    ///The reason that the Reject Transaction was created
    #[serde(
        rename = "rejectReason",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub reject_reason: Option<TrailingStopLossOrderRejectTransactionRejectReason>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The time-in-force requested for the TrailingStopLoss Order.
    /// Restricted to "GTC", "GFD" and "GTD" for TrailingStopLoss Orders.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<TrailingStopLossOrderRejectTransactionTimeInForce>,
    ///The ID of the Trade to close when the price threshold is breached.
    #[serde(rename = "tradeID", default, skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,
    ///Specification of which price component should be used when
    /// determining if an Order should be triggered and filled. This allows
    /// Orders to be triggered based on the bid, ask, mid, default (ask for
    /// buy, bid for sell) or inverse (ask for sell, bid for buy) price
    /// depending on the desired behaviour. Orders are always filled using
    /// their default price component. This feature is only provided
    /// through the REST API. Clients who choose to specify a non-default
    /// trigger condition will not see it reflected in any of OANDA's
    /// proprietary or partner trading platforms, their transaction history
    /// or their account statements. OANDA platforms always assume that an
    /// Order's trigger condition is set to the default value when
    /// indicating the distance from an Order's trigger price, and will
    /// always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when
    /// creating a guaranteed Stop Loss Order. In this case the
    /// TriggerCondition value must either be "DEFAULT", or the "natural"
    /// trigger side "DEFAULT" results in. So for a Stop Loss Order for a
    /// long trade valid values are "DEFAULT" and "BID", and for short
    /// trades "DEFAULT" and "ASK" are valid.
    #[serde(
        rename = "triggerCondition",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trigger_condition: Option<TrailingStopLossOrderRejectTransactionTriggerCondition>,
    ///The Type of the Transaction. Always set to
    /// "TRAILING_STOP_LOSS_ORDER_REJECT" in a
    /// TrailingStopLossOrderRejectTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<TrailingStopLossOrderRejectTransactionType>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&TrailingStopLossOrderRejectTransaction> for TrailingStopLossOrderRejectTransaction {
    fn from(value: &TrailingStopLossOrderRejectTransaction) -> Self {
        value.clone()
    }
}

impl TrailingStopLossOrderRejectTransaction {
    pub fn builder() -> builder::TrailingStopLossOrderRejectTransaction {
        Default::default()
    }
}

///The reason that the Trailing Stop Loss Order was initiated
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Trailing Stop Loss Order was
/// initiated",
///  "type": "string",
///  "enum": [
///    "CLIENT_ORDER",
///    "REPLACEMENT",
///    "ON_FILL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TrailingStopLossOrderRejectTransactionReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "REPLACEMENT")]
    Replacement,
    #[serde(rename = "ON_FILL")]
    OnFill,
}

impl From<&TrailingStopLossOrderRejectTransactionReason>
    for TrailingStopLossOrderRejectTransactionReason
{
    fn from(value: &TrailingStopLossOrderRejectTransactionReason) -> Self {
        value.clone()
    }
}

impl ToString for TrailingStopLossOrderRejectTransactionReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ClientOrder => "CLIENT_ORDER".to_string(),
            Self::Replacement => "REPLACEMENT".to_string(),
            Self::OnFill => "ON_FILL".to_string(),
        }
    }
}

impl std::str::FromStr for TrailingStopLossOrderRejectTransactionReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CLIENT_ORDER" => Ok(Self::ClientOrder),
            "REPLACEMENT" => Ok(Self::Replacement),
            "ON_FILL" => Ok(Self::OnFill),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TrailingStopLossOrderRejectTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TrailingStopLossOrderRejectTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TrailingStopLossOrderRejectTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The reason that the Reject Transaction was created
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Reject Transaction was created",
///  "type": "string",
///  "enum": [
///    "INTERNAL_SERVER_ERROR",
///    "INSTRUMENT_PRICE_UNKNOWN",
///    "ACCOUNT_NOT_ACTIVE",
///    "ACCOUNT_LOCKED",
///    "ACCOUNT_ORDER_CREATION_LOCKED",
///    "ACCOUNT_CONFIGURATION_LOCKED",
///    "ACCOUNT_DEPOSIT_LOCKED",
///    "ACCOUNT_WITHDRAWAL_LOCKED",
///    "ACCOUNT_ORDER_CANCEL_LOCKED",
///    "INSTRUMENT_NOT_TRADEABLE",
///    "PENDING_ORDERS_ALLOWED_EXCEEDED",
///    "ORDER_ID_UNSPECIFIED",
///    "ORDER_DOESNT_EXIST",
///    "ORDER_IDENTIFIER_INCONSISTENCY",
///    "TRADE_ID_UNSPECIFIED",
///    "TRADE_DOESNT_EXIST",
///    "TRADE_IDENTIFIER_INCONSISTENCY",
///    "INSUFFICIENT_MARGIN",
///    "INSTRUMENT_MISSING",
///    "INSTRUMENT_UNKNOWN",
///    "UNITS_MISSING",
///    "UNITS_INVALID",
///    "UNITS_PRECISION_EXCEEDED",
///    "UNITS_LIMIT_EXCEEDED",
///    "UNITS_MIMIMUM_NOT_MET",
///    "PRICE_MISSING",
///    "PRICE_INVALID",
///    "PRICE_PRECISION_EXCEEDED",
///    "PRICE_DISTANCE_MISSING",
///    "PRICE_DISTANCE_INVALID",
///    "PRICE_DISTANCE_PRECISION_EXCEEDED",
///    "PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "PRICE_DISTANCE_MINIMUM_NOT_MET",
///    "TIME_IN_FORCE_MISSING",
///    "TIME_IN_FORCE_INVALID",
///    "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING",
///    "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST",
///    "PRICE_BOUND_INVALID",
///    "PRICE_BOUND_PRECISION_EXCEEDED",
///    "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS",
///    "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED",
///    "CLIENT_ORDER_ID_INVALID",
///    "CLIENT_ORDER_ID_ALREADY_EXISTS",
///    "CLIENT_ORDER_TAG_INVALID",
///    "CLIENT_ORDER_COMMENT_INVALID",
///    "CLIENT_TRADE_ID_INVALID",
///    "CLIENT_TRADE_ID_ALREADY_EXISTS",
///    "CLIENT_TRADE_TAG_INVALID",
///    "CLIENT_TRADE_COMMENT_INVALID",
///    "ORDER_FILL_POSITION_ACTION_MISSING",
///    "ORDER_FILL_POSITION_ACTION_INVALID",
///    "TRIGGER_CONDITION_MISSING",
///    "TRIGGER_CONDITION_INVALID",
///    "ORDER_PARTIAL_FILL_OPTION_MISSING",
///    "ORDER_PARTIAL_FILL_OPTION_INVALID",
///    "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL",
///    "TAKE_PROFIT_ORDER_ALREADY_EXISTS",
///    "TAKE_PROFIT_ON_FILL_PRICE_MISSING",
///    "TAKE_PROFIT_ON_FILL_PRICE_INVALID",
///    "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED",
///    "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING",
///    "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "STOP_LOSS_ORDER_ALREADY_EXISTS",
///    "STOP_LOSS_ORDER_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD",
///    "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION",
///    "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION",
///    "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED",
///    "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ORDER_NOT_CANCELABLE",
///    "STOP_LOSS_ORDER_NOT_REPLACEABLE",
///    "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///    "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING",
///    "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER",
///    "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ON_FILL_PRICE_MISSING",
///    "STOP_LOSS_ON_FILL_PRICE_INVALID",
///    "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_DISTANCE_INVALID",
///    "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///    "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET",
///    "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED",
///    "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "CLOSE_TRADE_TYPE_MISSING",
///    "CLOSE_TRADE_PARTIAL_UNITS_MISSING",
///    "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE",
///    "CLOSEOUT_POSITION_DOESNT_EXIST",
///    "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION",
///    "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE",
///    "CLOSEOUT_POSITION_REJECT",
///    "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING",
///    "MARKUP_GROUP_ID_INVALID",
///    "POSITION_AGGREGATION_MODE_INVALID",
///    "ADMIN_CONFIGURE_DATA_MISSING",
///    "MARGIN_RATE_INVALID",
///    "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT",
///    "ALIAS_INVALID",
///    "CLIENT_CONFIGURE_DATA_MISSING",
///    "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL",
///    "AMOUNT_INVALID",
///    "INSUFFICIENT_FUNDS",
///    "AMOUNT_MISSING",
///    "FUNDING_REASON_MISSING",
///    "CLIENT_EXTENSIONS_DATA_MISSING",
///    "REPLACING_ORDER_INVALID",
///    "REPLACING_TRADE_ID_INVALID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TrailingStopLossOrderRejectTransactionRejectReason {
    #[serde(rename = "INTERNAL_SERVER_ERROR")]
    InternalServerError,
    #[serde(rename = "INSTRUMENT_PRICE_UNKNOWN")]
    InstrumentPriceUnknown,
    #[serde(rename = "ACCOUNT_NOT_ACTIVE")]
    AccountNotActive,
    #[serde(rename = "ACCOUNT_LOCKED")]
    AccountLocked,
    #[serde(rename = "ACCOUNT_ORDER_CREATION_LOCKED")]
    AccountOrderCreationLocked,
    #[serde(rename = "ACCOUNT_CONFIGURATION_LOCKED")]
    AccountConfigurationLocked,
    #[serde(rename = "ACCOUNT_DEPOSIT_LOCKED")]
    AccountDepositLocked,
    #[serde(rename = "ACCOUNT_WITHDRAWAL_LOCKED")]
    AccountWithdrawalLocked,
    #[serde(rename = "ACCOUNT_ORDER_CANCEL_LOCKED")]
    AccountOrderCancelLocked,
    #[serde(rename = "INSTRUMENT_NOT_TRADEABLE")]
    InstrumentNotTradeable,
    #[serde(rename = "PENDING_ORDERS_ALLOWED_EXCEEDED")]
    PendingOrdersAllowedExceeded,
    #[serde(rename = "ORDER_ID_UNSPECIFIED")]
    OrderIdUnspecified,
    #[serde(rename = "ORDER_DOESNT_EXIST")]
    OrderDoesntExist,
    #[serde(rename = "ORDER_IDENTIFIER_INCONSISTENCY")]
    OrderIdentifierInconsistency,
    #[serde(rename = "TRADE_ID_UNSPECIFIED")]
    TradeIdUnspecified,
    #[serde(rename = "TRADE_DOESNT_EXIST")]
    TradeDoesntExist,
    #[serde(rename = "TRADE_IDENTIFIER_INCONSISTENCY")]
    TradeIdentifierInconsistency,
    #[serde(rename = "INSUFFICIENT_MARGIN")]
    InsufficientMargin,
    #[serde(rename = "INSTRUMENT_MISSING")]
    InstrumentMissing,
    #[serde(rename = "INSTRUMENT_UNKNOWN")]
    InstrumentUnknown,
    #[serde(rename = "UNITS_MISSING")]
    UnitsMissing,
    #[serde(rename = "UNITS_INVALID")]
    UnitsInvalid,
    #[serde(rename = "UNITS_PRECISION_EXCEEDED")]
    UnitsPrecisionExceeded,
    #[serde(rename = "UNITS_LIMIT_EXCEEDED")]
    UnitsLimitExceeded,
    #[serde(rename = "UNITS_MIMIMUM_NOT_MET")]
    UnitsMimimumNotMet,
    #[serde(rename = "PRICE_MISSING")]
    PriceMissing,
    #[serde(rename = "PRICE_INVALID")]
    PriceInvalid,
    #[serde(rename = "PRICE_PRECISION_EXCEEDED")]
    PricePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MISSING")]
    PriceDistanceMissing,
    #[serde(rename = "PRICE_DISTANCE_INVALID")]
    PriceDistanceInvalid,
    #[serde(rename = "PRICE_DISTANCE_PRECISION_EXCEEDED")]
    PriceDistancePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    PriceDistanceMaximumExceeded,
    #[serde(rename = "PRICE_DISTANCE_MINIMUM_NOT_MET")]
    PriceDistanceMinimumNotMet,
    #[serde(rename = "TIME_IN_FORCE_MISSING")]
    TimeInForceMissing,
    #[serde(rename = "TIME_IN_FORCE_INVALID")]
    TimeInForceInvalid,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING")]
    TimeInForceGtdTimestampMissing,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST")]
    TimeInForceGtdTimestampInPast,
    #[serde(rename = "PRICE_BOUND_INVALID")]
    PriceBoundInvalid,
    #[serde(rename = "PRICE_BOUND_PRECISION_EXCEEDED")]
    PriceBoundPrecisionExceeded,
    #[serde(rename = "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS")]
    OrdersOnFillDuplicateClientOrderIds,
    #[serde(rename = "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED")]
    TradeOnFillClientExtensionsNotSupported,
    #[serde(rename = "CLIENT_ORDER_ID_INVALID")]
    ClientOrderIdInvalid,
    #[serde(rename = "CLIENT_ORDER_ID_ALREADY_EXISTS")]
    ClientOrderIdAlreadyExists,
    #[serde(rename = "CLIENT_ORDER_TAG_INVALID")]
    ClientOrderTagInvalid,
    #[serde(rename = "CLIENT_ORDER_COMMENT_INVALID")]
    ClientOrderCommentInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_INVALID")]
    ClientTradeIdInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_ALREADY_EXISTS")]
    ClientTradeIdAlreadyExists,
    #[serde(rename = "CLIENT_TRADE_TAG_INVALID")]
    ClientTradeTagInvalid,
    #[serde(rename = "CLIENT_TRADE_COMMENT_INVALID")]
    ClientTradeCommentInvalid,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_MISSING")]
    OrderFillPositionActionMissing,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_INVALID")]
    OrderFillPositionActionInvalid,
    #[serde(rename = "TRIGGER_CONDITION_MISSING")]
    TriggerConditionMissing,
    #[serde(rename = "TRIGGER_CONDITION_INVALID")]
    TriggerConditionInvalid,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_MISSING")]
    OrderPartialFillOptionMissing,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_INVALID")]
    OrderPartialFillOptionInvalid,
    #[serde(rename = "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL")]
    InvalidReissueImmediatePartialFill,
    #[serde(rename = "TAKE_PROFIT_ORDER_ALREADY_EXISTS")]
    TakeProfitOrderAlreadyExists,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_MISSING")]
    TakeProfitOnFillPriceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_INVALID")]
    TakeProfitOnFillPriceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    TakeProfitOnFillPricePrecisionExceeded,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING")]
    TakeProfitOnFillTimeInForceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID")]
    TakeProfitOnFillTimeInForceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TakeProfitOnFillGtdTimestampMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TakeProfitOnFillGtdTimestampInPast,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TakeProfitOnFillClientOrderIdInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TakeProfitOnFillClientOrderTagInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TakeProfitOnFillClientOrderCommentInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TakeProfitOnFillTriggerConditionMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TakeProfitOnFillTriggerConditionInvalid,
    #[serde(rename = "STOP_LOSS_ORDER_ALREADY_EXISTS")]
    StopLossOrderAlreadyExists,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_REQUIRED")]
    StopLossOrderGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD")]
    StopLossOrderGuaranteedPriceWithinSpread,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED")]
    StopLossOrderGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION")]
    StopLossOrderGuaranteedHaltedCreateViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION")]
    StopLossOrderGuaranteedHaltedTightenViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED")]
    StopLossOrderGuaranteedHedgingNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOrderGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_CANCELABLE")]
    StopLossOrderNotCancelable,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_REPLACEABLE")]
    StopLossOrderNotReplaceable,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOrderGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOrderPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOrderPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER")]
    StopLossOnFillRequiredForPendingOrder,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED")]
    StopLossOnFillGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED")]
    StopLossOnFillGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_MISSING")]
    StopLossOnFillPriceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_INVALID")]
    StopLossOnFillPriceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    StopLossOnFillPricePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOnFillGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOnFillGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_INVALID")]
    StopLossOnFillDistanceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    StopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED")]
    StopLossOnFillDistancePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOnFillPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOnFillPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    StopLossOnFillTimeInForceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    StopLossOnFillTimeInForceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    StopLossOnFillGtdTimestampMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    StopLossOnFillGtdTimestampInPast,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    StopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    StopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    StopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    StopLossOnFillTriggerConditionMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    StopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS")]
    TrailingStopLossOrderAlreadyExists,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING")]
    TrailingStopLossOnFillPriceDistanceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID")]
    TrailingStopLossOnFillPriceDistanceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED")]
    TrailingStopLossOnFillPriceDistancePrecisionExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    TrailingStopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET")]
    TrailingStopLossOnFillPriceDistanceMinimumNotMet,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    TrailingStopLossOnFillTimeInForceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    TrailingStopLossOnFillTimeInForceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TrailingStopLossOnFillGtdTimestampMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TrailingStopLossOnFillGtdTimestampInPast,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TrailingStopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TrailingStopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TrailingStopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED")]
    TrailingStopLossOrdersNotSupported,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TrailingStopLossOnFillTriggerConditionMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TrailingStopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "CLOSE_TRADE_TYPE_MISSING")]
    CloseTradeTypeMissing,
    #[serde(rename = "CLOSE_TRADE_PARTIAL_UNITS_MISSING")]
    CloseTradePartialUnitsMissing,
    #[serde(rename = "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE")]
    CloseTradeUnitsExceedTradeSize,
    #[serde(rename = "CLOSEOUT_POSITION_DOESNT_EXIST")]
    CloseoutPositionDoesntExist,
    #[serde(rename = "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION")]
    CloseoutPositionIncompleteSpecification,
    #[serde(rename = "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE")]
    CloseoutPositionUnitsExceedPositionSize,
    #[serde(rename = "CLOSEOUT_POSITION_REJECT")]
    CloseoutPositionReject,
    #[serde(rename = "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING")]
    CloseoutPositionPartialUnitsMissing,
    #[serde(rename = "MARKUP_GROUP_ID_INVALID")]
    MarkupGroupIdInvalid,
    #[serde(rename = "POSITION_AGGREGATION_MODE_INVALID")]
    PositionAggregationModeInvalid,
    #[serde(rename = "ADMIN_CONFIGURE_DATA_MISSING")]
    AdminConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_INVALID")]
    MarginRateInvalid,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT")]
    MarginRateWouldTriggerCloseout,
    #[serde(rename = "ALIAS_INVALID")]
    AliasInvalid,
    #[serde(rename = "CLIENT_CONFIGURE_DATA_MISSING")]
    ClientConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL")]
    MarginRateWouldTriggerMarginCall,
    #[serde(rename = "AMOUNT_INVALID")]
    AmountInvalid,
    #[serde(rename = "INSUFFICIENT_FUNDS")]
    InsufficientFunds,
    #[serde(rename = "AMOUNT_MISSING")]
    AmountMissing,
    #[serde(rename = "FUNDING_REASON_MISSING")]
    FundingReasonMissing,
    #[serde(rename = "CLIENT_EXTENSIONS_DATA_MISSING")]
    ClientExtensionsDataMissing,
    #[serde(rename = "REPLACING_ORDER_INVALID")]
    ReplacingOrderInvalid,
    #[serde(rename = "REPLACING_TRADE_ID_INVALID")]
    ReplacingTradeIdInvalid,
}

impl From<&TrailingStopLossOrderRejectTransactionRejectReason>
    for TrailingStopLossOrderRejectTransactionRejectReason
{
    fn from(value: &TrailingStopLossOrderRejectTransactionRejectReason) -> Self {
        value.clone()
    }
}

impl ToString for TrailingStopLossOrderRejectTransactionRejectReason {
    fn to_string(&self) -> String {
        match *self {
            Self::InternalServerError => "INTERNAL_SERVER_ERROR".to_string(),
            Self::InstrumentPriceUnknown => "INSTRUMENT_PRICE_UNKNOWN".to_string(),
            Self::AccountNotActive => "ACCOUNT_NOT_ACTIVE".to_string(),
            Self::AccountLocked => "ACCOUNT_LOCKED".to_string(),
            Self::AccountOrderCreationLocked => "ACCOUNT_ORDER_CREATION_LOCKED".to_string(),
            Self::AccountConfigurationLocked => "ACCOUNT_CONFIGURATION_LOCKED".to_string(),
            Self::AccountDepositLocked => "ACCOUNT_DEPOSIT_LOCKED".to_string(),
            Self::AccountWithdrawalLocked => "ACCOUNT_WITHDRAWAL_LOCKED".to_string(),
            Self::AccountOrderCancelLocked => "ACCOUNT_ORDER_CANCEL_LOCKED".to_string(),
            Self::InstrumentNotTradeable => "INSTRUMENT_NOT_TRADEABLE".to_string(),
            Self::PendingOrdersAllowedExceeded => "PENDING_ORDERS_ALLOWED_EXCEEDED".to_string(),
            Self::OrderIdUnspecified => "ORDER_ID_UNSPECIFIED".to_string(),
            Self::OrderDoesntExist => "ORDER_DOESNT_EXIST".to_string(),
            Self::OrderIdentifierInconsistency => "ORDER_IDENTIFIER_INCONSISTENCY".to_string(),
            Self::TradeIdUnspecified => "TRADE_ID_UNSPECIFIED".to_string(),
            Self::TradeDoesntExist => "TRADE_DOESNT_EXIST".to_string(),
            Self::TradeIdentifierInconsistency => "TRADE_IDENTIFIER_INCONSISTENCY".to_string(),
            Self::InsufficientMargin => "INSUFFICIENT_MARGIN".to_string(),
            Self::InstrumentMissing => "INSTRUMENT_MISSING".to_string(),
            Self::InstrumentUnknown => "INSTRUMENT_UNKNOWN".to_string(),
            Self::UnitsMissing => "UNITS_MISSING".to_string(),
            Self::UnitsInvalid => "UNITS_INVALID".to_string(),
            Self::UnitsPrecisionExceeded => "UNITS_PRECISION_EXCEEDED".to_string(),
            Self::UnitsLimitExceeded => "UNITS_LIMIT_EXCEEDED".to_string(),
            Self::UnitsMimimumNotMet => "UNITS_MIMIMUM_NOT_MET".to_string(),
            Self::PriceMissing => "PRICE_MISSING".to_string(),
            Self::PriceInvalid => "PRICE_INVALID".to_string(),
            Self::PricePrecisionExceeded => "PRICE_PRECISION_EXCEEDED".to_string(),
            Self::PriceDistanceMissing => "PRICE_DISTANCE_MISSING".to_string(),
            Self::PriceDistanceInvalid => "PRICE_DISTANCE_INVALID".to_string(),
            Self::PriceDistancePrecisionExceeded => "PRICE_DISTANCE_PRECISION_EXCEEDED".to_string(),
            Self::PriceDistanceMaximumExceeded => "PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string(),
            Self::PriceDistanceMinimumNotMet => "PRICE_DISTANCE_MINIMUM_NOT_MET".to_string(),
            Self::TimeInForceMissing => "TIME_IN_FORCE_MISSING".to_string(),
            Self::TimeInForceInvalid => "TIME_IN_FORCE_INVALID".to_string(),
            Self::TimeInForceGtdTimestampMissing => {
                "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TimeInForceGtdTimestampInPast => {
                "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::PriceBoundInvalid => "PRICE_BOUND_INVALID".to_string(),
            Self::PriceBoundPrecisionExceeded => "PRICE_BOUND_PRECISION_EXCEEDED".to_string(),
            Self::OrdersOnFillDuplicateClientOrderIds => {
                "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS".to_string()
            }
            Self::TradeOnFillClientExtensionsNotSupported => {
                "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED".to_string()
            }
            Self::ClientOrderIdInvalid => "CLIENT_ORDER_ID_INVALID".to_string(),
            Self::ClientOrderIdAlreadyExists => "CLIENT_ORDER_ID_ALREADY_EXISTS".to_string(),
            Self::ClientOrderTagInvalid => "CLIENT_ORDER_TAG_INVALID".to_string(),
            Self::ClientOrderCommentInvalid => "CLIENT_ORDER_COMMENT_INVALID".to_string(),
            Self::ClientTradeIdInvalid => "CLIENT_TRADE_ID_INVALID".to_string(),
            Self::ClientTradeIdAlreadyExists => "CLIENT_TRADE_ID_ALREADY_EXISTS".to_string(),
            Self::ClientTradeTagInvalid => "CLIENT_TRADE_TAG_INVALID".to_string(),
            Self::ClientTradeCommentInvalid => "CLIENT_TRADE_COMMENT_INVALID".to_string(),
            Self::OrderFillPositionActionMissing => {
                "ORDER_FILL_POSITION_ACTION_MISSING".to_string()
            }
            Self::OrderFillPositionActionInvalid => {
                "ORDER_FILL_POSITION_ACTION_INVALID".to_string()
            }
            Self::TriggerConditionMissing => "TRIGGER_CONDITION_MISSING".to_string(),
            Self::TriggerConditionInvalid => "TRIGGER_CONDITION_INVALID".to_string(),
            Self::OrderPartialFillOptionMissing => "ORDER_PARTIAL_FILL_OPTION_MISSING".to_string(),
            Self::OrderPartialFillOptionInvalid => "ORDER_PARTIAL_FILL_OPTION_INVALID".to_string(),
            Self::InvalidReissueImmediatePartialFill => {
                "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL".to_string()
            }
            Self::TakeProfitOrderAlreadyExists => "TAKE_PROFIT_ORDER_ALREADY_EXISTS".to_string(),
            Self::TakeProfitOnFillPriceMissing => "TAKE_PROFIT_ON_FILL_PRICE_MISSING".to_string(),
            Self::TakeProfitOnFillPriceInvalid => "TAKE_PROFIT_ON_FILL_PRICE_INVALID".to_string(),
            Self::TakeProfitOnFillPricePrecisionExceeded => {
                "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED".to_string()
            }
            Self::TakeProfitOnFillTimeInForceMissing => {
                "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::TakeProfitOnFillTimeInForceInvalid => {
                "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::TakeProfitOnFillGtdTimestampMissing => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TakeProfitOnFillGtdTimestampInPast => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TakeProfitOnFillClientOrderIdInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::TakeProfitOnFillClientOrderTagInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::TakeProfitOnFillClientOrderCommentInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::TakeProfitOnFillTriggerConditionMissing => {
                "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::TakeProfitOnFillTriggerConditionInvalid => {
                "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::StopLossOrderAlreadyExists => "STOP_LOSS_ORDER_ALREADY_EXISTS".to_string(),
            Self::StopLossOrderGuaranteedRequired => {
                "STOP_LOSS_ORDER_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOrderGuaranteedPriceWithinSpread => {
                "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD".to_string()
            }
            Self::StopLossOrderGuaranteedNotAllowed => {
                "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOrderGuaranteedHaltedCreateViolation => {
                "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION".to_string()
            }
            Self::StopLossOrderGuaranteedHaltedTightenViolation => {
                "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION".to_string()
            }
            Self::StopLossOrderGuaranteedHedgingNotAllowed => {
                "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED".to_string()
            }
            Self::StopLossOrderGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOrderNotCancelable => "STOP_LOSS_ORDER_NOT_CANCELABLE".to_string(),
            Self::StopLossOrderNotReplaceable => "STOP_LOSS_ORDER_NOT_REPLACEABLE".to_string(),
            Self::StopLossOrderGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOrderPriceAndDistanceBothSpecified => {
                "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED".to_string()
            }
            Self::StopLossOrderPriceAndDistanceBothMissing => {
                "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING".to_string()
            }
            Self::StopLossOnFillRequiredForPendingOrder => {
                "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER".to_string()
            }
            Self::StopLossOnFillGuaranteedNotAllowed => {
                "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOnFillGuaranteedRequired => {
                "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOnFillPriceMissing => "STOP_LOSS_ON_FILL_PRICE_MISSING".to_string(),
            Self::StopLossOnFillPriceInvalid => "STOP_LOSS_ON_FILL_PRICE_INVALID".to_string(),
            Self::StopLossOnFillPricePrecisionExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOnFillGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillDistanceInvalid => "STOP_LOSS_ON_FILL_DISTANCE_INVALID".to_string(),
            Self::StopLossOnFillPriceDistanceMaximumExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::StopLossOnFillDistancePrecisionExceeded => {
                "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillPriceAndDistanceBothSpecified => {
                "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED".to_string()
            }
            Self::StopLossOnFillPriceAndDistanceBothMissing => {
                "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING".to_string()
            }
            Self::StopLossOnFillTimeInForceMissing => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::StopLossOnFillTimeInForceInvalid => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::StopLossOnFillGtdTimestampMissing => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::StopLossOnFillGtdTimestampInPast => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::StopLossOnFillClientOrderIdInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::StopLossOnFillClientOrderTagInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::StopLossOnFillClientOrderCommentInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::StopLossOnFillTriggerConditionMissing => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::StopLossOnFillTriggerConditionInvalid => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::TrailingStopLossOrderAlreadyExists => {
                "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistancePrecisionExceeded => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMaximumExceeded => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMinimumNotMet => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET".to_string()
            }
            Self::TrailingStopLossOnFillTimeInForceMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillTimeInForceInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampInPast => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderIdInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderTagInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderCommentInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::TrailingStopLossOrdersNotSupported => {
                "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED".to_string()
            }
            Self::TrailingStopLossOnFillTriggerConditionMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillTriggerConditionInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::CloseTradeTypeMissing => "CLOSE_TRADE_TYPE_MISSING".to_string(),
            Self::CloseTradePartialUnitsMissing => "CLOSE_TRADE_PARTIAL_UNITS_MISSING".to_string(),
            Self::CloseTradeUnitsExceedTradeSize => {
                "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE".to_string()
            }
            Self::CloseoutPositionDoesntExist => "CLOSEOUT_POSITION_DOESNT_EXIST".to_string(),
            Self::CloseoutPositionIncompleteSpecification => {
                "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION".to_string()
            }
            Self::CloseoutPositionUnitsExceedPositionSize => {
                "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE".to_string()
            }
            Self::CloseoutPositionReject => "CLOSEOUT_POSITION_REJECT".to_string(),
            Self::CloseoutPositionPartialUnitsMissing => {
                "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING".to_string()
            }
            Self::MarkupGroupIdInvalid => "MARKUP_GROUP_ID_INVALID".to_string(),
            Self::PositionAggregationModeInvalid => "POSITION_AGGREGATION_MODE_INVALID".to_string(),
            Self::AdminConfigureDataMissing => "ADMIN_CONFIGURE_DATA_MISSING".to_string(),
            Self::MarginRateInvalid => "MARGIN_RATE_INVALID".to_string(),
            Self::MarginRateWouldTriggerCloseout => {
                "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT".to_string()
            }
            Self::AliasInvalid => "ALIAS_INVALID".to_string(),
            Self::ClientConfigureDataMissing => "CLIENT_CONFIGURE_DATA_MISSING".to_string(),
            Self::MarginRateWouldTriggerMarginCall => {
                "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL".to_string()
            }
            Self::AmountInvalid => "AMOUNT_INVALID".to_string(),
            Self::InsufficientFunds => "INSUFFICIENT_FUNDS".to_string(),
            Self::AmountMissing => "AMOUNT_MISSING".to_string(),
            Self::FundingReasonMissing => "FUNDING_REASON_MISSING".to_string(),
            Self::ClientExtensionsDataMissing => "CLIENT_EXTENSIONS_DATA_MISSING".to_string(),
            Self::ReplacingOrderInvalid => "REPLACING_ORDER_INVALID".to_string(),
            Self::ReplacingTradeIdInvalid => "REPLACING_TRADE_ID_INVALID".to_string(),
        }
    }
}

impl std::str::FromStr for TrailingStopLossOrderRejectTransactionRejectReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "INTERNAL_SERVER_ERROR" => Ok(Self::InternalServerError),
            "INSTRUMENT_PRICE_UNKNOWN" => Ok(Self::InstrumentPriceUnknown),
            "ACCOUNT_NOT_ACTIVE" => Ok(Self::AccountNotActive),
            "ACCOUNT_LOCKED" => Ok(Self::AccountLocked),
            "ACCOUNT_ORDER_CREATION_LOCKED" => Ok(Self::AccountOrderCreationLocked),
            "ACCOUNT_CONFIGURATION_LOCKED" => Ok(Self::AccountConfigurationLocked),
            "ACCOUNT_DEPOSIT_LOCKED" => Ok(Self::AccountDepositLocked),
            "ACCOUNT_WITHDRAWAL_LOCKED" => Ok(Self::AccountWithdrawalLocked),
            "ACCOUNT_ORDER_CANCEL_LOCKED" => Ok(Self::AccountOrderCancelLocked),
            "INSTRUMENT_NOT_TRADEABLE" => Ok(Self::InstrumentNotTradeable),
            "PENDING_ORDERS_ALLOWED_EXCEEDED" => Ok(Self::PendingOrdersAllowedExceeded),
            "ORDER_ID_UNSPECIFIED" => Ok(Self::OrderIdUnspecified),
            "ORDER_DOESNT_EXIST" => Ok(Self::OrderDoesntExist),
            "ORDER_IDENTIFIER_INCONSISTENCY" => Ok(Self::OrderIdentifierInconsistency),
            "TRADE_ID_UNSPECIFIED" => Ok(Self::TradeIdUnspecified),
            "TRADE_DOESNT_EXIST" => Ok(Self::TradeDoesntExist),
            "TRADE_IDENTIFIER_INCONSISTENCY" => Ok(Self::TradeIdentifierInconsistency),
            "INSUFFICIENT_MARGIN" => Ok(Self::InsufficientMargin),
            "INSTRUMENT_MISSING" => Ok(Self::InstrumentMissing),
            "INSTRUMENT_UNKNOWN" => Ok(Self::InstrumentUnknown),
            "UNITS_MISSING" => Ok(Self::UnitsMissing),
            "UNITS_INVALID" => Ok(Self::UnitsInvalid),
            "UNITS_PRECISION_EXCEEDED" => Ok(Self::UnitsPrecisionExceeded),
            "UNITS_LIMIT_EXCEEDED" => Ok(Self::UnitsLimitExceeded),
            "UNITS_MIMIMUM_NOT_MET" => Ok(Self::UnitsMimimumNotMet),
            "PRICE_MISSING" => Ok(Self::PriceMissing),
            "PRICE_INVALID" => Ok(Self::PriceInvalid),
            "PRICE_PRECISION_EXCEEDED" => Ok(Self::PricePrecisionExceeded),
            "PRICE_DISTANCE_MISSING" => Ok(Self::PriceDistanceMissing),
            "PRICE_DISTANCE_INVALID" => Ok(Self::PriceDistanceInvalid),
            "PRICE_DISTANCE_PRECISION_EXCEEDED" => Ok(Self::PriceDistancePrecisionExceeded),
            "PRICE_DISTANCE_MAXIMUM_EXCEEDED" => Ok(Self::PriceDistanceMaximumExceeded),
            "PRICE_DISTANCE_MINIMUM_NOT_MET" => Ok(Self::PriceDistanceMinimumNotMet),
            "TIME_IN_FORCE_MISSING" => Ok(Self::TimeInForceMissing),
            "TIME_IN_FORCE_INVALID" => Ok(Self::TimeInForceInvalid),
            "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING" => Ok(Self::TimeInForceGtdTimestampMissing),
            "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST" => Ok(Self::TimeInForceGtdTimestampInPast),
            "PRICE_BOUND_INVALID" => Ok(Self::PriceBoundInvalid),
            "PRICE_BOUND_PRECISION_EXCEEDED" => Ok(Self::PriceBoundPrecisionExceeded),
            "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS" => {
                Ok(Self::OrdersOnFillDuplicateClientOrderIds)
            }
            "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED" => {
                Ok(Self::TradeOnFillClientExtensionsNotSupported)
            }
            "CLIENT_ORDER_ID_INVALID" => Ok(Self::ClientOrderIdInvalid),
            "CLIENT_ORDER_ID_ALREADY_EXISTS" => Ok(Self::ClientOrderIdAlreadyExists),
            "CLIENT_ORDER_TAG_INVALID" => Ok(Self::ClientOrderTagInvalid),
            "CLIENT_ORDER_COMMENT_INVALID" => Ok(Self::ClientOrderCommentInvalid),
            "CLIENT_TRADE_ID_INVALID" => Ok(Self::ClientTradeIdInvalid),
            "CLIENT_TRADE_ID_ALREADY_EXISTS" => Ok(Self::ClientTradeIdAlreadyExists),
            "CLIENT_TRADE_TAG_INVALID" => Ok(Self::ClientTradeTagInvalid),
            "CLIENT_TRADE_COMMENT_INVALID" => Ok(Self::ClientTradeCommentInvalid),
            "ORDER_FILL_POSITION_ACTION_MISSING" => Ok(Self::OrderFillPositionActionMissing),
            "ORDER_FILL_POSITION_ACTION_INVALID" => Ok(Self::OrderFillPositionActionInvalid),
            "TRIGGER_CONDITION_MISSING" => Ok(Self::TriggerConditionMissing),
            "TRIGGER_CONDITION_INVALID" => Ok(Self::TriggerConditionInvalid),
            "ORDER_PARTIAL_FILL_OPTION_MISSING" => Ok(Self::OrderPartialFillOptionMissing),
            "ORDER_PARTIAL_FILL_OPTION_INVALID" => Ok(Self::OrderPartialFillOptionInvalid),
            "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL" => {
                Ok(Self::InvalidReissueImmediatePartialFill)
            }
            "TAKE_PROFIT_ORDER_ALREADY_EXISTS" => Ok(Self::TakeProfitOrderAlreadyExists),
            "TAKE_PROFIT_ON_FILL_PRICE_MISSING" => Ok(Self::TakeProfitOnFillPriceMissing),
            "TAKE_PROFIT_ON_FILL_PRICE_INVALID" => Ok(Self::TakeProfitOnFillPriceInvalid),
            "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(Self::TakeProfitOnFillPricePrecisionExceeded)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(Self::TakeProfitOnFillTimeInForceMissing)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(Self::TakeProfitOnFillTimeInForceInvalid)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::TakeProfitOnFillGtdTimestampMissing)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TakeProfitOnFillGtdTimestampInPast)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderIdInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderTagInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderCommentInvalid)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::TakeProfitOnFillTriggerConditionMissing)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::TakeProfitOnFillTriggerConditionInvalid)
            }
            "STOP_LOSS_ORDER_ALREADY_EXISTS" => Ok(Self::StopLossOrderAlreadyExists),
            "STOP_LOSS_ORDER_GUARANTEED_REQUIRED" => Ok(Self::StopLossOrderGuaranteedRequired),
            "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD" => {
                Ok(Self::StopLossOrderGuaranteedPriceWithinSpread)
            }
            "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED" => Ok(Self::StopLossOrderGuaranteedNotAllowed),
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION" => {
                Ok(Self::StopLossOrderGuaranteedHaltedCreateViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION" => {
                Ok(Self::StopLossOrderGuaranteedHaltedTightenViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED" => {
                Ok(Self::StopLossOrderGuaranteedHedgingNotAllowed)
            }
            "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOrderGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ORDER_NOT_CANCELABLE" => Ok(Self::StopLossOrderNotCancelable),
            "STOP_LOSS_ORDER_NOT_REPLACEABLE" => Ok(Self::StopLossOrderNotReplaceable),
            "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOrderGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(Self::StopLossOrderPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(Self::StopLossOrderPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER" => {
                Ok(Self::StopLossOnFillRequiredForPendingOrder)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED" => {
                Ok(Self::StopLossOnFillGuaranteedNotAllowed)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED" => Ok(Self::StopLossOnFillGuaranteedRequired),
            "STOP_LOSS_ON_FILL_PRICE_MISSING" => Ok(Self::StopLossOnFillPriceMissing),
            "STOP_LOSS_ON_FILL_PRICE_INVALID" => Ok(Self::StopLossOnFillPriceInvalid),
            "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(Self::StopLossOnFillPricePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOnFillGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOnFillGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_INVALID" => Ok(Self::StopLossOnFillDistanceInvalid),
            "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::StopLossOnFillPriceDistanceMaximumExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(Self::StopLossOnFillDistancePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(Self::StopLossOnFillPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(Self::StopLossOnFillPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => Ok(Self::StopLossOnFillTimeInForceMissing),
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => Ok(Self::StopLossOnFillTimeInForceInvalid),
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::StopLossOnFillGtdTimestampMissing)
            }
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => Ok(Self::StopLossOnFillGtdTimestampInPast),
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderIdInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderTagInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderCommentInvalid)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::StopLossOnFillTriggerConditionMissing)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::StopLossOnFillTriggerConditionInvalid)
            }
            "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS" => {
                Ok(Self::TrailingStopLossOrderAlreadyExists)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(Self::TrailingStopLossOnFillPriceDistancePrecisionExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMaximumExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMinimumNotMet)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(Self::TrailingStopLossOnFillTimeInForceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(Self::TrailingStopLossOnFillTimeInForceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampInPast)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderIdInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderTagInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderCommentInvalid)
            }
            "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED" => {
                Ok(Self::TrailingStopLossOrdersNotSupported)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::TrailingStopLossOnFillTriggerConditionMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::TrailingStopLossOnFillTriggerConditionInvalid)
            }
            "CLOSE_TRADE_TYPE_MISSING" => Ok(Self::CloseTradeTypeMissing),
            "CLOSE_TRADE_PARTIAL_UNITS_MISSING" => Ok(Self::CloseTradePartialUnitsMissing),
            "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE" => Ok(Self::CloseTradeUnitsExceedTradeSize),
            "CLOSEOUT_POSITION_DOESNT_EXIST" => Ok(Self::CloseoutPositionDoesntExist),
            "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION" => {
                Ok(Self::CloseoutPositionIncompleteSpecification)
            }
            "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE" => {
                Ok(Self::CloseoutPositionUnitsExceedPositionSize)
            }
            "CLOSEOUT_POSITION_REJECT" => Ok(Self::CloseoutPositionReject),
            "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING" => {
                Ok(Self::CloseoutPositionPartialUnitsMissing)
            }
            "MARKUP_GROUP_ID_INVALID" => Ok(Self::MarkupGroupIdInvalid),
            "POSITION_AGGREGATION_MODE_INVALID" => Ok(Self::PositionAggregationModeInvalid),
            "ADMIN_CONFIGURE_DATA_MISSING" => Ok(Self::AdminConfigureDataMissing),
            "MARGIN_RATE_INVALID" => Ok(Self::MarginRateInvalid),
            "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT" => Ok(Self::MarginRateWouldTriggerCloseout),
            "ALIAS_INVALID" => Ok(Self::AliasInvalid),
            "CLIENT_CONFIGURE_DATA_MISSING" => Ok(Self::ClientConfigureDataMissing),
            "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL" => Ok(Self::MarginRateWouldTriggerMarginCall),
            "AMOUNT_INVALID" => Ok(Self::AmountInvalid),
            "INSUFFICIENT_FUNDS" => Ok(Self::InsufficientFunds),
            "AMOUNT_MISSING" => Ok(Self::AmountMissing),
            "FUNDING_REASON_MISSING" => Ok(Self::FundingReasonMissing),
            "CLIENT_EXTENSIONS_DATA_MISSING" => Ok(Self::ClientExtensionsDataMissing),
            "REPLACING_ORDER_INVALID" => Ok(Self::ReplacingOrderInvalid),
            "REPLACING_TRADE_ID_INVALID" => Ok(Self::ReplacingTradeIdInvalid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TrailingStopLossOrderRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TrailingStopLossOrderRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TrailingStopLossOrderRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The time-in-force requested for the TrailingStopLoss Order. Restricted
/// to "GTC", "GFD" and "GTD" for TrailingStopLoss Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the TrailingStopLoss
/// Order. Restricted to \"GTC\", \"GFD\" and \"GTD\" for TrailingStopLoss
/// Orders.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TrailingStopLossOrderRejectTransactionTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&TrailingStopLossOrderRejectTransactionTimeInForce>
    for TrailingStopLossOrderRejectTransactionTimeInForce
{
    fn from(value: &TrailingStopLossOrderRejectTransactionTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for TrailingStopLossOrderRejectTransactionTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for TrailingStopLossOrderRejectTransactionTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TrailingStopLossOrderRejectTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TrailingStopLossOrderRejectTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TrailingStopLossOrderRejectTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///Specification of which price component should be used when determining
/// if an Order should be triggered and filled. This allows Orders to be
/// triggered based on the bid, ask, mid, default (ask for buy, bid for
/// sell) or inverse (ask for sell, bid for buy) price depending on the
/// desired behaviour. Orders are always filled using their default price
/// component. This feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order. A special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
/// results in. So for a Stop Loss Order for a long trade valid values are
/// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are valid.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of which price component should be used
/// when determining if an Order should be triggered and filled. This allows
/// Orders to be triggered based on the bid, ask, mid, default (ask for buy,
/// bid for sell) or inverse (ask for sell, bid for buy) price depending on
/// the desired behaviour. Orders are always filled using their default
/// price component.\nThis feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///  "type": "string",
///  "enum": [
///    "DEFAULT",
///    "INVERSE",
///    "BID",
///    "ASK",
///    "MID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TrailingStopLossOrderRejectTransactionTriggerCondition {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "INVERSE")]
    Inverse,
    #[serde(rename = "BID")]
    Bid,
    #[serde(rename = "ASK")]
    Ask,
    #[serde(rename = "MID")]
    Mid,
}

impl From<&TrailingStopLossOrderRejectTransactionTriggerCondition>
    for TrailingStopLossOrderRejectTransactionTriggerCondition
{
    fn from(value: &TrailingStopLossOrderRejectTransactionTriggerCondition) -> Self {
        value.clone()
    }
}

impl ToString for TrailingStopLossOrderRejectTransactionTriggerCondition {
    fn to_string(&self) -> String {
        match *self {
            Self::Default => "DEFAULT".to_string(),
            Self::Inverse => "INVERSE".to_string(),
            Self::Bid => "BID".to_string(),
            Self::Ask => "ASK".to_string(),
            Self::Mid => "MID".to_string(),
        }
    }
}

impl std::str::FromStr for TrailingStopLossOrderRejectTransactionTriggerCondition {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DEFAULT" => Ok(Self::Default),
            "INVERSE" => Ok(Self::Inverse),
            "BID" => Ok(Self::Bid),
            "ASK" => Ok(Self::Ask),
            "MID" => Ok(Self::Mid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TrailingStopLossOrderRejectTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TrailingStopLossOrderRejectTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TrailingStopLossOrderRejectTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Type of the Transaction. Always set to
/// "TRAILING_STOP_LOSS_ORDER_REJECT" in a
/// TrailingStopLossOrderRejectTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"TRAILING_STOP_LOSS_ORDER_REJECT\" in a
/// TrailingStopLossOrderRejectTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TrailingStopLossOrderRejectTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&TrailingStopLossOrderRejectTransactionType>
    for TrailingStopLossOrderRejectTransactionType
{
    fn from(value: &TrailingStopLossOrderRejectTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for TrailingStopLossOrderRejectTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for TrailingStopLossOrderRejectTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TrailingStopLossOrderRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TrailingStopLossOrderRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TrailingStopLossOrderRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A TrailingStopLossOrderRequest specifies the parameters that may be set
/// when creating a Trailing Stop Loss Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A TrailingStopLossOrderRequest specifies the parameters
/// that may be set when creating a Trailing Stop Loss Order.",
///  "type": "object",
///  "properties": {
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "clientTradeID": {
///      "description": "The client ID of the Trade to be closed when the
/// price threshold is breached.",
///      "type": "string"
///    },
///    "distance": {
///      "description": "The price distance (in price units) specified for
/// the TrailingStopLoss Order.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "gtdTime": {
///      "description": "The date/time when the StopLoss Order will be
/// cancelled if its timeInForce is \"GTD\".",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the
/// TrailingStopLoss Order. Restricted to \"GTC\", \"GFD\" and \"GTD\" for
/// TrailingStopLoss Orders.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeID": {
///      "description": "The ID of the Trade to close when the price
/// threshold is breached.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "triggerCondition": {
///      "description": "Specification of which price component should be
/// used when determining if an Order should be triggered and filled. This
/// allows Orders to be triggered based on the bid, ask, mid, default (ask
/// for buy, bid for sell) or inverse (ask for sell, bid for buy) price
/// depending on the desired behaviour. Orders are always filled using their
/// default price component.\nThis feature is only provided through the REST
/// API. Clients who choose to specify a non-default trigger condition will
/// not see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///      "type": "string",
///      "enum": [
///        "DEFAULT",
///        "INVERSE",
///        "BID",
///        "ASK",
///        "MID"
///      ]
///    },
///    "type": {
///      "description": "The type of the Order to Create. Must be set to
/// \"TRAILING_STOP_LOSS\" when creating a Trailng Stop Loss Order.",
///      "type": "string",
///      "enum": [
///        "MARKET",
///        "LIMIT",
///        "STOP",
///        "MARKET_IF_TOUCHED",
///        "TAKE_PROFIT",
///        "STOP_LOSS",
///        "TRAILING_STOP_LOSS",
///        "FIXED_PRICE"
///      ]
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TrailingStopLossOrderRequest {
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The client ID of the Trade to be closed when the price threshold is
    /// breached.
    #[serde(
        rename = "clientTradeID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_trade_id: Option<String>,
    ///The price distance (in price units) specified for the
    /// TrailingStopLoss Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distance: Option<String>,
    ///The date/time when the StopLoss Order will be cancelled if its
    /// timeInForce is "GTD".
    #[serde(rename = "gtdTime", default, skip_serializing_if = "Option::is_none")]
    pub gtd_time: Option<String>,
    ///The time-in-force requested for the TrailingStopLoss Order.
    /// Restricted to "GTC", "GFD" and "GTD" for TrailingStopLoss Orders.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<TrailingStopLossOrderRequestTimeInForce>,
    ///The ID of the Trade to close when the price threshold is breached.
    #[serde(rename = "tradeID", default, skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,
    ///Specification of which price component should be used when
    /// determining if an Order should be triggered and filled. This allows
    /// Orders to be triggered based on the bid, ask, mid, default (ask for
    /// buy, bid for sell) or inverse (ask for sell, bid for buy) price
    /// depending on the desired behaviour. Orders are always filled using
    /// their default price component. This feature is only provided
    /// through the REST API. Clients who choose to specify a non-default
    /// trigger condition will not see it reflected in any of OANDA's
    /// proprietary or partner trading platforms, their transaction history
    /// or their account statements. OANDA platforms always assume that an
    /// Order's trigger condition is set to the default value when
    /// indicating the distance from an Order's trigger price, and will
    /// always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when
    /// creating a guaranteed Stop Loss Order. In this case the
    /// TriggerCondition value must either be "DEFAULT", or the "natural"
    /// trigger side "DEFAULT" results in. So for a Stop Loss Order for a
    /// long trade valid values are "DEFAULT" and "BID", and for short
    /// trades "DEFAULT" and "ASK" are valid.
    #[serde(
        rename = "triggerCondition",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trigger_condition: Option<TrailingStopLossOrderRequestTriggerCondition>,
    ///The type of the Order to Create. Must be set to "TRAILING_STOP_LOSS"
    /// when creating a Trailng Stop Loss Order.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<TrailingStopLossOrderRequestType>,
}

impl From<&TrailingStopLossOrderRequest> for TrailingStopLossOrderRequest {
    fn from(value: &TrailingStopLossOrderRequest) -> Self {
        value.clone()
    }
}

impl TrailingStopLossOrderRequest {
    pub fn builder() -> builder::TrailingStopLossOrderRequest {
        Default::default()
    }
}

///The time-in-force requested for the TrailingStopLoss Order. Restricted
/// to "GTC", "GFD" and "GTD" for TrailingStopLoss Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the TrailingStopLoss
/// Order. Restricted to \"GTC\", \"GFD\" and \"GTD\" for TrailingStopLoss
/// Orders.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TrailingStopLossOrderRequestTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&TrailingStopLossOrderRequestTimeInForce> for TrailingStopLossOrderRequestTimeInForce {
    fn from(value: &TrailingStopLossOrderRequestTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for TrailingStopLossOrderRequestTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for TrailingStopLossOrderRequestTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TrailingStopLossOrderRequestTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TrailingStopLossOrderRequestTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TrailingStopLossOrderRequestTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///Specification of which price component should be used when determining
/// if an Order should be triggered and filled. This allows Orders to be
/// triggered based on the bid, ask, mid, default (ask for buy, bid for
/// sell) or inverse (ask for sell, bid for buy) price depending on the
/// desired behaviour. Orders are always filled using their default price
/// component. This feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order. A special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
/// results in. So for a Stop Loss Order for a long trade valid values are
/// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are valid.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of which price component should be used
/// when determining if an Order should be triggered and filled. This allows
/// Orders to be triggered based on the bid, ask, mid, default (ask for buy,
/// bid for sell) or inverse (ask for sell, bid for buy) price depending on
/// the desired behaviour. Orders are always filled using their default
/// price component.\nThis feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///  "type": "string",
///  "enum": [
///    "DEFAULT",
///    "INVERSE",
///    "BID",
///    "ASK",
///    "MID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TrailingStopLossOrderRequestTriggerCondition {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "INVERSE")]
    Inverse,
    #[serde(rename = "BID")]
    Bid,
    #[serde(rename = "ASK")]
    Ask,
    #[serde(rename = "MID")]
    Mid,
}

impl From<&TrailingStopLossOrderRequestTriggerCondition>
    for TrailingStopLossOrderRequestTriggerCondition
{
    fn from(value: &TrailingStopLossOrderRequestTriggerCondition) -> Self {
        value.clone()
    }
}

impl ToString for TrailingStopLossOrderRequestTriggerCondition {
    fn to_string(&self) -> String {
        match *self {
            Self::Default => "DEFAULT".to_string(),
            Self::Inverse => "INVERSE".to_string(),
            Self::Bid => "BID".to_string(),
            Self::Ask => "ASK".to_string(),
            Self::Mid => "MID".to_string(),
        }
    }
}

impl std::str::FromStr for TrailingStopLossOrderRequestTriggerCondition {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DEFAULT" => Ok(Self::Default),
            "INVERSE" => Ok(Self::Inverse),
            "BID" => Ok(Self::Bid),
            "ASK" => Ok(Self::Ask),
            "MID" => Ok(Self::Mid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TrailingStopLossOrderRequestTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TrailingStopLossOrderRequestTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TrailingStopLossOrderRequestTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The type of the Order to Create. Must be set to "TRAILING_STOP_LOSS"
/// when creating a Trailng Stop Loss Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The type of the Order to Create. Must be set to
/// \"TRAILING_STOP_LOSS\" when creating a Trailng Stop Loss Order.",
///  "type": "string",
///  "enum": [
///    "MARKET",
///    "LIMIT",
///    "STOP",
///    "MARKET_IF_TOUCHED",
///    "TAKE_PROFIT",
///    "STOP_LOSS",
///    "TRAILING_STOP_LOSS",
///    "FIXED_PRICE"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TrailingStopLossOrderRequestType {
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "STOP")]
    Stop,
    #[serde(rename = "MARKET_IF_TOUCHED")]
    MarketIfTouched,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "STOP_LOSS")]
    StopLoss,
    #[serde(rename = "TRAILING_STOP_LOSS")]
    TrailingStopLoss,
    #[serde(rename = "FIXED_PRICE")]
    FixedPrice,
}

impl From<&TrailingStopLossOrderRequestType> for TrailingStopLossOrderRequestType {
    fn from(value: &TrailingStopLossOrderRequestType) -> Self {
        value.clone()
    }
}

impl ToString for TrailingStopLossOrderRequestType {
    fn to_string(&self) -> String {
        match *self {
            Self::Market => "MARKET".to_string(),
            Self::Limit => "LIMIT".to_string(),
            Self::Stop => "STOP".to_string(),
            Self::MarketIfTouched => "MARKET_IF_TOUCHED".to_string(),
            Self::TakeProfit => "TAKE_PROFIT".to_string(),
            Self::StopLoss => "STOP_LOSS".to_string(),
            Self::TrailingStopLoss => "TRAILING_STOP_LOSS".to_string(),
            Self::FixedPrice => "FIXED_PRICE".to_string(),
        }
    }
}

impl std::str::FromStr for TrailingStopLossOrderRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "MARKET" => Ok(Self::Market),
            "LIMIT" => Ok(Self::Limit),
            "STOP" => Ok(Self::Stop),
            "MARKET_IF_TOUCHED" => Ok(Self::MarketIfTouched),
            "TAKE_PROFIT" => Ok(Self::TakeProfit),
            "STOP_LOSS" => Ok(Self::StopLoss),
            "TRAILING_STOP_LOSS" => Ok(Self::TrailingStopLoss),
            "FIXED_PRICE" => Ok(Self::FixedPrice),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TrailingStopLossOrderRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TrailingStopLossOrderRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TrailingStopLossOrderRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The current state of the Order.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The current state of the Order.",
///  "type": "string",
///  "enum": [
///    "PENDING",
///    "FILLED",
///    "TRIGGERED",
///    "CANCELLED"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TrailingStopLossOrderState {
    #[serde(rename = "PENDING")]
    Pending,
    #[serde(rename = "FILLED")]
    Filled,
    #[serde(rename = "TRIGGERED")]
    Triggered,
    #[serde(rename = "CANCELLED")]
    Cancelled,
}

impl From<&TrailingStopLossOrderState> for TrailingStopLossOrderState {
    fn from(value: &TrailingStopLossOrderState) -> Self {
        value.clone()
    }
}

impl ToString for TrailingStopLossOrderState {
    fn to_string(&self) -> String {
        match *self {
            Self::Pending => "PENDING".to_string(),
            Self::Filled => "FILLED".to_string(),
            Self::Triggered => "TRIGGERED".to_string(),
            Self::Cancelled => "CANCELLED".to_string(),
        }
    }
}

impl std::str::FromStr for TrailingStopLossOrderState {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "PENDING" => Ok(Self::Pending),
            "FILLED" => Ok(Self::Filled),
            "TRIGGERED" => Ok(Self::Triggered),
            "CANCELLED" => Ok(Self::Cancelled),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TrailingStopLossOrderState {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TrailingStopLossOrderState {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TrailingStopLossOrderState {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The time-in-force requested for the TrailingStopLoss Order. Restricted
/// to "GTC", "GFD" and "GTD" for TrailingStopLoss Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the TrailingStopLoss
/// Order. Restricted to \"GTC\", \"GFD\" and \"GTD\" for TrailingStopLoss
/// Orders.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TrailingStopLossOrderTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&TrailingStopLossOrderTimeInForce> for TrailingStopLossOrderTimeInForce {
    fn from(value: &TrailingStopLossOrderTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for TrailingStopLossOrderTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for TrailingStopLossOrderTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TrailingStopLossOrderTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TrailingStopLossOrderTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TrailingStopLossOrderTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A TrailingStopLossOrderTransaction represents the creation of a
/// TrailingStopLoss Order in the user's Account.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A TrailingStopLossOrderTransaction represents the
/// creation of a TrailingStopLoss Order in the user's Account.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "cancellingTransactionID": {
///      "description": "The ID of the Transaction that cancels the replaced
/// Order (only provided if this Order replaces an existing Order).",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "clientExtensions": {
///      "$ref": "#/components/schemas/ClientExtensions"
///    },
///    "clientTradeID": {
///      "description": "The client ID of the Trade to be closed when the
/// price threshold is breached.",
///      "type": "string"
///    },
///    "distance": {
///      "description": "The price distance (in price units) specified for
/// the TrailingStopLoss Order.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "gtdTime": {
///      "description": "The date/time when the StopLoss Order will be
/// cancelled if its timeInForce is \"GTD\".",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "orderFillTransactionID": {
///      "description": "The ID of the OrderFill Transaction that caused
/// this Order to be created (only provided if this Order was created
/// automatically when another Order was filled).",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "reason": {
///      "description": "The reason that the Trailing Stop Loss Order was
/// initiated",
///      "type": "string",
///      "enum": [
///        "CLIENT_ORDER",
///        "REPLACEMENT",
///        "ON_FILL"
///      ]
///    },
///    "replacesOrderID": {
///      "description": "The ID of the Order that this Order replaces (only
/// provided if this Order replaces an existing Order).",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned OrderID.
/// OANDA-assigned OrderIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that created the Order."
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "timeInForce": {
///      "description": "The time-in-force requested for the
/// TrailingStopLoss Order. Restricted to \"GTC\", \"GFD\" and \"GTD\" for
/// TrailingStopLoss Orders.",
///      "type": "string",
///      "enum": [
///        "GTC",
///        "GTD",
///        "GFD",
///        "FOK",
///        "IOC"
///      ]
///    },
///    "tradeID": {
///      "description": "The ID of the Trade to close when the price
/// threshold is breached.",
///      "type": "string",
///      "format": "The string representation of the OANDA-assigned TradeID.
/// OANDA-assigned TradeIDs are positive integers, and are derived from the
/// TransactionID of the Transaction that opened the Trade."
///    },
///    "triggerCondition": {
///      "description": "Specification of which price component should be
/// used when determining if an Order should be triggered and filled. This
/// allows Orders to be triggered based on the bid, ask, mid, default (ask
/// for buy, bid for sell) or inverse (ask for sell, bid for buy) price
/// depending on the desired behaviour. Orders are always filled using their
/// default price component.\nThis feature is only provided through the REST
/// API. Clients who choose to specify a non-default trigger condition will
/// not see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///      "type": "string",
///      "enum": [
///        "DEFAULT",
///        "INVERSE",
///        "BID",
///        "ASK",
///        "MID"
///      ]
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to \"TRAILING_STOP_LOSS_ORDER\" in a TrailingStopLossOrderTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TrailingStopLossOrderTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    ///The ID of the Transaction that cancels the replaced Order (only
    /// provided if this Order replaces an existing Order).
    #[serde(
        rename = "cancellingTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub cancelling_transaction_id: Option<String>,
    #[serde(
        rename = "clientExtensions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_extensions: Option<ClientExtensions>,
    ///The client ID of the Trade to be closed when the price threshold is
    /// breached.
    #[serde(
        rename = "clientTradeID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub client_trade_id: Option<String>,
    ///The price distance (in price units) specified for the
    /// TrailingStopLoss Order.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distance: Option<String>,
    ///The date/time when the StopLoss Order will be cancelled if its
    /// timeInForce is "GTD".
    #[serde(rename = "gtdTime", default, skip_serializing_if = "Option::is_none")]
    pub gtd_time: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The ID of the OrderFill Transaction that caused this Order to be
    /// created (only provided if this Order was created automatically when
    /// another Order was filled).
    #[serde(
        rename = "orderFillTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub order_fill_transaction_id: Option<String>,
    ///The reason that the Trailing Stop Loss Order was initiated
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<TrailingStopLossOrderTransactionReason>,
    ///The ID of the Order that this Order replaces (only provided if this
    /// Order replaces an existing Order).
    #[serde(
        rename = "replacesOrderID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub replaces_order_id: Option<String>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The time-in-force requested for the TrailingStopLoss Order.
    /// Restricted to "GTC", "GFD" and "GTD" for TrailingStopLoss Orders.
    #[serde(
        rename = "timeInForce",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub time_in_force: Option<TrailingStopLossOrderTransactionTimeInForce>,
    ///The ID of the Trade to close when the price threshold is breached.
    #[serde(rename = "tradeID", default, skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,
    ///Specification of which price component should be used when
    /// determining if an Order should be triggered and filled. This allows
    /// Orders to be triggered based on the bid, ask, mid, default (ask for
    /// buy, bid for sell) or inverse (ask for sell, bid for buy) price
    /// depending on the desired behaviour. Orders are always filled using
    /// their default price component. This feature is only provided
    /// through the REST API. Clients who choose to specify a non-default
    /// trigger condition will not see it reflected in any of OANDA's
    /// proprietary or partner trading platforms, their transaction history
    /// or their account statements. OANDA platforms always assume that an
    /// Order's trigger condition is set to the default value when
    /// indicating the distance from an Order's trigger price, and will
    /// always provide the default trigger condition when creating or
    /// modifying an Order. A special restriction applies when
    /// creating a guaranteed Stop Loss Order. In this case the
    /// TriggerCondition value must either be "DEFAULT", or the "natural"
    /// trigger side "DEFAULT" results in. So for a Stop Loss Order for a
    /// long trade valid values are "DEFAULT" and "BID", and for short
    /// trades "DEFAULT" and "ASK" are valid.
    #[serde(
        rename = "triggerCondition",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub trigger_condition: Option<TrailingStopLossOrderTransactionTriggerCondition>,
    ///The Type of the Transaction. Always set to
    /// "TRAILING_STOP_LOSS_ORDER" in a TrailingStopLossOrderTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<TrailingStopLossOrderTransactionType>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&TrailingStopLossOrderTransaction> for TrailingStopLossOrderTransaction {
    fn from(value: &TrailingStopLossOrderTransaction) -> Self {
        value.clone()
    }
}

impl TrailingStopLossOrderTransaction {
    pub fn builder() -> builder::TrailingStopLossOrderTransaction {
        Default::default()
    }
}

///The reason that the Trailing Stop Loss Order was initiated
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Trailing Stop Loss Order was
/// initiated",
///  "type": "string",
///  "enum": [
///    "CLIENT_ORDER",
///    "REPLACEMENT",
///    "ON_FILL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TrailingStopLossOrderTransactionReason {
    #[serde(rename = "CLIENT_ORDER")]
    ClientOrder,
    #[serde(rename = "REPLACEMENT")]
    Replacement,
    #[serde(rename = "ON_FILL")]
    OnFill,
}

impl From<&TrailingStopLossOrderTransactionReason> for TrailingStopLossOrderTransactionReason {
    fn from(value: &TrailingStopLossOrderTransactionReason) -> Self {
        value.clone()
    }
}

impl ToString for TrailingStopLossOrderTransactionReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ClientOrder => "CLIENT_ORDER".to_string(),
            Self::Replacement => "REPLACEMENT".to_string(),
            Self::OnFill => "ON_FILL".to_string(),
        }
    }
}

impl std::str::FromStr for TrailingStopLossOrderTransactionReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CLIENT_ORDER" => Ok(Self::ClientOrder),
            "REPLACEMENT" => Ok(Self::Replacement),
            "ON_FILL" => Ok(Self::OnFill),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TrailingStopLossOrderTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TrailingStopLossOrderTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TrailingStopLossOrderTransactionReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The time-in-force requested for the TrailingStopLoss Order. Restricted
/// to "GTC", "GFD" and "GTD" for TrailingStopLoss Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The time-in-force requested for the TrailingStopLoss
/// Order. Restricted to \"GTC\", \"GFD\" and \"GTD\" for TrailingStopLoss
/// Orders.",
///  "type": "string",
///  "enum": [
///    "GTC",
///    "GTD",
///    "GFD",
///    "FOK",
///    "IOC"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TrailingStopLossOrderTransactionTimeInForce {
    #[serde(rename = "GTC")]
    Gtc,
    #[serde(rename = "GTD")]
    Gtd,
    #[serde(rename = "GFD")]
    Gfd,
    #[serde(rename = "FOK")]
    Fok,
    #[serde(rename = "IOC")]
    Ioc,
}

impl From<&TrailingStopLossOrderTransactionTimeInForce>
    for TrailingStopLossOrderTransactionTimeInForce
{
    fn from(value: &TrailingStopLossOrderTransactionTimeInForce) -> Self {
        value.clone()
    }
}

impl ToString for TrailingStopLossOrderTransactionTimeInForce {
    fn to_string(&self) -> String {
        match *self {
            Self::Gtc => "GTC".to_string(),
            Self::Gtd => "GTD".to_string(),
            Self::Gfd => "GFD".to_string(),
            Self::Fok => "FOK".to_string(),
            Self::Ioc => "IOC".to_string(),
        }
    }
}

impl std::str::FromStr for TrailingStopLossOrderTransactionTimeInForce {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "GTC" => Ok(Self::Gtc),
            "GTD" => Ok(Self::Gtd),
            "GFD" => Ok(Self::Gfd),
            "FOK" => Ok(Self::Fok),
            "IOC" => Ok(Self::Ioc),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TrailingStopLossOrderTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TrailingStopLossOrderTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TrailingStopLossOrderTransactionTimeInForce {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///Specification of which price component should be used when determining
/// if an Order should be triggered and filled. This allows Orders to be
/// triggered based on the bid, ask, mid, default (ask for buy, bid for
/// sell) or inverse (ask for sell, bid for buy) price depending on the
/// desired behaviour. Orders are always filled using their default price
/// component. This feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order. A special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
/// results in. So for a Stop Loss Order for a long trade valid values are
/// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are valid.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of which price component should be used
/// when determining if an Order should be triggered and filled. This allows
/// Orders to be triggered based on the bid, ask, mid, default (ask for buy,
/// bid for sell) or inverse (ask for sell, bid for buy) price depending on
/// the desired behaviour. Orders are always filled using their default
/// price component.\nThis feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///  "type": "string",
///  "enum": [
///    "DEFAULT",
///    "INVERSE",
///    "BID",
///    "ASK",
///    "MID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TrailingStopLossOrderTransactionTriggerCondition {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "INVERSE")]
    Inverse,
    #[serde(rename = "BID")]
    Bid,
    #[serde(rename = "ASK")]
    Ask,
    #[serde(rename = "MID")]
    Mid,
}

impl From<&TrailingStopLossOrderTransactionTriggerCondition>
    for TrailingStopLossOrderTransactionTriggerCondition
{
    fn from(value: &TrailingStopLossOrderTransactionTriggerCondition) -> Self {
        value.clone()
    }
}

impl ToString for TrailingStopLossOrderTransactionTriggerCondition {
    fn to_string(&self) -> String {
        match *self {
            Self::Default => "DEFAULT".to_string(),
            Self::Inverse => "INVERSE".to_string(),
            Self::Bid => "BID".to_string(),
            Self::Ask => "ASK".to_string(),
            Self::Mid => "MID".to_string(),
        }
    }
}

impl std::str::FromStr for TrailingStopLossOrderTransactionTriggerCondition {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DEFAULT" => Ok(Self::Default),
            "INVERSE" => Ok(Self::Inverse),
            "BID" => Ok(Self::Bid),
            "ASK" => Ok(Self::Ask),
            "MID" => Ok(Self::Mid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TrailingStopLossOrderTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TrailingStopLossOrderTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TrailingStopLossOrderTransactionTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Type of the Transaction. Always set to "TRAILING_STOP_LOSS_ORDER" in
/// a TrailingStopLossOrderTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to \"TRAILING_STOP_LOSS_ORDER\" in a TrailingStopLossOrderTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TrailingStopLossOrderTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&TrailingStopLossOrderTransactionType> for TrailingStopLossOrderTransactionType {
    fn from(value: &TrailingStopLossOrderTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for TrailingStopLossOrderTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for TrailingStopLossOrderTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TrailingStopLossOrderTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TrailingStopLossOrderTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TrailingStopLossOrderTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///Specification of which price component should be used when determining
/// if an Order should be triggered and filled. This allows Orders to be
/// triggered based on the bid, ask, mid, default (ask for buy, bid for
/// sell) or inverse (ask for sell, bid for buy) price depending on the
/// desired behaviour. Orders are always filled using their default price
/// component. This feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order. A special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be "DEFAULT", or the "natural" trigger side "DEFAULT"
/// results in. So for a Stop Loss Order for a long trade valid values are
/// "DEFAULT" and "BID", and for short trades "DEFAULT" and "ASK" are valid.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Specification of which price component should be used
/// when determining if an Order should be triggered and filled. This allows
/// Orders to be triggered based on the bid, ask, mid, default (ask for buy,
/// bid for sell) or inverse (ask for sell, bid for buy) price depending on
/// the desired behaviour. Orders are always filled using their default
/// price component.\nThis feature is only provided through the REST API.
/// Clients who choose to specify a non-default trigger condition will not
/// see it reflected in any of OANDA's proprietary or partner trading
/// platforms, their transaction history or their account statements. OANDA
/// platforms always assume that an Order's trigger condition is set to the
/// default value when indicating the distance from an Order's trigger
/// price, and will always provide the default trigger condition when
/// creating or modifying an Order.\nA special restriction applies when
/// creating a guaranteed Stop Loss Order. In this case the TriggerCondition
/// value must either be \"DEFAULT\", or the \"natural\" trigger side
/// \"DEFAULT\" results in. So for a Stop Loss Order for a long trade valid
/// values are \"DEFAULT\" and \"BID\", and for short trades \"DEFAULT\" and
/// \"ASK\" are valid.",
///  "type": "string",
///  "enum": [
///    "DEFAULT",
///    "INVERSE",
///    "BID",
///    "ASK",
///    "MID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TrailingStopLossOrderTriggerCondition {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "INVERSE")]
    Inverse,
    #[serde(rename = "BID")]
    Bid,
    #[serde(rename = "ASK")]
    Ask,
    #[serde(rename = "MID")]
    Mid,
}

impl From<&TrailingStopLossOrderTriggerCondition> for TrailingStopLossOrderTriggerCondition {
    fn from(value: &TrailingStopLossOrderTriggerCondition) -> Self {
        value.clone()
    }
}

impl ToString for TrailingStopLossOrderTriggerCondition {
    fn to_string(&self) -> String {
        match *self {
            Self::Default => "DEFAULT".to_string(),
            Self::Inverse => "INVERSE".to_string(),
            Self::Bid => "BID".to_string(),
            Self::Ask => "ASK".to_string(),
            Self::Mid => "MID".to_string(),
        }
    }
}

impl std::str::FromStr for TrailingStopLossOrderTriggerCondition {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "DEFAULT" => Ok(Self::Default),
            "INVERSE" => Ok(Self::Inverse),
            "BID" => Ok(Self::Bid),
            "ASK" => Ok(Self::Ask),
            "MID" => Ok(Self::Mid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TrailingStopLossOrderTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TrailingStopLossOrderTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TrailingStopLossOrderTriggerCondition {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The type of the Order. Always set to "TRAILING_STOP_LOSS" for Trailing
/// Stop Loss Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The type of the Order. Always set to
/// \"TRAILING_STOP_LOSS\" for Trailing Stop Loss Orders.",
///  "type": "string",
///  "enum": [
///    "MARKET",
///    "LIMIT",
///    "STOP",
///    "MARKET_IF_TOUCHED",
///    "TAKE_PROFIT",
///    "STOP_LOSS",
///    "TRAILING_STOP_LOSS",
///    "FIXED_PRICE"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TrailingStopLossOrderType {
    #[serde(rename = "MARKET")]
    Market,
    #[serde(rename = "LIMIT")]
    Limit,
    #[serde(rename = "STOP")]
    Stop,
    #[serde(rename = "MARKET_IF_TOUCHED")]
    MarketIfTouched,
    #[serde(rename = "TAKE_PROFIT")]
    TakeProfit,
    #[serde(rename = "STOP_LOSS")]
    StopLoss,
    #[serde(rename = "TRAILING_STOP_LOSS")]
    TrailingStopLoss,
    #[serde(rename = "FIXED_PRICE")]
    FixedPrice,
}

impl From<&TrailingStopLossOrderType> for TrailingStopLossOrderType {
    fn from(value: &TrailingStopLossOrderType) -> Self {
        value.clone()
    }
}

impl ToString for TrailingStopLossOrderType {
    fn to_string(&self) -> String {
        match *self {
            Self::Market => "MARKET".to_string(),
            Self::Limit => "LIMIT".to_string(),
            Self::Stop => "STOP".to_string(),
            Self::MarketIfTouched => "MARKET_IF_TOUCHED".to_string(),
            Self::TakeProfit => "TAKE_PROFIT".to_string(),
            Self::StopLoss => "STOP_LOSS".to_string(),
            Self::TrailingStopLoss => "TRAILING_STOP_LOSS".to_string(),
            Self::FixedPrice => "FIXED_PRICE".to_string(),
        }
    }
}

impl std::str::FromStr for TrailingStopLossOrderType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "MARKET" => Ok(Self::Market),
            "LIMIT" => Ok(Self::Limit),
            "STOP" => Ok(Self::Stop),
            "MARKET_IF_TOUCHED" => Ok(Self::MarketIfTouched),
            "TAKE_PROFIT" => Ok(Self::TakeProfit),
            "STOP_LOSS" => Ok(Self::StopLoss),
            "TRAILING_STOP_LOSS" => Ok(Self::TrailingStopLoss),
            "FIXED_PRICE" => Ok(Self::FixedPrice),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TrailingStopLossOrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TrailingStopLossOrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TrailingStopLossOrderType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The base Transaction specification. Specifies properties that are common
/// between all Transaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The base Transaction specification. Specifies
/// properties that are common between all Transaction.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Transaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&Transaction> for Transaction {
    fn from(value: &Transaction) -> Self {
        value.clone()
    }
}

impl Transaction {
    pub fn builder() -> builder::Transaction {
        Default::default()
    }
}

///A filter that can be used when fetching Transactions
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A filter that can be used when fetching Transactions",
///  "type": "string",
///  "enum": [
///    "ORDER",
///    "FUNDING",
///    "ADMIN",
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ONE_CANCELS_ALL_ORDER",
///    "ONE_CANCELS_ALL_ORDER_REJECT",
///    "ONE_CANCELS_ALL_ORDER_TRIGGERED",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TransactionFilter {
    #[serde(rename = "ORDER")]
    Order,
    #[serde(rename = "FUNDING")]
    Funding,
    #[serde(rename = "ADMIN")]
    Admin,
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ONE_CANCELS_ALL_ORDER")]
    OneCancelsAllOrder,
    #[serde(rename = "ONE_CANCELS_ALL_ORDER_REJECT")]
    OneCancelsAllOrderReject,
    #[serde(rename = "ONE_CANCELS_ALL_ORDER_TRIGGERED")]
    OneCancelsAllOrderTriggered,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&TransactionFilter> for TransactionFilter {
    fn from(value: &TransactionFilter) -> Self {
        value.clone()
    }
}

impl ToString for TransactionFilter {
    fn to_string(&self) -> String {
        match *self {
            Self::Order => "ORDER".to_string(),
            Self::Funding => "FUNDING".to_string(),
            Self::Admin => "ADMIN".to_string(),
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OneCancelsAllOrder => "ONE_CANCELS_ALL_ORDER".to_string(),
            Self::OneCancelsAllOrderReject => "ONE_CANCELS_ALL_ORDER_REJECT".to_string(),
            Self::OneCancelsAllOrderTriggered => "ONE_CANCELS_ALL_ORDER_TRIGGERED".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for TransactionFilter {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "ORDER" => Ok(Self::Order),
            "FUNDING" => Ok(Self::Funding),
            "ADMIN" => Ok(Self::Admin),
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ONE_CANCELS_ALL_ORDER" => Ok(Self::OneCancelsAllOrder),
            "ONE_CANCELS_ALL_ORDER_REJECT" => Ok(Self::OneCancelsAllOrderReject),
            "ONE_CANCELS_ALL_ORDER_TRIGGERED" => Ok(Self::OneCancelsAllOrderTriggered),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TransactionFilter {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TransactionFilter {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TransactionFilter {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A TransactionHeartbeat object is injected into the Transaction stream to
/// ensure that the HTTP connection remains active.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A TransactionHeartbeat object is injected into the Transaction stream to ensure that the HTTP connection remains active.",
///  "type": "object",
///  "properties": {
///    "lastTransactionID": {
///      "description": "The ID of the most recent Transaction created for
/// the Account",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "time": {
///      "description": "The date/time when the TransactionHeartbeat was
/// created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "type": {
///      "description": "The string \"HEARTBEAT\"",
///      "type": "string"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TransactionHeartbeat {
    ///The ID of the most recent Transaction created for the Account
    #[serde(
        rename = "lastTransactionID",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub last_transaction_id: Option<String>,
    ///The date/time when the TransactionHeartbeat was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The string "HEARTBEAT"
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
}

impl From<&TransactionHeartbeat> for TransactionHeartbeat {
    fn from(value: &TransactionHeartbeat) -> Self {
        value.clone()
    }
}

impl TransactionHeartbeat {
    pub fn builder() -> builder::TransactionHeartbeat {
        Default::default()
    }
}

///The unique Transaction identifier within each Account.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The unique Transaction identifier within each
/// Account.",
///  "type": "string",
///  "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct TransactionId(pub String);
impl std::ops::Deref for TransactionId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl From<TransactionId> for String {
    fn from(value: TransactionId) -> Self {
        value.0
    }
}

impl From<&TransactionId> for TransactionId {
    fn from(value: &TransactionId) -> Self {
        value.clone()
    }
}

impl From<String> for TransactionId {
    fn from(value: String) -> Self {
        Self(value)
    }
}

impl std::str::FromStr for TransactionId {
    type Err = std::convert::Infallible;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}

impl ToString for TransactionId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

///The reason that a Transaction was rejected.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that a Transaction was rejected.",
///  "type": "string",
///  "enum": [
///    "INTERNAL_SERVER_ERROR",
///    "INSTRUMENT_PRICE_UNKNOWN",
///    "ACCOUNT_NOT_ACTIVE",
///    "ACCOUNT_LOCKED",
///    "ACCOUNT_ORDER_CREATION_LOCKED",
///    "ACCOUNT_CONFIGURATION_LOCKED",
///    "ACCOUNT_DEPOSIT_LOCKED",
///    "ACCOUNT_WITHDRAWAL_LOCKED",
///    "ACCOUNT_ORDER_CANCEL_LOCKED",
///    "INSTRUMENT_NOT_TRADEABLE",
///    "PENDING_ORDERS_ALLOWED_EXCEEDED",
///    "ORDER_ID_UNSPECIFIED",
///    "ORDER_DOESNT_EXIST",
///    "ORDER_IDENTIFIER_INCONSISTENCY",
///    "TRADE_ID_UNSPECIFIED",
///    "TRADE_DOESNT_EXIST",
///    "TRADE_IDENTIFIER_INCONSISTENCY",
///    "INSUFFICIENT_MARGIN",
///    "INSTRUMENT_MISSING",
///    "INSTRUMENT_UNKNOWN",
///    "UNITS_MISSING",
///    "UNITS_INVALID",
///    "UNITS_PRECISION_EXCEEDED",
///    "UNITS_LIMIT_EXCEEDED",
///    "UNITS_MIMIMUM_NOT_MET",
///    "PRICE_MISSING",
///    "PRICE_INVALID",
///    "PRICE_PRECISION_EXCEEDED",
///    "PRICE_DISTANCE_MISSING",
///    "PRICE_DISTANCE_INVALID",
///    "PRICE_DISTANCE_PRECISION_EXCEEDED",
///    "PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "PRICE_DISTANCE_MINIMUM_NOT_MET",
///    "TIME_IN_FORCE_MISSING",
///    "TIME_IN_FORCE_INVALID",
///    "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING",
///    "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST",
///    "PRICE_BOUND_INVALID",
///    "PRICE_BOUND_PRECISION_EXCEEDED",
///    "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS",
///    "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED",
///    "CLIENT_ORDER_ID_INVALID",
///    "CLIENT_ORDER_ID_ALREADY_EXISTS",
///    "CLIENT_ORDER_TAG_INVALID",
///    "CLIENT_ORDER_COMMENT_INVALID",
///    "CLIENT_TRADE_ID_INVALID",
///    "CLIENT_TRADE_ID_ALREADY_EXISTS",
///    "CLIENT_TRADE_TAG_INVALID",
///    "CLIENT_TRADE_COMMENT_INVALID",
///    "ORDER_FILL_POSITION_ACTION_MISSING",
///    "ORDER_FILL_POSITION_ACTION_INVALID",
///    "TRIGGER_CONDITION_MISSING",
///    "TRIGGER_CONDITION_INVALID",
///    "ORDER_PARTIAL_FILL_OPTION_MISSING",
///    "ORDER_PARTIAL_FILL_OPTION_INVALID",
///    "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL",
///    "TAKE_PROFIT_ORDER_ALREADY_EXISTS",
///    "TAKE_PROFIT_ON_FILL_PRICE_MISSING",
///    "TAKE_PROFIT_ON_FILL_PRICE_INVALID",
///    "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED",
///    "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING",
///    "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "STOP_LOSS_ORDER_ALREADY_EXISTS",
///    "STOP_LOSS_ORDER_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD",
///    "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION",
///    "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION",
///    "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED",
///    "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ORDER_NOT_CANCELABLE",
///    "STOP_LOSS_ORDER_NOT_REPLACEABLE",
///    "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///    "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING",
///    "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER",
///    "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ON_FILL_PRICE_MISSING",
///    "STOP_LOSS_ON_FILL_PRICE_INVALID",
///    "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_DISTANCE_INVALID",
///    "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///    "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET",
///    "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED",
///    "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "CLOSE_TRADE_TYPE_MISSING",
///    "CLOSE_TRADE_PARTIAL_UNITS_MISSING",
///    "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE",
///    "CLOSEOUT_POSITION_DOESNT_EXIST",
///    "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION",
///    "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE",
///    "CLOSEOUT_POSITION_REJECT",
///    "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING",
///    "MARKUP_GROUP_ID_INVALID",
///    "POSITION_AGGREGATION_MODE_INVALID",
///    "ADMIN_CONFIGURE_DATA_MISSING",
///    "MARGIN_RATE_INVALID",
///    "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT",
///    "ALIAS_INVALID",
///    "CLIENT_CONFIGURE_DATA_MISSING",
///    "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL",
///    "AMOUNT_INVALID",
///    "INSUFFICIENT_FUNDS",
///    "AMOUNT_MISSING",
///    "FUNDING_REASON_MISSING",
///    "CLIENT_EXTENSIONS_DATA_MISSING",
///    "REPLACING_ORDER_INVALID",
///    "REPLACING_TRADE_ID_INVALID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TransactionRejectReason {
    #[serde(rename = "INTERNAL_SERVER_ERROR")]
    InternalServerError,
    #[serde(rename = "INSTRUMENT_PRICE_UNKNOWN")]
    InstrumentPriceUnknown,
    #[serde(rename = "ACCOUNT_NOT_ACTIVE")]
    AccountNotActive,
    #[serde(rename = "ACCOUNT_LOCKED")]
    AccountLocked,
    #[serde(rename = "ACCOUNT_ORDER_CREATION_LOCKED")]
    AccountOrderCreationLocked,
    #[serde(rename = "ACCOUNT_CONFIGURATION_LOCKED")]
    AccountConfigurationLocked,
    #[serde(rename = "ACCOUNT_DEPOSIT_LOCKED")]
    AccountDepositLocked,
    #[serde(rename = "ACCOUNT_WITHDRAWAL_LOCKED")]
    AccountWithdrawalLocked,
    #[serde(rename = "ACCOUNT_ORDER_CANCEL_LOCKED")]
    AccountOrderCancelLocked,
    #[serde(rename = "INSTRUMENT_NOT_TRADEABLE")]
    InstrumentNotTradeable,
    #[serde(rename = "PENDING_ORDERS_ALLOWED_EXCEEDED")]
    PendingOrdersAllowedExceeded,
    #[serde(rename = "ORDER_ID_UNSPECIFIED")]
    OrderIdUnspecified,
    #[serde(rename = "ORDER_DOESNT_EXIST")]
    OrderDoesntExist,
    #[serde(rename = "ORDER_IDENTIFIER_INCONSISTENCY")]
    OrderIdentifierInconsistency,
    #[serde(rename = "TRADE_ID_UNSPECIFIED")]
    TradeIdUnspecified,
    #[serde(rename = "TRADE_DOESNT_EXIST")]
    TradeDoesntExist,
    #[serde(rename = "TRADE_IDENTIFIER_INCONSISTENCY")]
    TradeIdentifierInconsistency,
    #[serde(rename = "INSUFFICIENT_MARGIN")]
    InsufficientMargin,
    #[serde(rename = "INSTRUMENT_MISSING")]
    InstrumentMissing,
    #[serde(rename = "INSTRUMENT_UNKNOWN")]
    InstrumentUnknown,
    #[serde(rename = "UNITS_MISSING")]
    UnitsMissing,
    #[serde(rename = "UNITS_INVALID")]
    UnitsInvalid,
    #[serde(rename = "UNITS_PRECISION_EXCEEDED")]
    UnitsPrecisionExceeded,
    #[serde(rename = "UNITS_LIMIT_EXCEEDED")]
    UnitsLimitExceeded,
    #[serde(rename = "UNITS_MIMIMUM_NOT_MET")]
    UnitsMimimumNotMet,
    #[serde(rename = "PRICE_MISSING")]
    PriceMissing,
    #[serde(rename = "PRICE_INVALID")]
    PriceInvalid,
    #[serde(rename = "PRICE_PRECISION_EXCEEDED")]
    PricePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MISSING")]
    PriceDistanceMissing,
    #[serde(rename = "PRICE_DISTANCE_INVALID")]
    PriceDistanceInvalid,
    #[serde(rename = "PRICE_DISTANCE_PRECISION_EXCEEDED")]
    PriceDistancePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    PriceDistanceMaximumExceeded,
    #[serde(rename = "PRICE_DISTANCE_MINIMUM_NOT_MET")]
    PriceDistanceMinimumNotMet,
    #[serde(rename = "TIME_IN_FORCE_MISSING")]
    TimeInForceMissing,
    #[serde(rename = "TIME_IN_FORCE_INVALID")]
    TimeInForceInvalid,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING")]
    TimeInForceGtdTimestampMissing,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST")]
    TimeInForceGtdTimestampInPast,
    #[serde(rename = "PRICE_BOUND_INVALID")]
    PriceBoundInvalid,
    #[serde(rename = "PRICE_BOUND_PRECISION_EXCEEDED")]
    PriceBoundPrecisionExceeded,
    #[serde(rename = "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS")]
    OrdersOnFillDuplicateClientOrderIds,
    #[serde(rename = "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED")]
    TradeOnFillClientExtensionsNotSupported,
    #[serde(rename = "CLIENT_ORDER_ID_INVALID")]
    ClientOrderIdInvalid,
    #[serde(rename = "CLIENT_ORDER_ID_ALREADY_EXISTS")]
    ClientOrderIdAlreadyExists,
    #[serde(rename = "CLIENT_ORDER_TAG_INVALID")]
    ClientOrderTagInvalid,
    #[serde(rename = "CLIENT_ORDER_COMMENT_INVALID")]
    ClientOrderCommentInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_INVALID")]
    ClientTradeIdInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_ALREADY_EXISTS")]
    ClientTradeIdAlreadyExists,
    #[serde(rename = "CLIENT_TRADE_TAG_INVALID")]
    ClientTradeTagInvalid,
    #[serde(rename = "CLIENT_TRADE_COMMENT_INVALID")]
    ClientTradeCommentInvalid,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_MISSING")]
    OrderFillPositionActionMissing,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_INVALID")]
    OrderFillPositionActionInvalid,
    #[serde(rename = "TRIGGER_CONDITION_MISSING")]
    TriggerConditionMissing,
    #[serde(rename = "TRIGGER_CONDITION_INVALID")]
    TriggerConditionInvalid,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_MISSING")]
    OrderPartialFillOptionMissing,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_INVALID")]
    OrderPartialFillOptionInvalid,
    #[serde(rename = "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL")]
    InvalidReissueImmediatePartialFill,
    #[serde(rename = "TAKE_PROFIT_ORDER_ALREADY_EXISTS")]
    TakeProfitOrderAlreadyExists,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_MISSING")]
    TakeProfitOnFillPriceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_INVALID")]
    TakeProfitOnFillPriceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    TakeProfitOnFillPricePrecisionExceeded,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING")]
    TakeProfitOnFillTimeInForceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID")]
    TakeProfitOnFillTimeInForceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TakeProfitOnFillGtdTimestampMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TakeProfitOnFillGtdTimestampInPast,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TakeProfitOnFillClientOrderIdInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TakeProfitOnFillClientOrderTagInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TakeProfitOnFillClientOrderCommentInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TakeProfitOnFillTriggerConditionMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TakeProfitOnFillTriggerConditionInvalid,
    #[serde(rename = "STOP_LOSS_ORDER_ALREADY_EXISTS")]
    StopLossOrderAlreadyExists,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_REQUIRED")]
    StopLossOrderGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD")]
    StopLossOrderGuaranteedPriceWithinSpread,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED")]
    StopLossOrderGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION")]
    StopLossOrderGuaranteedHaltedCreateViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION")]
    StopLossOrderGuaranteedHaltedTightenViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED")]
    StopLossOrderGuaranteedHedgingNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOrderGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_CANCELABLE")]
    StopLossOrderNotCancelable,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_REPLACEABLE")]
    StopLossOrderNotReplaceable,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOrderGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOrderPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOrderPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER")]
    StopLossOnFillRequiredForPendingOrder,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED")]
    StopLossOnFillGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED")]
    StopLossOnFillGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_MISSING")]
    StopLossOnFillPriceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_INVALID")]
    StopLossOnFillPriceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    StopLossOnFillPricePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOnFillGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOnFillGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_INVALID")]
    StopLossOnFillDistanceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    StopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED")]
    StopLossOnFillDistancePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOnFillPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOnFillPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    StopLossOnFillTimeInForceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    StopLossOnFillTimeInForceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    StopLossOnFillGtdTimestampMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    StopLossOnFillGtdTimestampInPast,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    StopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    StopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    StopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    StopLossOnFillTriggerConditionMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    StopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS")]
    TrailingStopLossOrderAlreadyExists,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING")]
    TrailingStopLossOnFillPriceDistanceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID")]
    TrailingStopLossOnFillPriceDistanceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED")]
    TrailingStopLossOnFillPriceDistancePrecisionExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    TrailingStopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET")]
    TrailingStopLossOnFillPriceDistanceMinimumNotMet,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    TrailingStopLossOnFillTimeInForceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    TrailingStopLossOnFillTimeInForceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TrailingStopLossOnFillGtdTimestampMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TrailingStopLossOnFillGtdTimestampInPast,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TrailingStopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TrailingStopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TrailingStopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED")]
    TrailingStopLossOrdersNotSupported,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TrailingStopLossOnFillTriggerConditionMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TrailingStopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "CLOSE_TRADE_TYPE_MISSING")]
    CloseTradeTypeMissing,
    #[serde(rename = "CLOSE_TRADE_PARTIAL_UNITS_MISSING")]
    CloseTradePartialUnitsMissing,
    #[serde(rename = "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE")]
    CloseTradeUnitsExceedTradeSize,
    #[serde(rename = "CLOSEOUT_POSITION_DOESNT_EXIST")]
    CloseoutPositionDoesntExist,
    #[serde(rename = "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION")]
    CloseoutPositionIncompleteSpecification,
    #[serde(rename = "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE")]
    CloseoutPositionUnitsExceedPositionSize,
    #[serde(rename = "CLOSEOUT_POSITION_REJECT")]
    CloseoutPositionReject,
    #[serde(rename = "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING")]
    CloseoutPositionPartialUnitsMissing,
    #[serde(rename = "MARKUP_GROUP_ID_INVALID")]
    MarkupGroupIdInvalid,
    #[serde(rename = "POSITION_AGGREGATION_MODE_INVALID")]
    PositionAggregationModeInvalid,
    #[serde(rename = "ADMIN_CONFIGURE_DATA_MISSING")]
    AdminConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_INVALID")]
    MarginRateInvalid,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT")]
    MarginRateWouldTriggerCloseout,
    #[serde(rename = "ALIAS_INVALID")]
    AliasInvalid,
    #[serde(rename = "CLIENT_CONFIGURE_DATA_MISSING")]
    ClientConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL")]
    MarginRateWouldTriggerMarginCall,
    #[serde(rename = "AMOUNT_INVALID")]
    AmountInvalid,
    #[serde(rename = "INSUFFICIENT_FUNDS")]
    InsufficientFunds,
    #[serde(rename = "AMOUNT_MISSING")]
    AmountMissing,
    #[serde(rename = "FUNDING_REASON_MISSING")]
    FundingReasonMissing,
    #[serde(rename = "CLIENT_EXTENSIONS_DATA_MISSING")]
    ClientExtensionsDataMissing,
    #[serde(rename = "REPLACING_ORDER_INVALID")]
    ReplacingOrderInvalid,
    #[serde(rename = "REPLACING_TRADE_ID_INVALID")]
    ReplacingTradeIdInvalid,
}

impl From<&TransactionRejectReason> for TransactionRejectReason {
    fn from(value: &TransactionRejectReason) -> Self {
        value.clone()
    }
}

impl ToString for TransactionRejectReason {
    fn to_string(&self) -> String {
        match *self {
            Self::InternalServerError => "INTERNAL_SERVER_ERROR".to_string(),
            Self::InstrumentPriceUnknown => "INSTRUMENT_PRICE_UNKNOWN".to_string(),
            Self::AccountNotActive => "ACCOUNT_NOT_ACTIVE".to_string(),
            Self::AccountLocked => "ACCOUNT_LOCKED".to_string(),
            Self::AccountOrderCreationLocked => "ACCOUNT_ORDER_CREATION_LOCKED".to_string(),
            Self::AccountConfigurationLocked => "ACCOUNT_CONFIGURATION_LOCKED".to_string(),
            Self::AccountDepositLocked => "ACCOUNT_DEPOSIT_LOCKED".to_string(),
            Self::AccountWithdrawalLocked => "ACCOUNT_WITHDRAWAL_LOCKED".to_string(),
            Self::AccountOrderCancelLocked => "ACCOUNT_ORDER_CANCEL_LOCKED".to_string(),
            Self::InstrumentNotTradeable => "INSTRUMENT_NOT_TRADEABLE".to_string(),
            Self::PendingOrdersAllowedExceeded => "PENDING_ORDERS_ALLOWED_EXCEEDED".to_string(),
            Self::OrderIdUnspecified => "ORDER_ID_UNSPECIFIED".to_string(),
            Self::OrderDoesntExist => "ORDER_DOESNT_EXIST".to_string(),
            Self::OrderIdentifierInconsistency => "ORDER_IDENTIFIER_INCONSISTENCY".to_string(),
            Self::TradeIdUnspecified => "TRADE_ID_UNSPECIFIED".to_string(),
            Self::TradeDoesntExist => "TRADE_DOESNT_EXIST".to_string(),
            Self::TradeIdentifierInconsistency => "TRADE_IDENTIFIER_INCONSISTENCY".to_string(),
            Self::InsufficientMargin => "INSUFFICIENT_MARGIN".to_string(),
            Self::InstrumentMissing => "INSTRUMENT_MISSING".to_string(),
            Self::InstrumentUnknown => "INSTRUMENT_UNKNOWN".to_string(),
            Self::UnitsMissing => "UNITS_MISSING".to_string(),
            Self::UnitsInvalid => "UNITS_INVALID".to_string(),
            Self::UnitsPrecisionExceeded => "UNITS_PRECISION_EXCEEDED".to_string(),
            Self::UnitsLimitExceeded => "UNITS_LIMIT_EXCEEDED".to_string(),
            Self::UnitsMimimumNotMet => "UNITS_MIMIMUM_NOT_MET".to_string(),
            Self::PriceMissing => "PRICE_MISSING".to_string(),
            Self::PriceInvalid => "PRICE_INVALID".to_string(),
            Self::PricePrecisionExceeded => "PRICE_PRECISION_EXCEEDED".to_string(),
            Self::PriceDistanceMissing => "PRICE_DISTANCE_MISSING".to_string(),
            Self::PriceDistanceInvalid => "PRICE_DISTANCE_INVALID".to_string(),
            Self::PriceDistancePrecisionExceeded => "PRICE_DISTANCE_PRECISION_EXCEEDED".to_string(),
            Self::PriceDistanceMaximumExceeded => "PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string(),
            Self::PriceDistanceMinimumNotMet => "PRICE_DISTANCE_MINIMUM_NOT_MET".to_string(),
            Self::TimeInForceMissing => "TIME_IN_FORCE_MISSING".to_string(),
            Self::TimeInForceInvalid => "TIME_IN_FORCE_INVALID".to_string(),
            Self::TimeInForceGtdTimestampMissing => {
                "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TimeInForceGtdTimestampInPast => {
                "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::PriceBoundInvalid => "PRICE_BOUND_INVALID".to_string(),
            Self::PriceBoundPrecisionExceeded => "PRICE_BOUND_PRECISION_EXCEEDED".to_string(),
            Self::OrdersOnFillDuplicateClientOrderIds => {
                "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS".to_string()
            }
            Self::TradeOnFillClientExtensionsNotSupported => {
                "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED".to_string()
            }
            Self::ClientOrderIdInvalid => "CLIENT_ORDER_ID_INVALID".to_string(),
            Self::ClientOrderIdAlreadyExists => "CLIENT_ORDER_ID_ALREADY_EXISTS".to_string(),
            Self::ClientOrderTagInvalid => "CLIENT_ORDER_TAG_INVALID".to_string(),
            Self::ClientOrderCommentInvalid => "CLIENT_ORDER_COMMENT_INVALID".to_string(),
            Self::ClientTradeIdInvalid => "CLIENT_TRADE_ID_INVALID".to_string(),
            Self::ClientTradeIdAlreadyExists => "CLIENT_TRADE_ID_ALREADY_EXISTS".to_string(),
            Self::ClientTradeTagInvalid => "CLIENT_TRADE_TAG_INVALID".to_string(),
            Self::ClientTradeCommentInvalid => "CLIENT_TRADE_COMMENT_INVALID".to_string(),
            Self::OrderFillPositionActionMissing => {
                "ORDER_FILL_POSITION_ACTION_MISSING".to_string()
            }
            Self::OrderFillPositionActionInvalid => {
                "ORDER_FILL_POSITION_ACTION_INVALID".to_string()
            }
            Self::TriggerConditionMissing => "TRIGGER_CONDITION_MISSING".to_string(),
            Self::TriggerConditionInvalid => "TRIGGER_CONDITION_INVALID".to_string(),
            Self::OrderPartialFillOptionMissing => "ORDER_PARTIAL_FILL_OPTION_MISSING".to_string(),
            Self::OrderPartialFillOptionInvalid => "ORDER_PARTIAL_FILL_OPTION_INVALID".to_string(),
            Self::InvalidReissueImmediatePartialFill => {
                "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL".to_string()
            }
            Self::TakeProfitOrderAlreadyExists => "TAKE_PROFIT_ORDER_ALREADY_EXISTS".to_string(),
            Self::TakeProfitOnFillPriceMissing => "TAKE_PROFIT_ON_FILL_PRICE_MISSING".to_string(),
            Self::TakeProfitOnFillPriceInvalid => "TAKE_PROFIT_ON_FILL_PRICE_INVALID".to_string(),
            Self::TakeProfitOnFillPricePrecisionExceeded => {
                "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED".to_string()
            }
            Self::TakeProfitOnFillTimeInForceMissing => {
                "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::TakeProfitOnFillTimeInForceInvalid => {
                "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::TakeProfitOnFillGtdTimestampMissing => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TakeProfitOnFillGtdTimestampInPast => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TakeProfitOnFillClientOrderIdInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::TakeProfitOnFillClientOrderTagInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::TakeProfitOnFillClientOrderCommentInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::TakeProfitOnFillTriggerConditionMissing => {
                "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::TakeProfitOnFillTriggerConditionInvalid => {
                "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::StopLossOrderAlreadyExists => "STOP_LOSS_ORDER_ALREADY_EXISTS".to_string(),
            Self::StopLossOrderGuaranteedRequired => {
                "STOP_LOSS_ORDER_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOrderGuaranteedPriceWithinSpread => {
                "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD".to_string()
            }
            Self::StopLossOrderGuaranteedNotAllowed => {
                "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOrderGuaranteedHaltedCreateViolation => {
                "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION".to_string()
            }
            Self::StopLossOrderGuaranteedHaltedTightenViolation => {
                "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION".to_string()
            }
            Self::StopLossOrderGuaranteedHedgingNotAllowed => {
                "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED".to_string()
            }
            Self::StopLossOrderGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOrderNotCancelable => "STOP_LOSS_ORDER_NOT_CANCELABLE".to_string(),
            Self::StopLossOrderNotReplaceable => "STOP_LOSS_ORDER_NOT_REPLACEABLE".to_string(),
            Self::StopLossOrderGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOrderPriceAndDistanceBothSpecified => {
                "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED".to_string()
            }
            Self::StopLossOrderPriceAndDistanceBothMissing => {
                "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING".to_string()
            }
            Self::StopLossOnFillRequiredForPendingOrder => {
                "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER".to_string()
            }
            Self::StopLossOnFillGuaranteedNotAllowed => {
                "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOnFillGuaranteedRequired => {
                "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOnFillPriceMissing => "STOP_LOSS_ON_FILL_PRICE_MISSING".to_string(),
            Self::StopLossOnFillPriceInvalid => "STOP_LOSS_ON_FILL_PRICE_INVALID".to_string(),
            Self::StopLossOnFillPricePrecisionExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOnFillGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillDistanceInvalid => "STOP_LOSS_ON_FILL_DISTANCE_INVALID".to_string(),
            Self::StopLossOnFillPriceDistanceMaximumExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::StopLossOnFillDistancePrecisionExceeded => {
                "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillPriceAndDistanceBothSpecified => {
                "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED".to_string()
            }
            Self::StopLossOnFillPriceAndDistanceBothMissing => {
                "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING".to_string()
            }
            Self::StopLossOnFillTimeInForceMissing => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::StopLossOnFillTimeInForceInvalid => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::StopLossOnFillGtdTimestampMissing => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::StopLossOnFillGtdTimestampInPast => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::StopLossOnFillClientOrderIdInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::StopLossOnFillClientOrderTagInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::StopLossOnFillClientOrderCommentInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::StopLossOnFillTriggerConditionMissing => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::StopLossOnFillTriggerConditionInvalid => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::TrailingStopLossOrderAlreadyExists => {
                "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistancePrecisionExceeded => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMaximumExceeded => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMinimumNotMet => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET".to_string()
            }
            Self::TrailingStopLossOnFillTimeInForceMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillTimeInForceInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampInPast => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderIdInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderTagInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderCommentInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::TrailingStopLossOrdersNotSupported => {
                "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED".to_string()
            }
            Self::TrailingStopLossOnFillTriggerConditionMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillTriggerConditionInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::CloseTradeTypeMissing => "CLOSE_TRADE_TYPE_MISSING".to_string(),
            Self::CloseTradePartialUnitsMissing => "CLOSE_TRADE_PARTIAL_UNITS_MISSING".to_string(),
            Self::CloseTradeUnitsExceedTradeSize => {
                "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE".to_string()
            }
            Self::CloseoutPositionDoesntExist => "CLOSEOUT_POSITION_DOESNT_EXIST".to_string(),
            Self::CloseoutPositionIncompleteSpecification => {
                "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION".to_string()
            }
            Self::CloseoutPositionUnitsExceedPositionSize => {
                "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE".to_string()
            }
            Self::CloseoutPositionReject => "CLOSEOUT_POSITION_REJECT".to_string(),
            Self::CloseoutPositionPartialUnitsMissing => {
                "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING".to_string()
            }
            Self::MarkupGroupIdInvalid => "MARKUP_GROUP_ID_INVALID".to_string(),
            Self::PositionAggregationModeInvalid => "POSITION_AGGREGATION_MODE_INVALID".to_string(),
            Self::AdminConfigureDataMissing => "ADMIN_CONFIGURE_DATA_MISSING".to_string(),
            Self::MarginRateInvalid => "MARGIN_RATE_INVALID".to_string(),
            Self::MarginRateWouldTriggerCloseout => {
                "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT".to_string()
            }
            Self::AliasInvalid => "ALIAS_INVALID".to_string(),
            Self::ClientConfigureDataMissing => "CLIENT_CONFIGURE_DATA_MISSING".to_string(),
            Self::MarginRateWouldTriggerMarginCall => {
                "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL".to_string()
            }
            Self::AmountInvalid => "AMOUNT_INVALID".to_string(),
            Self::InsufficientFunds => "INSUFFICIENT_FUNDS".to_string(),
            Self::AmountMissing => "AMOUNT_MISSING".to_string(),
            Self::FundingReasonMissing => "FUNDING_REASON_MISSING".to_string(),
            Self::ClientExtensionsDataMissing => "CLIENT_EXTENSIONS_DATA_MISSING".to_string(),
            Self::ReplacingOrderInvalid => "REPLACING_ORDER_INVALID".to_string(),
            Self::ReplacingTradeIdInvalid => "REPLACING_TRADE_ID_INVALID".to_string(),
        }
    }
}

impl std::str::FromStr for TransactionRejectReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "INTERNAL_SERVER_ERROR" => Ok(Self::InternalServerError),
            "INSTRUMENT_PRICE_UNKNOWN" => Ok(Self::InstrumentPriceUnknown),
            "ACCOUNT_NOT_ACTIVE" => Ok(Self::AccountNotActive),
            "ACCOUNT_LOCKED" => Ok(Self::AccountLocked),
            "ACCOUNT_ORDER_CREATION_LOCKED" => Ok(Self::AccountOrderCreationLocked),
            "ACCOUNT_CONFIGURATION_LOCKED" => Ok(Self::AccountConfigurationLocked),
            "ACCOUNT_DEPOSIT_LOCKED" => Ok(Self::AccountDepositLocked),
            "ACCOUNT_WITHDRAWAL_LOCKED" => Ok(Self::AccountWithdrawalLocked),
            "ACCOUNT_ORDER_CANCEL_LOCKED" => Ok(Self::AccountOrderCancelLocked),
            "INSTRUMENT_NOT_TRADEABLE" => Ok(Self::InstrumentNotTradeable),
            "PENDING_ORDERS_ALLOWED_EXCEEDED" => Ok(Self::PendingOrdersAllowedExceeded),
            "ORDER_ID_UNSPECIFIED" => Ok(Self::OrderIdUnspecified),
            "ORDER_DOESNT_EXIST" => Ok(Self::OrderDoesntExist),
            "ORDER_IDENTIFIER_INCONSISTENCY" => Ok(Self::OrderIdentifierInconsistency),
            "TRADE_ID_UNSPECIFIED" => Ok(Self::TradeIdUnspecified),
            "TRADE_DOESNT_EXIST" => Ok(Self::TradeDoesntExist),
            "TRADE_IDENTIFIER_INCONSISTENCY" => Ok(Self::TradeIdentifierInconsistency),
            "INSUFFICIENT_MARGIN" => Ok(Self::InsufficientMargin),
            "INSTRUMENT_MISSING" => Ok(Self::InstrumentMissing),
            "INSTRUMENT_UNKNOWN" => Ok(Self::InstrumentUnknown),
            "UNITS_MISSING" => Ok(Self::UnitsMissing),
            "UNITS_INVALID" => Ok(Self::UnitsInvalid),
            "UNITS_PRECISION_EXCEEDED" => Ok(Self::UnitsPrecisionExceeded),
            "UNITS_LIMIT_EXCEEDED" => Ok(Self::UnitsLimitExceeded),
            "UNITS_MIMIMUM_NOT_MET" => Ok(Self::UnitsMimimumNotMet),
            "PRICE_MISSING" => Ok(Self::PriceMissing),
            "PRICE_INVALID" => Ok(Self::PriceInvalid),
            "PRICE_PRECISION_EXCEEDED" => Ok(Self::PricePrecisionExceeded),
            "PRICE_DISTANCE_MISSING" => Ok(Self::PriceDistanceMissing),
            "PRICE_DISTANCE_INVALID" => Ok(Self::PriceDistanceInvalid),
            "PRICE_DISTANCE_PRECISION_EXCEEDED" => Ok(Self::PriceDistancePrecisionExceeded),
            "PRICE_DISTANCE_MAXIMUM_EXCEEDED" => Ok(Self::PriceDistanceMaximumExceeded),
            "PRICE_DISTANCE_MINIMUM_NOT_MET" => Ok(Self::PriceDistanceMinimumNotMet),
            "TIME_IN_FORCE_MISSING" => Ok(Self::TimeInForceMissing),
            "TIME_IN_FORCE_INVALID" => Ok(Self::TimeInForceInvalid),
            "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING" => Ok(Self::TimeInForceGtdTimestampMissing),
            "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST" => Ok(Self::TimeInForceGtdTimestampInPast),
            "PRICE_BOUND_INVALID" => Ok(Self::PriceBoundInvalid),
            "PRICE_BOUND_PRECISION_EXCEEDED" => Ok(Self::PriceBoundPrecisionExceeded),
            "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS" => {
                Ok(Self::OrdersOnFillDuplicateClientOrderIds)
            }
            "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED" => {
                Ok(Self::TradeOnFillClientExtensionsNotSupported)
            }
            "CLIENT_ORDER_ID_INVALID" => Ok(Self::ClientOrderIdInvalid),
            "CLIENT_ORDER_ID_ALREADY_EXISTS" => Ok(Self::ClientOrderIdAlreadyExists),
            "CLIENT_ORDER_TAG_INVALID" => Ok(Self::ClientOrderTagInvalid),
            "CLIENT_ORDER_COMMENT_INVALID" => Ok(Self::ClientOrderCommentInvalid),
            "CLIENT_TRADE_ID_INVALID" => Ok(Self::ClientTradeIdInvalid),
            "CLIENT_TRADE_ID_ALREADY_EXISTS" => Ok(Self::ClientTradeIdAlreadyExists),
            "CLIENT_TRADE_TAG_INVALID" => Ok(Self::ClientTradeTagInvalid),
            "CLIENT_TRADE_COMMENT_INVALID" => Ok(Self::ClientTradeCommentInvalid),
            "ORDER_FILL_POSITION_ACTION_MISSING" => Ok(Self::OrderFillPositionActionMissing),
            "ORDER_FILL_POSITION_ACTION_INVALID" => Ok(Self::OrderFillPositionActionInvalid),
            "TRIGGER_CONDITION_MISSING" => Ok(Self::TriggerConditionMissing),
            "TRIGGER_CONDITION_INVALID" => Ok(Self::TriggerConditionInvalid),
            "ORDER_PARTIAL_FILL_OPTION_MISSING" => Ok(Self::OrderPartialFillOptionMissing),
            "ORDER_PARTIAL_FILL_OPTION_INVALID" => Ok(Self::OrderPartialFillOptionInvalid),
            "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL" => {
                Ok(Self::InvalidReissueImmediatePartialFill)
            }
            "TAKE_PROFIT_ORDER_ALREADY_EXISTS" => Ok(Self::TakeProfitOrderAlreadyExists),
            "TAKE_PROFIT_ON_FILL_PRICE_MISSING" => Ok(Self::TakeProfitOnFillPriceMissing),
            "TAKE_PROFIT_ON_FILL_PRICE_INVALID" => Ok(Self::TakeProfitOnFillPriceInvalid),
            "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(Self::TakeProfitOnFillPricePrecisionExceeded)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(Self::TakeProfitOnFillTimeInForceMissing)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(Self::TakeProfitOnFillTimeInForceInvalid)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::TakeProfitOnFillGtdTimestampMissing)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TakeProfitOnFillGtdTimestampInPast)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderIdInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderTagInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderCommentInvalid)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::TakeProfitOnFillTriggerConditionMissing)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::TakeProfitOnFillTriggerConditionInvalid)
            }
            "STOP_LOSS_ORDER_ALREADY_EXISTS" => Ok(Self::StopLossOrderAlreadyExists),
            "STOP_LOSS_ORDER_GUARANTEED_REQUIRED" => Ok(Self::StopLossOrderGuaranteedRequired),
            "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD" => {
                Ok(Self::StopLossOrderGuaranteedPriceWithinSpread)
            }
            "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED" => Ok(Self::StopLossOrderGuaranteedNotAllowed),
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION" => {
                Ok(Self::StopLossOrderGuaranteedHaltedCreateViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION" => {
                Ok(Self::StopLossOrderGuaranteedHaltedTightenViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED" => {
                Ok(Self::StopLossOrderGuaranteedHedgingNotAllowed)
            }
            "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOrderGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ORDER_NOT_CANCELABLE" => Ok(Self::StopLossOrderNotCancelable),
            "STOP_LOSS_ORDER_NOT_REPLACEABLE" => Ok(Self::StopLossOrderNotReplaceable),
            "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOrderGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(Self::StopLossOrderPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(Self::StopLossOrderPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER" => {
                Ok(Self::StopLossOnFillRequiredForPendingOrder)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED" => {
                Ok(Self::StopLossOnFillGuaranteedNotAllowed)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED" => Ok(Self::StopLossOnFillGuaranteedRequired),
            "STOP_LOSS_ON_FILL_PRICE_MISSING" => Ok(Self::StopLossOnFillPriceMissing),
            "STOP_LOSS_ON_FILL_PRICE_INVALID" => Ok(Self::StopLossOnFillPriceInvalid),
            "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(Self::StopLossOnFillPricePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOnFillGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOnFillGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_INVALID" => Ok(Self::StopLossOnFillDistanceInvalid),
            "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::StopLossOnFillPriceDistanceMaximumExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(Self::StopLossOnFillDistancePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(Self::StopLossOnFillPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(Self::StopLossOnFillPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => Ok(Self::StopLossOnFillTimeInForceMissing),
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => Ok(Self::StopLossOnFillTimeInForceInvalid),
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::StopLossOnFillGtdTimestampMissing)
            }
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => Ok(Self::StopLossOnFillGtdTimestampInPast),
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderIdInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderTagInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderCommentInvalid)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::StopLossOnFillTriggerConditionMissing)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::StopLossOnFillTriggerConditionInvalid)
            }
            "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS" => {
                Ok(Self::TrailingStopLossOrderAlreadyExists)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(Self::TrailingStopLossOnFillPriceDistancePrecisionExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMaximumExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMinimumNotMet)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(Self::TrailingStopLossOnFillTimeInForceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(Self::TrailingStopLossOnFillTimeInForceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampInPast)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderIdInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderTagInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderCommentInvalid)
            }
            "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED" => {
                Ok(Self::TrailingStopLossOrdersNotSupported)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::TrailingStopLossOnFillTriggerConditionMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::TrailingStopLossOnFillTriggerConditionInvalid)
            }
            "CLOSE_TRADE_TYPE_MISSING" => Ok(Self::CloseTradeTypeMissing),
            "CLOSE_TRADE_PARTIAL_UNITS_MISSING" => Ok(Self::CloseTradePartialUnitsMissing),
            "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE" => Ok(Self::CloseTradeUnitsExceedTradeSize),
            "CLOSEOUT_POSITION_DOESNT_EXIST" => Ok(Self::CloseoutPositionDoesntExist),
            "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION" => {
                Ok(Self::CloseoutPositionIncompleteSpecification)
            }
            "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE" => {
                Ok(Self::CloseoutPositionUnitsExceedPositionSize)
            }
            "CLOSEOUT_POSITION_REJECT" => Ok(Self::CloseoutPositionReject),
            "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING" => {
                Ok(Self::CloseoutPositionPartialUnitsMissing)
            }
            "MARKUP_GROUP_ID_INVALID" => Ok(Self::MarkupGroupIdInvalid),
            "POSITION_AGGREGATION_MODE_INVALID" => Ok(Self::PositionAggregationModeInvalid),
            "ADMIN_CONFIGURE_DATA_MISSING" => Ok(Self::AdminConfigureDataMissing),
            "MARGIN_RATE_INVALID" => Ok(Self::MarginRateInvalid),
            "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT" => Ok(Self::MarginRateWouldTriggerCloseout),
            "ALIAS_INVALID" => Ok(Self::AliasInvalid),
            "CLIENT_CONFIGURE_DATA_MISSING" => Ok(Self::ClientConfigureDataMissing),
            "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL" => Ok(Self::MarginRateWouldTriggerMarginCall),
            "AMOUNT_INVALID" => Ok(Self::AmountInvalid),
            "INSUFFICIENT_FUNDS" => Ok(Self::InsufficientFunds),
            "AMOUNT_MISSING" => Ok(Self::AmountMissing),
            "FUNDING_REASON_MISSING" => Ok(Self::FundingReasonMissing),
            "CLIENT_EXTENSIONS_DATA_MISSING" => Ok(Self::ClientExtensionsDataMissing),
            "REPLACING_ORDER_INVALID" => Ok(Self::ReplacingOrderInvalid),
            "REPLACING_TRADE_ID_INVALID" => Ok(Self::ReplacingTradeIdInvalid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The possible types of a Transaction
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The possible types of a Transaction",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&TransactionType> for TransactionType {
    fn from(value: &TransactionType) -> Self {
        value.clone()
    }
}

impl ToString for TransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for TransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A TransferFundsRejectTransaction represents the rejection of the
/// transfer of funds in/out of an Account.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A TransferFundsRejectTransaction represents the
/// rejection of the transfer of funds in/out of an Account.",
///  "type": "object",
///  "properties": {
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "amount": {
///      "description": "The amount to deposit/withdraw from the Account in
/// the Account's home currency. A positive value indicates a deposit, a
/// negative value indicates a withdrawal.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "comment": {
///      "description": "An optional comment that may be attached to a fund
/// transfer for audit purposes",
///      "type": "string"
///    },
///    "fundingReason": {
///      "description": "The reason that an Account is being funded.",
///      "type": "string",
///      "enum": [
///        "CLIENT_FUNDING",
///        "ACCOUNT_TRANSFER",
///        "DIVISION_MIGRATION",
///        "SITE_MIGRATION",
///        "ADJUSTMENT"
///      ]
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "rejectReason": {
///      "description": "The reason that the Reject Transaction was
/// created",
///      "type": "string",
///      "enum": [
///        "INTERNAL_SERVER_ERROR",
///        "INSTRUMENT_PRICE_UNKNOWN",
///        "ACCOUNT_NOT_ACTIVE",
///        "ACCOUNT_LOCKED",
///        "ACCOUNT_ORDER_CREATION_LOCKED",
///        "ACCOUNT_CONFIGURATION_LOCKED",
///        "ACCOUNT_DEPOSIT_LOCKED",
///        "ACCOUNT_WITHDRAWAL_LOCKED",
///        "ACCOUNT_ORDER_CANCEL_LOCKED",
///        "INSTRUMENT_NOT_TRADEABLE",
///        "PENDING_ORDERS_ALLOWED_EXCEEDED",
///        "ORDER_ID_UNSPECIFIED",
///        "ORDER_DOESNT_EXIST",
///        "ORDER_IDENTIFIER_INCONSISTENCY",
///        "TRADE_ID_UNSPECIFIED",
///        "TRADE_DOESNT_EXIST",
///        "TRADE_IDENTIFIER_INCONSISTENCY",
///        "INSUFFICIENT_MARGIN",
///        "INSTRUMENT_MISSING",
///        "INSTRUMENT_UNKNOWN",
///        "UNITS_MISSING",
///        "UNITS_INVALID",
///        "UNITS_PRECISION_EXCEEDED",
///        "UNITS_LIMIT_EXCEEDED",
///        "UNITS_MIMIMUM_NOT_MET",
///        "PRICE_MISSING",
///        "PRICE_INVALID",
///        "PRICE_PRECISION_EXCEEDED",
///        "PRICE_DISTANCE_MISSING",
///        "PRICE_DISTANCE_INVALID",
///        "PRICE_DISTANCE_PRECISION_EXCEEDED",
///        "PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "PRICE_DISTANCE_MINIMUM_NOT_MET",
///        "TIME_IN_FORCE_MISSING",
///        "TIME_IN_FORCE_INVALID",
///        "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING",
///        "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST",
///        "PRICE_BOUND_INVALID",
///        "PRICE_BOUND_PRECISION_EXCEEDED",
///        "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS",
///        "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED",
///        "CLIENT_ORDER_ID_INVALID",
///        "CLIENT_ORDER_ID_ALREADY_EXISTS",
///        "CLIENT_ORDER_TAG_INVALID",
///        "CLIENT_ORDER_COMMENT_INVALID",
///        "CLIENT_TRADE_ID_INVALID",
///        "CLIENT_TRADE_ID_ALREADY_EXISTS",
///        "CLIENT_TRADE_TAG_INVALID",
///        "CLIENT_TRADE_COMMENT_INVALID",
///        "ORDER_FILL_POSITION_ACTION_MISSING",
///        "ORDER_FILL_POSITION_ACTION_INVALID",
///        "TRIGGER_CONDITION_MISSING",
///        "TRIGGER_CONDITION_INVALID",
///        "ORDER_PARTIAL_FILL_OPTION_MISSING",
///        "ORDER_PARTIAL_FILL_OPTION_INVALID",
///        "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL",
///        "TAKE_PROFIT_ORDER_ALREADY_EXISTS",
///        "TAKE_PROFIT_ON_FILL_PRICE_MISSING",
///        "TAKE_PROFIT_ON_FILL_PRICE_INVALID",
///        "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED",
///        "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING",
///        "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID",
///        "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "STOP_LOSS_ORDER_ALREADY_EXISTS",
///        "STOP_LOSS_ORDER_GUARANTEED_REQUIRED",
///        "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD",
///        "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED",
///        "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION",
///        "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION",
///        "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED",
///        "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///        "STOP_LOSS_ORDER_NOT_CANCELABLE",
///        "STOP_LOSS_ORDER_NOT_REPLACEABLE",
///        "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///        "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///        "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING",
///        "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER",
///        "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///        "STOP_LOSS_ON_FILL_PRICE_MISSING",
///        "STOP_LOSS_ON_FILL_PRICE_INVALID",
///        "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///        "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_DISTANCE_INVALID",
///        "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED",
///        "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///        "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING",
///        "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///        "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///        "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///        "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET",
///        "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///        "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///        "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED",
///        "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///        "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///        "CLOSE_TRADE_TYPE_MISSING",
///        "CLOSE_TRADE_PARTIAL_UNITS_MISSING",
///        "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE",
///        "CLOSEOUT_POSITION_DOESNT_EXIST",
///        "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION",
///        "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE",
///        "CLOSEOUT_POSITION_REJECT",
///        "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING",
///        "MARKUP_GROUP_ID_INVALID",
///        "POSITION_AGGREGATION_MODE_INVALID",
///        "ADMIN_CONFIGURE_DATA_MISSING",
///        "MARGIN_RATE_INVALID",
///        "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT",
///        "ALIAS_INVALID",
///        "CLIENT_CONFIGURE_DATA_MISSING",
///        "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL",
///        "AMOUNT_INVALID",
///        "INSUFFICIENT_FUNDS",
///        "AMOUNT_MISSING",
///        "FUNDING_REASON_MISSING",
///        "CLIENT_EXTENSIONS_DATA_MISSING",
///        "REPLACING_ORDER_INVALID",
///        "REPLACING_TRADE_ID_INVALID"
///      ]
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"TRANSFER_FUNDS_REJECT\" in a TransferFundsRejectTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TransferFundsRejectTransaction {
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The amount to deposit/withdraw from the Account in the Account's
    /// home currency. A positive value indicates a deposit, a negative
    /// value indicates a withdrawal.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub amount: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    ///An optional comment that may be attached to a fund transfer for
    /// audit purposes
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    ///The reason that an Account is being funded.
    #[serde(
        rename = "fundingReason",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub funding_reason: Option<TransferFundsRejectTransactionFundingReason>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The reason that the Reject Transaction was created
    #[serde(
        rename = "rejectReason",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub reject_reason: Option<TransferFundsRejectTransactionRejectReason>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The Type of the Transaction. Always set to "TRANSFER_FUNDS_REJECT"
    /// in a TransferFundsRejectTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<TransferFundsRejectTransactionType>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&TransferFundsRejectTransaction> for TransferFundsRejectTransaction {
    fn from(value: &TransferFundsRejectTransaction) -> Self {
        value.clone()
    }
}

impl TransferFundsRejectTransaction {
    pub fn builder() -> builder::TransferFundsRejectTransaction {
        Default::default()
    }
}

///The reason that an Account is being funded.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that an Account is being funded.",
///  "type": "string",
///  "enum": [
///    "CLIENT_FUNDING",
///    "ACCOUNT_TRANSFER",
///    "DIVISION_MIGRATION",
///    "SITE_MIGRATION",
///    "ADJUSTMENT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TransferFundsRejectTransactionFundingReason {
    #[serde(rename = "CLIENT_FUNDING")]
    ClientFunding,
    #[serde(rename = "ACCOUNT_TRANSFER")]
    AccountTransfer,
    #[serde(rename = "DIVISION_MIGRATION")]
    DivisionMigration,
    #[serde(rename = "SITE_MIGRATION")]
    SiteMigration,
    #[serde(rename = "ADJUSTMENT")]
    Adjustment,
}

impl From<&TransferFundsRejectTransactionFundingReason>
    for TransferFundsRejectTransactionFundingReason
{
    fn from(value: &TransferFundsRejectTransactionFundingReason) -> Self {
        value.clone()
    }
}

impl ToString for TransferFundsRejectTransactionFundingReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ClientFunding => "CLIENT_FUNDING".to_string(),
            Self::AccountTransfer => "ACCOUNT_TRANSFER".to_string(),
            Self::DivisionMigration => "DIVISION_MIGRATION".to_string(),
            Self::SiteMigration => "SITE_MIGRATION".to_string(),
            Self::Adjustment => "ADJUSTMENT".to_string(),
        }
    }
}

impl std::str::FromStr for TransferFundsRejectTransactionFundingReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CLIENT_FUNDING" => Ok(Self::ClientFunding),
            "ACCOUNT_TRANSFER" => Ok(Self::AccountTransfer),
            "DIVISION_MIGRATION" => Ok(Self::DivisionMigration),
            "SITE_MIGRATION" => Ok(Self::SiteMigration),
            "ADJUSTMENT" => Ok(Self::Adjustment),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TransferFundsRejectTransactionFundingReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TransferFundsRejectTransactionFundingReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TransferFundsRejectTransactionFundingReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The reason that the Reject Transaction was created
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that the Reject Transaction was created",
///  "type": "string",
///  "enum": [
///    "INTERNAL_SERVER_ERROR",
///    "INSTRUMENT_PRICE_UNKNOWN",
///    "ACCOUNT_NOT_ACTIVE",
///    "ACCOUNT_LOCKED",
///    "ACCOUNT_ORDER_CREATION_LOCKED",
///    "ACCOUNT_CONFIGURATION_LOCKED",
///    "ACCOUNT_DEPOSIT_LOCKED",
///    "ACCOUNT_WITHDRAWAL_LOCKED",
///    "ACCOUNT_ORDER_CANCEL_LOCKED",
///    "INSTRUMENT_NOT_TRADEABLE",
///    "PENDING_ORDERS_ALLOWED_EXCEEDED",
///    "ORDER_ID_UNSPECIFIED",
///    "ORDER_DOESNT_EXIST",
///    "ORDER_IDENTIFIER_INCONSISTENCY",
///    "TRADE_ID_UNSPECIFIED",
///    "TRADE_DOESNT_EXIST",
///    "TRADE_IDENTIFIER_INCONSISTENCY",
///    "INSUFFICIENT_MARGIN",
///    "INSTRUMENT_MISSING",
///    "INSTRUMENT_UNKNOWN",
///    "UNITS_MISSING",
///    "UNITS_INVALID",
///    "UNITS_PRECISION_EXCEEDED",
///    "UNITS_LIMIT_EXCEEDED",
///    "UNITS_MIMIMUM_NOT_MET",
///    "PRICE_MISSING",
///    "PRICE_INVALID",
///    "PRICE_PRECISION_EXCEEDED",
///    "PRICE_DISTANCE_MISSING",
///    "PRICE_DISTANCE_INVALID",
///    "PRICE_DISTANCE_PRECISION_EXCEEDED",
///    "PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "PRICE_DISTANCE_MINIMUM_NOT_MET",
///    "TIME_IN_FORCE_MISSING",
///    "TIME_IN_FORCE_INVALID",
///    "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING",
///    "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST",
///    "PRICE_BOUND_INVALID",
///    "PRICE_BOUND_PRECISION_EXCEEDED",
///    "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS",
///    "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED",
///    "CLIENT_ORDER_ID_INVALID",
///    "CLIENT_ORDER_ID_ALREADY_EXISTS",
///    "CLIENT_ORDER_TAG_INVALID",
///    "CLIENT_ORDER_COMMENT_INVALID",
///    "CLIENT_TRADE_ID_INVALID",
///    "CLIENT_TRADE_ID_ALREADY_EXISTS",
///    "CLIENT_TRADE_TAG_INVALID",
///    "CLIENT_TRADE_COMMENT_INVALID",
///    "ORDER_FILL_POSITION_ACTION_MISSING",
///    "ORDER_FILL_POSITION_ACTION_INVALID",
///    "TRIGGER_CONDITION_MISSING",
///    "TRIGGER_CONDITION_INVALID",
///    "ORDER_PARTIAL_FILL_OPTION_MISSING",
///    "ORDER_PARTIAL_FILL_OPTION_INVALID",
///    "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL",
///    "TAKE_PROFIT_ORDER_ALREADY_EXISTS",
///    "TAKE_PROFIT_ON_FILL_PRICE_MISSING",
///    "TAKE_PROFIT_ON_FILL_PRICE_INVALID",
///    "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED",
///    "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING",
///    "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "STOP_LOSS_ORDER_ALREADY_EXISTS",
///    "STOP_LOSS_ORDER_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD",
///    "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION",
///    "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION",
///    "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED",
///    "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ORDER_NOT_CANCELABLE",
///    "STOP_LOSS_ORDER_NOT_REPLACEABLE",
///    "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///    "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING",
///    "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER",
///    "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED",
///    "STOP_LOSS_ON_FILL_PRICE_MISSING",
///    "STOP_LOSS_ON_FILL_PRICE_INVALID",
///    "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET",
///    "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_DISTANCE_INVALID",
///    "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED",
///    "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED",
///    "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///    "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED",
///    "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET",
///    "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID",
///    "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID",
///    "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED",
///    "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING",
///    "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID",
///    "CLOSE_TRADE_TYPE_MISSING",
///    "CLOSE_TRADE_PARTIAL_UNITS_MISSING",
///    "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE",
///    "CLOSEOUT_POSITION_DOESNT_EXIST",
///    "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION",
///    "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE",
///    "CLOSEOUT_POSITION_REJECT",
///    "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING",
///    "MARKUP_GROUP_ID_INVALID",
///    "POSITION_AGGREGATION_MODE_INVALID",
///    "ADMIN_CONFIGURE_DATA_MISSING",
///    "MARGIN_RATE_INVALID",
///    "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT",
///    "ALIAS_INVALID",
///    "CLIENT_CONFIGURE_DATA_MISSING",
///    "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL",
///    "AMOUNT_INVALID",
///    "INSUFFICIENT_FUNDS",
///    "AMOUNT_MISSING",
///    "FUNDING_REASON_MISSING",
///    "CLIENT_EXTENSIONS_DATA_MISSING",
///    "REPLACING_ORDER_INVALID",
///    "REPLACING_TRADE_ID_INVALID"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TransferFundsRejectTransactionRejectReason {
    #[serde(rename = "INTERNAL_SERVER_ERROR")]
    InternalServerError,
    #[serde(rename = "INSTRUMENT_PRICE_UNKNOWN")]
    InstrumentPriceUnknown,
    #[serde(rename = "ACCOUNT_NOT_ACTIVE")]
    AccountNotActive,
    #[serde(rename = "ACCOUNT_LOCKED")]
    AccountLocked,
    #[serde(rename = "ACCOUNT_ORDER_CREATION_LOCKED")]
    AccountOrderCreationLocked,
    #[serde(rename = "ACCOUNT_CONFIGURATION_LOCKED")]
    AccountConfigurationLocked,
    #[serde(rename = "ACCOUNT_DEPOSIT_LOCKED")]
    AccountDepositLocked,
    #[serde(rename = "ACCOUNT_WITHDRAWAL_LOCKED")]
    AccountWithdrawalLocked,
    #[serde(rename = "ACCOUNT_ORDER_CANCEL_LOCKED")]
    AccountOrderCancelLocked,
    #[serde(rename = "INSTRUMENT_NOT_TRADEABLE")]
    InstrumentNotTradeable,
    #[serde(rename = "PENDING_ORDERS_ALLOWED_EXCEEDED")]
    PendingOrdersAllowedExceeded,
    #[serde(rename = "ORDER_ID_UNSPECIFIED")]
    OrderIdUnspecified,
    #[serde(rename = "ORDER_DOESNT_EXIST")]
    OrderDoesntExist,
    #[serde(rename = "ORDER_IDENTIFIER_INCONSISTENCY")]
    OrderIdentifierInconsistency,
    #[serde(rename = "TRADE_ID_UNSPECIFIED")]
    TradeIdUnspecified,
    #[serde(rename = "TRADE_DOESNT_EXIST")]
    TradeDoesntExist,
    #[serde(rename = "TRADE_IDENTIFIER_INCONSISTENCY")]
    TradeIdentifierInconsistency,
    #[serde(rename = "INSUFFICIENT_MARGIN")]
    InsufficientMargin,
    #[serde(rename = "INSTRUMENT_MISSING")]
    InstrumentMissing,
    #[serde(rename = "INSTRUMENT_UNKNOWN")]
    InstrumentUnknown,
    #[serde(rename = "UNITS_MISSING")]
    UnitsMissing,
    #[serde(rename = "UNITS_INVALID")]
    UnitsInvalid,
    #[serde(rename = "UNITS_PRECISION_EXCEEDED")]
    UnitsPrecisionExceeded,
    #[serde(rename = "UNITS_LIMIT_EXCEEDED")]
    UnitsLimitExceeded,
    #[serde(rename = "UNITS_MIMIMUM_NOT_MET")]
    UnitsMimimumNotMet,
    #[serde(rename = "PRICE_MISSING")]
    PriceMissing,
    #[serde(rename = "PRICE_INVALID")]
    PriceInvalid,
    #[serde(rename = "PRICE_PRECISION_EXCEEDED")]
    PricePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MISSING")]
    PriceDistanceMissing,
    #[serde(rename = "PRICE_DISTANCE_INVALID")]
    PriceDistanceInvalid,
    #[serde(rename = "PRICE_DISTANCE_PRECISION_EXCEEDED")]
    PriceDistancePrecisionExceeded,
    #[serde(rename = "PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    PriceDistanceMaximumExceeded,
    #[serde(rename = "PRICE_DISTANCE_MINIMUM_NOT_MET")]
    PriceDistanceMinimumNotMet,
    #[serde(rename = "TIME_IN_FORCE_MISSING")]
    TimeInForceMissing,
    #[serde(rename = "TIME_IN_FORCE_INVALID")]
    TimeInForceInvalid,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING")]
    TimeInForceGtdTimestampMissing,
    #[serde(rename = "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST")]
    TimeInForceGtdTimestampInPast,
    #[serde(rename = "PRICE_BOUND_INVALID")]
    PriceBoundInvalid,
    #[serde(rename = "PRICE_BOUND_PRECISION_EXCEEDED")]
    PriceBoundPrecisionExceeded,
    #[serde(rename = "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS")]
    OrdersOnFillDuplicateClientOrderIds,
    #[serde(rename = "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED")]
    TradeOnFillClientExtensionsNotSupported,
    #[serde(rename = "CLIENT_ORDER_ID_INVALID")]
    ClientOrderIdInvalid,
    #[serde(rename = "CLIENT_ORDER_ID_ALREADY_EXISTS")]
    ClientOrderIdAlreadyExists,
    #[serde(rename = "CLIENT_ORDER_TAG_INVALID")]
    ClientOrderTagInvalid,
    #[serde(rename = "CLIENT_ORDER_COMMENT_INVALID")]
    ClientOrderCommentInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_INVALID")]
    ClientTradeIdInvalid,
    #[serde(rename = "CLIENT_TRADE_ID_ALREADY_EXISTS")]
    ClientTradeIdAlreadyExists,
    #[serde(rename = "CLIENT_TRADE_TAG_INVALID")]
    ClientTradeTagInvalid,
    #[serde(rename = "CLIENT_TRADE_COMMENT_INVALID")]
    ClientTradeCommentInvalid,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_MISSING")]
    OrderFillPositionActionMissing,
    #[serde(rename = "ORDER_FILL_POSITION_ACTION_INVALID")]
    OrderFillPositionActionInvalid,
    #[serde(rename = "TRIGGER_CONDITION_MISSING")]
    TriggerConditionMissing,
    #[serde(rename = "TRIGGER_CONDITION_INVALID")]
    TriggerConditionInvalid,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_MISSING")]
    OrderPartialFillOptionMissing,
    #[serde(rename = "ORDER_PARTIAL_FILL_OPTION_INVALID")]
    OrderPartialFillOptionInvalid,
    #[serde(rename = "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL")]
    InvalidReissueImmediatePartialFill,
    #[serde(rename = "TAKE_PROFIT_ORDER_ALREADY_EXISTS")]
    TakeProfitOrderAlreadyExists,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_MISSING")]
    TakeProfitOnFillPriceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_INVALID")]
    TakeProfitOnFillPriceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    TakeProfitOnFillPricePrecisionExceeded,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING")]
    TakeProfitOnFillTimeInForceMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID")]
    TakeProfitOnFillTimeInForceInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TakeProfitOnFillGtdTimestampMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TakeProfitOnFillGtdTimestampInPast,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TakeProfitOnFillClientOrderIdInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TakeProfitOnFillClientOrderTagInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TakeProfitOnFillClientOrderCommentInvalid,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TakeProfitOnFillTriggerConditionMissing,
    #[serde(rename = "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TakeProfitOnFillTriggerConditionInvalid,
    #[serde(rename = "STOP_LOSS_ORDER_ALREADY_EXISTS")]
    StopLossOrderAlreadyExists,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_REQUIRED")]
    StopLossOrderGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD")]
    StopLossOrderGuaranteedPriceWithinSpread,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED")]
    StopLossOrderGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION")]
    StopLossOrderGuaranteedHaltedCreateViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION")]
    StopLossOrderGuaranteedHaltedTightenViolation,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED")]
    StopLossOrderGuaranteedHedgingNotAllowed,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOrderGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_CANCELABLE")]
    StopLossOrderNotCancelable,
    #[serde(rename = "STOP_LOSS_ORDER_NOT_REPLACEABLE")]
    StopLossOrderNotReplaceable,
    #[serde(rename = "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOrderGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOrderPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOrderPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER")]
    StopLossOnFillRequiredForPendingOrder,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED")]
    StopLossOnFillGuaranteedNotAllowed,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED")]
    StopLossOnFillGuaranteedRequired,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_MISSING")]
    StopLossOnFillPriceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_INVALID")]
    StopLossOnFillPriceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED")]
    StopLossOnFillPricePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET")]
    StopLossOnFillGuaranteedMinimumDistanceNotMet,
    #[serde(rename = "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED")]
    StopLossOnFillGuaranteedLevelRestrictionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_INVALID")]
    StopLossOnFillDistanceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    StopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED")]
    StopLossOnFillDistancePrecisionExceeded,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED")]
    StopLossOnFillPriceAndDistanceBothSpecified,
    #[serde(rename = "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING")]
    StopLossOnFillPriceAndDistanceBothMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    StopLossOnFillTimeInForceMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    StopLossOnFillTimeInForceInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    StopLossOnFillGtdTimestampMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    StopLossOnFillGtdTimestampInPast,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    StopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    StopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    StopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    StopLossOnFillTriggerConditionMissing,
    #[serde(rename = "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    StopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS")]
    TrailingStopLossOrderAlreadyExists,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING")]
    TrailingStopLossOnFillPriceDistanceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID")]
    TrailingStopLossOnFillPriceDistanceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED")]
    TrailingStopLossOnFillPriceDistancePrecisionExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED")]
    TrailingStopLossOnFillPriceDistanceMaximumExceeded,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET")]
    TrailingStopLossOnFillPriceDistanceMinimumNotMet,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING")]
    TrailingStopLossOnFillTimeInForceMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID")]
    TrailingStopLossOnFillTimeInForceInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING")]
    TrailingStopLossOnFillGtdTimestampMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST")]
    TrailingStopLossOnFillGtdTimestampInPast,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID")]
    TrailingStopLossOnFillClientOrderIdInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID")]
    TrailingStopLossOnFillClientOrderTagInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID")]
    TrailingStopLossOnFillClientOrderCommentInvalid,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED")]
    TrailingStopLossOrdersNotSupported,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING")]
    TrailingStopLossOnFillTriggerConditionMissing,
    #[serde(rename = "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID")]
    TrailingStopLossOnFillTriggerConditionInvalid,
    #[serde(rename = "CLOSE_TRADE_TYPE_MISSING")]
    CloseTradeTypeMissing,
    #[serde(rename = "CLOSE_TRADE_PARTIAL_UNITS_MISSING")]
    CloseTradePartialUnitsMissing,
    #[serde(rename = "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE")]
    CloseTradeUnitsExceedTradeSize,
    #[serde(rename = "CLOSEOUT_POSITION_DOESNT_EXIST")]
    CloseoutPositionDoesntExist,
    #[serde(rename = "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION")]
    CloseoutPositionIncompleteSpecification,
    #[serde(rename = "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE")]
    CloseoutPositionUnitsExceedPositionSize,
    #[serde(rename = "CLOSEOUT_POSITION_REJECT")]
    CloseoutPositionReject,
    #[serde(rename = "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING")]
    CloseoutPositionPartialUnitsMissing,
    #[serde(rename = "MARKUP_GROUP_ID_INVALID")]
    MarkupGroupIdInvalid,
    #[serde(rename = "POSITION_AGGREGATION_MODE_INVALID")]
    PositionAggregationModeInvalid,
    #[serde(rename = "ADMIN_CONFIGURE_DATA_MISSING")]
    AdminConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_INVALID")]
    MarginRateInvalid,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT")]
    MarginRateWouldTriggerCloseout,
    #[serde(rename = "ALIAS_INVALID")]
    AliasInvalid,
    #[serde(rename = "CLIENT_CONFIGURE_DATA_MISSING")]
    ClientConfigureDataMissing,
    #[serde(rename = "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL")]
    MarginRateWouldTriggerMarginCall,
    #[serde(rename = "AMOUNT_INVALID")]
    AmountInvalid,
    #[serde(rename = "INSUFFICIENT_FUNDS")]
    InsufficientFunds,
    #[serde(rename = "AMOUNT_MISSING")]
    AmountMissing,
    #[serde(rename = "FUNDING_REASON_MISSING")]
    FundingReasonMissing,
    #[serde(rename = "CLIENT_EXTENSIONS_DATA_MISSING")]
    ClientExtensionsDataMissing,
    #[serde(rename = "REPLACING_ORDER_INVALID")]
    ReplacingOrderInvalid,
    #[serde(rename = "REPLACING_TRADE_ID_INVALID")]
    ReplacingTradeIdInvalid,
}

impl From<&TransferFundsRejectTransactionRejectReason>
    for TransferFundsRejectTransactionRejectReason
{
    fn from(value: &TransferFundsRejectTransactionRejectReason) -> Self {
        value.clone()
    }
}

impl ToString for TransferFundsRejectTransactionRejectReason {
    fn to_string(&self) -> String {
        match *self {
            Self::InternalServerError => "INTERNAL_SERVER_ERROR".to_string(),
            Self::InstrumentPriceUnknown => "INSTRUMENT_PRICE_UNKNOWN".to_string(),
            Self::AccountNotActive => "ACCOUNT_NOT_ACTIVE".to_string(),
            Self::AccountLocked => "ACCOUNT_LOCKED".to_string(),
            Self::AccountOrderCreationLocked => "ACCOUNT_ORDER_CREATION_LOCKED".to_string(),
            Self::AccountConfigurationLocked => "ACCOUNT_CONFIGURATION_LOCKED".to_string(),
            Self::AccountDepositLocked => "ACCOUNT_DEPOSIT_LOCKED".to_string(),
            Self::AccountWithdrawalLocked => "ACCOUNT_WITHDRAWAL_LOCKED".to_string(),
            Self::AccountOrderCancelLocked => "ACCOUNT_ORDER_CANCEL_LOCKED".to_string(),
            Self::InstrumentNotTradeable => "INSTRUMENT_NOT_TRADEABLE".to_string(),
            Self::PendingOrdersAllowedExceeded => "PENDING_ORDERS_ALLOWED_EXCEEDED".to_string(),
            Self::OrderIdUnspecified => "ORDER_ID_UNSPECIFIED".to_string(),
            Self::OrderDoesntExist => "ORDER_DOESNT_EXIST".to_string(),
            Self::OrderIdentifierInconsistency => "ORDER_IDENTIFIER_INCONSISTENCY".to_string(),
            Self::TradeIdUnspecified => "TRADE_ID_UNSPECIFIED".to_string(),
            Self::TradeDoesntExist => "TRADE_DOESNT_EXIST".to_string(),
            Self::TradeIdentifierInconsistency => "TRADE_IDENTIFIER_INCONSISTENCY".to_string(),
            Self::InsufficientMargin => "INSUFFICIENT_MARGIN".to_string(),
            Self::InstrumentMissing => "INSTRUMENT_MISSING".to_string(),
            Self::InstrumentUnknown => "INSTRUMENT_UNKNOWN".to_string(),
            Self::UnitsMissing => "UNITS_MISSING".to_string(),
            Self::UnitsInvalid => "UNITS_INVALID".to_string(),
            Self::UnitsPrecisionExceeded => "UNITS_PRECISION_EXCEEDED".to_string(),
            Self::UnitsLimitExceeded => "UNITS_LIMIT_EXCEEDED".to_string(),
            Self::UnitsMimimumNotMet => "UNITS_MIMIMUM_NOT_MET".to_string(),
            Self::PriceMissing => "PRICE_MISSING".to_string(),
            Self::PriceInvalid => "PRICE_INVALID".to_string(),
            Self::PricePrecisionExceeded => "PRICE_PRECISION_EXCEEDED".to_string(),
            Self::PriceDistanceMissing => "PRICE_DISTANCE_MISSING".to_string(),
            Self::PriceDistanceInvalid => "PRICE_DISTANCE_INVALID".to_string(),
            Self::PriceDistancePrecisionExceeded => "PRICE_DISTANCE_PRECISION_EXCEEDED".to_string(),
            Self::PriceDistanceMaximumExceeded => "PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string(),
            Self::PriceDistanceMinimumNotMet => "PRICE_DISTANCE_MINIMUM_NOT_MET".to_string(),
            Self::TimeInForceMissing => "TIME_IN_FORCE_MISSING".to_string(),
            Self::TimeInForceInvalid => "TIME_IN_FORCE_INVALID".to_string(),
            Self::TimeInForceGtdTimestampMissing => {
                "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TimeInForceGtdTimestampInPast => {
                "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::PriceBoundInvalid => "PRICE_BOUND_INVALID".to_string(),
            Self::PriceBoundPrecisionExceeded => "PRICE_BOUND_PRECISION_EXCEEDED".to_string(),
            Self::OrdersOnFillDuplicateClientOrderIds => {
                "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS".to_string()
            }
            Self::TradeOnFillClientExtensionsNotSupported => {
                "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED".to_string()
            }
            Self::ClientOrderIdInvalid => "CLIENT_ORDER_ID_INVALID".to_string(),
            Self::ClientOrderIdAlreadyExists => "CLIENT_ORDER_ID_ALREADY_EXISTS".to_string(),
            Self::ClientOrderTagInvalid => "CLIENT_ORDER_TAG_INVALID".to_string(),
            Self::ClientOrderCommentInvalid => "CLIENT_ORDER_COMMENT_INVALID".to_string(),
            Self::ClientTradeIdInvalid => "CLIENT_TRADE_ID_INVALID".to_string(),
            Self::ClientTradeIdAlreadyExists => "CLIENT_TRADE_ID_ALREADY_EXISTS".to_string(),
            Self::ClientTradeTagInvalid => "CLIENT_TRADE_TAG_INVALID".to_string(),
            Self::ClientTradeCommentInvalid => "CLIENT_TRADE_COMMENT_INVALID".to_string(),
            Self::OrderFillPositionActionMissing => {
                "ORDER_FILL_POSITION_ACTION_MISSING".to_string()
            }
            Self::OrderFillPositionActionInvalid => {
                "ORDER_FILL_POSITION_ACTION_INVALID".to_string()
            }
            Self::TriggerConditionMissing => "TRIGGER_CONDITION_MISSING".to_string(),
            Self::TriggerConditionInvalid => "TRIGGER_CONDITION_INVALID".to_string(),
            Self::OrderPartialFillOptionMissing => "ORDER_PARTIAL_FILL_OPTION_MISSING".to_string(),
            Self::OrderPartialFillOptionInvalid => "ORDER_PARTIAL_FILL_OPTION_INVALID".to_string(),
            Self::InvalidReissueImmediatePartialFill => {
                "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL".to_string()
            }
            Self::TakeProfitOrderAlreadyExists => "TAKE_PROFIT_ORDER_ALREADY_EXISTS".to_string(),
            Self::TakeProfitOnFillPriceMissing => "TAKE_PROFIT_ON_FILL_PRICE_MISSING".to_string(),
            Self::TakeProfitOnFillPriceInvalid => "TAKE_PROFIT_ON_FILL_PRICE_INVALID".to_string(),
            Self::TakeProfitOnFillPricePrecisionExceeded => {
                "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED".to_string()
            }
            Self::TakeProfitOnFillTimeInForceMissing => {
                "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::TakeProfitOnFillTimeInForceInvalid => {
                "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::TakeProfitOnFillGtdTimestampMissing => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TakeProfitOnFillGtdTimestampInPast => {
                "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TakeProfitOnFillClientOrderIdInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::TakeProfitOnFillClientOrderTagInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::TakeProfitOnFillClientOrderCommentInvalid => {
                "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::TakeProfitOnFillTriggerConditionMissing => {
                "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::TakeProfitOnFillTriggerConditionInvalid => {
                "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::StopLossOrderAlreadyExists => "STOP_LOSS_ORDER_ALREADY_EXISTS".to_string(),
            Self::StopLossOrderGuaranteedRequired => {
                "STOP_LOSS_ORDER_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOrderGuaranteedPriceWithinSpread => {
                "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD".to_string()
            }
            Self::StopLossOrderGuaranteedNotAllowed => {
                "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOrderGuaranteedHaltedCreateViolation => {
                "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION".to_string()
            }
            Self::StopLossOrderGuaranteedHaltedTightenViolation => {
                "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION".to_string()
            }
            Self::StopLossOrderGuaranteedHedgingNotAllowed => {
                "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED".to_string()
            }
            Self::StopLossOrderGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOrderNotCancelable => "STOP_LOSS_ORDER_NOT_CANCELABLE".to_string(),
            Self::StopLossOrderNotReplaceable => "STOP_LOSS_ORDER_NOT_REPLACEABLE".to_string(),
            Self::StopLossOrderGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOrderPriceAndDistanceBothSpecified => {
                "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED".to_string()
            }
            Self::StopLossOrderPriceAndDistanceBothMissing => {
                "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING".to_string()
            }
            Self::StopLossOnFillRequiredForPendingOrder => {
                "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER".to_string()
            }
            Self::StopLossOnFillGuaranteedNotAllowed => {
                "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED".to_string()
            }
            Self::StopLossOnFillGuaranteedRequired => {
                "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED".to_string()
            }
            Self::StopLossOnFillPriceMissing => "STOP_LOSS_ON_FILL_PRICE_MISSING".to_string(),
            Self::StopLossOnFillPriceInvalid => "STOP_LOSS_ON_FILL_PRICE_INVALID".to_string(),
            Self::StopLossOnFillPricePrecisionExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillGuaranteedMinimumDistanceNotMet => {
                "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET".to_string()
            }
            Self::StopLossOnFillGuaranteedLevelRestrictionExceeded => {
                "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillDistanceInvalid => "STOP_LOSS_ON_FILL_DISTANCE_INVALID".to_string(),
            Self::StopLossOnFillPriceDistanceMaximumExceeded => {
                "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::StopLossOnFillDistancePrecisionExceeded => {
                "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED".to_string()
            }
            Self::StopLossOnFillPriceAndDistanceBothSpecified => {
                "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED".to_string()
            }
            Self::StopLossOnFillPriceAndDistanceBothMissing => {
                "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING".to_string()
            }
            Self::StopLossOnFillTimeInForceMissing => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::StopLossOnFillTimeInForceInvalid => {
                "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::StopLossOnFillGtdTimestampMissing => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::StopLossOnFillGtdTimestampInPast => {
                "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::StopLossOnFillClientOrderIdInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::StopLossOnFillClientOrderTagInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::StopLossOnFillClientOrderCommentInvalid => {
                "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::StopLossOnFillTriggerConditionMissing => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::StopLossOnFillTriggerConditionInvalid => {
                "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::TrailingStopLossOrderAlreadyExists => {
                "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistancePrecisionExceeded => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMaximumExceeded => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED".to_string()
            }
            Self::TrailingStopLossOnFillPriceDistanceMinimumNotMet => {
                "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET".to_string()
            }
            Self::TrailingStopLossOnFillTimeInForceMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillTimeInForceInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillGtdTimestampInPast => {
                "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderIdInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderTagInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID".to_string()
            }
            Self::TrailingStopLossOnFillClientOrderCommentInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID".to_string()
            }
            Self::TrailingStopLossOrdersNotSupported => {
                "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED".to_string()
            }
            Self::TrailingStopLossOnFillTriggerConditionMissing => {
                "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING".to_string()
            }
            Self::TrailingStopLossOnFillTriggerConditionInvalid => {
                "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID".to_string()
            }
            Self::CloseTradeTypeMissing => "CLOSE_TRADE_TYPE_MISSING".to_string(),
            Self::CloseTradePartialUnitsMissing => "CLOSE_TRADE_PARTIAL_UNITS_MISSING".to_string(),
            Self::CloseTradeUnitsExceedTradeSize => {
                "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE".to_string()
            }
            Self::CloseoutPositionDoesntExist => "CLOSEOUT_POSITION_DOESNT_EXIST".to_string(),
            Self::CloseoutPositionIncompleteSpecification => {
                "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION".to_string()
            }
            Self::CloseoutPositionUnitsExceedPositionSize => {
                "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE".to_string()
            }
            Self::CloseoutPositionReject => "CLOSEOUT_POSITION_REJECT".to_string(),
            Self::CloseoutPositionPartialUnitsMissing => {
                "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING".to_string()
            }
            Self::MarkupGroupIdInvalid => "MARKUP_GROUP_ID_INVALID".to_string(),
            Self::PositionAggregationModeInvalid => "POSITION_AGGREGATION_MODE_INVALID".to_string(),
            Self::AdminConfigureDataMissing => "ADMIN_CONFIGURE_DATA_MISSING".to_string(),
            Self::MarginRateInvalid => "MARGIN_RATE_INVALID".to_string(),
            Self::MarginRateWouldTriggerCloseout => {
                "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT".to_string()
            }
            Self::AliasInvalid => "ALIAS_INVALID".to_string(),
            Self::ClientConfigureDataMissing => "CLIENT_CONFIGURE_DATA_MISSING".to_string(),
            Self::MarginRateWouldTriggerMarginCall => {
                "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL".to_string()
            }
            Self::AmountInvalid => "AMOUNT_INVALID".to_string(),
            Self::InsufficientFunds => "INSUFFICIENT_FUNDS".to_string(),
            Self::AmountMissing => "AMOUNT_MISSING".to_string(),
            Self::FundingReasonMissing => "FUNDING_REASON_MISSING".to_string(),
            Self::ClientExtensionsDataMissing => "CLIENT_EXTENSIONS_DATA_MISSING".to_string(),
            Self::ReplacingOrderInvalid => "REPLACING_ORDER_INVALID".to_string(),
            Self::ReplacingTradeIdInvalid => "REPLACING_TRADE_ID_INVALID".to_string(),
        }
    }
}

impl std::str::FromStr for TransferFundsRejectTransactionRejectReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "INTERNAL_SERVER_ERROR" => Ok(Self::InternalServerError),
            "INSTRUMENT_PRICE_UNKNOWN" => Ok(Self::InstrumentPriceUnknown),
            "ACCOUNT_NOT_ACTIVE" => Ok(Self::AccountNotActive),
            "ACCOUNT_LOCKED" => Ok(Self::AccountLocked),
            "ACCOUNT_ORDER_CREATION_LOCKED" => Ok(Self::AccountOrderCreationLocked),
            "ACCOUNT_CONFIGURATION_LOCKED" => Ok(Self::AccountConfigurationLocked),
            "ACCOUNT_DEPOSIT_LOCKED" => Ok(Self::AccountDepositLocked),
            "ACCOUNT_WITHDRAWAL_LOCKED" => Ok(Self::AccountWithdrawalLocked),
            "ACCOUNT_ORDER_CANCEL_LOCKED" => Ok(Self::AccountOrderCancelLocked),
            "INSTRUMENT_NOT_TRADEABLE" => Ok(Self::InstrumentNotTradeable),
            "PENDING_ORDERS_ALLOWED_EXCEEDED" => Ok(Self::PendingOrdersAllowedExceeded),
            "ORDER_ID_UNSPECIFIED" => Ok(Self::OrderIdUnspecified),
            "ORDER_DOESNT_EXIST" => Ok(Self::OrderDoesntExist),
            "ORDER_IDENTIFIER_INCONSISTENCY" => Ok(Self::OrderIdentifierInconsistency),
            "TRADE_ID_UNSPECIFIED" => Ok(Self::TradeIdUnspecified),
            "TRADE_DOESNT_EXIST" => Ok(Self::TradeDoesntExist),
            "TRADE_IDENTIFIER_INCONSISTENCY" => Ok(Self::TradeIdentifierInconsistency),
            "INSUFFICIENT_MARGIN" => Ok(Self::InsufficientMargin),
            "INSTRUMENT_MISSING" => Ok(Self::InstrumentMissing),
            "INSTRUMENT_UNKNOWN" => Ok(Self::InstrumentUnknown),
            "UNITS_MISSING" => Ok(Self::UnitsMissing),
            "UNITS_INVALID" => Ok(Self::UnitsInvalid),
            "UNITS_PRECISION_EXCEEDED" => Ok(Self::UnitsPrecisionExceeded),
            "UNITS_LIMIT_EXCEEDED" => Ok(Self::UnitsLimitExceeded),
            "UNITS_MIMIMUM_NOT_MET" => Ok(Self::UnitsMimimumNotMet),
            "PRICE_MISSING" => Ok(Self::PriceMissing),
            "PRICE_INVALID" => Ok(Self::PriceInvalid),
            "PRICE_PRECISION_EXCEEDED" => Ok(Self::PricePrecisionExceeded),
            "PRICE_DISTANCE_MISSING" => Ok(Self::PriceDistanceMissing),
            "PRICE_DISTANCE_INVALID" => Ok(Self::PriceDistanceInvalid),
            "PRICE_DISTANCE_PRECISION_EXCEEDED" => Ok(Self::PriceDistancePrecisionExceeded),
            "PRICE_DISTANCE_MAXIMUM_EXCEEDED" => Ok(Self::PriceDistanceMaximumExceeded),
            "PRICE_DISTANCE_MINIMUM_NOT_MET" => Ok(Self::PriceDistanceMinimumNotMet),
            "TIME_IN_FORCE_MISSING" => Ok(Self::TimeInForceMissing),
            "TIME_IN_FORCE_INVALID" => Ok(Self::TimeInForceInvalid),
            "TIME_IN_FORCE_GTD_TIMESTAMP_MISSING" => Ok(Self::TimeInForceGtdTimestampMissing),
            "TIME_IN_FORCE_GTD_TIMESTAMP_IN_PAST" => Ok(Self::TimeInForceGtdTimestampInPast),
            "PRICE_BOUND_INVALID" => Ok(Self::PriceBoundInvalid),
            "PRICE_BOUND_PRECISION_EXCEEDED" => Ok(Self::PriceBoundPrecisionExceeded),
            "ORDERS_ON_FILL_DUPLICATE_CLIENT_ORDER_IDS" => {
                Ok(Self::OrdersOnFillDuplicateClientOrderIds)
            }
            "TRADE_ON_FILL_CLIENT_EXTENSIONS_NOT_SUPPORTED" => {
                Ok(Self::TradeOnFillClientExtensionsNotSupported)
            }
            "CLIENT_ORDER_ID_INVALID" => Ok(Self::ClientOrderIdInvalid),
            "CLIENT_ORDER_ID_ALREADY_EXISTS" => Ok(Self::ClientOrderIdAlreadyExists),
            "CLIENT_ORDER_TAG_INVALID" => Ok(Self::ClientOrderTagInvalid),
            "CLIENT_ORDER_COMMENT_INVALID" => Ok(Self::ClientOrderCommentInvalid),
            "CLIENT_TRADE_ID_INVALID" => Ok(Self::ClientTradeIdInvalid),
            "CLIENT_TRADE_ID_ALREADY_EXISTS" => Ok(Self::ClientTradeIdAlreadyExists),
            "CLIENT_TRADE_TAG_INVALID" => Ok(Self::ClientTradeTagInvalid),
            "CLIENT_TRADE_COMMENT_INVALID" => Ok(Self::ClientTradeCommentInvalid),
            "ORDER_FILL_POSITION_ACTION_MISSING" => Ok(Self::OrderFillPositionActionMissing),
            "ORDER_FILL_POSITION_ACTION_INVALID" => Ok(Self::OrderFillPositionActionInvalid),
            "TRIGGER_CONDITION_MISSING" => Ok(Self::TriggerConditionMissing),
            "TRIGGER_CONDITION_INVALID" => Ok(Self::TriggerConditionInvalid),
            "ORDER_PARTIAL_FILL_OPTION_MISSING" => Ok(Self::OrderPartialFillOptionMissing),
            "ORDER_PARTIAL_FILL_OPTION_INVALID" => Ok(Self::OrderPartialFillOptionInvalid),
            "INVALID_REISSUE_IMMEDIATE_PARTIAL_FILL" => {
                Ok(Self::InvalidReissueImmediatePartialFill)
            }
            "TAKE_PROFIT_ORDER_ALREADY_EXISTS" => Ok(Self::TakeProfitOrderAlreadyExists),
            "TAKE_PROFIT_ON_FILL_PRICE_MISSING" => Ok(Self::TakeProfitOnFillPriceMissing),
            "TAKE_PROFIT_ON_FILL_PRICE_INVALID" => Ok(Self::TakeProfitOnFillPriceInvalid),
            "TAKE_PROFIT_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(Self::TakeProfitOnFillPricePrecisionExceeded)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(Self::TakeProfitOnFillTimeInForceMissing)
            }
            "TAKE_PROFIT_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(Self::TakeProfitOnFillTimeInForceInvalid)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::TakeProfitOnFillGtdTimestampMissing)
            }
            "TAKE_PROFIT_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TakeProfitOnFillGtdTimestampInPast)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderIdInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderTagInvalid)
            }
            "TAKE_PROFIT_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::TakeProfitOnFillClientOrderCommentInvalid)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::TakeProfitOnFillTriggerConditionMissing)
            }
            "TAKE_PROFIT_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::TakeProfitOnFillTriggerConditionInvalid)
            }
            "STOP_LOSS_ORDER_ALREADY_EXISTS" => Ok(Self::StopLossOrderAlreadyExists),
            "STOP_LOSS_ORDER_GUARANTEED_REQUIRED" => Ok(Self::StopLossOrderGuaranteedRequired),
            "STOP_LOSS_ORDER_GUARANTEED_PRICE_WITHIN_SPREAD" => {
                Ok(Self::StopLossOrderGuaranteedPriceWithinSpread)
            }
            "STOP_LOSS_ORDER_GUARANTEED_NOT_ALLOWED" => Ok(Self::StopLossOrderGuaranteedNotAllowed),
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_CREATE_VIOLATION" => {
                Ok(Self::StopLossOrderGuaranteedHaltedCreateViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HALTED_TIGHTEN_VIOLATION" => {
                Ok(Self::StopLossOrderGuaranteedHaltedTightenViolation)
            }
            "STOP_LOSS_ORDER_GUARANTEED_HEDGING_NOT_ALLOWED" => {
                Ok(Self::StopLossOrderGuaranteedHedgingNotAllowed)
            }
            "STOP_LOSS_ORDER_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOrderGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ORDER_NOT_CANCELABLE" => Ok(Self::StopLossOrderNotCancelable),
            "STOP_LOSS_ORDER_NOT_REPLACEABLE" => Ok(Self::StopLossOrderNotReplaceable),
            "STOP_LOSS_ORDER_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOrderGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(Self::StopLossOrderPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ORDER_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(Self::StopLossOrderPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_REQUIRED_FOR_PENDING_ORDER" => {
                Ok(Self::StopLossOnFillRequiredForPendingOrder)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_NOT_ALLOWED" => {
                Ok(Self::StopLossOnFillGuaranteedNotAllowed)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_REQUIRED" => Ok(Self::StopLossOnFillGuaranteedRequired),
            "STOP_LOSS_ON_FILL_PRICE_MISSING" => Ok(Self::StopLossOnFillPriceMissing),
            "STOP_LOSS_ON_FILL_PRICE_INVALID" => Ok(Self::StopLossOnFillPriceInvalid),
            "STOP_LOSS_ON_FILL_PRICE_PRECISION_EXCEEDED" => {
                Ok(Self::StopLossOnFillPricePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_MINIMUM_DISTANCE_NOT_MET" => {
                Ok(Self::StopLossOnFillGuaranteedMinimumDistanceNotMet)
            }
            "STOP_LOSS_ON_FILL_GUARANTEED_LEVEL_RESTRICTION_EXCEEDED" => {
                Ok(Self::StopLossOnFillGuaranteedLevelRestrictionExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_INVALID" => Ok(Self::StopLossOnFillDistanceInvalid),
            "STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::StopLossOnFillPriceDistanceMaximumExceeded)
            }
            "STOP_LOSS_ON_FILL_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(Self::StopLossOnFillDistancePrecisionExceeded)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_SPECIFIED" => {
                Ok(Self::StopLossOnFillPriceAndDistanceBothSpecified)
            }
            "STOP_LOSS_ON_FILL_PRICE_AND_DISTANCE_BOTH_MISSING" => {
                Ok(Self::StopLossOnFillPriceAndDistanceBothMissing)
            }
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => Ok(Self::StopLossOnFillTimeInForceMissing),
            "STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => Ok(Self::StopLossOnFillTimeInForceInvalid),
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::StopLossOnFillGtdTimestampMissing)
            }
            "STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => Ok(Self::StopLossOnFillGtdTimestampInPast),
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderIdInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderTagInvalid)
            }
            "STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::StopLossOnFillClientOrderCommentInvalid)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::StopLossOnFillTriggerConditionMissing)
            }
            "STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::StopLossOnFillTriggerConditionInvalid)
            }
            "TRAILING_STOP_LOSS_ORDER_ALREADY_EXISTS" => {
                Ok(Self::TrailingStopLossOrderAlreadyExists)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MISSING" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_INVALID" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_PRECISION_EXCEEDED" => {
                Ok(Self::TrailingStopLossOnFillPriceDistancePrecisionExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MAXIMUM_EXCEEDED" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMaximumExceeded)
            }
            "TRAILING_STOP_LOSS_ON_FILL_PRICE_DISTANCE_MINIMUM_NOT_MET" => {
                Ok(Self::TrailingStopLossOnFillPriceDistanceMinimumNotMet)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_MISSING" => {
                Ok(Self::TrailingStopLossOnFillTimeInForceMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TIME_IN_FORCE_INVALID" => {
                Ok(Self::TrailingStopLossOnFillTimeInForceInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_MISSING" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_GTD_TIMESTAMP_IN_PAST" => {
                Ok(Self::TrailingStopLossOnFillGtdTimestampInPast)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_ID_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderIdInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_TAG_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderTagInvalid)
            }
            "TRAILING_STOP_LOSS_ON_FILL_CLIENT_ORDER_COMMENT_INVALID" => {
                Ok(Self::TrailingStopLossOnFillClientOrderCommentInvalid)
            }
            "TRAILING_STOP_LOSS_ORDERS_NOT_SUPPORTED" => {
                Ok(Self::TrailingStopLossOrdersNotSupported)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_MISSING" => {
                Ok(Self::TrailingStopLossOnFillTriggerConditionMissing)
            }
            "TRAILING_STOP_LOSS_ON_FILL_TRIGGER_CONDITION_INVALID" => {
                Ok(Self::TrailingStopLossOnFillTriggerConditionInvalid)
            }
            "CLOSE_TRADE_TYPE_MISSING" => Ok(Self::CloseTradeTypeMissing),
            "CLOSE_TRADE_PARTIAL_UNITS_MISSING" => Ok(Self::CloseTradePartialUnitsMissing),
            "CLOSE_TRADE_UNITS_EXCEED_TRADE_SIZE" => Ok(Self::CloseTradeUnitsExceedTradeSize),
            "CLOSEOUT_POSITION_DOESNT_EXIST" => Ok(Self::CloseoutPositionDoesntExist),
            "CLOSEOUT_POSITION_INCOMPLETE_SPECIFICATION" => {
                Ok(Self::CloseoutPositionIncompleteSpecification)
            }
            "CLOSEOUT_POSITION_UNITS_EXCEED_POSITION_SIZE" => {
                Ok(Self::CloseoutPositionUnitsExceedPositionSize)
            }
            "CLOSEOUT_POSITION_REJECT" => Ok(Self::CloseoutPositionReject),
            "CLOSEOUT_POSITION_PARTIAL_UNITS_MISSING" => {
                Ok(Self::CloseoutPositionPartialUnitsMissing)
            }
            "MARKUP_GROUP_ID_INVALID" => Ok(Self::MarkupGroupIdInvalid),
            "POSITION_AGGREGATION_MODE_INVALID" => Ok(Self::PositionAggregationModeInvalid),
            "ADMIN_CONFIGURE_DATA_MISSING" => Ok(Self::AdminConfigureDataMissing),
            "MARGIN_RATE_INVALID" => Ok(Self::MarginRateInvalid),
            "MARGIN_RATE_WOULD_TRIGGER_CLOSEOUT" => Ok(Self::MarginRateWouldTriggerCloseout),
            "ALIAS_INVALID" => Ok(Self::AliasInvalid),
            "CLIENT_CONFIGURE_DATA_MISSING" => Ok(Self::ClientConfigureDataMissing),
            "MARGIN_RATE_WOULD_TRIGGER_MARGIN_CALL" => Ok(Self::MarginRateWouldTriggerMarginCall),
            "AMOUNT_INVALID" => Ok(Self::AmountInvalid),
            "INSUFFICIENT_FUNDS" => Ok(Self::InsufficientFunds),
            "AMOUNT_MISSING" => Ok(Self::AmountMissing),
            "FUNDING_REASON_MISSING" => Ok(Self::FundingReasonMissing),
            "CLIENT_EXTENSIONS_DATA_MISSING" => Ok(Self::ClientExtensionsDataMissing),
            "REPLACING_ORDER_INVALID" => Ok(Self::ReplacingOrderInvalid),
            "REPLACING_TRADE_ID_INVALID" => Ok(Self::ReplacingTradeIdInvalid),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TransferFundsRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TransferFundsRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TransferFundsRejectTransactionRejectReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Type of the Transaction. Always set to "TRANSFER_FUNDS_REJECT" in a
/// TransferFundsRejectTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"TRANSFER_FUNDS_REJECT\" in a TransferFundsRejectTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TransferFundsRejectTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&TransferFundsRejectTransactionType> for TransferFundsRejectTransactionType {
    fn from(value: &TransferFundsRejectTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for TransferFundsRejectTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for TransferFundsRejectTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TransferFundsRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TransferFundsRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TransferFundsRejectTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///A TransferFundsTransaction represents the transfer of funds in/out of an
/// Account.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A TransferFundsTransaction represents the transfer of
/// funds in/out of an Account.",
///  "type": "object",
///  "properties": {
///    "accountBalance": {
///      "description": "The Account's balance after funds are
/// transferred.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "accountID": {
///      "description": "The ID of the Account the Transaction was created
/// for.",
///      "type": "string",
///      "format": "\"-\"-delimited string with format
/// \"{siteID}-{divisionID}-{userID}-{accountNumber}\""
///    },
///    "amount": {
///      "description": "The amount to deposit/withdraw from the Account in
/// the Account's home currency. A positive value indicates a deposit, a
/// negative value indicates a withdrawal.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on the Account's home currency."
///    },
///    "batchID": {
///      "description": "The ID of the \"batch\" that the Transaction
/// belongs to. Transactions in the same batch are applied to the Account
/// simultaneously.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "comment": {
///      "description": "An optional comment that may be attached to a fund
/// transfer for audit purposes",
///      "type": "string"
///    },
///    "fundingReason": {
///      "description": "The reason that an Account is being funded.",
///      "type": "string",
///      "enum": [
///        "CLIENT_FUNDING",
///        "ACCOUNT_TRANSFER",
///        "DIVISION_MIGRATION",
///        "SITE_MIGRATION",
///        "ADJUSTMENT"
///      ]
///    },
///    "id": {
///      "description": "The Transaction's Identifier.",
///      "type": "string",
///      "format": "String representation of the numerical OANDA-assigned
/// TransactionID"
///    },
///    "requestID": {
///      "description": "The Request ID of the request which generated the
/// transaction.",
///      "type": "string"
///    },
///    "time": {
///      "description": "The date/time when the Transaction was created.",
///      "type": "string",
///      "format": "The RFC 3339 representation is a string conforming to https://tools.ietf.org/rfc/rfc3339.txt. The Unix representation is a string representing the number of seconds since the Unix Epoch (January 1st, 1970 at UTC). The value is a fractional number, where the fractional part represents a fraction of a second (up to nine decimal places)."
///    },
///    "type": {
///      "description": "The Type of the Transaction. Always set to
/// \"TRANSFER_FUNDS\" in a TransferFundsTransaction.",
///      "type": "string",
///      "enum": [
///        "CREATE",
///        "CLOSE",
///        "REOPEN",
///        "CLIENT_CONFIGURE",
///        "CLIENT_CONFIGURE_REJECT",
///        "TRANSFER_FUNDS",
///        "TRANSFER_FUNDS_REJECT",
///        "MARKET_ORDER",
///        "MARKET_ORDER_REJECT",
///        "FIXED_PRICE_ORDER",
///        "LIMIT_ORDER",
///        "LIMIT_ORDER_REJECT",
///        "STOP_ORDER",
///        "STOP_ORDER_REJECT",
///        "MARKET_IF_TOUCHED_ORDER",
///        "MARKET_IF_TOUCHED_ORDER_REJECT",
///        "TAKE_PROFIT_ORDER",
///        "TAKE_PROFIT_ORDER_REJECT",
///        "STOP_LOSS_ORDER",
///        "STOP_LOSS_ORDER_REJECT",
///        "TRAILING_STOP_LOSS_ORDER",
///        "TRAILING_STOP_LOSS_ORDER_REJECT",
///        "ORDER_FILL",
///        "ORDER_CANCEL",
///        "ORDER_CANCEL_REJECT",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY",
///        "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY",
///        "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///        "MARGIN_CALL_ENTER",
///        "MARGIN_CALL_EXTEND",
///        "MARGIN_CALL_EXIT",
///        "DELAYED_TRADE_CLOSURE",
///        "DAILY_FINANCING",
///        "RESET_RESETTABLE_PL"
///      ]
///    },
///    "userID": {
///      "description": "The ID of the user that initiated the creation of
/// the Transaction.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TransferFundsTransaction {
    ///The Account's balance after funds are transferred.
    #[serde(
        rename = "accountBalance",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub account_balance: Option<String>,
    ///The ID of the Account the Transaction was created for.
    #[serde(rename = "accountID", default, skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    ///The amount to deposit/withdraw from the Account in the Account's
    /// home currency. A positive value indicates a deposit, a negative
    /// value indicates a withdrawal.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub amount: Option<String>,
    ///The ID of the "batch" that the Transaction belongs to. Transactions
    /// in the same batch are applied to the Account simultaneously.
    #[serde(rename = "batchID", default, skip_serializing_if = "Option::is_none")]
    pub batch_id: Option<String>,
    ///An optional comment that may be attached to a fund transfer for
    /// audit purposes
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    ///The reason that an Account is being funded.
    #[serde(
        rename = "fundingReason",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub funding_reason: Option<TransferFundsTransactionFundingReason>,
    ///The Transaction's Identifier.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    ///The Request ID of the request which generated the transaction.
    #[serde(rename = "requestID", default, skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    ///The date/time when the Transaction was created.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub time: Option<String>,
    ///The Type of the Transaction. Always set to "TRANSFER_FUNDS" in a
    /// TransferFundsTransaction.
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<TransferFundsTransactionType>,
    ///The ID of the user that initiated the creation of the Transaction.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&TransferFundsTransaction> for TransferFundsTransaction {
    fn from(value: &TransferFundsTransaction) -> Self {
        value.clone()
    }
}

impl TransferFundsTransaction {
    pub fn builder() -> builder::TransferFundsTransaction {
        Default::default()
    }
}

///The reason that an Account is being funded.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The reason that an Account is being funded.",
///  "type": "string",
///  "enum": [
///    "CLIENT_FUNDING",
///    "ACCOUNT_TRANSFER",
///    "DIVISION_MIGRATION",
///    "SITE_MIGRATION",
///    "ADJUSTMENT"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TransferFundsTransactionFundingReason {
    #[serde(rename = "CLIENT_FUNDING")]
    ClientFunding,
    #[serde(rename = "ACCOUNT_TRANSFER")]
    AccountTransfer,
    #[serde(rename = "DIVISION_MIGRATION")]
    DivisionMigration,
    #[serde(rename = "SITE_MIGRATION")]
    SiteMigration,
    #[serde(rename = "ADJUSTMENT")]
    Adjustment,
}

impl From<&TransferFundsTransactionFundingReason> for TransferFundsTransactionFundingReason {
    fn from(value: &TransferFundsTransactionFundingReason) -> Self {
        value.clone()
    }
}

impl ToString for TransferFundsTransactionFundingReason {
    fn to_string(&self) -> String {
        match *self {
            Self::ClientFunding => "CLIENT_FUNDING".to_string(),
            Self::AccountTransfer => "ACCOUNT_TRANSFER".to_string(),
            Self::DivisionMigration => "DIVISION_MIGRATION".to_string(),
            Self::SiteMigration => "SITE_MIGRATION".to_string(),
            Self::Adjustment => "ADJUSTMENT".to_string(),
        }
    }
}

impl std::str::FromStr for TransferFundsTransactionFundingReason {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CLIENT_FUNDING" => Ok(Self::ClientFunding),
            "ACCOUNT_TRANSFER" => Ok(Self::AccountTransfer),
            "DIVISION_MIGRATION" => Ok(Self::DivisionMigration),
            "SITE_MIGRATION" => Ok(Self::SiteMigration),
            "ADJUSTMENT" => Ok(Self::Adjustment),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TransferFundsTransactionFundingReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TransferFundsTransactionFundingReason {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TransferFundsTransactionFundingReason {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///The Type of the Transaction. Always set to "TRANSFER_FUNDS" in a
/// TransferFundsTransaction.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The Type of the Transaction. Always set to
/// \"TRANSFER_FUNDS\" in a TransferFundsTransaction.",
///  "type": "string",
///  "enum": [
///    "CREATE",
///    "CLOSE",
///    "REOPEN",
///    "CLIENT_CONFIGURE",
///    "CLIENT_CONFIGURE_REJECT",
///    "TRANSFER_FUNDS",
///    "TRANSFER_FUNDS_REJECT",
///    "MARKET_ORDER",
///    "MARKET_ORDER_REJECT",
///    "FIXED_PRICE_ORDER",
///    "LIMIT_ORDER",
///    "LIMIT_ORDER_REJECT",
///    "STOP_ORDER",
///    "STOP_ORDER_REJECT",
///    "MARKET_IF_TOUCHED_ORDER",
///    "MARKET_IF_TOUCHED_ORDER_REJECT",
///    "TAKE_PROFIT_ORDER",
///    "TAKE_PROFIT_ORDER_REJECT",
///    "STOP_LOSS_ORDER",
///    "STOP_LOSS_ORDER_REJECT",
///    "TRAILING_STOP_LOSS_ORDER",
///    "TRAILING_STOP_LOSS_ORDER_REJECT",
///    "ORDER_FILL",
///    "ORDER_CANCEL",
///    "ORDER_CANCEL_REJECT",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY",
///    "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY",
///    "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT",
///    "MARGIN_CALL_ENTER",
///    "MARGIN_CALL_EXTEND",
///    "MARGIN_CALL_EXIT",
///    "DELAYED_TRADE_CLOSURE",
///    "DAILY_FINANCING",
///    "RESET_RESETTABLE_PL"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TransferFundsTransactionType {
    #[serde(rename = "CREATE")]
    Create,
    #[serde(rename = "CLOSE")]
    Close,
    #[serde(rename = "REOPEN")]
    Reopen,
    #[serde(rename = "CLIENT_CONFIGURE")]
    ClientConfigure,
    #[serde(rename = "CLIENT_CONFIGURE_REJECT")]
    ClientConfigureReject,
    #[serde(rename = "TRANSFER_FUNDS")]
    TransferFunds,
    #[serde(rename = "TRANSFER_FUNDS_REJECT")]
    TransferFundsReject,
    #[serde(rename = "MARKET_ORDER")]
    MarketOrder,
    #[serde(rename = "MARKET_ORDER_REJECT")]
    MarketOrderReject,
    #[serde(rename = "FIXED_PRICE_ORDER")]
    FixedPriceOrder,
    #[serde(rename = "LIMIT_ORDER")]
    LimitOrder,
    #[serde(rename = "LIMIT_ORDER_REJECT")]
    LimitOrderReject,
    #[serde(rename = "STOP_ORDER")]
    StopOrder,
    #[serde(rename = "STOP_ORDER_REJECT")]
    StopOrderReject,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER")]
    MarketIfTouchedOrder,
    #[serde(rename = "MARKET_IF_TOUCHED_ORDER_REJECT")]
    MarketIfTouchedOrderReject,
    #[serde(rename = "TAKE_PROFIT_ORDER")]
    TakeProfitOrder,
    #[serde(rename = "TAKE_PROFIT_ORDER_REJECT")]
    TakeProfitOrderReject,
    #[serde(rename = "STOP_LOSS_ORDER")]
    StopLossOrder,
    #[serde(rename = "STOP_LOSS_ORDER_REJECT")]
    StopLossOrderReject,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER")]
    TrailingStopLossOrder,
    #[serde(rename = "TRAILING_STOP_LOSS_ORDER_REJECT")]
    TrailingStopLossOrderReject,
    #[serde(rename = "ORDER_FILL")]
    OrderFill,
    #[serde(rename = "ORDER_CANCEL")]
    OrderCancel,
    #[serde(rename = "ORDER_CANCEL_REJECT")]
    OrderCancelReject,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY")]
    OrderClientExtensionsModify,
    #[serde(rename = "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    OrderClientExtensionsModifyReject,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY")]
    TradeClientExtensionsModify,
    #[serde(rename = "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT")]
    TradeClientExtensionsModifyReject,
    #[serde(rename = "MARGIN_CALL_ENTER")]
    MarginCallEnter,
    #[serde(rename = "MARGIN_CALL_EXTEND")]
    MarginCallExtend,
    #[serde(rename = "MARGIN_CALL_EXIT")]
    MarginCallExit,
    #[serde(rename = "DELAYED_TRADE_CLOSURE")]
    DelayedTradeClosure,
    #[serde(rename = "DAILY_FINANCING")]
    DailyFinancing,
    #[serde(rename = "RESET_RESETTABLE_PL")]
    ResetResettablePl,
}

impl From<&TransferFundsTransactionType> for TransferFundsTransactionType {
    fn from(value: &TransferFundsTransactionType) -> Self {
        value.clone()
    }
}

impl ToString for TransferFundsTransactionType {
    fn to_string(&self) -> String {
        match *self {
            Self::Create => "CREATE".to_string(),
            Self::Close => "CLOSE".to_string(),
            Self::Reopen => "REOPEN".to_string(),
            Self::ClientConfigure => "CLIENT_CONFIGURE".to_string(),
            Self::ClientConfigureReject => "CLIENT_CONFIGURE_REJECT".to_string(),
            Self::TransferFunds => "TRANSFER_FUNDS".to_string(),
            Self::TransferFundsReject => "TRANSFER_FUNDS_REJECT".to_string(),
            Self::MarketOrder => "MARKET_ORDER".to_string(),
            Self::MarketOrderReject => "MARKET_ORDER_REJECT".to_string(),
            Self::FixedPriceOrder => "FIXED_PRICE_ORDER".to_string(),
            Self::LimitOrder => "LIMIT_ORDER".to_string(),
            Self::LimitOrderReject => "LIMIT_ORDER_REJECT".to_string(),
            Self::StopOrder => "STOP_ORDER".to_string(),
            Self::StopOrderReject => "STOP_ORDER_REJECT".to_string(),
            Self::MarketIfTouchedOrder => "MARKET_IF_TOUCHED_ORDER".to_string(),
            Self::MarketIfTouchedOrderReject => "MARKET_IF_TOUCHED_ORDER_REJECT".to_string(),
            Self::TakeProfitOrder => "TAKE_PROFIT_ORDER".to_string(),
            Self::TakeProfitOrderReject => "TAKE_PROFIT_ORDER_REJECT".to_string(),
            Self::StopLossOrder => "STOP_LOSS_ORDER".to_string(),
            Self::StopLossOrderReject => "STOP_LOSS_ORDER_REJECT".to_string(),
            Self::TrailingStopLossOrder => "TRAILING_STOP_LOSS_ORDER".to_string(),
            Self::TrailingStopLossOrderReject => "TRAILING_STOP_LOSS_ORDER_REJECT".to_string(),
            Self::OrderFill => "ORDER_FILL".to_string(),
            Self::OrderCancel => "ORDER_CANCEL".to_string(),
            Self::OrderCancelReject => "ORDER_CANCEL_REJECT".to_string(),
            Self::OrderClientExtensionsModify => "ORDER_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::OrderClientExtensionsModifyReject => {
                "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::TradeClientExtensionsModify => "TRADE_CLIENT_EXTENSIONS_MODIFY".to_string(),
            Self::TradeClientExtensionsModifyReject => {
                "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT".to_string()
            }
            Self::MarginCallEnter => "MARGIN_CALL_ENTER".to_string(),
            Self::MarginCallExtend => "MARGIN_CALL_EXTEND".to_string(),
            Self::MarginCallExit => "MARGIN_CALL_EXIT".to_string(),
            Self::DelayedTradeClosure => "DELAYED_TRADE_CLOSURE".to_string(),
            Self::DailyFinancing => "DAILY_FINANCING".to_string(),
            Self::ResetResettablePl => "RESET_RESETTABLE_PL".to_string(),
        }
    }
}

impl std::str::FromStr for TransferFundsTransactionType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "CREATE" => Ok(Self::Create),
            "CLOSE" => Ok(Self::Close),
            "REOPEN" => Ok(Self::Reopen),
            "CLIENT_CONFIGURE" => Ok(Self::ClientConfigure),
            "CLIENT_CONFIGURE_REJECT" => Ok(Self::ClientConfigureReject),
            "TRANSFER_FUNDS" => Ok(Self::TransferFunds),
            "TRANSFER_FUNDS_REJECT" => Ok(Self::TransferFundsReject),
            "MARKET_ORDER" => Ok(Self::MarketOrder),
            "MARKET_ORDER_REJECT" => Ok(Self::MarketOrderReject),
            "FIXED_PRICE_ORDER" => Ok(Self::FixedPriceOrder),
            "LIMIT_ORDER" => Ok(Self::LimitOrder),
            "LIMIT_ORDER_REJECT" => Ok(Self::LimitOrderReject),
            "STOP_ORDER" => Ok(Self::StopOrder),
            "STOP_ORDER_REJECT" => Ok(Self::StopOrderReject),
            "MARKET_IF_TOUCHED_ORDER" => Ok(Self::MarketIfTouchedOrder),
            "MARKET_IF_TOUCHED_ORDER_REJECT" => Ok(Self::MarketIfTouchedOrderReject),
            "TAKE_PROFIT_ORDER" => Ok(Self::TakeProfitOrder),
            "TAKE_PROFIT_ORDER_REJECT" => Ok(Self::TakeProfitOrderReject),
            "STOP_LOSS_ORDER" => Ok(Self::StopLossOrder),
            "STOP_LOSS_ORDER_REJECT" => Ok(Self::StopLossOrderReject),
            "TRAILING_STOP_LOSS_ORDER" => Ok(Self::TrailingStopLossOrder),
            "TRAILING_STOP_LOSS_ORDER_REJECT" => Ok(Self::TrailingStopLossOrderReject),
            "ORDER_FILL" => Ok(Self::OrderFill),
            "ORDER_CANCEL" => Ok(Self::OrderCancel),
            "ORDER_CANCEL_REJECT" => Ok(Self::OrderCancelReject),
            "ORDER_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::OrderClientExtensionsModify),
            "ORDER_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::OrderClientExtensionsModifyReject),
            "TRADE_CLIENT_EXTENSIONS_MODIFY" => Ok(Self::TradeClientExtensionsModify),
            "TRADE_CLIENT_EXTENSIONS_MODIFY_REJECT" => Ok(Self::TradeClientExtensionsModifyReject),
            "MARGIN_CALL_ENTER" => Ok(Self::MarginCallEnter),
            "MARGIN_CALL_EXTEND" => Ok(Self::MarginCallExtend),
            "MARGIN_CALL_EXIT" => Ok(Self::MarginCallExit),
            "DELAYED_TRADE_CLOSURE" => Ok(Self::DelayedTradeClosure),
            "DAILY_FINANCING" => Ok(Self::DailyFinancing),
            "RESET_RESETTABLE_PL" => Ok(Self::ResetResettablePl),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for TransferFundsTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for TransferFundsTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for TransferFundsTransactionType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

///Representation of how many units of an Instrument are available to be
/// traded by an Order depending on its postionFill option.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Representation of how many units of an Instrument are
/// available to be traded by an Order depending on its postionFill
/// option.",
///  "type": "object",
///  "properties": {
///    "default": {
///      "$ref": "#/components/schemas/UnitsAvailableDetails"
///    },
///    "openOnly": {
///      "$ref": "#/components/schemas/UnitsAvailableDetails"
///    },
///    "reduceFirst": {
///      "$ref": "#/components/schemas/UnitsAvailableDetails"
///    },
///    "reduceOnly": {
///      "$ref": "#/components/schemas/UnitsAvailableDetails"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct UnitsAvailable {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default: Option<UnitsAvailableDetails>,
    #[serde(rename = "openOnly", default, skip_serializing_if = "Option::is_none")]
    pub open_only: Option<UnitsAvailableDetails>,
    #[serde(
        rename = "reduceFirst",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub reduce_first: Option<UnitsAvailableDetails>,
    #[serde(
        rename = "reduceOnly",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub reduce_only: Option<UnitsAvailableDetails>,
}

impl From<&UnitsAvailable> for UnitsAvailable {
    fn from(value: &UnitsAvailable) -> Self {
        value.clone()
    }
}

impl UnitsAvailable {
    pub fn builder() -> builder::UnitsAvailable {
        Default::default()
    }
}

///Representation of many units of an Instrument are available to be traded
/// for both long and short Orders.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "Representation of many units of an Instrument are
/// available to be traded for both long and short Orders.",
///  "type": "object",
///  "properties": {
///    "long": {
///      "description": "The units available for long Orders.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    },
///    "short": {
///      "description": "The units available for short Orders.",
///      "type": "string",
///      "format": "A decimal number encoded as a string. The amount of
/// precision provided depends on what the number represents."
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct UnitsAvailableDetails {
    ///The units available for long Orders.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub long: Option<String>,
    ///The units available for short Orders.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub short: Option<String>,
}

impl From<&UnitsAvailableDetails> for UnitsAvailableDetails {
    fn from(value: &UnitsAvailableDetails) -> Self {
        value.clone()
    }
}

impl UnitsAvailableDetails {
    pub fn builder() -> builder::UnitsAvailableDetails {
        Default::default()
    }
}

///A representation of user information, as provided to the user themself.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A representation of user information, as provided to
/// the user themself.",
///  "type": "object",
///  "properties": {
///    "country": {
///      "description": "The country that the user is based in.",
///      "type": "string"
///    },
///    "emailAddress": {
///      "description": "The user's email address.",
///      "type": "string"
///    },
///    "userID": {
///      "description": "The user's OANDA-assigned user ID.",
///      "type": "integer"
///    },
///    "username": {
///      "description": "The user-provided username.",
///      "type": "string"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct UserInfo {
    ///The country that the user is based in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub country: Option<String>,
    ///The user's email address.
    #[serde(
        rename = "emailAddress",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub email_address: Option<String>,
    ///The user's OANDA-assigned user ID.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
    ///The user-provided username.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

impl From<&UserInfo> for UserInfo {
    fn from(value: &UserInfo) -> Self {
        value.clone()
    }
}

impl UserInfo {
    pub fn builder() -> builder::UserInfo {
        Default::default()
    }
}

///A representation of user information, as available to external (3rd
/// party) clients.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "A representation of user information, as available to
/// external (3rd party) clients.",
///  "type": "object",
///  "properties": {
///    "FIFO": {
///      "description": "Flag indicating if the the user's Accounts adhere
/// to FIFO execution rules.",
///      "type": "boolean"
///    },
///    "country": {
///      "description": "The country that the user is based in.",
///      "type": "string"
///    },
///    "userID": {
///      "description": "The user's OANDA-assigned user ID.",
///      "type": "integer"
///    }
///  }
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct UserInfoExternal {
    ///The country that the user is based in.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub country: Option<String>,
    ///Flag indicating if the the user's Accounts adhere to FIFO execution
    /// rules.
    #[serde(rename = "FIFO", default, skip_serializing_if = "Option::is_none")]
    pub fifo: Option<bool>,
    ///The user's OANDA-assigned user ID.
    #[serde(rename = "userID", default, skip_serializing_if = "Option::is_none")]
    pub user_id: Option<i64>,
}

impl From<&UserInfoExternal> for UserInfoExternal {
    fn from(value: &UserInfoExternal) -> Self {
        value.clone()
    }
}

impl UserInfoExternal {
    pub fn builder() -> builder::UserInfoExternal {
        Default::default()
    }
}

///The specifier that refers to a User
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The specifier that refers to a User",
///  "type": "string",
///  "format": "A user specifier may have one of 3 formats: the OANDA-assigned User ID (numerical), the client-provided username prefixed by the \"@\" symbol (e.g. \"@myusername\"), or the \"@\" symbol. The \"@\" symbol on its own acts as an alias for the username of the user accessing the endpoint (as inferred from the token provided)."
///}
/// ```
/// </details>
#[derive(Clone, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct UserSpecifier(pub String);
impl std::ops::Deref for UserSpecifier {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl From<UserSpecifier> for String {
    fn from(value: UserSpecifier) -> Self {
        value.0
    }
}

impl From<&UserSpecifier> for UserSpecifier {
    fn from(value: &UserSpecifier) -> Self {
        value.clone()
    }
}

impl From<String> for UserSpecifier {
    fn from(value: String) -> Self {
        Self(value)
    }
}

impl std::str::FromStr for UserSpecifier {
    type Err = std::convert::Infallible;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}

impl ToString for UserSpecifier {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

///The day of the week to use for candlestick granularities with weekly
/// alignment.
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "description": "The day of the week to use for candlestick
/// granularities with weekly alignment.",
///  "type": "string",
///  "enum": [
///    "Monday",
///    "Tuesday",
///    "Wednesday",
///    "Thursday",
///    "Friday",
///    "Saturday",
///    "Sunday"
///  ]
///}
/// ```
/// </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WeeklyAlignment {
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday,
    Sunday,
}

impl From<&WeeklyAlignment> for WeeklyAlignment {
    fn from(value: &WeeklyAlignment) -> Self {
        value.clone()
    }
}

impl ToString for WeeklyAlignment {
    fn to_string(&self) -> String {
        match *self {
            Self::Monday => "Monday".to_string(),
            Self::Tuesday => "Tuesday".to_string(),
            Self::Wednesday => "Wednesday".to_string(),
            Self::Thursday => "Thursday".to_string(),
            Self::Friday => "Friday".to_string(),
            Self::Saturday => "Saturday".to_string(),
            Self::Sunday => "Sunday".to_string(),
        }
    }
}

impl std::str::FromStr for WeeklyAlignment {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "Monday" => Ok(Self::Monday),
            "Tuesday" => Ok(Self::Tuesday),
            "Wednesday" => Ok(Self::Wednesday),
            "Thursday" => Ok(Self::Thursday),
            "Friday" => Ok(Self::Friday),
            "Saturday" => Ok(Self::Saturday),
            "Sunday" => Ok(Self::Sunday),
            _ => Err("invalid value".into()),
        }
    }
}

impl std::convert::TryFrom<&str> for WeeklyAlignment {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<&String> for WeeklyAlignment {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

impl std::convert::TryFrom<String> for WeeklyAlignment {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}

/// Types for composing complex structures.
pub mod builder {
    #[derive(Clone, Debug)]
    pub struct Account {
        alias: Result<Option<String>, String>,
        balance: Result<Option<String>, String>,
        commission: Result<Option<String>, String>,
        created_by_user_id: Result<Option<i64>, String>,
        created_time: Result<Option<String>, String>,
        currency: Result<Option<String>, String>,
        financing: Result<Option<String>, String>,
        guaranteed_execution_fees: Result<Option<String>, String>,
        guaranteed_stop_loss_order_mode:
            Result<Option<super::AccountGuaranteedStopLossOrderMode>, String>,
        hedging_enabled: Result<Option<bool>, String>,
        id: Result<Option<String>, String>,
        last_margin_call_extension_time: Result<Option<String>, String>,
        last_order_fill_timestamp: Result<Option<String>, String>,
        last_transaction_id: Result<Option<String>, String>,
        margin_available: Result<Option<String>, String>,
        margin_call_enter_time: Result<Option<String>, String>,
        margin_call_extension_count: Result<Option<i64>, String>,
        margin_call_margin_used: Result<Option<String>, String>,
        margin_call_percent: Result<Option<String>, String>,
        margin_closeout_margin_used: Result<Option<String>, String>,
        margin_closeout_nav: Result<Option<String>, String>,
        margin_closeout_percent: Result<Option<String>, String>,
        margin_closeout_position_value: Result<Option<String>, String>,
        margin_closeout_unrealized_pl: Result<Option<String>, String>,
        margin_rate: Result<Option<String>, String>,
        margin_used: Result<Option<String>, String>,
        nav: Result<Option<String>, String>,
        open_position_count: Result<Option<i64>, String>,
        open_trade_count: Result<Option<i64>, String>,
        orders: Result<Vec<super::Order>, String>,
        pending_order_count: Result<Option<i64>, String>,
        pl: Result<Option<String>, String>,
        position_value: Result<Option<String>, String>,
        positions: Result<Vec<super::Position>, String>,
        resettable_pl: Result<Option<String>, String>,
        resettable_pl_time: Result<Option<String>, String>,
        trades: Result<Vec<super::TradeSummary>, String>,
        unrealized_pl: Result<Option<String>, String>,
        withdrawal_limit: Result<Option<String>, String>,
    }

    impl Default for Account {
        fn default() -> Self {
            Self {
                alias: Ok(Default::default()),
                balance: Ok(Default::default()),
                commission: Ok(Default::default()),
                created_by_user_id: Ok(Default::default()),
                created_time: Ok(Default::default()),
                currency: Ok(Default::default()),
                financing: Ok(Default::default()),
                guaranteed_execution_fees: Ok(Default::default()),
                guaranteed_stop_loss_order_mode: Ok(Default::default()),
                hedging_enabled: Ok(Default::default()),
                id: Ok(Default::default()),
                last_margin_call_extension_time: Ok(Default::default()),
                last_order_fill_timestamp: Ok(Default::default()),
                last_transaction_id: Ok(Default::default()),
                margin_available: Ok(Default::default()),
                margin_call_enter_time: Ok(Default::default()),
                margin_call_extension_count: Ok(Default::default()),
                margin_call_margin_used: Ok(Default::default()),
                margin_call_percent: Ok(Default::default()),
                margin_closeout_margin_used: Ok(Default::default()),
                margin_closeout_nav: Ok(Default::default()),
                margin_closeout_percent: Ok(Default::default()),
                margin_closeout_position_value: Ok(Default::default()),
                margin_closeout_unrealized_pl: Ok(Default::default()),
                margin_rate: Ok(Default::default()),
                margin_used: Ok(Default::default()),
                nav: Ok(Default::default()),
                open_position_count: Ok(Default::default()),
                open_trade_count: Ok(Default::default()),
                orders: Ok(Default::default()),
                pending_order_count: Ok(Default::default()),
                pl: Ok(Default::default()),
                position_value: Ok(Default::default()),
                positions: Ok(Default::default()),
                resettable_pl: Ok(Default::default()),
                resettable_pl_time: Ok(Default::default()),
                trades: Ok(Default::default()),
                unrealized_pl: Ok(Default::default()),
                withdrawal_limit: Ok(Default::default()),
            }
        }
    }

    impl Account {
        pub fn alias<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.alias = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for alias: {}", e));
            self
        }
        pub fn balance<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.balance = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for balance: {}", e));
            self
        }
        pub fn commission<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.commission = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for commission: {}", e));
            self
        }
        pub fn created_by_user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.created_by_user_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for created_by_user_id: {}",
                    e
                )
            });
            self
        }
        pub fn created_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.created_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for created_time: {}", e));
            self
        }
        pub fn currency<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.currency = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for currency: {}", e));
            self
        }
        pub fn financing<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.financing = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for financing: {}", e));
            self
        }
        pub fn guaranteed_execution_fees<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.guaranteed_execution_fees = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for guaranteed_execution_fees: {}",
                    e
                )
            });
            self
        }
        pub fn guaranteed_stop_loss_order_mode<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::AccountGuaranteedStopLossOrderMode>>,
            T::Error: std::fmt::Display,
        {
            self.guaranteed_stop_loss_order_mode = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for guaranteed_stop_loss_order_mode: {}",
                    e
                )
            });
            self
        }
        pub fn hedging_enabled<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<bool>>,
            T::Error: std::fmt::Display,
        {
            self.hedging_enabled = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for hedging_enabled: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn last_margin_call_extension_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_margin_call_extension_time = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_margin_call_extension_time: {}",
                    e
                )
            });
            self
        }
        pub fn last_order_fill_timestamp<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_order_fill_timestamp = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_order_fill_timestamp: {}",
                    e
                )
            });
            self
        }
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn margin_available<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_available = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_available: {}",
                    e
                )
            });
            self
        }
        pub fn margin_call_enter_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_call_enter_time = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_call_enter_time: {}",
                    e
                )
            });
            self
        }
        pub fn margin_call_extension_count<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.margin_call_extension_count = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_call_extension_count: {}",
                    e
                )
            });
            self
        }
        pub fn margin_call_margin_used<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_call_margin_used = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_call_margin_used: {}",
                    e
                )
            });
            self
        }
        pub fn margin_call_percent<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_call_percent = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_call_percent: {}",
                    e
                )
            });
            self
        }
        pub fn margin_closeout_margin_used<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_closeout_margin_used = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_closeout_margin_used: {}",
                    e
                )
            });
            self
        }
        pub fn margin_closeout_nav<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_closeout_nav = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_closeout_nav: {}",
                    e
                )
            });
            self
        }
        pub fn margin_closeout_percent<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_closeout_percent = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_closeout_percent: {}",
                    e
                )
            });
            self
        }
        pub fn margin_closeout_position_value<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_closeout_position_value = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_closeout_position_value: {}",
                    e
                )
            });
            self
        }
        pub fn margin_closeout_unrealized_pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_closeout_unrealized_pl = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_closeout_unrealized_pl: {}",
                    e
                )
            });
            self
        }
        pub fn margin_rate<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_rate = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for margin_rate: {}", e));
            self
        }
        pub fn margin_used<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_used = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for margin_used: {}", e));
            self
        }
        pub fn nav<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.nav = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for nav: {}", e));
            self
        }
        pub fn open_position_count<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.open_position_count = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for open_position_count: {}",
                    e
                )
            });
            self
        }
        pub fn open_trade_count<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.open_trade_count = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for open_trade_count: {}",
                    e
                )
            });
            self
        }
        pub fn orders<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Order>>,
            T::Error: std::fmt::Display,
        {
            self.orders = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for orders: {}", e));
            self
        }
        pub fn pending_order_count<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.pending_order_count = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for pending_order_count: {}",
                    e
                )
            });
            self
        }
        pub fn pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.pl = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for pl: {}", e));
            self
        }
        pub fn position_value<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.position_value = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for position_value: {}", e));
            self
        }
        pub fn positions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Position>>,
            T::Error: std::fmt::Display,
        {
            self.positions = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for positions: {}", e));
            self
        }
        pub fn resettable_pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.resettable_pl = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for resettable_pl: {}", e));
            self
        }
        pub fn resettable_pl_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.resettable_pl_time = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for resettable_pl_time: {}",
                    e
                )
            });
            self
        }
        pub fn trades<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::TradeSummary>>,
            T::Error: std::fmt::Display,
        {
            self.trades = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trades: {}", e));
            self
        }
        pub fn unrealized_pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.unrealized_pl = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for unrealized_pl: {}", e));
            self
        }
        pub fn withdrawal_limit<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.withdrawal_limit = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for withdrawal_limit: {}",
                    e
                )
            });
            self
        }
    }

    impl std::convert::TryFrom<Account> for super::Account {
        type Error = super::error::ConversionError;
        fn try_from(value: Account) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                alias: value.alias?,
                balance: value.balance?,
                commission: value.commission?,
                created_by_user_id: value.created_by_user_id?,
                created_time: value.created_time?,
                currency: value.currency?,
                financing: value.financing?,
                guaranteed_execution_fees: value.guaranteed_execution_fees?,
                guaranteed_stop_loss_order_mode: value.guaranteed_stop_loss_order_mode?,
                hedging_enabled: value.hedging_enabled?,
                id: value.id?,
                last_margin_call_extension_time: value.last_margin_call_extension_time?,
                last_order_fill_timestamp: value.last_order_fill_timestamp?,
                last_transaction_id: value.last_transaction_id?,
                margin_available: value.margin_available?,
                margin_call_enter_time: value.margin_call_enter_time?,
                margin_call_extension_count: value.margin_call_extension_count?,
                margin_call_margin_used: value.margin_call_margin_used?,
                margin_call_percent: value.margin_call_percent?,
                margin_closeout_margin_used: value.margin_closeout_margin_used?,
                margin_closeout_nav: value.margin_closeout_nav?,
                margin_closeout_percent: value.margin_closeout_percent?,
                margin_closeout_position_value: value.margin_closeout_position_value?,
                margin_closeout_unrealized_pl: value.margin_closeout_unrealized_pl?,
                margin_rate: value.margin_rate?,
                margin_used: value.margin_used?,
                nav: value.nav?,
                open_position_count: value.open_position_count?,
                open_trade_count: value.open_trade_count?,
                orders: value.orders?,
                pending_order_count: value.pending_order_count?,
                pl: value.pl?,
                position_value: value.position_value?,
                positions: value.positions?,
                resettable_pl: value.resettable_pl?,
                resettable_pl_time: value.resettable_pl_time?,
                trades: value.trades?,
                unrealized_pl: value.unrealized_pl?,
                withdrawal_limit: value.withdrawal_limit?,
            })
        }
    }

    impl From<super::Account> for Account {
        fn from(value: super::Account) -> Self {
            Self {
                alias: Ok(value.alias),
                balance: Ok(value.balance),
                commission: Ok(value.commission),
                created_by_user_id: Ok(value.created_by_user_id),
                created_time: Ok(value.created_time),
                currency: Ok(value.currency),
                financing: Ok(value.financing),
                guaranteed_execution_fees: Ok(value.guaranteed_execution_fees),
                guaranteed_stop_loss_order_mode: Ok(value.guaranteed_stop_loss_order_mode),
                hedging_enabled: Ok(value.hedging_enabled),
                id: Ok(value.id),
                last_margin_call_extension_time: Ok(value.last_margin_call_extension_time),
                last_order_fill_timestamp: Ok(value.last_order_fill_timestamp),
                last_transaction_id: Ok(value.last_transaction_id),
                margin_available: Ok(value.margin_available),
                margin_call_enter_time: Ok(value.margin_call_enter_time),
                margin_call_extension_count: Ok(value.margin_call_extension_count),
                margin_call_margin_used: Ok(value.margin_call_margin_used),
                margin_call_percent: Ok(value.margin_call_percent),
                margin_closeout_margin_used: Ok(value.margin_closeout_margin_used),
                margin_closeout_nav: Ok(value.margin_closeout_nav),
                margin_closeout_percent: Ok(value.margin_closeout_percent),
                margin_closeout_position_value: Ok(value.margin_closeout_position_value),
                margin_closeout_unrealized_pl: Ok(value.margin_closeout_unrealized_pl),
                margin_rate: Ok(value.margin_rate),
                margin_used: Ok(value.margin_used),
                nav: Ok(value.nav),
                open_position_count: Ok(value.open_position_count),
                open_trade_count: Ok(value.open_trade_count),
                orders: Ok(value.orders),
                pending_order_count: Ok(value.pending_order_count),
                pl: Ok(value.pl),
                position_value: Ok(value.position_value),
                positions: Ok(value.positions),
                resettable_pl: Ok(value.resettable_pl),
                resettable_pl_time: Ok(value.resettable_pl_time),
                trades: Ok(value.trades),
                unrealized_pl: Ok(value.unrealized_pl),
                withdrawal_limit: Ok(value.withdrawal_limit),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct AccountChanges {
        orders_cancelled: Result<Vec<super::Order>, String>,
        orders_created: Result<Vec<super::Order>, String>,
        orders_filled: Result<Vec<super::Order>, String>,
        orders_triggered: Result<Vec<super::Order>, String>,
        positions: Result<Vec<super::Position>, String>,
        trades_closed: Result<Vec<super::TradeSummary>, String>,
        trades_opened: Result<Vec<super::TradeSummary>, String>,
        trades_reduced: Result<Vec<super::TradeSummary>, String>,
        transactions: Result<Vec<super::Transaction>, String>,
    }

    impl Default for AccountChanges {
        fn default() -> Self {
            Self {
                orders_cancelled: Ok(Default::default()),
                orders_created: Ok(Default::default()),
                orders_filled: Ok(Default::default()),
                orders_triggered: Ok(Default::default()),
                positions: Ok(Default::default()),
                trades_closed: Ok(Default::default()),
                trades_opened: Ok(Default::default()),
                trades_reduced: Ok(Default::default()),
                transactions: Ok(Default::default()),
            }
        }
    }

    impl AccountChanges {
        pub fn orders_cancelled<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Order>>,
            T::Error: std::fmt::Display,
        {
            self.orders_cancelled = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for orders_cancelled: {}",
                    e
                )
            });
            self
        }
        pub fn orders_created<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Order>>,
            T::Error: std::fmt::Display,
        {
            self.orders_created = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for orders_created: {}", e));
            self
        }
        pub fn orders_filled<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Order>>,
            T::Error: std::fmt::Display,
        {
            self.orders_filled = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for orders_filled: {}", e));
            self
        }
        pub fn orders_triggered<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Order>>,
            T::Error: std::fmt::Display,
        {
            self.orders_triggered = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for orders_triggered: {}",
                    e
                )
            });
            self
        }
        pub fn positions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Position>>,
            T::Error: std::fmt::Display,
        {
            self.positions = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for positions: {}", e));
            self
        }
        pub fn trades_closed<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::TradeSummary>>,
            T::Error: std::fmt::Display,
        {
            self.trades_closed = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trades_closed: {}", e));
            self
        }
        pub fn trades_opened<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::TradeSummary>>,
            T::Error: std::fmt::Display,
        {
            self.trades_opened = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trades_opened: {}", e));
            self
        }
        pub fn trades_reduced<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::TradeSummary>>,
            T::Error: std::fmt::Display,
        {
            self.trades_reduced = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trades_reduced: {}", e));
            self
        }
        pub fn transactions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Transaction>>,
            T::Error: std::fmt::Display,
        {
            self.transactions = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for transactions: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<AccountChanges> for super::AccountChanges {
        type Error = super::error::ConversionError;
        fn try_from(value: AccountChanges) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                orders_cancelled: value.orders_cancelled?,
                orders_created: value.orders_created?,
                orders_filled: value.orders_filled?,
                orders_triggered: value.orders_triggered?,
                positions: value.positions?,
                trades_closed: value.trades_closed?,
                trades_opened: value.trades_opened?,
                trades_reduced: value.trades_reduced?,
                transactions: value.transactions?,
            })
        }
    }

    impl From<super::AccountChanges> for AccountChanges {
        fn from(value: super::AccountChanges) -> Self {
            Self {
                orders_cancelled: Ok(value.orders_cancelled),
                orders_created: Ok(value.orders_created),
                orders_filled: Ok(value.orders_filled),
                orders_triggered: Ok(value.orders_triggered),
                positions: Ok(value.positions),
                trades_closed: Ok(value.trades_closed),
                trades_opened: Ok(value.trades_opened),
                trades_reduced: Ok(value.trades_reduced),
                transactions: Ok(value.transactions),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct AccountChangesState {
        margin_available: Result<Option<String>, String>,
        margin_call_margin_used: Result<Option<String>, String>,
        margin_call_percent: Result<Option<String>, String>,
        margin_closeout_margin_used: Result<Option<String>, String>,
        margin_closeout_nav: Result<Option<String>, String>,
        margin_closeout_percent: Result<Option<String>, String>,
        margin_closeout_position_value: Result<Option<String>, String>,
        margin_closeout_unrealized_pl: Result<Option<String>, String>,
        margin_used: Result<Option<String>, String>,
        nav: Result<Option<String>, String>,
        orders: Result<Vec<super::DynamicOrderState>, String>,
        position_value: Result<Option<String>, String>,
        positions: Result<Vec<super::CalculatedPositionState>, String>,
        trades: Result<Vec<super::CalculatedTradeState>, String>,
        unrealized_pl: Result<Option<String>, String>,
        withdrawal_limit: Result<Option<String>, String>,
    }

    impl Default for AccountChangesState {
        fn default() -> Self {
            Self {
                margin_available: Ok(Default::default()),
                margin_call_margin_used: Ok(Default::default()),
                margin_call_percent: Ok(Default::default()),
                margin_closeout_margin_used: Ok(Default::default()),
                margin_closeout_nav: Ok(Default::default()),
                margin_closeout_percent: Ok(Default::default()),
                margin_closeout_position_value: Ok(Default::default()),
                margin_closeout_unrealized_pl: Ok(Default::default()),
                margin_used: Ok(Default::default()),
                nav: Ok(Default::default()),
                orders: Ok(Default::default()),
                position_value: Ok(Default::default()),
                positions: Ok(Default::default()),
                trades: Ok(Default::default()),
                unrealized_pl: Ok(Default::default()),
                withdrawal_limit: Ok(Default::default()),
            }
        }
    }

    impl AccountChangesState {
        pub fn margin_available<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_available = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_available: {}",
                    e
                )
            });
            self
        }
        pub fn margin_call_margin_used<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_call_margin_used = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_call_margin_used: {}",
                    e
                )
            });
            self
        }
        pub fn margin_call_percent<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_call_percent = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_call_percent: {}",
                    e
                )
            });
            self
        }
        pub fn margin_closeout_margin_used<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_closeout_margin_used = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_closeout_margin_used: {}",
                    e
                )
            });
            self
        }
        pub fn margin_closeout_nav<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_closeout_nav = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_closeout_nav: {}",
                    e
                )
            });
            self
        }
        pub fn margin_closeout_percent<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_closeout_percent = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_closeout_percent: {}",
                    e
                )
            });
            self
        }
        pub fn margin_closeout_position_value<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_closeout_position_value = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_closeout_position_value: {}",
                    e
                )
            });
            self
        }
        pub fn margin_closeout_unrealized_pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_closeout_unrealized_pl = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_closeout_unrealized_pl: {}",
                    e
                )
            });
            self
        }
        pub fn margin_used<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_used = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for margin_used: {}", e));
            self
        }
        pub fn nav<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.nav = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for nav: {}", e));
            self
        }
        pub fn orders<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::DynamicOrderState>>,
            T::Error: std::fmt::Display,
        {
            self.orders = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for orders: {}", e));
            self
        }
        pub fn position_value<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.position_value = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for position_value: {}", e));
            self
        }
        pub fn positions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::CalculatedPositionState>>,
            T::Error: std::fmt::Display,
        {
            self.positions = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for positions: {}", e));
            self
        }
        pub fn trades<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::CalculatedTradeState>>,
            T::Error: std::fmt::Display,
        {
            self.trades = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trades: {}", e));
            self
        }
        pub fn unrealized_pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.unrealized_pl = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for unrealized_pl: {}", e));
            self
        }
        pub fn withdrawal_limit<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.withdrawal_limit = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for withdrawal_limit: {}",
                    e
                )
            });
            self
        }
    }

    impl std::convert::TryFrom<AccountChangesState> for super::AccountChangesState {
        type Error = super::error::ConversionError;
        fn try_from(value: AccountChangesState) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                margin_available: value.margin_available?,
                margin_call_margin_used: value.margin_call_margin_used?,
                margin_call_percent: value.margin_call_percent?,
                margin_closeout_margin_used: value.margin_closeout_margin_used?,
                margin_closeout_nav: value.margin_closeout_nav?,
                margin_closeout_percent: value.margin_closeout_percent?,
                margin_closeout_position_value: value.margin_closeout_position_value?,
                margin_closeout_unrealized_pl: value.margin_closeout_unrealized_pl?,
                margin_used: value.margin_used?,
                nav: value.nav?,
                orders: value.orders?,
                position_value: value.position_value?,
                positions: value.positions?,
                trades: value.trades?,
                unrealized_pl: value.unrealized_pl?,
                withdrawal_limit: value.withdrawal_limit?,
            })
        }
    }

    impl From<super::AccountChangesState> for AccountChangesState {
        fn from(value: super::AccountChangesState) -> Self {
            Self {
                margin_available: Ok(value.margin_available),
                margin_call_margin_used: Ok(value.margin_call_margin_used),
                margin_call_percent: Ok(value.margin_call_percent),
                margin_closeout_margin_used: Ok(value.margin_closeout_margin_used),
                margin_closeout_nav: Ok(value.margin_closeout_nav),
                margin_closeout_percent: Ok(value.margin_closeout_percent),
                margin_closeout_position_value: Ok(value.margin_closeout_position_value),
                margin_closeout_unrealized_pl: Ok(value.margin_closeout_unrealized_pl),
                margin_used: Ok(value.margin_used),
                nav: Ok(value.nav),
                orders: Ok(value.orders),
                position_value: Ok(value.position_value),
                positions: Ok(value.positions),
                trades: Ok(value.trades),
                unrealized_pl: Ok(value.unrealized_pl),
                withdrawal_limit: Ok(value.withdrawal_limit),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct AccountProperties {
        id: Result<Option<String>, String>,
        mt4_account_id: Result<Option<i64>, String>,
        tags: Result<Vec<String>, String>,
    }

    impl Default for AccountProperties {
        fn default() -> Self {
            Self {
                id: Ok(Default::default()),
                mt4_account_id: Ok(Default::default()),
                tags: Ok(Default::default()),
            }
        }
    }

    impl AccountProperties {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn mt4_account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.mt4_account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for mt4_account_id: {}", e));
            self
        }
        pub fn tags<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self.tags = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for tags: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<AccountProperties> for super::AccountProperties {
        type Error = super::error::ConversionError;
        fn try_from(value: AccountProperties) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                mt4_account_id: value.mt4_account_id?,
                tags: value.tags?,
            })
        }
    }

    impl From<super::AccountProperties> for AccountProperties {
        fn from(value: super::AccountProperties) -> Self {
            Self {
                id: Ok(value.id),
                mt4_account_id: Ok(value.mt4_account_id),
                tags: Ok(value.tags),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct AccountSummary {
        alias: Result<Option<String>, String>,
        balance: Result<Option<String>, String>,
        commission: Result<Option<String>, String>,
        created_by_user_id: Result<Option<i64>, String>,
        created_time: Result<Option<String>, String>,
        currency: Result<Option<String>, String>,
        financing: Result<Option<String>, String>,
        guaranteed_execution_fees: Result<Option<String>, String>,
        guaranteed_stop_loss_order_mode:
            Result<Option<super::AccountSummaryGuaranteedStopLossOrderMode>, String>,
        hedging_enabled: Result<Option<bool>, String>,
        id: Result<Option<String>, String>,
        last_margin_call_extension_time: Result<Option<String>, String>,
        last_order_fill_timestamp: Result<Option<String>, String>,
        last_transaction_id: Result<Option<String>, String>,
        margin_available: Result<Option<String>, String>,
        margin_call_enter_time: Result<Option<String>, String>,
        margin_call_extension_count: Result<Option<i64>, String>,
        margin_call_margin_used: Result<Option<String>, String>,
        margin_call_percent: Result<Option<String>, String>,
        margin_closeout_margin_used: Result<Option<String>, String>,
        margin_closeout_nav: Result<Option<String>, String>,
        margin_closeout_percent: Result<Option<String>, String>,
        margin_closeout_position_value: Result<Option<String>, String>,
        margin_closeout_unrealized_pl: Result<Option<String>, String>,
        margin_rate: Result<Option<String>, String>,
        margin_used: Result<Option<String>, String>,
        nav: Result<Option<String>, String>,
        open_position_count: Result<Option<i64>, String>,
        open_trade_count: Result<Option<i64>, String>,
        pending_order_count: Result<Option<i64>, String>,
        pl: Result<Option<String>, String>,
        position_value: Result<Option<String>, String>,
        resettable_pl: Result<Option<String>, String>,
        resettable_pl_time: Result<Option<String>, String>,
        unrealized_pl: Result<Option<String>, String>,
        withdrawal_limit: Result<Option<String>, String>,
    }

    impl Default for AccountSummary {
        fn default() -> Self {
            Self {
                alias: Ok(Default::default()),
                balance: Ok(Default::default()),
                commission: Ok(Default::default()),
                created_by_user_id: Ok(Default::default()),
                created_time: Ok(Default::default()),
                currency: Ok(Default::default()),
                financing: Ok(Default::default()),
                guaranteed_execution_fees: Ok(Default::default()),
                guaranteed_stop_loss_order_mode: Ok(Default::default()),
                hedging_enabled: Ok(Default::default()),
                id: Ok(Default::default()),
                last_margin_call_extension_time: Ok(Default::default()),
                last_order_fill_timestamp: Ok(Default::default()),
                last_transaction_id: Ok(Default::default()),
                margin_available: Ok(Default::default()),
                margin_call_enter_time: Ok(Default::default()),
                margin_call_extension_count: Ok(Default::default()),
                margin_call_margin_used: Ok(Default::default()),
                margin_call_percent: Ok(Default::default()),
                margin_closeout_margin_used: Ok(Default::default()),
                margin_closeout_nav: Ok(Default::default()),
                margin_closeout_percent: Ok(Default::default()),
                margin_closeout_position_value: Ok(Default::default()),
                margin_closeout_unrealized_pl: Ok(Default::default()),
                margin_rate: Ok(Default::default()),
                margin_used: Ok(Default::default()),
                nav: Ok(Default::default()),
                open_position_count: Ok(Default::default()),
                open_trade_count: Ok(Default::default()),
                pending_order_count: Ok(Default::default()),
                pl: Ok(Default::default()),
                position_value: Ok(Default::default()),
                resettable_pl: Ok(Default::default()),
                resettable_pl_time: Ok(Default::default()),
                unrealized_pl: Ok(Default::default()),
                withdrawal_limit: Ok(Default::default()),
            }
        }
    }

    impl AccountSummary {
        pub fn alias<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.alias = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for alias: {}", e));
            self
        }
        pub fn balance<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.balance = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for balance: {}", e));
            self
        }
        pub fn commission<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.commission = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for commission: {}", e));
            self
        }
        pub fn created_by_user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.created_by_user_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for created_by_user_id: {}",
                    e
                )
            });
            self
        }
        pub fn created_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.created_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for created_time: {}", e));
            self
        }
        pub fn currency<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.currency = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for currency: {}", e));
            self
        }
        pub fn financing<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.financing = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for financing: {}", e));
            self
        }
        pub fn guaranteed_execution_fees<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.guaranteed_execution_fees = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for guaranteed_execution_fees: {}",
                    e
                )
            });
            self
        }
        pub fn guaranteed_stop_loss_order_mode<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::AccountSummaryGuaranteedStopLossOrderMode>>,
            T::Error: std::fmt::Display,
        {
            self.guaranteed_stop_loss_order_mode = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for guaranteed_stop_loss_order_mode: {}",
                    e
                )
            });
            self
        }
        pub fn hedging_enabled<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<bool>>,
            T::Error: std::fmt::Display,
        {
            self.hedging_enabled = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for hedging_enabled: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn last_margin_call_extension_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_margin_call_extension_time = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_margin_call_extension_time: {}",
                    e
                )
            });
            self
        }
        pub fn last_order_fill_timestamp<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_order_fill_timestamp = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_order_fill_timestamp: {}",
                    e
                )
            });
            self
        }
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn margin_available<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_available = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_available: {}",
                    e
                )
            });
            self
        }
        pub fn margin_call_enter_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_call_enter_time = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_call_enter_time: {}",
                    e
                )
            });
            self
        }
        pub fn margin_call_extension_count<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.margin_call_extension_count = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_call_extension_count: {}",
                    e
                )
            });
            self
        }
        pub fn margin_call_margin_used<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_call_margin_used = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_call_margin_used: {}",
                    e
                )
            });
            self
        }
        pub fn margin_call_percent<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_call_percent = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_call_percent: {}",
                    e
                )
            });
            self
        }
        pub fn margin_closeout_margin_used<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_closeout_margin_used = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_closeout_margin_used: {}",
                    e
                )
            });
            self
        }
        pub fn margin_closeout_nav<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_closeout_nav = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_closeout_nav: {}",
                    e
                )
            });
            self
        }
        pub fn margin_closeout_percent<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_closeout_percent = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_closeout_percent: {}",
                    e
                )
            });
            self
        }
        pub fn margin_closeout_position_value<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_closeout_position_value = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_closeout_position_value: {}",
                    e
                )
            });
            self
        }
        pub fn margin_closeout_unrealized_pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_closeout_unrealized_pl = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_closeout_unrealized_pl: {}",
                    e
                )
            });
            self
        }
        pub fn margin_rate<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_rate = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for margin_rate: {}", e));
            self
        }
        pub fn margin_used<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_used = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for margin_used: {}", e));
            self
        }
        pub fn nav<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.nav = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for nav: {}", e));
            self
        }
        pub fn open_position_count<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.open_position_count = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for open_position_count: {}",
                    e
                )
            });
            self
        }
        pub fn open_trade_count<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.open_trade_count = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for open_trade_count: {}",
                    e
                )
            });
            self
        }
        pub fn pending_order_count<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.pending_order_count = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for pending_order_count: {}",
                    e
                )
            });
            self
        }
        pub fn pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.pl = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for pl: {}", e));
            self
        }
        pub fn position_value<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.position_value = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for position_value: {}", e));
            self
        }
        pub fn resettable_pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.resettable_pl = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for resettable_pl: {}", e));
            self
        }
        pub fn resettable_pl_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.resettable_pl_time = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for resettable_pl_time: {}",
                    e
                )
            });
            self
        }
        pub fn unrealized_pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.unrealized_pl = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for unrealized_pl: {}", e));
            self
        }
        pub fn withdrawal_limit<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.withdrawal_limit = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for withdrawal_limit: {}",
                    e
                )
            });
            self
        }
    }

    impl std::convert::TryFrom<AccountSummary> for super::AccountSummary {
        type Error = super::error::ConversionError;
        fn try_from(value: AccountSummary) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                alias: value.alias?,
                balance: value.balance?,
                commission: value.commission?,
                created_by_user_id: value.created_by_user_id?,
                created_time: value.created_time?,
                currency: value.currency?,
                financing: value.financing?,
                guaranteed_execution_fees: value.guaranteed_execution_fees?,
                guaranteed_stop_loss_order_mode: value.guaranteed_stop_loss_order_mode?,
                hedging_enabled: value.hedging_enabled?,
                id: value.id?,
                last_margin_call_extension_time: value.last_margin_call_extension_time?,
                last_order_fill_timestamp: value.last_order_fill_timestamp?,
                last_transaction_id: value.last_transaction_id?,
                margin_available: value.margin_available?,
                margin_call_enter_time: value.margin_call_enter_time?,
                margin_call_extension_count: value.margin_call_extension_count?,
                margin_call_margin_used: value.margin_call_margin_used?,
                margin_call_percent: value.margin_call_percent?,
                margin_closeout_margin_used: value.margin_closeout_margin_used?,
                margin_closeout_nav: value.margin_closeout_nav?,
                margin_closeout_percent: value.margin_closeout_percent?,
                margin_closeout_position_value: value.margin_closeout_position_value?,
                margin_closeout_unrealized_pl: value.margin_closeout_unrealized_pl?,
                margin_rate: value.margin_rate?,
                margin_used: value.margin_used?,
                nav: value.nav?,
                open_position_count: value.open_position_count?,
                open_trade_count: value.open_trade_count?,
                pending_order_count: value.pending_order_count?,
                pl: value.pl?,
                position_value: value.position_value?,
                resettable_pl: value.resettable_pl?,
                resettable_pl_time: value.resettable_pl_time?,
                unrealized_pl: value.unrealized_pl?,
                withdrawal_limit: value.withdrawal_limit?,
            })
        }
    }

    impl From<super::AccountSummary> for AccountSummary {
        fn from(value: super::AccountSummary) -> Self {
            Self {
                alias: Ok(value.alias),
                balance: Ok(value.balance),
                commission: Ok(value.commission),
                created_by_user_id: Ok(value.created_by_user_id),
                created_time: Ok(value.created_time),
                currency: Ok(value.currency),
                financing: Ok(value.financing),
                guaranteed_execution_fees: Ok(value.guaranteed_execution_fees),
                guaranteed_stop_loss_order_mode: Ok(value.guaranteed_stop_loss_order_mode),
                hedging_enabled: Ok(value.hedging_enabled),
                id: Ok(value.id),
                last_margin_call_extension_time: Ok(value.last_margin_call_extension_time),
                last_order_fill_timestamp: Ok(value.last_order_fill_timestamp),
                last_transaction_id: Ok(value.last_transaction_id),
                margin_available: Ok(value.margin_available),
                margin_call_enter_time: Ok(value.margin_call_enter_time),
                margin_call_extension_count: Ok(value.margin_call_extension_count),
                margin_call_margin_used: Ok(value.margin_call_margin_used),
                margin_call_percent: Ok(value.margin_call_percent),
                margin_closeout_margin_used: Ok(value.margin_closeout_margin_used),
                margin_closeout_nav: Ok(value.margin_closeout_nav),
                margin_closeout_percent: Ok(value.margin_closeout_percent),
                margin_closeout_position_value: Ok(value.margin_closeout_position_value),
                margin_closeout_unrealized_pl: Ok(value.margin_closeout_unrealized_pl),
                margin_rate: Ok(value.margin_rate),
                margin_used: Ok(value.margin_used),
                nav: Ok(value.nav),
                open_position_count: Ok(value.open_position_count),
                open_trade_count: Ok(value.open_trade_count),
                pending_order_count: Ok(value.pending_order_count),
                pl: Ok(value.pl),
                position_value: Ok(value.position_value),
                resettable_pl: Ok(value.resettable_pl),
                resettable_pl_time: Ok(value.resettable_pl_time),
                unrealized_pl: Ok(value.unrealized_pl),
                withdrawal_limit: Ok(value.withdrawal_limit),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct CalculatedAccountState {
        margin_available: Result<Option<String>, String>,
        margin_call_margin_used: Result<Option<String>, String>,
        margin_call_percent: Result<Option<String>, String>,
        margin_closeout_margin_used: Result<Option<String>, String>,
        margin_closeout_nav: Result<Option<String>, String>,
        margin_closeout_percent: Result<Option<String>, String>,
        margin_closeout_position_value: Result<Option<String>, String>,
        margin_closeout_unrealized_pl: Result<Option<String>, String>,
        margin_used: Result<Option<String>, String>,
        nav: Result<Option<String>, String>,
        position_value: Result<Option<String>, String>,
        unrealized_pl: Result<Option<String>, String>,
        withdrawal_limit: Result<Option<String>, String>,
    }

    impl Default for CalculatedAccountState {
        fn default() -> Self {
            Self {
                margin_available: Ok(Default::default()),
                margin_call_margin_used: Ok(Default::default()),
                margin_call_percent: Ok(Default::default()),
                margin_closeout_margin_used: Ok(Default::default()),
                margin_closeout_nav: Ok(Default::default()),
                margin_closeout_percent: Ok(Default::default()),
                margin_closeout_position_value: Ok(Default::default()),
                margin_closeout_unrealized_pl: Ok(Default::default()),
                margin_used: Ok(Default::default()),
                nav: Ok(Default::default()),
                position_value: Ok(Default::default()),
                unrealized_pl: Ok(Default::default()),
                withdrawal_limit: Ok(Default::default()),
            }
        }
    }

    impl CalculatedAccountState {
        pub fn margin_available<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_available = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_available: {}",
                    e
                )
            });
            self
        }
        pub fn margin_call_margin_used<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_call_margin_used = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_call_margin_used: {}",
                    e
                )
            });
            self
        }
        pub fn margin_call_percent<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_call_percent = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_call_percent: {}",
                    e
                )
            });
            self
        }
        pub fn margin_closeout_margin_used<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_closeout_margin_used = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_closeout_margin_used: {}",
                    e
                )
            });
            self
        }
        pub fn margin_closeout_nav<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_closeout_nav = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_closeout_nav: {}",
                    e
                )
            });
            self
        }
        pub fn margin_closeout_percent<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_closeout_percent = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_closeout_percent: {}",
                    e
                )
            });
            self
        }
        pub fn margin_closeout_position_value<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_closeout_position_value = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_closeout_position_value: {}",
                    e
                )
            });
            self
        }
        pub fn margin_closeout_unrealized_pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_closeout_unrealized_pl = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for margin_closeout_unrealized_pl: {}",
                    e
                )
            });
            self
        }
        pub fn margin_used<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_used = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for margin_used: {}", e));
            self
        }
        pub fn nav<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.nav = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for nav: {}", e));
            self
        }
        pub fn position_value<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.position_value = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for position_value: {}", e));
            self
        }
        pub fn unrealized_pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.unrealized_pl = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for unrealized_pl: {}", e));
            self
        }
        pub fn withdrawal_limit<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.withdrawal_limit = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for withdrawal_limit: {}",
                    e
                )
            });
            self
        }
    }

    impl std::convert::TryFrom<CalculatedAccountState> for super::CalculatedAccountState {
        type Error = super::error::ConversionError;
        fn try_from(value: CalculatedAccountState) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                margin_available: value.margin_available?,
                margin_call_margin_used: value.margin_call_margin_used?,
                margin_call_percent: value.margin_call_percent?,
                margin_closeout_margin_used: value.margin_closeout_margin_used?,
                margin_closeout_nav: value.margin_closeout_nav?,
                margin_closeout_percent: value.margin_closeout_percent?,
                margin_closeout_position_value: value.margin_closeout_position_value?,
                margin_closeout_unrealized_pl: value.margin_closeout_unrealized_pl?,
                margin_used: value.margin_used?,
                nav: value.nav?,
                position_value: value.position_value?,
                unrealized_pl: value.unrealized_pl?,
                withdrawal_limit: value.withdrawal_limit?,
            })
        }
    }

    impl From<super::CalculatedAccountState> for CalculatedAccountState {
        fn from(value: super::CalculatedAccountState) -> Self {
            Self {
                margin_available: Ok(value.margin_available),
                margin_call_margin_used: Ok(value.margin_call_margin_used),
                margin_call_percent: Ok(value.margin_call_percent),
                margin_closeout_margin_used: Ok(value.margin_closeout_margin_used),
                margin_closeout_nav: Ok(value.margin_closeout_nav),
                margin_closeout_percent: Ok(value.margin_closeout_percent),
                margin_closeout_position_value: Ok(value.margin_closeout_position_value),
                margin_closeout_unrealized_pl: Ok(value.margin_closeout_unrealized_pl),
                margin_used: Ok(value.margin_used),
                nav: Ok(value.nav),
                position_value: Ok(value.position_value),
                unrealized_pl: Ok(value.unrealized_pl),
                withdrawal_limit: Ok(value.withdrawal_limit),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct CalculatedPositionState {
        instrument: Result<Option<String>, String>,
        long_unrealized_pl: Result<Option<String>, String>,
        margin_used: Result<Option<String>, String>,
        net_unrealized_pl: Result<Option<String>, String>,
        short_unrealized_pl: Result<Option<String>, String>,
    }

    impl Default for CalculatedPositionState {
        fn default() -> Self {
            Self {
                instrument: Ok(Default::default()),
                long_unrealized_pl: Ok(Default::default()),
                margin_used: Ok(Default::default()),
                net_unrealized_pl: Ok(Default::default()),
                short_unrealized_pl: Ok(Default::default()),
            }
        }
    }

    impl CalculatedPositionState {
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn long_unrealized_pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.long_unrealized_pl = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for long_unrealized_pl: {}",
                    e
                )
            });
            self
        }
        pub fn margin_used<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_used = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for margin_used: {}", e));
            self
        }
        pub fn net_unrealized_pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.net_unrealized_pl = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for net_unrealized_pl: {}",
                    e
                )
            });
            self
        }
        pub fn short_unrealized_pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.short_unrealized_pl = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for short_unrealized_pl: {}",
                    e
                )
            });
            self
        }
    }

    impl std::convert::TryFrom<CalculatedPositionState> for super::CalculatedPositionState {
        type Error = super::error::ConversionError;
        fn try_from(value: CalculatedPositionState) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                instrument: value.instrument?,
                long_unrealized_pl: value.long_unrealized_pl?,
                margin_used: value.margin_used?,
                net_unrealized_pl: value.net_unrealized_pl?,
                short_unrealized_pl: value.short_unrealized_pl?,
            })
        }
    }

    impl From<super::CalculatedPositionState> for CalculatedPositionState {
        fn from(value: super::CalculatedPositionState) -> Self {
            Self {
                instrument: Ok(value.instrument),
                long_unrealized_pl: Ok(value.long_unrealized_pl),
                margin_used: Ok(value.margin_used),
                net_unrealized_pl: Ok(value.net_unrealized_pl),
                short_unrealized_pl: Ok(value.short_unrealized_pl),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct CalculatedTradeState {
        id: Result<Option<String>, String>,
        margin_used: Result<Option<String>, String>,
        unrealized_pl: Result<Option<String>, String>,
    }

    impl Default for CalculatedTradeState {
        fn default() -> Self {
            Self {
                id: Ok(Default::default()),
                margin_used: Ok(Default::default()),
                unrealized_pl: Ok(Default::default()),
            }
        }
    }

    impl CalculatedTradeState {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn margin_used<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_used = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for margin_used: {}", e));
            self
        }
        pub fn unrealized_pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.unrealized_pl = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for unrealized_pl: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<CalculatedTradeState> for super::CalculatedTradeState {
        type Error = super::error::ConversionError;
        fn try_from(value: CalculatedTradeState) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                margin_used: value.margin_used?,
                unrealized_pl: value.unrealized_pl?,
            })
        }
    }

    impl From<super::CalculatedTradeState> for CalculatedTradeState {
        fn from(value: super::CalculatedTradeState) -> Self {
            Self {
                id: Ok(value.id),
                margin_used: Ok(value.margin_used),
                unrealized_pl: Ok(value.unrealized_pl),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct CancelOrderResponse {
        last_transaction_id: Result<Option<String>, String>,
        order_cancel_transaction: Result<Option<super::OrderCancelTransaction>, String>,
        related_transaction_i_ds: Result<Vec<String>, String>,
    }

    impl Default for CancelOrderResponse {
        fn default() -> Self {
            Self {
                last_transaction_id: Ok(Default::default()),
                order_cancel_transaction: Ok(Default::default()),
                related_transaction_i_ds: Ok(Default::default()),
            }
        }
    }

    impl CancelOrderResponse {
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn order_cancel_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderCancelTransaction>>,
            T::Error: std::fmt::Display,
        {
            self.order_cancel_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for order_cancel_transaction: {}",
                    e
                )
            });
            self
        }
        pub fn related_transaction_i_ds<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self.related_transaction_i_ds = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for related_transaction_i_ds: {}",
                    e
                )
            });
            self
        }
    }

    impl std::convert::TryFrom<CancelOrderResponse> for super::CancelOrderResponse {
        type Error = super::error::ConversionError;
        fn try_from(value: CancelOrderResponse) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                last_transaction_id: value.last_transaction_id?,
                order_cancel_transaction: value.order_cancel_transaction?,
                related_transaction_i_ds: value.related_transaction_i_ds?,
            })
        }
    }

    impl From<super::CancelOrderResponse> for CancelOrderResponse {
        fn from(value: super::CancelOrderResponse) -> Self {
            Self {
                last_transaction_id: Ok(value.last_transaction_id),
                order_cancel_transaction: Ok(value.order_cancel_transaction),
                related_transaction_i_ds: Ok(value.related_transaction_i_ds),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct Candlestick {
        ask: Result<Option<super::CandlestickData>, String>,
        bid: Result<Option<super::CandlestickData>, String>,
        complete: Result<Option<bool>, String>,
        mid: Result<Option<super::CandlestickData>, String>,
        time: Result<Option<String>, String>,
        volume: Result<Option<i64>, String>,
    }

    impl Default for Candlestick {
        fn default() -> Self {
            Self {
                ask: Ok(Default::default()),
                bid: Ok(Default::default()),
                complete: Ok(Default::default()),
                mid: Ok(Default::default()),
                time: Ok(Default::default()),
                volume: Ok(Default::default()),
            }
        }
    }

    impl Candlestick {
        pub fn ask<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::CandlestickData>>,
            T::Error: std::fmt::Display,
        {
            self.ask = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for ask: {}", e));
            self
        }
        pub fn bid<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::CandlestickData>>,
            T::Error: std::fmt::Display,
        {
            self.bid = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for bid: {}", e));
            self
        }
        pub fn complete<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<bool>>,
            T::Error: std::fmt::Display,
        {
            self.complete = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for complete: {}", e));
            self
        }
        pub fn mid<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::CandlestickData>>,
            T::Error: std::fmt::Display,
        {
            self.mid = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for mid: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn volume<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.volume = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for volume: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<Candlestick> for super::Candlestick {
        type Error = super::error::ConversionError;
        fn try_from(value: Candlestick) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                ask: value.ask?,
                bid: value.bid?,
                complete: value.complete?,
                mid: value.mid?,
                time: value.time?,
                volume: value.volume?,
            })
        }
    }

    impl From<super::Candlestick> for Candlestick {
        fn from(value: super::Candlestick) -> Self {
            Self {
                ask: Ok(value.ask),
                bid: Ok(value.bid),
                complete: Ok(value.complete),
                mid: Ok(value.mid),
                time: Ok(value.time),
                volume: Ok(value.volume),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct CandlestickData {
        c: Result<Option<String>, String>,
        h: Result<Option<String>, String>,
        l: Result<Option<String>, String>,
        o: Result<Option<String>, String>,
    }

    impl Default for CandlestickData {
        fn default() -> Self {
            Self {
                c: Ok(Default::default()),
                h: Ok(Default::default()),
                l: Ok(Default::default()),
                o: Ok(Default::default()),
            }
        }
    }

    impl CandlestickData {
        pub fn c<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.c = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for c: {}", e));
            self
        }
        pub fn h<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.h = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for h: {}", e));
            self
        }
        pub fn l<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.l = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for l: {}", e));
            self
        }
        pub fn o<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.o = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for o: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<CandlestickData> for super::CandlestickData {
        type Error = super::error::ConversionError;
        fn try_from(value: CandlestickData) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                c: value.c?,
                h: value.h?,
                l: value.l?,
                o: value.o?,
            })
        }
    }

    impl From<super::CandlestickData> for CandlestickData {
        fn from(value: super::CandlestickData) -> Self {
            Self {
                c: Ok(value.c),
                h: Ok(value.h),
                l: Ok(value.l),
                o: Ok(value.o),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct ClientConfigureRejectTransaction {
        account_id: Result<Option<String>, String>,
        alias: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        margin_rate: Result<Option<String>, String>,
        reject_reason: Result<Option<super::ClientConfigureRejectTransactionRejectReason>, String>,
        request_id: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
        type_: Result<Option<super::ClientConfigureRejectTransactionType>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for ClientConfigureRejectTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                alias: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                id: Ok(Default::default()),
                margin_rate: Ok(Default::default()),
                reject_reason: Ok(Default::default()),
                request_id: Ok(Default::default()),
                time: Ok(Default::default()),
                type_: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl ClientConfigureRejectTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn alias<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.alias = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for alias: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn margin_rate<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_rate = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for margin_rate: {}", e));
            self
        }
        pub fn reject_reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientConfigureRejectTransactionRejectReason>>,
            T::Error: std::fmt::Display,
        {
            self.reject_reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reject_reason: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientConfigureRejectTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<ClientConfigureRejectTransaction>
        for super::ClientConfigureRejectTransaction
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ClientConfigureRejectTransaction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                alias: value.alias?,
                batch_id: value.batch_id?,
                id: value.id?,
                margin_rate: value.margin_rate?,
                reject_reason: value.reject_reason?,
                request_id: value.request_id?,
                time: value.time?,
                type_: value.type_?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::ClientConfigureRejectTransaction> for ClientConfigureRejectTransaction {
        fn from(value: super::ClientConfigureRejectTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                alias: Ok(value.alias),
                batch_id: Ok(value.batch_id),
                id: Ok(value.id),
                margin_rate: Ok(value.margin_rate),
                reject_reason: Ok(value.reject_reason),
                request_id: Ok(value.request_id),
                time: Ok(value.time),
                type_: Ok(value.type_),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct ClientConfigureTransaction {
        account_id: Result<Option<String>, String>,
        alias: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        margin_rate: Result<Option<String>, String>,
        request_id: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
        type_: Result<Option<super::ClientConfigureTransactionType>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for ClientConfigureTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                alias: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                id: Ok(Default::default()),
                margin_rate: Ok(Default::default()),
                request_id: Ok(Default::default()),
                time: Ok(Default::default()),
                type_: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl ClientConfigureTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn alias<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.alias = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for alias: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn margin_rate<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_rate = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for margin_rate: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientConfigureTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<ClientConfigureTransaction> for super::ClientConfigureTransaction {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ClientConfigureTransaction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                alias: value.alias?,
                batch_id: value.batch_id?,
                id: value.id?,
                margin_rate: value.margin_rate?,
                request_id: value.request_id?,
                time: value.time?,
                type_: value.type_?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::ClientConfigureTransaction> for ClientConfigureTransaction {
        fn from(value: super::ClientConfigureTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                alias: Ok(value.alias),
                batch_id: Ok(value.batch_id),
                id: Ok(value.id),
                margin_rate: Ok(value.margin_rate),
                request_id: Ok(value.request_id),
                time: Ok(value.time),
                type_: Ok(value.type_),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct ClientExtensions {
        comment: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        tag: Result<Option<String>, String>,
    }

    impl Default for ClientExtensions {
        fn default() -> Self {
            Self {
                comment: Ok(Default::default()),
                id: Ok(Default::default()),
                tag: Ok(Default::default()),
            }
        }
    }

    impl ClientExtensions {
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.comment = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for comment: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn tag<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.tag = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for tag: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<ClientExtensions> for super::ClientExtensions {
        type Error = super::error::ConversionError;
        fn try_from(value: ClientExtensions) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                comment: value.comment?,
                id: value.id?,
                tag: value.tag?,
            })
        }
    }

    impl From<super::ClientExtensions> for ClientExtensions {
        fn from(value: super::ClientExtensions) -> Self {
            Self {
                comment: Ok(value.comment),
                id: Ok(value.id),
                tag: Ok(value.tag),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct ClientPrice {
        asks: Result<Vec<super::PriceBucket>, String>,
        bids: Result<Vec<super::PriceBucket>, String>,
        closeout_ask: Result<Option<String>, String>,
        closeout_bid: Result<Option<String>, String>,
        instrument: Result<Option<String>, String>,
        quote_home_conversion_factors: Result<Option<super::QuoteHomeConversionFactors>, String>,
        status: Result<Option<super::ClientPriceStatus>, String>,
        time: Result<Option<String>, String>,
        tradeable: Result<Option<bool>, String>,
        type_: Result<Option<String>, String>,
        units_available: Result<Option<super::UnitsAvailable>, String>,
    }

    impl Default for ClientPrice {
        fn default() -> Self {
            Self {
                asks: Ok(Default::default()),
                bids: Ok(Default::default()),
                closeout_ask: Ok(Default::default()),
                closeout_bid: Ok(Default::default()),
                instrument: Ok(Default::default()),
                quote_home_conversion_factors: Ok(Default::default()),
                status: Ok(Default::default()),
                time: Ok(Default::default()),
                tradeable: Ok(Default::default()),
                type_: Ok(Default::default()),
                units_available: Ok(Default::default()),
            }
        }
    }

    impl ClientPrice {
        pub fn asks<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::PriceBucket>>,
            T::Error: std::fmt::Display,
        {
            self.asks = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for asks: {}", e));
            self
        }
        pub fn bids<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::PriceBucket>>,
            T::Error: std::fmt::Display,
        {
            self.bids = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for bids: {}", e));
            self
        }
        pub fn closeout_ask<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.closeout_ask = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for closeout_ask: {}", e));
            self
        }
        pub fn closeout_bid<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.closeout_bid = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for closeout_bid: {}", e));
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn quote_home_conversion_factors<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::QuoteHomeConversionFactors>>,
            T::Error: std::fmt::Display,
        {
            self.quote_home_conversion_factors = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for quote_home_conversion_factors: {}",
                    e
                )
            });
            self
        }
        pub fn status<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientPriceStatus>>,
            T::Error: std::fmt::Display,
        {
            self.status = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for status: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn tradeable<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<bool>>,
            T::Error: std::fmt::Display,
        {
            self.tradeable = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for tradeable: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn units_available<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::UnitsAvailable>>,
            T::Error: std::fmt::Display,
        {
            self.units_available = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for units_available: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<ClientPrice> for super::ClientPrice {
        type Error = super::error::ConversionError;
        fn try_from(value: ClientPrice) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                asks: value.asks?,
                bids: value.bids?,
                closeout_ask: value.closeout_ask?,
                closeout_bid: value.closeout_bid?,
                instrument: value.instrument?,
                quote_home_conversion_factors: value.quote_home_conversion_factors?,
                status: value.status?,
                time: value.time?,
                tradeable: value.tradeable?,
                type_: value.type_?,
                units_available: value.units_available?,
            })
        }
    }

    impl From<super::ClientPrice> for ClientPrice {
        fn from(value: super::ClientPrice) -> Self {
            Self {
                asks: Ok(value.asks),
                bids: Ok(value.bids),
                closeout_ask: Ok(value.closeout_ask),
                closeout_bid: Ok(value.closeout_bid),
                instrument: Ok(value.instrument),
                quote_home_conversion_factors: Ok(value.quote_home_conversion_factors),
                status: Ok(value.status),
                time: Ok(value.time),
                tradeable: Ok(value.tradeable),
                type_: Ok(value.type_),
                units_available: Ok(value.units_available),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct ClosePositionBody {
        long_client_extensions: Result<Option<super::ClientExtensions>, String>,
        long_units: Result<Option<String>, String>,
        short_client_extensions: Result<Option<super::ClientExtensions>, String>,
        short_units: Result<Option<String>, String>,
    }

    impl Default for ClosePositionBody {
        fn default() -> Self {
            Self {
                long_client_extensions: Ok(Default::default()),
                long_units: Ok(Default::default()),
                short_client_extensions: Ok(Default::default()),
                short_units: Ok(Default::default()),
            }
        }
    }

    impl ClosePositionBody {
        pub fn long_client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.long_client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for long_client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn long_units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.long_units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for long_units: {}", e));
            self
        }
        pub fn short_client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.short_client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for short_client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn short_units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.short_units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for short_units: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<ClosePositionBody> for super::ClosePositionBody {
        type Error = super::error::ConversionError;
        fn try_from(value: ClosePositionBody) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                long_client_extensions: value.long_client_extensions?,
                long_units: value.long_units?,
                short_client_extensions: value.short_client_extensions?,
                short_units: value.short_units?,
            })
        }
    }

    impl From<super::ClosePositionBody> for ClosePositionBody {
        fn from(value: super::ClosePositionBody) -> Self {
            Self {
                long_client_extensions: Ok(value.long_client_extensions),
                long_units: Ok(value.long_units),
                short_client_extensions: Ok(value.short_client_extensions),
                short_units: Ok(value.short_units),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct ClosePositionResponse {
        last_transaction_id: Result<Option<String>, String>,
        long_order_cancel_transaction: Result<Option<super::OrderCancelTransaction>, String>,
        long_order_create_transaction: Result<Option<super::MarketOrderTransaction>, String>,
        long_order_fill_transaction: Result<Option<super::OrderFillTransaction>, String>,
        related_transaction_i_ds: Result<Vec<String>, String>,
        short_order_cancel_transaction: Result<Option<super::OrderCancelTransaction>, String>,
        short_order_create_transaction: Result<Option<super::MarketOrderTransaction>, String>,
        short_order_fill_transaction: Result<Option<super::OrderFillTransaction>, String>,
    }

    impl Default for ClosePositionResponse {
        fn default() -> Self {
            Self {
                last_transaction_id: Ok(Default::default()),
                long_order_cancel_transaction: Ok(Default::default()),
                long_order_create_transaction: Ok(Default::default()),
                long_order_fill_transaction: Ok(Default::default()),
                related_transaction_i_ds: Ok(Default::default()),
                short_order_cancel_transaction: Ok(Default::default()),
                short_order_create_transaction: Ok(Default::default()),
                short_order_fill_transaction: Ok(Default::default()),
            }
        }
    }

    impl ClosePositionResponse {
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn long_order_cancel_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderCancelTransaction>>,
            T::Error: std::fmt::Display,
        {
            self.long_order_cancel_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for long_order_cancel_transaction: {}",
                    e
                )
            });
            self
        }
        pub fn long_order_create_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderTransaction>>,
            T::Error: std::fmt::Display,
        {
            self.long_order_create_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for long_order_create_transaction: {}",
                    e
                )
            });
            self
        }
        pub fn long_order_fill_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderFillTransaction>>,
            T::Error: std::fmt::Display,
        {
            self.long_order_fill_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for long_order_fill_transaction: {}",
                    e
                )
            });
            self
        }
        pub fn related_transaction_i_ds<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self.related_transaction_i_ds = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for related_transaction_i_ds: {}",
                    e
                )
            });
            self
        }
        pub fn short_order_cancel_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderCancelTransaction>>,
            T::Error: std::fmt::Display,
        {
            self.short_order_cancel_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for short_order_cancel_transaction: {}",
                    e
                )
            });
            self
        }
        pub fn short_order_create_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderTransaction>>,
            T::Error: std::fmt::Display,
        {
            self.short_order_create_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for short_order_create_transaction: {}",
                    e
                )
            });
            self
        }
        pub fn short_order_fill_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderFillTransaction>>,
            T::Error: std::fmt::Display,
        {
            self.short_order_fill_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for short_order_fill_transaction: {}",
                    e
                )
            });
            self
        }
    }

    impl std::convert::TryFrom<ClosePositionResponse> for super::ClosePositionResponse {
        type Error = super::error::ConversionError;
        fn try_from(value: ClosePositionResponse) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                last_transaction_id: value.last_transaction_id?,
                long_order_cancel_transaction: value.long_order_cancel_transaction?,
                long_order_create_transaction: value.long_order_create_transaction?,
                long_order_fill_transaction: value.long_order_fill_transaction?,
                related_transaction_i_ds: value.related_transaction_i_ds?,
                short_order_cancel_transaction: value.short_order_cancel_transaction?,
                short_order_create_transaction: value.short_order_create_transaction?,
                short_order_fill_transaction: value.short_order_fill_transaction?,
            })
        }
    }

    impl From<super::ClosePositionResponse> for ClosePositionResponse {
        fn from(value: super::ClosePositionResponse) -> Self {
            Self {
                last_transaction_id: Ok(value.last_transaction_id),
                long_order_cancel_transaction: Ok(value.long_order_cancel_transaction),
                long_order_create_transaction: Ok(value.long_order_create_transaction),
                long_order_fill_transaction: Ok(value.long_order_fill_transaction),
                related_transaction_i_ds: Ok(value.related_transaction_i_ds),
                short_order_cancel_transaction: Ok(value.short_order_cancel_transaction),
                short_order_create_transaction: Ok(value.short_order_create_transaction),
                short_order_fill_transaction: Ok(value.short_order_fill_transaction),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct CloseTradeBody {
        units: Result<Option<String>, String>,
    }

    impl Default for CloseTradeBody {
        fn default() -> Self {
            Self {
                units: Ok(Default::default()),
            }
        }
    }

    impl CloseTradeBody {
        pub fn units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for units: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<CloseTradeBody> for super::CloseTradeBody {
        type Error = super::error::ConversionError;
        fn try_from(value: CloseTradeBody) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                units: value.units?,
            })
        }
    }

    impl From<super::CloseTradeBody> for CloseTradeBody {
        fn from(value: super::CloseTradeBody) -> Self {
            Self {
                units: Ok(value.units),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct CloseTradeResponse {
        last_transaction_id: Result<Option<String>, String>,
        order_cancel_transaction: Result<Option<super::OrderCancelTransaction>, String>,
        order_create_transaction: Result<Option<super::MarketOrderTransaction>, String>,
        order_fill_transaction: Result<Option<super::OrderFillTransaction>, String>,
        related_transaction_i_ds: Result<Vec<String>, String>,
    }

    impl Default for CloseTradeResponse {
        fn default() -> Self {
            Self {
                last_transaction_id: Ok(Default::default()),
                order_cancel_transaction: Ok(Default::default()),
                order_create_transaction: Ok(Default::default()),
                order_fill_transaction: Ok(Default::default()),
                related_transaction_i_ds: Ok(Default::default()),
            }
        }
    }

    impl CloseTradeResponse {
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn order_cancel_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderCancelTransaction>>,
            T::Error: std::fmt::Display,
        {
            self.order_cancel_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for order_cancel_transaction: {}",
                    e
                )
            });
            self
        }
        pub fn order_create_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderTransaction>>,
            T::Error: std::fmt::Display,
        {
            self.order_create_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for order_create_transaction: {}",
                    e
                )
            });
            self
        }
        pub fn order_fill_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderFillTransaction>>,
            T::Error: std::fmt::Display,
        {
            self.order_fill_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for order_fill_transaction: {}",
                    e
                )
            });
            self
        }
        pub fn related_transaction_i_ds<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self.related_transaction_i_ds = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for related_transaction_i_ds: {}",
                    e
                )
            });
            self
        }
    }

    impl std::convert::TryFrom<CloseTradeResponse> for super::CloseTradeResponse {
        type Error = super::error::ConversionError;
        fn try_from(value: CloseTradeResponse) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                last_transaction_id: value.last_transaction_id?,
                order_cancel_transaction: value.order_cancel_transaction?,
                order_create_transaction: value.order_create_transaction?,
                order_fill_transaction: value.order_fill_transaction?,
                related_transaction_i_ds: value.related_transaction_i_ds?,
            })
        }
    }

    impl From<super::CloseTradeResponse> for CloseTradeResponse {
        fn from(value: super::CloseTradeResponse) -> Self {
            Self {
                last_transaction_id: Ok(value.last_transaction_id),
                order_cancel_transaction: Ok(value.order_cancel_transaction),
                order_create_transaction: Ok(value.order_create_transaction),
                order_fill_transaction: Ok(value.order_fill_transaction),
                related_transaction_i_ds: Ok(value.related_transaction_i_ds),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct CloseTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        request_id: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
        type_: Result<Option<super::CloseTransactionType>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for CloseTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                id: Ok(Default::default()),
                request_id: Ok(Default::default()),
                time: Ok(Default::default()),
                type_: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl CloseTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::CloseTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<CloseTransaction> for super::CloseTransaction {
        type Error = super::error::ConversionError;
        fn try_from(value: CloseTransaction) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                id: value.id?,
                request_id: value.request_id?,
                time: value.time?,
                type_: value.type_?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::CloseTransaction> for CloseTransaction {
        fn from(value: super::CloseTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                id: Ok(value.id),
                request_id: Ok(value.request_id),
                time: Ok(value.time),
                type_: Ok(value.type_),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct ConfigureAccountBody {
        alias: Result<Option<String>, String>,
        margin_rate: Result<Option<String>, String>,
    }

    impl Default for ConfigureAccountBody {
        fn default() -> Self {
            Self {
                alias: Ok(Default::default()),
                margin_rate: Ok(Default::default()),
            }
        }
    }

    impl ConfigureAccountBody {
        pub fn alias<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.alias = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for alias: {}", e));
            self
        }
        pub fn margin_rate<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_rate = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for margin_rate: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<ConfigureAccountBody> for super::ConfigureAccountBody {
        type Error = super::error::ConversionError;
        fn try_from(value: ConfigureAccountBody) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                alias: value.alias?,
                margin_rate: value.margin_rate?,
            })
        }
    }

    impl From<super::ConfigureAccountBody> for ConfigureAccountBody {
        fn from(value: super::ConfigureAccountBody) -> Self {
            Self {
                alias: Ok(value.alias),
                margin_rate: Ok(value.margin_rate),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct ConfigureAccountResponse {
        client_configure_transaction: Result<Option<super::ClientConfigureTransaction>, String>,
        last_transaction_id: Result<Option<String>, String>,
    }

    impl Default for ConfigureAccountResponse {
        fn default() -> Self {
            Self {
                client_configure_transaction: Ok(Default::default()),
                last_transaction_id: Ok(Default::default()),
            }
        }
    }

    impl ConfigureAccountResponse {
        pub fn client_configure_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientConfigureTransaction>>,
            T::Error: std::fmt::Display,
        {
            self.client_configure_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_configure_transaction: {}",
                    e
                )
            });
            self
        }
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
    }

    impl std::convert::TryFrom<ConfigureAccountResponse> for super::ConfigureAccountResponse {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ConfigureAccountResponse,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                client_configure_transaction: value.client_configure_transaction?,
                last_transaction_id: value.last_transaction_id?,
            })
        }
    }

    impl From<super::ConfigureAccountResponse> for ConfigureAccountResponse {
        fn from(value: super::ConfigureAccountResponse) -> Self {
            Self {
                client_configure_transaction: Ok(value.client_configure_transaction),
                last_transaction_id: Ok(value.last_transaction_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct CreateOrderBody {
        order: Result<Option<super::OrderRequest>, String>,
    }

    impl Default for CreateOrderBody {
        fn default() -> Self {
            Self {
                order: Ok(Default::default()),
            }
        }
    }

    impl CreateOrderBody {
        pub fn order<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderRequest>>,
            T::Error: std::fmt::Display,
        {
            self.order = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for order: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<CreateOrderBody> for super::CreateOrderBody {
        type Error = super::error::ConversionError;
        fn try_from(value: CreateOrderBody) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                order: value.order?,
            })
        }
    }

    impl From<super::CreateOrderBody> for CreateOrderBody {
        fn from(value: super::CreateOrderBody) -> Self {
            Self {
                order: Ok(value.order),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct CreateOrderResponse {
        last_transaction_id: Result<Option<String>, String>,
        order_cancel_transaction: Result<Option<super::OrderCancelTransaction>, String>,
        order_create_transaction: Result<Option<super::Transaction>, String>,
        order_fill_transaction: Result<Option<super::OrderFillTransaction>, String>,
        order_reissue_reject_transaction: Result<Option<super::Transaction>, String>,
        order_reissue_transaction: Result<Option<super::Transaction>, String>,
        related_transaction_i_ds: Result<Vec<String>, String>,
    }

    impl Default for CreateOrderResponse {
        fn default() -> Self {
            Self {
                last_transaction_id: Ok(Default::default()),
                order_cancel_transaction: Ok(Default::default()),
                order_create_transaction: Ok(Default::default()),
                order_fill_transaction: Ok(Default::default()),
                order_reissue_reject_transaction: Ok(Default::default()),
                order_reissue_transaction: Ok(Default::default()),
                related_transaction_i_ds: Ok(Default::default()),
            }
        }
    }

    impl CreateOrderResponse {
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn order_cancel_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderCancelTransaction>>,
            T::Error: std::fmt::Display,
        {
            self.order_cancel_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for order_cancel_transaction: {}",
                    e
                )
            });
            self
        }
        pub fn order_create_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::Transaction>>,
            T::Error: std::fmt::Display,
        {
            self.order_create_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for order_create_transaction: {}",
                    e
                )
            });
            self
        }
        pub fn order_fill_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderFillTransaction>>,
            T::Error: std::fmt::Display,
        {
            self.order_fill_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for order_fill_transaction: {}",
                    e
                )
            });
            self
        }
        pub fn order_reissue_reject_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::Transaction>>,
            T::Error: std::fmt::Display,
        {
            self.order_reissue_reject_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for order_reissue_reject_transaction: {}",
                    e
                )
            });
            self
        }
        pub fn order_reissue_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::Transaction>>,
            T::Error: std::fmt::Display,
        {
            self.order_reissue_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for order_reissue_transaction: {}",
                    e
                )
            });
            self
        }
        pub fn related_transaction_i_ds<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self.related_transaction_i_ds = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for related_transaction_i_ds: {}",
                    e
                )
            });
            self
        }
    }

    impl std::convert::TryFrom<CreateOrderResponse> for super::CreateOrderResponse {
        type Error = super::error::ConversionError;
        fn try_from(value: CreateOrderResponse) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                last_transaction_id: value.last_transaction_id?,
                order_cancel_transaction: value.order_cancel_transaction?,
                order_create_transaction: value.order_create_transaction?,
                order_fill_transaction: value.order_fill_transaction?,
                order_reissue_reject_transaction: value.order_reissue_reject_transaction?,
                order_reissue_transaction: value.order_reissue_transaction?,
                related_transaction_i_ds: value.related_transaction_i_ds?,
            })
        }
    }

    impl From<super::CreateOrderResponse> for CreateOrderResponse {
        fn from(value: super::CreateOrderResponse) -> Self {
            Self {
                last_transaction_id: Ok(value.last_transaction_id),
                order_cancel_transaction: Ok(value.order_cancel_transaction),
                order_create_transaction: Ok(value.order_create_transaction),
                order_fill_transaction: Ok(value.order_fill_transaction),
                order_reissue_reject_transaction: Ok(value.order_reissue_reject_transaction),
                order_reissue_transaction: Ok(value.order_reissue_transaction),
                related_transaction_i_ds: Ok(value.related_transaction_i_ds),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct CreateTransaction {
        account_id: Result<Option<String>, String>,
        account_number: Result<Option<i64>, String>,
        account_user_id: Result<Option<i64>, String>,
        batch_id: Result<Option<String>, String>,
        division_id: Result<Option<i64>, String>,
        home_currency: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        request_id: Result<Option<String>, String>,
        site_id: Result<Option<i64>, String>,
        time: Result<Option<String>, String>,
        type_: Result<Option<super::CreateTransactionType>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for CreateTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                account_number: Ok(Default::default()),
                account_user_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                division_id: Ok(Default::default()),
                home_currency: Ok(Default::default()),
                id: Ok(Default::default()),
                request_id: Ok(Default::default()),
                site_id: Ok(Default::default()),
                time: Ok(Default::default()),
                type_: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl CreateTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn account_number<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.account_number = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_number: {}", e));
            self
        }
        pub fn account_user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.account_user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_user_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn division_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.division_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for division_id: {}", e));
            self
        }
        pub fn home_currency<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.home_currency = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for home_currency: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn site_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.site_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for site_id: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::CreateTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<CreateTransaction> for super::CreateTransaction {
        type Error = super::error::ConversionError;
        fn try_from(value: CreateTransaction) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                account_number: value.account_number?,
                account_user_id: value.account_user_id?,
                batch_id: value.batch_id?,
                division_id: value.division_id?,
                home_currency: value.home_currency?,
                id: value.id?,
                request_id: value.request_id?,
                site_id: value.site_id?,
                time: value.time?,
                type_: value.type_?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::CreateTransaction> for CreateTransaction {
        fn from(value: super::CreateTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                account_number: Ok(value.account_number),
                account_user_id: Ok(value.account_user_id),
                batch_id: Ok(value.batch_id),
                division_id: Ok(value.division_id),
                home_currency: Ok(value.home_currency),
                id: Ok(value.id),
                request_id: Ok(value.request_id),
                site_id: Ok(value.site_id),
                time: Ok(value.time),
                type_: Ok(value.type_),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct DailyFinancingTransaction {
        account_balance: Result<Option<String>, String>,
        account_financing_mode:
            Result<Option<super::DailyFinancingTransactionAccountFinancingMode>, String>,
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        financing: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        position_financings: Result<Vec<super::PositionFinancing>, String>,
        request_id: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
        type_: Result<Option<super::DailyFinancingTransactionType>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for DailyFinancingTransaction {
        fn default() -> Self {
            Self {
                account_balance: Ok(Default::default()),
                account_financing_mode: Ok(Default::default()),
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                financing: Ok(Default::default()),
                id: Ok(Default::default()),
                position_financings: Ok(Default::default()),
                request_id: Ok(Default::default()),
                time: Ok(Default::default()),
                type_: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl DailyFinancingTransaction {
        pub fn account_balance<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_balance = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_balance: {}", e));
            self
        }
        pub fn account_financing_mode<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::DailyFinancingTransactionAccountFinancingMode>>,
            T::Error: std::fmt::Display,
        {
            self.account_financing_mode = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for account_financing_mode: {}",
                    e
                )
            });
            self
        }
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn financing<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.financing = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for financing: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn position_financings<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::PositionFinancing>>,
            T::Error: std::fmt::Display,
        {
            self.position_financings = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for position_financings: {}",
                    e
                )
            });
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::DailyFinancingTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<DailyFinancingTransaction> for super::DailyFinancingTransaction {
        type Error = super::error::ConversionError;
        fn try_from(
            value: DailyFinancingTransaction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_balance: value.account_balance?,
                account_financing_mode: value.account_financing_mode?,
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                financing: value.financing?,
                id: value.id?,
                position_financings: value.position_financings?,
                request_id: value.request_id?,
                time: value.time?,
                type_: value.type_?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::DailyFinancingTransaction> for DailyFinancingTransaction {
        fn from(value: super::DailyFinancingTransaction) -> Self {
            Self {
                account_balance: Ok(value.account_balance),
                account_financing_mode: Ok(value.account_financing_mode),
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                financing: Ok(value.financing),
                id: Ok(value.id),
                position_financings: Ok(value.position_financings),
                request_id: Ok(value.request_id),
                time: Ok(value.time),
                type_: Ok(value.type_),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct DelayedTradeClosureTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        reason: Result<Option<super::DelayedTradeClosureTransactionReason>, String>,
        request_id: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
        trade_i_ds: Result<Option<String>, String>,
        type_: Result<Option<super::DelayedTradeClosureTransactionType>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for DelayedTradeClosureTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                id: Ok(Default::default()),
                reason: Ok(Default::default()),
                request_id: Ok(Default::default()),
                time: Ok(Default::default()),
                trade_i_ds: Ok(Default::default()),
                type_: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl DelayedTradeClosureTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::DelayedTradeClosureTransactionReason>>,
            T::Error: std::fmt::Display,
        {
            self.reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reason: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn trade_i_ds<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_i_ds = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_i_ds: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::DelayedTradeClosureTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<DelayedTradeClosureTransaction>
        for super::DelayedTradeClosureTransaction
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: DelayedTradeClosureTransaction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                id: value.id?,
                reason: value.reason?,
                request_id: value.request_id?,
                time: value.time?,
                trade_i_ds: value.trade_i_ds?,
                type_: value.type_?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::DelayedTradeClosureTransaction> for DelayedTradeClosureTransaction {
        fn from(value: super::DelayedTradeClosureTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                id: Ok(value.id),
                reason: Ok(value.reason),
                request_id: Ok(value.request_id),
                time: Ok(value.time),
                trade_i_ds: Ok(value.trade_i_ds),
                type_: Ok(value.type_),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct DynamicOrderState {
        id: Result<Option<String>, String>,
        is_trigger_distance_exact: Result<Option<bool>, String>,
        trailing_stop_value: Result<Option<String>, String>,
        trigger_distance: Result<Option<String>, String>,
    }

    impl Default for DynamicOrderState {
        fn default() -> Self {
            Self {
                id: Ok(Default::default()),
                is_trigger_distance_exact: Ok(Default::default()),
                trailing_stop_value: Ok(Default::default()),
                trigger_distance: Ok(Default::default()),
            }
        }
    }

    impl DynamicOrderState {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn is_trigger_distance_exact<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<bool>>,
            T::Error: std::fmt::Display,
        {
            self.is_trigger_distance_exact = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for is_trigger_distance_exact: {}",
                    e
                )
            });
            self
        }
        pub fn trailing_stop_value<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trailing_stop_value = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trailing_stop_value: {}",
                    e
                )
            });
            self
        }
        pub fn trigger_distance<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trigger_distance = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trigger_distance: {}",
                    e
                )
            });
            self
        }
    }

    impl std::convert::TryFrom<DynamicOrderState> for super::DynamicOrderState {
        type Error = super::error::ConversionError;
        fn try_from(value: DynamicOrderState) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                is_trigger_distance_exact: value.is_trigger_distance_exact?,
                trailing_stop_value: value.trailing_stop_value?,
                trigger_distance: value.trigger_distance?,
            })
        }
    }

    impl From<super::DynamicOrderState> for DynamicOrderState {
        fn from(value: super::DynamicOrderState) -> Self {
            Self {
                id: Ok(value.id),
                is_trigger_distance_exact: Ok(value.is_trigger_distance_exact),
                trailing_stop_value: Ok(value.trailing_stop_value),
                trigger_distance: Ok(value.trigger_distance),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct FixedPriceOrder {
        cancelled_time: Result<Option<String>, String>,
        cancelling_transaction_id: Result<Option<String>, String>,
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        create_time: Result<Option<String>, String>,
        filled_time: Result<Option<String>, String>,
        filling_transaction_id: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        instrument: Result<Option<String>, String>,
        position_fill: Result<Option<super::FixedPriceOrderPositionFill>, String>,
        price: Result<Option<String>, String>,
        state: Result<Option<super::FixedPriceOrderState>, String>,
        stop_loss_on_fill: Result<Option<super::StopLossDetails>, String>,
        take_profit_on_fill: Result<Option<super::TakeProfitDetails>, String>,
        trade_client_extensions: Result<Option<super::ClientExtensions>, String>,
        trade_closed_i_ds: Result<Vec<String>, String>,
        trade_opened_id: Result<Option<String>, String>,
        trade_reduced_id: Result<Option<String>, String>,
        trade_state: Result<Option<String>, String>,
        trailing_stop_loss_on_fill: Result<Option<super::TrailingStopLossDetails>, String>,
        type_: Result<Option<super::FixedPriceOrderType>, String>,
        units: Result<Option<String>, String>,
    }

    impl Default for FixedPriceOrder {
        fn default() -> Self {
            Self {
                cancelled_time: Ok(Default::default()),
                cancelling_transaction_id: Ok(Default::default()),
                client_extensions: Ok(Default::default()),
                create_time: Ok(Default::default()),
                filled_time: Ok(Default::default()),
                filling_transaction_id: Ok(Default::default()),
                id: Ok(Default::default()),
                instrument: Ok(Default::default()),
                position_fill: Ok(Default::default()),
                price: Ok(Default::default()),
                state: Ok(Default::default()),
                stop_loss_on_fill: Ok(Default::default()),
                take_profit_on_fill: Ok(Default::default()),
                trade_client_extensions: Ok(Default::default()),
                trade_closed_i_ds: Ok(Default::default()),
                trade_opened_id: Ok(Default::default()),
                trade_reduced_id: Ok(Default::default()),
                trade_state: Ok(Default::default()),
                trailing_stop_loss_on_fill: Ok(Default::default()),
                type_: Ok(Default::default()),
                units: Ok(Default::default()),
            }
        }
    }

    impl FixedPriceOrder {
        pub fn cancelled_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.cancelled_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for cancelled_time: {}", e));
            self
        }
        pub fn cancelling_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.cancelling_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for cancelling_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn create_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.create_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for create_time: {}", e));
            self
        }
        pub fn filled_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.filled_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for filled_time: {}", e));
            self
        }
        pub fn filling_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.filling_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for filling_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn position_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::FixedPriceOrderPositionFill>>,
            T::Error: std::fmt::Display,
        {
            self.position_fill = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for position_fill: {}", e));
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn state<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::FixedPriceOrderState>>,
            T::Error: std::fmt::Display,
        {
            self.state = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for state: {}", e));
            self
        }
        pub fn stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn take_profit_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitDetails>>,
            T::Error: std::fmt::Display,
        {
            self.take_profit_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for take_profit_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn trade_client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.trade_client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn trade_closed_i_ds<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_closed_i_ds = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_closed_i_ds: {}",
                    e
                )
            });
            self
        }
        pub fn trade_opened_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_opened_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_opened_id: {}", e));
            self
        }
        pub fn trade_reduced_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_reduced_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_reduced_id: {}",
                    e
                )
            });
            self
        }
        pub fn trade_state<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_state = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_state: {}", e));
            self
        }
        pub fn trailing_stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.trailing_stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trailing_stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::FixedPriceOrderType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for units: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<FixedPriceOrder> for super::FixedPriceOrder {
        type Error = super::error::ConversionError;
        fn try_from(value: FixedPriceOrder) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                cancelled_time: value.cancelled_time?,
                cancelling_transaction_id: value.cancelling_transaction_id?,
                client_extensions: value.client_extensions?,
                create_time: value.create_time?,
                filled_time: value.filled_time?,
                filling_transaction_id: value.filling_transaction_id?,
                id: value.id?,
                instrument: value.instrument?,
                position_fill: value.position_fill?,
                price: value.price?,
                state: value.state?,
                stop_loss_on_fill: value.stop_loss_on_fill?,
                take_profit_on_fill: value.take_profit_on_fill?,
                trade_client_extensions: value.trade_client_extensions?,
                trade_closed_i_ds: value.trade_closed_i_ds?,
                trade_opened_id: value.trade_opened_id?,
                trade_reduced_id: value.trade_reduced_id?,
                trade_state: value.trade_state?,
                trailing_stop_loss_on_fill: value.trailing_stop_loss_on_fill?,
                type_: value.type_?,
                units: value.units?,
            })
        }
    }

    impl From<super::FixedPriceOrder> for FixedPriceOrder {
        fn from(value: super::FixedPriceOrder) -> Self {
            Self {
                cancelled_time: Ok(value.cancelled_time),
                cancelling_transaction_id: Ok(value.cancelling_transaction_id),
                client_extensions: Ok(value.client_extensions),
                create_time: Ok(value.create_time),
                filled_time: Ok(value.filled_time),
                filling_transaction_id: Ok(value.filling_transaction_id),
                id: Ok(value.id),
                instrument: Ok(value.instrument),
                position_fill: Ok(value.position_fill),
                price: Ok(value.price),
                state: Ok(value.state),
                stop_loss_on_fill: Ok(value.stop_loss_on_fill),
                take_profit_on_fill: Ok(value.take_profit_on_fill),
                trade_client_extensions: Ok(value.trade_client_extensions),
                trade_closed_i_ds: Ok(value.trade_closed_i_ds),
                trade_opened_id: Ok(value.trade_opened_id),
                trade_reduced_id: Ok(value.trade_reduced_id),
                trade_state: Ok(value.trade_state),
                trailing_stop_loss_on_fill: Ok(value.trailing_stop_loss_on_fill),
                type_: Ok(value.type_),
                units: Ok(value.units),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct FixedPriceOrderTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        id: Result<Option<String>, String>,
        instrument: Result<Option<String>, String>,
        position_fill: Result<Option<super::FixedPriceOrderTransactionPositionFill>, String>,
        price: Result<Option<String>, String>,
        reason: Result<Option<super::FixedPriceOrderTransactionReason>, String>,
        request_id: Result<Option<String>, String>,
        stop_loss_on_fill: Result<Option<super::StopLossDetails>, String>,
        take_profit_on_fill: Result<Option<super::TakeProfitDetails>, String>,
        time: Result<Option<String>, String>,
        trade_client_extensions: Result<Option<super::ClientExtensions>, String>,
        trade_state: Result<Option<String>, String>,
        trailing_stop_loss_on_fill: Result<Option<super::TrailingStopLossDetails>, String>,
        type_: Result<Option<super::FixedPriceOrderTransactionType>, String>,
        units: Result<Option<String>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for FixedPriceOrderTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                client_extensions: Ok(Default::default()),
                id: Ok(Default::default()),
                instrument: Ok(Default::default()),
                position_fill: Ok(Default::default()),
                price: Ok(Default::default()),
                reason: Ok(Default::default()),
                request_id: Ok(Default::default()),
                stop_loss_on_fill: Ok(Default::default()),
                take_profit_on_fill: Ok(Default::default()),
                time: Ok(Default::default()),
                trade_client_extensions: Ok(Default::default()),
                trade_state: Ok(Default::default()),
                trailing_stop_loss_on_fill: Ok(Default::default()),
                type_: Ok(Default::default()),
                units: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl FixedPriceOrderTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn position_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::FixedPriceOrderTransactionPositionFill>>,
            T::Error: std::fmt::Display,
        {
            self.position_fill = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for position_fill: {}", e));
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::FixedPriceOrderTransactionReason>>,
            T::Error: std::fmt::Display,
        {
            self.reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reason: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn take_profit_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitDetails>>,
            T::Error: std::fmt::Display,
        {
            self.take_profit_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for take_profit_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn trade_client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.trade_client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn trade_state<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_state = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_state: {}", e));
            self
        }
        pub fn trailing_stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.trailing_stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trailing_stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::FixedPriceOrderTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for units: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<FixedPriceOrderTransaction> for super::FixedPriceOrderTransaction {
        type Error = super::error::ConversionError;
        fn try_from(
            value: FixedPriceOrderTransaction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                client_extensions: value.client_extensions?,
                id: value.id?,
                instrument: value.instrument?,
                position_fill: value.position_fill?,
                price: value.price?,
                reason: value.reason?,
                request_id: value.request_id?,
                stop_loss_on_fill: value.stop_loss_on_fill?,
                take_profit_on_fill: value.take_profit_on_fill?,
                time: value.time?,
                trade_client_extensions: value.trade_client_extensions?,
                trade_state: value.trade_state?,
                trailing_stop_loss_on_fill: value.trailing_stop_loss_on_fill?,
                type_: value.type_?,
                units: value.units?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::FixedPriceOrderTransaction> for FixedPriceOrderTransaction {
        fn from(value: super::FixedPriceOrderTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                client_extensions: Ok(value.client_extensions),
                id: Ok(value.id),
                instrument: Ok(value.instrument),
                position_fill: Ok(value.position_fill),
                price: Ok(value.price),
                reason: Ok(value.reason),
                request_id: Ok(value.request_id),
                stop_loss_on_fill: Ok(value.stop_loss_on_fill),
                take_profit_on_fill: Ok(value.take_profit_on_fill),
                time: Ok(value.time),
                trade_client_extensions: Ok(value.trade_client_extensions),
                trade_state: Ok(value.trade_state),
                trailing_stop_loss_on_fill: Ok(value.trailing_stop_loss_on_fill),
                type_: Ok(value.type_),
                units: Ok(value.units),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct GetAccountChangesResponse {
        changes: Result<Option<super::AccountChanges>, String>,
        last_transaction_id: Result<Option<String>, String>,
        state: Result<Option<super::AccountChangesState>, String>,
    }

    impl Default for GetAccountChangesResponse {
        fn default() -> Self {
            Self {
                changes: Ok(Default::default()),
                last_transaction_id: Ok(Default::default()),
                state: Ok(Default::default()),
            }
        }
    }

    impl GetAccountChangesResponse {
        pub fn changes<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::AccountChanges>>,
            T::Error: std::fmt::Display,
        {
            self.changes = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for changes: {}", e));
            self
        }
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn state<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::AccountChangesState>>,
            T::Error: std::fmt::Display,
        {
            self.state = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for state: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<GetAccountChangesResponse> for super::GetAccountChangesResponse {
        type Error = super::error::ConversionError;
        fn try_from(
            value: GetAccountChangesResponse,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                changes: value.changes?,
                last_transaction_id: value.last_transaction_id?,
                state: value.state?,
            })
        }
    }

    impl From<super::GetAccountChangesResponse> for GetAccountChangesResponse {
        fn from(value: super::GetAccountChangesResponse) -> Self {
            Self {
                changes: Ok(value.changes),
                last_transaction_id: Ok(value.last_transaction_id),
                state: Ok(value.state),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct GetAccountInstrumentCandlesResponse {
        candles: Result<Vec<super::Candlestick>, String>,
        granularity: Result<Option<super::GetAccountInstrumentCandlesResponseGranularity>, String>,
        instrument: Result<Option<String>, String>,
    }

    impl Default for GetAccountInstrumentCandlesResponse {
        fn default() -> Self {
            Self {
                candles: Ok(Default::default()),
                granularity: Ok(Default::default()),
                instrument: Ok(Default::default()),
            }
        }
    }

    impl GetAccountInstrumentCandlesResponse {
        pub fn candles<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Candlestick>>,
            T::Error: std::fmt::Display,
        {
            self.candles = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for candles: {}", e));
            self
        }
        pub fn granularity<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::GetAccountInstrumentCandlesResponseGranularity>>,
            T::Error: std::fmt::Display,
        {
            self.granularity = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for granularity: {}", e));
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<GetAccountInstrumentCandlesResponse>
        for super::GetAccountInstrumentCandlesResponse
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: GetAccountInstrumentCandlesResponse,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                candles: value.candles?,
                granularity: value.granularity?,
                instrument: value.instrument?,
            })
        }
    }

    impl From<super::GetAccountInstrumentCandlesResponse> for GetAccountInstrumentCandlesResponse {
        fn from(value: super::GetAccountInstrumentCandlesResponse) -> Self {
            Self {
                candles: Ok(value.candles),
                granularity: Ok(value.granularity),
                instrument: Ok(value.instrument),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct GetAccountInstrumentsResponse {
        instruments: Result<Vec<super::Instrument>, String>,
        last_transaction_id: Result<Option<String>, String>,
    }

    impl Default for GetAccountInstrumentsResponse {
        fn default() -> Self {
            Self {
                instruments: Ok(Default::default()),
                last_transaction_id: Ok(Default::default()),
            }
        }
    }

    impl GetAccountInstrumentsResponse {
        pub fn instruments<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Instrument>>,
            T::Error: std::fmt::Display,
        {
            self.instruments = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instruments: {}", e));
            self
        }
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
    }

    impl std::convert::TryFrom<GetAccountInstrumentsResponse> for super::GetAccountInstrumentsResponse {
        type Error = super::error::ConversionError;
        fn try_from(
            value: GetAccountInstrumentsResponse,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                instruments: value.instruments?,
                last_transaction_id: value.last_transaction_id?,
            })
        }
    }

    impl From<super::GetAccountInstrumentsResponse> for GetAccountInstrumentsResponse {
        fn from(value: super::GetAccountInstrumentsResponse) -> Self {
            Self {
                instruments: Ok(value.instruments),
                last_transaction_id: Ok(value.last_transaction_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct GetAccountResponse {
        account: Result<Option<super::Account>, String>,
        last_transaction_id: Result<Option<String>, String>,
    }

    impl Default for GetAccountResponse {
        fn default() -> Self {
            Self {
                account: Ok(Default::default()),
                last_transaction_id: Ok(Default::default()),
            }
        }
    }

    impl GetAccountResponse {
        pub fn account<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::Account>>,
            T::Error: std::fmt::Display,
        {
            self.account = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account: {}", e));
            self
        }
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
    }

    impl std::convert::TryFrom<GetAccountResponse> for super::GetAccountResponse {
        type Error = super::error::ConversionError;
        fn try_from(value: GetAccountResponse) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account: value.account?,
                last_transaction_id: value.last_transaction_id?,
            })
        }
    }

    impl From<super::GetAccountResponse> for GetAccountResponse {
        fn from(value: super::GetAccountResponse) -> Self {
            Self {
                account: Ok(value.account),
                last_transaction_id: Ok(value.last_transaction_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct GetAccountSummaryResponse {
        account: Result<Option<super::AccountSummary>, String>,
        last_transaction_id: Result<Option<String>, String>,
    }

    impl Default for GetAccountSummaryResponse {
        fn default() -> Self {
            Self {
                account: Ok(Default::default()),
                last_transaction_id: Ok(Default::default()),
            }
        }
    }

    impl GetAccountSummaryResponse {
        pub fn account<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::AccountSummary>>,
            T::Error: std::fmt::Display,
        {
            self.account = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account: {}", e));
            self
        }
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
    }

    impl std::convert::TryFrom<GetAccountSummaryResponse> for super::GetAccountSummaryResponse {
        type Error = super::error::ConversionError;
        fn try_from(
            value: GetAccountSummaryResponse,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account: value.account?,
                last_transaction_id: value.last_transaction_id?,
            })
        }
    }

    impl From<super::GetAccountSummaryResponse> for GetAccountSummaryResponse {
        fn from(value: super::GetAccountSummaryResponse) -> Self {
            Self {
                account: Ok(value.account),
                last_transaction_id: Ok(value.last_transaction_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct GetInstrumentCandlesResponse {
        candles: Result<Vec<super::Candlestick>, String>,
        granularity: Result<Option<super::GetInstrumentCandlesResponseGranularity>, String>,
        instrument: Result<Option<String>, String>,
    }

    impl Default for GetInstrumentCandlesResponse {
        fn default() -> Self {
            Self {
                candles: Ok(Default::default()),
                granularity: Ok(Default::default()),
                instrument: Ok(Default::default()),
            }
        }
    }

    impl GetInstrumentCandlesResponse {
        pub fn candles<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Candlestick>>,
            T::Error: std::fmt::Display,
        {
            self.candles = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for candles: {}", e));
            self
        }
        pub fn granularity<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::GetInstrumentCandlesResponseGranularity>>,
            T::Error: std::fmt::Display,
        {
            self.granularity = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for granularity: {}", e));
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<GetInstrumentCandlesResponse> for super::GetInstrumentCandlesResponse {
        type Error = super::error::ConversionError;
        fn try_from(
            value: GetInstrumentCandlesResponse,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                candles: value.candles?,
                granularity: value.granularity?,
                instrument: value.instrument?,
            })
        }
    }

    impl From<super::GetInstrumentCandlesResponse> for GetInstrumentCandlesResponse {
        fn from(value: super::GetInstrumentCandlesResponse) -> Self {
            Self {
                candles: Ok(value.candles),
                granularity: Ok(value.granularity),
                instrument: Ok(value.instrument),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct GetInstrumentOrderBookResponse {
        order_book: Result<Option<super::OrderBook>, String>,
    }

    impl Default for GetInstrumentOrderBookResponse {
        fn default() -> Self {
            Self {
                order_book: Ok(Default::default()),
            }
        }
    }

    impl GetInstrumentOrderBookResponse {
        pub fn order_book<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderBook>>,
            T::Error: std::fmt::Display,
        {
            self.order_book = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for order_book: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<GetInstrumentOrderBookResponse>
        for super::GetInstrumentOrderBookResponse
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: GetInstrumentOrderBookResponse,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                order_book: value.order_book?,
            })
        }
    }

    impl From<super::GetInstrumentOrderBookResponse> for GetInstrumentOrderBookResponse {
        fn from(value: super::GetInstrumentOrderBookResponse) -> Self {
            Self {
                order_book: Ok(value.order_book),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct GetInstrumentPositionBookResponse {
        position_book: Result<Option<super::PositionBook>, String>,
    }

    impl Default for GetInstrumentPositionBookResponse {
        fn default() -> Self {
            Self {
                position_book: Ok(Default::default()),
            }
        }
    }

    impl GetInstrumentPositionBookResponse {
        pub fn position_book<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::PositionBook>>,
            T::Error: std::fmt::Display,
        {
            self.position_book = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for position_book: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<GetInstrumentPositionBookResponse>
        for super::GetInstrumentPositionBookResponse
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: GetInstrumentPositionBookResponse,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                position_book: value.position_book?,
            })
        }
    }

    impl From<super::GetInstrumentPositionBookResponse> for GetInstrumentPositionBookResponse {
        fn from(value: super::GetInstrumentPositionBookResponse) -> Self {
            Self {
                position_book: Ok(value.position_book),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct GetLatestCandlesResponse {
        latest_candles: Result<Vec<super::GetLatestCandlesResponseLatestCandlesItem>, String>,
    }

    impl Default for GetLatestCandlesResponse {
        fn default() -> Self {
            Self {
                latest_candles: Ok(Default::default()),
            }
        }
    }

    impl GetLatestCandlesResponse {
        pub fn latest_candles<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::GetLatestCandlesResponseLatestCandlesItem>>,
            T::Error: std::fmt::Display,
        {
            self.latest_candles = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for latest_candles: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<GetLatestCandlesResponse> for super::GetLatestCandlesResponse {
        type Error = super::error::ConversionError;
        fn try_from(
            value: GetLatestCandlesResponse,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                latest_candles: value.latest_candles?,
            })
        }
    }

    impl From<super::GetLatestCandlesResponse> for GetLatestCandlesResponse {
        fn from(value: super::GetLatestCandlesResponse) -> Self {
            Self {
                latest_candles: Ok(value.latest_candles),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct GetLatestCandlesResponseLatestCandlesItem {
        candles: Result<Vec<super::Candlestick>, String>,
        granularity:
            Result<Option<super::GetLatestCandlesResponseLatestCandlesItemGranularity>, String>,
        instrument: Result<Option<String>, String>,
    }

    impl Default for GetLatestCandlesResponseLatestCandlesItem {
        fn default() -> Self {
            Self {
                candles: Ok(Default::default()),
                granularity: Ok(Default::default()),
                instrument: Ok(Default::default()),
            }
        }
    }

    impl GetLatestCandlesResponseLatestCandlesItem {
        pub fn candles<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Candlestick>>,
            T::Error: std::fmt::Display,
        {
            self.candles = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for candles: {}", e));
            self
        }
        pub fn granularity<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::GetLatestCandlesResponseLatestCandlesItemGranularity>,
            >,
            T::Error: std::fmt::Display,
        {
            self.granularity = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for granularity: {}", e));
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<GetLatestCandlesResponseLatestCandlesItem>
        for super::GetLatestCandlesResponseLatestCandlesItem
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: GetLatestCandlesResponseLatestCandlesItem,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                candles: value.candles?,
                granularity: value.granularity?,
                instrument: value.instrument?,
            })
        }
    }

    impl From<super::GetLatestCandlesResponseLatestCandlesItem>
        for GetLatestCandlesResponseLatestCandlesItem
    {
        fn from(value: super::GetLatestCandlesResponseLatestCandlesItem) -> Self {
            Self {
                candles: Ok(value.candles),
                granularity: Ok(value.granularity),
                instrument: Ok(value.instrument),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct GetOrderResponse {
        last_transaction_id: Result<Option<String>, String>,
        order: Result<Option<super::Order>, String>,
    }

    impl Default for GetOrderResponse {
        fn default() -> Self {
            Self {
                last_transaction_id: Ok(Default::default()),
                order: Ok(Default::default()),
            }
        }
    }

    impl GetOrderResponse {
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn order<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::Order>>,
            T::Error: std::fmt::Display,
        {
            self.order = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for order: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<GetOrderResponse> for super::GetOrderResponse {
        type Error = super::error::ConversionError;
        fn try_from(value: GetOrderResponse) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                last_transaction_id: value.last_transaction_id?,
                order: value.order?,
            })
        }
    }

    impl From<super::GetOrderResponse> for GetOrderResponse {
        fn from(value: super::GetOrderResponse) -> Self {
            Self {
                last_transaction_id: Ok(value.last_transaction_id),
                order: Ok(value.order),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct GetPositionResponse {
        last_transaction_id: Result<Option<String>, String>,
        position: Result<Option<super::Position>, String>,
    }

    impl Default for GetPositionResponse {
        fn default() -> Self {
            Self {
                last_transaction_id: Ok(Default::default()),
                position: Ok(Default::default()),
            }
        }
    }

    impl GetPositionResponse {
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn position<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::Position>>,
            T::Error: std::fmt::Display,
        {
            self.position = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for position: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<GetPositionResponse> for super::GetPositionResponse {
        type Error = super::error::ConversionError;
        fn try_from(value: GetPositionResponse) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                last_transaction_id: value.last_transaction_id?,
                position: value.position?,
            })
        }
    }

    impl From<super::GetPositionResponse> for GetPositionResponse {
        fn from(value: super::GetPositionResponse) -> Self {
            Self {
                last_transaction_id: Ok(value.last_transaction_id),
                position: Ok(value.position),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct GetPricesResponse {
        home_conversions: Result<Vec<super::HomeConversions>, String>,
        prices: Result<Vec<super::ClientPrice>, String>,
        time: Result<Option<String>, String>,
    }

    impl Default for GetPricesResponse {
        fn default() -> Self {
            Self {
                home_conversions: Ok(Default::default()),
                prices: Ok(Default::default()),
                time: Ok(Default::default()),
            }
        }
    }

    impl GetPricesResponse {
        pub fn home_conversions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::HomeConversions>>,
            T::Error: std::fmt::Display,
        {
            self.home_conversions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for home_conversions: {}",
                    e
                )
            });
            self
        }
        pub fn prices<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::ClientPrice>>,
            T::Error: std::fmt::Display,
        {
            self.prices = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for prices: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<GetPricesResponse> for super::GetPricesResponse {
        type Error = super::error::ConversionError;
        fn try_from(value: GetPricesResponse) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                home_conversions: value.home_conversions?,
                prices: value.prices?,
                time: value.time?,
            })
        }
    }

    impl From<super::GetPricesResponse> for GetPricesResponse {
        fn from(value: super::GetPricesResponse) -> Self {
            Self {
                home_conversions: Ok(value.home_conversions),
                prices: Ok(value.prices),
                time: Ok(value.time),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct GetTradeResponse {
        last_transaction_id: Result<Option<String>, String>,
        trade: Result<Option<super::Trade>, String>,
    }

    impl Default for GetTradeResponse {
        fn default() -> Self {
            Self {
                last_transaction_id: Ok(Default::default()),
                trade: Ok(Default::default()),
            }
        }
    }

    impl GetTradeResponse {
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn trade<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::Trade>>,
            T::Error: std::fmt::Display,
        {
            self.trade = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<GetTradeResponse> for super::GetTradeResponse {
        type Error = super::error::ConversionError;
        fn try_from(value: GetTradeResponse) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                last_transaction_id: value.last_transaction_id?,
                trade: value.trade?,
            })
        }
    }

    impl From<super::GetTradeResponse> for GetTradeResponse {
        fn from(value: super::GetTradeResponse) -> Self {
            Self {
                last_transaction_id: Ok(value.last_transaction_id),
                trade: Ok(value.trade),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct GetTransactionRangeResponse {
        last_transaction_id: Result<Option<String>, String>,
        transactions: Result<Vec<super::Transaction>, String>,
    }

    impl Default for GetTransactionRangeResponse {
        fn default() -> Self {
            Self {
                last_transaction_id: Ok(Default::default()),
                transactions: Ok(Default::default()),
            }
        }
    }

    impl GetTransactionRangeResponse {
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn transactions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Transaction>>,
            T::Error: std::fmt::Display,
        {
            self.transactions = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for transactions: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<GetTransactionRangeResponse> for super::GetTransactionRangeResponse {
        type Error = super::error::ConversionError;
        fn try_from(
            value: GetTransactionRangeResponse,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                last_transaction_id: value.last_transaction_id?,
                transactions: value.transactions?,
            })
        }
    }

    impl From<super::GetTransactionRangeResponse> for GetTransactionRangeResponse {
        fn from(value: super::GetTransactionRangeResponse) -> Self {
            Self {
                last_transaction_id: Ok(value.last_transaction_id),
                transactions: Ok(value.transactions),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct GetTransactionResponse {
        last_transaction_id: Result<Option<String>, String>,
        transaction: Result<Option<super::Transaction>, String>,
    }

    impl Default for GetTransactionResponse {
        fn default() -> Self {
            Self {
                last_transaction_id: Ok(Default::default()),
                transaction: Ok(Default::default()),
            }
        }
    }

    impl GetTransactionResponse {
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::Transaction>>,
            T::Error: std::fmt::Display,
        {
            self.transaction = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for transaction: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<GetTransactionResponse> for super::GetTransactionResponse {
        type Error = super::error::ConversionError;
        fn try_from(value: GetTransactionResponse) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                last_transaction_id: value.last_transaction_id?,
                transaction: value.transaction?,
            })
        }
    }

    impl From<super::GetTransactionResponse> for GetTransactionResponse {
        fn from(value: super::GetTransactionResponse) -> Self {
            Self {
                last_transaction_id: Ok(value.last_transaction_id),
                transaction: Ok(value.transaction),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct GetTransactionsSinceIdResponse {
        last_transaction_id: Result<Option<String>, String>,
        transactions: Result<Vec<super::Transaction>, String>,
    }

    impl Default for GetTransactionsSinceIdResponse {
        fn default() -> Self {
            Self {
                last_transaction_id: Ok(Default::default()),
                transactions: Ok(Default::default()),
            }
        }
    }

    impl GetTransactionsSinceIdResponse {
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn transactions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Transaction>>,
            T::Error: std::fmt::Display,
        {
            self.transactions = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for transactions: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<GetTransactionsSinceIdResponse>
        for super::GetTransactionsSinceIdResponse
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: GetTransactionsSinceIdResponse,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                last_transaction_id: value.last_transaction_id?,
                transactions: value.transactions?,
            })
        }
    }

    impl From<super::GetTransactionsSinceIdResponse> for GetTransactionsSinceIdResponse {
        fn from(value: super::GetTransactionsSinceIdResponse) -> Self {
            Self {
                last_transaction_id: Ok(value.last_transaction_id),
                transactions: Ok(value.transactions),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct GuaranteedStopLossOrderEntryData {
        level_restriction: Result<Option<super::GuaranteedStopLossOrderLevelRestriction>, String>,
        minimum_distance: Result<Option<String>, String>,
        premium: Result<Option<String>, String>,
    }

    impl Default for GuaranteedStopLossOrderEntryData {
        fn default() -> Self {
            Self {
                level_restriction: Ok(Default::default()),
                minimum_distance: Ok(Default::default()),
                premium: Ok(Default::default()),
            }
        }
    }

    impl GuaranteedStopLossOrderEntryData {
        pub fn level_restriction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::GuaranteedStopLossOrderLevelRestriction>>,
            T::Error: std::fmt::Display,
        {
            self.level_restriction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for level_restriction: {}",
                    e
                )
            });
            self
        }
        pub fn minimum_distance<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.minimum_distance = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for minimum_distance: {}",
                    e
                )
            });
            self
        }
        pub fn premium<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.premium = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for premium: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<GuaranteedStopLossOrderEntryData>
        for super::GuaranteedStopLossOrderEntryData
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: GuaranteedStopLossOrderEntryData,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                level_restriction: value.level_restriction?,
                minimum_distance: value.minimum_distance?,
                premium: value.premium?,
            })
        }
    }

    impl From<super::GuaranteedStopLossOrderEntryData> for GuaranteedStopLossOrderEntryData {
        fn from(value: super::GuaranteedStopLossOrderEntryData) -> Self {
            Self {
                level_restriction: Ok(value.level_restriction),
                minimum_distance: Ok(value.minimum_distance),
                premium: Ok(value.premium),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct GuaranteedStopLossOrderLevelRestriction {
        price_range: Result<Option<String>, String>,
        volume: Result<Option<String>, String>,
    }

    impl Default for GuaranteedStopLossOrderLevelRestriction {
        fn default() -> Self {
            Self {
                price_range: Ok(Default::default()),
                volume: Ok(Default::default()),
            }
        }
    }

    impl GuaranteedStopLossOrderLevelRestriction {
        pub fn price_range<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price_range = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price_range: {}", e));
            self
        }
        pub fn volume<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.volume = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for volume: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<GuaranteedStopLossOrderLevelRestriction>
        for super::GuaranteedStopLossOrderLevelRestriction
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: GuaranteedStopLossOrderLevelRestriction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                price_range: value.price_range?,
                volume: value.volume?,
            })
        }
    }

    impl From<super::GuaranteedStopLossOrderLevelRestriction>
        for GuaranteedStopLossOrderLevelRestriction
    {
        fn from(value: super::GuaranteedStopLossOrderLevelRestriction) -> Self {
            Self {
                price_range: Ok(value.price_range),
                volume: Ok(value.volume),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct HomeConversions {
        account_gain: Result<Option<String>, String>,
        account_loss: Result<Option<String>, String>,
        currency: Result<Option<String>, String>,
        position_value: Result<Option<String>, String>,
    }

    impl Default for HomeConversions {
        fn default() -> Self {
            Self {
                account_gain: Ok(Default::default()),
                account_loss: Ok(Default::default()),
                currency: Ok(Default::default()),
                position_value: Ok(Default::default()),
            }
        }
    }

    impl HomeConversions {
        pub fn account_gain<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_gain = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_gain: {}", e));
            self
        }
        pub fn account_loss<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_loss = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_loss: {}", e));
            self
        }
        pub fn currency<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.currency = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for currency: {}", e));
            self
        }
        pub fn position_value<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.position_value = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for position_value: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<HomeConversions> for super::HomeConversions {
        type Error = super::error::ConversionError;
        fn try_from(value: HomeConversions) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_gain: value.account_gain?,
                account_loss: value.account_loss?,
                currency: value.currency?,
                position_value: value.position_value?,
            })
        }
    }

    impl From<super::HomeConversions> for HomeConversions {
        fn from(value: super::HomeConversions) -> Self {
            Self {
                account_gain: Ok(value.account_gain),
                account_loss: Ok(value.account_loss),
                currency: Ok(value.currency),
                position_value: Ok(value.position_value),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct Instrument {
        commission: Result<Option<super::InstrumentCommission>, String>,
        display_name: Result<Option<String>, String>,
        display_precision: Result<Option<i64>, String>,
        margin_rate: Result<Option<String>, String>,
        maximum_order_units: Result<Option<String>, String>,
        maximum_position_size: Result<Option<String>, String>,
        maximum_trailing_stop_distance: Result<Option<String>, String>,
        minimum_trade_size: Result<Option<String>, String>,
        minimum_trailing_stop_distance: Result<Option<String>, String>,
        name: Result<Option<String>, String>,
        pip_location: Result<Option<i64>, String>,
        trade_units_precision: Result<Option<i64>, String>,
        type_: Result<Option<super::InstrumentType>, String>,
    }

    impl Default for Instrument {
        fn default() -> Self {
            Self {
                commission: Ok(Default::default()),
                display_name: Ok(Default::default()),
                display_precision: Ok(Default::default()),
                margin_rate: Ok(Default::default()),
                maximum_order_units: Ok(Default::default()),
                maximum_position_size: Ok(Default::default()),
                maximum_trailing_stop_distance: Ok(Default::default()),
                minimum_trade_size: Ok(Default::default()),
                minimum_trailing_stop_distance: Ok(Default::default()),
                name: Ok(Default::default()),
                pip_location: Ok(Default::default()),
                trade_units_precision: Ok(Default::default()),
                type_: Ok(Default::default()),
            }
        }
    }

    impl Instrument {
        pub fn commission<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::InstrumentCommission>>,
            T::Error: std::fmt::Display,
        {
            self.commission = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for commission: {}", e));
            self
        }
        pub fn display_name<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.display_name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for display_name: {}", e));
            self
        }
        pub fn display_precision<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.display_precision = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for display_precision: {}",
                    e
                )
            });
            self
        }
        pub fn margin_rate<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_rate = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for margin_rate: {}", e));
            self
        }
        pub fn maximum_order_units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.maximum_order_units = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for maximum_order_units: {}",
                    e
                )
            });
            self
        }
        pub fn maximum_position_size<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.maximum_position_size = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for maximum_position_size: {}",
                    e
                )
            });
            self
        }
        pub fn maximum_trailing_stop_distance<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.maximum_trailing_stop_distance = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for maximum_trailing_stop_distance: {}",
                    e
                )
            });
            self
        }
        pub fn minimum_trade_size<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.minimum_trade_size = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for minimum_trade_size: {}",
                    e
                )
            });
            self
        }
        pub fn minimum_trailing_stop_distance<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.minimum_trailing_stop_distance = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for minimum_trailing_stop_distance: {}",
                    e
                )
            });
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn pip_location<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.pip_location = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for pip_location: {}", e));
            self
        }
        pub fn trade_units_precision<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.trade_units_precision = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_units_precision: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::InstrumentType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<Instrument> for super::Instrument {
        type Error = super::error::ConversionError;
        fn try_from(value: Instrument) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                commission: value.commission?,
                display_name: value.display_name?,
                display_precision: value.display_precision?,
                margin_rate: value.margin_rate?,
                maximum_order_units: value.maximum_order_units?,
                maximum_position_size: value.maximum_position_size?,
                maximum_trailing_stop_distance: value.maximum_trailing_stop_distance?,
                minimum_trade_size: value.minimum_trade_size?,
                minimum_trailing_stop_distance: value.minimum_trailing_stop_distance?,
                name: value.name?,
                pip_location: value.pip_location?,
                trade_units_precision: value.trade_units_precision?,
                type_: value.type_?,
            })
        }
    }

    impl From<super::Instrument> for Instrument {
        fn from(value: super::Instrument) -> Self {
            Self {
                commission: Ok(value.commission),
                display_name: Ok(value.display_name),
                display_precision: Ok(value.display_precision),
                margin_rate: Ok(value.margin_rate),
                maximum_order_units: Ok(value.maximum_order_units),
                maximum_position_size: Ok(value.maximum_position_size),
                maximum_trailing_stop_distance: Ok(value.maximum_trailing_stop_distance),
                minimum_trade_size: Ok(value.minimum_trade_size),
                minimum_trailing_stop_distance: Ok(value.minimum_trailing_stop_distance),
                name: Ok(value.name),
                pip_location: Ok(value.pip_location),
                trade_units_precision: Ok(value.trade_units_precision),
                type_: Ok(value.type_),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct InstrumentCommission {
        commission: Result<Option<String>, String>,
        minimum_commission: Result<Option<String>, String>,
        units_traded: Result<Option<String>, String>,
    }

    impl Default for InstrumentCommission {
        fn default() -> Self {
            Self {
                commission: Ok(Default::default()),
                minimum_commission: Ok(Default::default()),
                units_traded: Ok(Default::default()),
            }
        }
    }

    impl InstrumentCommission {
        pub fn commission<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.commission = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for commission: {}", e));
            self
        }
        pub fn minimum_commission<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.minimum_commission = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for minimum_commission: {}",
                    e
                )
            });
            self
        }
        pub fn units_traded<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.units_traded = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for units_traded: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<InstrumentCommission> for super::InstrumentCommission {
        type Error = super::error::ConversionError;
        fn try_from(value: InstrumentCommission) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                commission: value.commission?,
                minimum_commission: value.minimum_commission?,
                units_traded: value.units_traded?,
            })
        }
    }

    impl From<super::InstrumentCommission> for InstrumentCommission {
        fn from(value: super::InstrumentCommission) -> Self {
            Self {
                commission: Ok(value.commission),
                minimum_commission: Ok(value.minimum_commission),
                units_traded: Ok(value.units_traded),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct LimitOrder {
        cancelled_time: Result<Option<String>, String>,
        cancelling_transaction_id: Result<Option<String>, String>,
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        create_time: Result<Option<String>, String>,
        filled_time: Result<Option<String>, String>,
        filling_transaction_id: Result<Option<String>, String>,
        gtd_time: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        instrument: Result<Option<String>, String>,
        position_fill: Result<Option<super::LimitOrderPositionFill>, String>,
        price: Result<Option<String>, String>,
        replaced_by_order_id: Result<Option<String>, String>,
        replaces_order_id: Result<Option<String>, String>,
        state: Result<Option<super::LimitOrderState>, String>,
        stop_loss_on_fill: Result<Option<super::StopLossDetails>, String>,
        take_profit_on_fill: Result<Option<super::TakeProfitDetails>, String>,
        time_in_force: Result<Option<super::LimitOrderTimeInForce>, String>,
        trade_client_extensions: Result<Option<super::ClientExtensions>, String>,
        trade_closed_i_ds: Result<Vec<String>, String>,
        trade_opened_id: Result<Option<String>, String>,
        trade_reduced_id: Result<Option<String>, String>,
        trailing_stop_loss_on_fill: Result<Option<super::TrailingStopLossDetails>, String>,
        trigger_condition: Result<Option<super::LimitOrderTriggerCondition>, String>,
        type_: Result<Option<super::LimitOrderType>, String>,
        units: Result<Option<String>, String>,
    }

    impl Default for LimitOrder {
        fn default() -> Self {
            Self {
                cancelled_time: Ok(Default::default()),
                cancelling_transaction_id: Ok(Default::default()),
                client_extensions: Ok(Default::default()),
                create_time: Ok(Default::default()),
                filled_time: Ok(Default::default()),
                filling_transaction_id: Ok(Default::default()),
                gtd_time: Ok(Default::default()),
                id: Ok(Default::default()),
                instrument: Ok(Default::default()),
                position_fill: Ok(Default::default()),
                price: Ok(Default::default()),
                replaced_by_order_id: Ok(Default::default()),
                replaces_order_id: Ok(Default::default()),
                state: Ok(Default::default()),
                stop_loss_on_fill: Ok(Default::default()),
                take_profit_on_fill: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_client_extensions: Ok(Default::default()),
                trade_closed_i_ds: Ok(Default::default()),
                trade_opened_id: Ok(Default::default()),
                trade_reduced_id: Ok(Default::default()),
                trailing_stop_loss_on_fill: Ok(Default::default()),
                trigger_condition: Ok(Default::default()),
                type_: Ok(Default::default()),
                units: Ok(Default::default()),
            }
        }
    }

    impl LimitOrder {
        pub fn cancelled_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.cancelled_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for cancelled_time: {}", e));
            self
        }
        pub fn cancelling_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.cancelling_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for cancelling_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn create_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.create_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for create_time: {}", e));
            self
        }
        pub fn filled_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.filled_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for filled_time: {}", e));
            self
        }
        pub fn filling_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.filling_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for filling_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn gtd_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gtd_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for gtd_time: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn position_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::LimitOrderPositionFill>>,
            T::Error: std::fmt::Display,
        {
            self.position_fill = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for position_fill: {}", e));
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn replaced_by_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.replaced_by_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for replaced_by_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn replaces_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.replaces_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for replaces_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn state<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::LimitOrderState>>,
            T::Error: std::fmt::Display,
        {
            self.state = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for state: {}", e));
            self
        }
        pub fn stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn take_profit_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitDetails>>,
            T::Error: std::fmt::Display,
        {
            self.take_profit_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for take_profit_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::LimitOrderTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.trade_client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn trade_closed_i_ds<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_closed_i_ds = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_closed_i_ds: {}",
                    e
                )
            });
            self
        }
        pub fn trade_opened_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_opened_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_opened_id: {}", e));
            self
        }
        pub fn trade_reduced_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_reduced_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_reduced_id: {}",
                    e
                )
            });
            self
        }
        pub fn trailing_stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.trailing_stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trailing_stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn trigger_condition<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::LimitOrderTriggerCondition>>,
            T::Error: std::fmt::Display,
        {
            self.trigger_condition = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trigger_condition: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::LimitOrderType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for units: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<LimitOrder> for super::LimitOrder {
        type Error = super::error::ConversionError;
        fn try_from(value: LimitOrder) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                cancelled_time: value.cancelled_time?,
                cancelling_transaction_id: value.cancelling_transaction_id?,
                client_extensions: value.client_extensions?,
                create_time: value.create_time?,
                filled_time: value.filled_time?,
                filling_transaction_id: value.filling_transaction_id?,
                gtd_time: value.gtd_time?,
                id: value.id?,
                instrument: value.instrument?,
                position_fill: value.position_fill?,
                price: value.price?,
                replaced_by_order_id: value.replaced_by_order_id?,
                replaces_order_id: value.replaces_order_id?,
                state: value.state?,
                stop_loss_on_fill: value.stop_loss_on_fill?,
                take_profit_on_fill: value.take_profit_on_fill?,
                time_in_force: value.time_in_force?,
                trade_client_extensions: value.trade_client_extensions?,
                trade_closed_i_ds: value.trade_closed_i_ds?,
                trade_opened_id: value.trade_opened_id?,
                trade_reduced_id: value.trade_reduced_id?,
                trailing_stop_loss_on_fill: value.trailing_stop_loss_on_fill?,
                trigger_condition: value.trigger_condition?,
                type_: value.type_?,
                units: value.units?,
            })
        }
    }

    impl From<super::LimitOrder> for LimitOrder {
        fn from(value: super::LimitOrder) -> Self {
            Self {
                cancelled_time: Ok(value.cancelled_time),
                cancelling_transaction_id: Ok(value.cancelling_transaction_id),
                client_extensions: Ok(value.client_extensions),
                create_time: Ok(value.create_time),
                filled_time: Ok(value.filled_time),
                filling_transaction_id: Ok(value.filling_transaction_id),
                gtd_time: Ok(value.gtd_time),
                id: Ok(value.id),
                instrument: Ok(value.instrument),
                position_fill: Ok(value.position_fill),
                price: Ok(value.price),
                replaced_by_order_id: Ok(value.replaced_by_order_id),
                replaces_order_id: Ok(value.replaces_order_id),
                state: Ok(value.state),
                stop_loss_on_fill: Ok(value.stop_loss_on_fill),
                take_profit_on_fill: Ok(value.take_profit_on_fill),
                time_in_force: Ok(value.time_in_force),
                trade_client_extensions: Ok(value.trade_client_extensions),
                trade_closed_i_ds: Ok(value.trade_closed_i_ds),
                trade_opened_id: Ok(value.trade_opened_id),
                trade_reduced_id: Ok(value.trade_reduced_id),
                trailing_stop_loss_on_fill: Ok(value.trailing_stop_loss_on_fill),
                trigger_condition: Ok(value.trigger_condition),
                type_: Ok(value.type_),
                units: Ok(value.units),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct LimitOrderRejectTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        gtd_time: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        instrument: Result<Option<String>, String>,
        intended_replaces_order_id: Result<Option<String>, String>,
        position_fill: Result<Option<super::LimitOrderRejectTransactionPositionFill>, String>,
        price: Result<Option<String>, String>,
        reason: Result<Option<super::LimitOrderRejectTransactionReason>, String>,
        reject_reason: Result<Option<super::LimitOrderRejectTransactionRejectReason>, String>,
        request_id: Result<Option<String>, String>,
        stop_loss_on_fill: Result<Option<super::StopLossDetails>, String>,
        take_profit_on_fill: Result<Option<super::TakeProfitDetails>, String>,
        time: Result<Option<String>, String>,
        time_in_force: Result<Option<super::LimitOrderRejectTransactionTimeInForce>, String>,
        trade_client_extensions: Result<Option<super::ClientExtensions>, String>,
        trailing_stop_loss_on_fill: Result<Option<super::TrailingStopLossDetails>, String>,
        trigger_condition:
            Result<Option<super::LimitOrderRejectTransactionTriggerCondition>, String>,
        type_: Result<Option<super::LimitOrderRejectTransactionType>, String>,
        units: Result<Option<String>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for LimitOrderRejectTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                client_extensions: Ok(Default::default()),
                gtd_time: Ok(Default::default()),
                id: Ok(Default::default()),
                instrument: Ok(Default::default()),
                intended_replaces_order_id: Ok(Default::default()),
                position_fill: Ok(Default::default()),
                price: Ok(Default::default()),
                reason: Ok(Default::default()),
                reject_reason: Ok(Default::default()),
                request_id: Ok(Default::default()),
                stop_loss_on_fill: Ok(Default::default()),
                take_profit_on_fill: Ok(Default::default()),
                time: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_client_extensions: Ok(Default::default()),
                trailing_stop_loss_on_fill: Ok(Default::default()),
                trigger_condition: Ok(Default::default()),
                type_: Ok(Default::default()),
                units: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl LimitOrderRejectTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn gtd_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gtd_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for gtd_time: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn intended_replaces_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.intended_replaces_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for intended_replaces_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn position_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::LimitOrderRejectTransactionPositionFill>>,
            T::Error: std::fmt::Display,
        {
            self.position_fill = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for position_fill: {}", e));
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::LimitOrderRejectTransactionReason>>,
            T::Error: std::fmt::Display,
        {
            self.reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reason: {}", e));
            self
        }
        pub fn reject_reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::LimitOrderRejectTransactionRejectReason>>,
            T::Error: std::fmt::Display,
        {
            self.reject_reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reject_reason: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn take_profit_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitDetails>>,
            T::Error: std::fmt::Display,
        {
            self.take_profit_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for take_profit_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::LimitOrderRejectTransactionTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.trade_client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn trailing_stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.trailing_stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trailing_stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn trigger_condition<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::LimitOrderRejectTransactionTriggerCondition>>,
            T::Error: std::fmt::Display,
        {
            self.trigger_condition = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trigger_condition: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::LimitOrderRejectTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for units: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<LimitOrderRejectTransaction> for super::LimitOrderRejectTransaction {
        type Error = super::error::ConversionError;
        fn try_from(
            value: LimitOrderRejectTransaction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                client_extensions: value.client_extensions?,
                gtd_time: value.gtd_time?,
                id: value.id?,
                instrument: value.instrument?,
                intended_replaces_order_id: value.intended_replaces_order_id?,
                position_fill: value.position_fill?,
                price: value.price?,
                reason: value.reason?,
                reject_reason: value.reject_reason?,
                request_id: value.request_id?,
                stop_loss_on_fill: value.stop_loss_on_fill?,
                take_profit_on_fill: value.take_profit_on_fill?,
                time: value.time?,
                time_in_force: value.time_in_force?,
                trade_client_extensions: value.trade_client_extensions?,
                trailing_stop_loss_on_fill: value.trailing_stop_loss_on_fill?,
                trigger_condition: value.trigger_condition?,
                type_: value.type_?,
                units: value.units?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::LimitOrderRejectTransaction> for LimitOrderRejectTransaction {
        fn from(value: super::LimitOrderRejectTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                client_extensions: Ok(value.client_extensions),
                gtd_time: Ok(value.gtd_time),
                id: Ok(value.id),
                instrument: Ok(value.instrument),
                intended_replaces_order_id: Ok(value.intended_replaces_order_id),
                position_fill: Ok(value.position_fill),
                price: Ok(value.price),
                reason: Ok(value.reason),
                reject_reason: Ok(value.reject_reason),
                request_id: Ok(value.request_id),
                stop_loss_on_fill: Ok(value.stop_loss_on_fill),
                take_profit_on_fill: Ok(value.take_profit_on_fill),
                time: Ok(value.time),
                time_in_force: Ok(value.time_in_force),
                trade_client_extensions: Ok(value.trade_client_extensions),
                trailing_stop_loss_on_fill: Ok(value.trailing_stop_loss_on_fill),
                trigger_condition: Ok(value.trigger_condition),
                type_: Ok(value.type_),
                units: Ok(value.units),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct LimitOrderRequest {
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        gtd_time: Result<Option<String>, String>,
        instrument: Result<Option<String>, String>,
        position_fill: Result<Option<super::LimitOrderRequestPositionFill>, String>,
        price: Result<Option<String>, String>,
        stop_loss_on_fill: Result<Option<super::StopLossDetails>, String>,
        take_profit_on_fill: Result<Option<super::TakeProfitDetails>, String>,
        time_in_force: Result<Option<super::LimitOrderRequestTimeInForce>, String>,
        trade_client_extensions: Result<Option<super::ClientExtensions>, String>,
        trailing_stop_loss_on_fill: Result<Option<super::TrailingStopLossDetails>, String>,
        trigger_condition: Result<Option<super::LimitOrderRequestTriggerCondition>, String>,
        type_: Result<Option<super::LimitOrderRequestType>, String>,
        units: Result<Option<String>, String>,
    }

    impl Default for LimitOrderRequest {
        fn default() -> Self {
            Self {
                client_extensions: Ok(Default::default()),
                gtd_time: Ok(Default::default()),
                instrument: Ok(Default::default()),
                position_fill: Ok(Default::default()),
                price: Ok(Default::default()),
                stop_loss_on_fill: Ok(Default::default()),
                take_profit_on_fill: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_client_extensions: Ok(Default::default()),
                trailing_stop_loss_on_fill: Ok(Default::default()),
                trigger_condition: Ok(Default::default()),
                type_: Ok(Default::default()),
                units: Ok(Default::default()),
            }
        }
    }

    impl LimitOrderRequest {
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn gtd_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gtd_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for gtd_time: {}", e));
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn position_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::LimitOrderRequestPositionFill>>,
            T::Error: std::fmt::Display,
        {
            self.position_fill = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for position_fill: {}", e));
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn take_profit_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitDetails>>,
            T::Error: std::fmt::Display,
        {
            self.take_profit_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for take_profit_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::LimitOrderRequestTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.trade_client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn trailing_stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.trailing_stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trailing_stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn trigger_condition<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::LimitOrderRequestTriggerCondition>>,
            T::Error: std::fmt::Display,
        {
            self.trigger_condition = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trigger_condition: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::LimitOrderRequestType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for units: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<LimitOrderRequest> for super::LimitOrderRequest {
        type Error = super::error::ConversionError;
        fn try_from(value: LimitOrderRequest) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                client_extensions: value.client_extensions?,
                gtd_time: value.gtd_time?,
                instrument: value.instrument?,
                position_fill: value.position_fill?,
                price: value.price?,
                stop_loss_on_fill: value.stop_loss_on_fill?,
                take_profit_on_fill: value.take_profit_on_fill?,
                time_in_force: value.time_in_force?,
                trade_client_extensions: value.trade_client_extensions?,
                trailing_stop_loss_on_fill: value.trailing_stop_loss_on_fill?,
                trigger_condition: value.trigger_condition?,
                type_: value.type_?,
                units: value.units?,
            })
        }
    }

    impl From<super::LimitOrderRequest> for LimitOrderRequest {
        fn from(value: super::LimitOrderRequest) -> Self {
            Self {
                client_extensions: Ok(value.client_extensions),
                gtd_time: Ok(value.gtd_time),
                instrument: Ok(value.instrument),
                position_fill: Ok(value.position_fill),
                price: Ok(value.price),
                stop_loss_on_fill: Ok(value.stop_loss_on_fill),
                take_profit_on_fill: Ok(value.take_profit_on_fill),
                time_in_force: Ok(value.time_in_force),
                trade_client_extensions: Ok(value.trade_client_extensions),
                trailing_stop_loss_on_fill: Ok(value.trailing_stop_loss_on_fill),
                trigger_condition: Ok(value.trigger_condition),
                type_: Ok(value.type_),
                units: Ok(value.units),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct LimitOrderTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        cancelling_transaction_id: Result<Option<String>, String>,
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        gtd_time: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        instrument: Result<Option<String>, String>,
        position_fill: Result<Option<super::LimitOrderTransactionPositionFill>, String>,
        price: Result<Option<String>, String>,
        reason: Result<Option<super::LimitOrderTransactionReason>, String>,
        replaces_order_id: Result<Option<String>, String>,
        request_id: Result<Option<String>, String>,
        stop_loss_on_fill: Result<Option<super::StopLossDetails>, String>,
        take_profit_on_fill: Result<Option<super::TakeProfitDetails>, String>,
        time: Result<Option<String>, String>,
        time_in_force: Result<Option<super::LimitOrderTransactionTimeInForce>, String>,
        trade_client_extensions: Result<Option<super::ClientExtensions>, String>,
        trailing_stop_loss_on_fill: Result<Option<super::TrailingStopLossDetails>, String>,
        trigger_condition: Result<Option<super::LimitOrderTransactionTriggerCondition>, String>,
        type_: Result<Option<super::LimitOrderTransactionType>, String>,
        units: Result<Option<String>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for LimitOrderTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                cancelling_transaction_id: Ok(Default::default()),
                client_extensions: Ok(Default::default()),
                gtd_time: Ok(Default::default()),
                id: Ok(Default::default()),
                instrument: Ok(Default::default()),
                position_fill: Ok(Default::default()),
                price: Ok(Default::default()),
                reason: Ok(Default::default()),
                replaces_order_id: Ok(Default::default()),
                request_id: Ok(Default::default()),
                stop_loss_on_fill: Ok(Default::default()),
                take_profit_on_fill: Ok(Default::default()),
                time: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_client_extensions: Ok(Default::default()),
                trailing_stop_loss_on_fill: Ok(Default::default()),
                trigger_condition: Ok(Default::default()),
                type_: Ok(Default::default()),
                units: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl LimitOrderTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn cancelling_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.cancelling_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for cancelling_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn gtd_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gtd_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for gtd_time: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn position_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::LimitOrderTransactionPositionFill>>,
            T::Error: std::fmt::Display,
        {
            self.position_fill = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for position_fill: {}", e));
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::LimitOrderTransactionReason>>,
            T::Error: std::fmt::Display,
        {
            self.reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reason: {}", e));
            self
        }
        pub fn replaces_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.replaces_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for replaces_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn take_profit_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitDetails>>,
            T::Error: std::fmt::Display,
        {
            self.take_profit_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for take_profit_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::LimitOrderTransactionTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.trade_client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn trailing_stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.trailing_stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trailing_stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn trigger_condition<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::LimitOrderTransactionTriggerCondition>>,
            T::Error: std::fmt::Display,
        {
            self.trigger_condition = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trigger_condition: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::LimitOrderTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for units: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<LimitOrderTransaction> for super::LimitOrderTransaction {
        type Error = super::error::ConversionError;
        fn try_from(value: LimitOrderTransaction) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                cancelling_transaction_id: value.cancelling_transaction_id?,
                client_extensions: value.client_extensions?,
                gtd_time: value.gtd_time?,
                id: value.id?,
                instrument: value.instrument?,
                position_fill: value.position_fill?,
                price: value.price?,
                reason: value.reason?,
                replaces_order_id: value.replaces_order_id?,
                request_id: value.request_id?,
                stop_loss_on_fill: value.stop_loss_on_fill?,
                take_profit_on_fill: value.take_profit_on_fill?,
                time: value.time?,
                time_in_force: value.time_in_force?,
                trade_client_extensions: value.trade_client_extensions?,
                trailing_stop_loss_on_fill: value.trailing_stop_loss_on_fill?,
                trigger_condition: value.trigger_condition?,
                type_: value.type_?,
                units: value.units?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::LimitOrderTransaction> for LimitOrderTransaction {
        fn from(value: super::LimitOrderTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                cancelling_transaction_id: Ok(value.cancelling_transaction_id),
                client_extensions: Ok(value.client_extensions),
                gtd_time: Ok(value.gtd_time),
                id: Ok(value.id),
                instrument: Ok(value.instrument),
                position_fill: Ok(value.position_fill),
                price: Ok(value.price),
                reason: Ok(value.reason),
                replaces_order_id: Ok(value.replaces_order_id),
                request_id: Ok(value.request_id),
                stop_loss_on_fill: Ok(value.stop_loss_on_fill),
                take_profit_on_fill: Ok(value.take_profit_on_fill),
                time: Ok(value.time),
                time_in_force: Ok(value.time_in_force),
                trade_client_extensions: Ok(value.trade_client_extensions),
                trailing_stop_loss_on_fill: Ok(value.trailing_stop_loss_on_fill),
                trigger_condition: Ok(value.trigger_condition),
                type_: Ok(value.type_),
                units: Ok(value.units),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct LiquidityRegenerationSchedule {
        steps: Result<Vec<super::LiquidityRegenerationScheduleStep>, String>,
    }

    impl Default for LiquidityRegenerationSchedule {
        fn default() -> Self {
            Self {
                steps: Ok(Default::default()),
            }
        }
    }

    impl LiquidityRegenerationSchedule {
        pub fn steps<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::LiquidityRegenerationScheduleStep>>,
            T::Error: std::fmt::Display,
        {
            self.steps = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for steps: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<LiquidityRegenerationSchedule> for super::LiquidityRegenerationSchedule {
        type Error = super::error::ConversionError;
        fn try_from(
            value: LiquidityRegenerationSchedule,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                steps: value.steps?,
            })
        }
    }

    impl From<super::LiquidityRegenerationSchedule> for LiquidityRegenerationSchedule {
        fn from(value: super::LiquidityRegenerationSchedule) -> Self {
            Self {
                steps: Ok(value.steps),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct LiquidityRegenerationScheduleStep {
        ask_liquidity_used: Result<Option<String>, String>,
        bid_liquidity_used: Result<Option<String>, String>,
        timestamp: Result<Option<String>, String>,
    }

    impl Default for LiquidityRegenerationScheduleStep {
        fn default() -> Self {
            Self {
                ask_liquidity_used: Ok(Default::default()),
                bid_liquidity_used: Ok(Default::default()),
                timestamp: Ok(Default::default()),
            }
        }
    }

    impl LiquidityRegenerationScheduleStep {
        pub fn ask_liquidity_used<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.ask_liquidity_used = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for ask_liquidity_used: {}",
                    e
                )
            });
            self
        }
        pub fn bid_liquidity_used<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.bid_liquidity_used = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for bid_liquidity_used: {}",
                    e
                )
            });
            self
        }
        pub fn timestamp<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.timestamp = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for timestamp: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<LiquidityRegenerationScheduleStep>
        for super::LiquidityRegenerationScheduleStep
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: LiquidityRegenerationScheduleStep,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                ask_liquidity_used: value.ask_liquidity_used?,
                bid_liquidity_used: value.bid_liquidity_used?,
                timestamp: value.timestamp?,
            })
        }
    }

    impl From<super::LiquidityRegenerationScheduleStep> for LiquidityRegenerationScheduleStep {
        fn from(value: super::LiquidityRegenerationScheduleStep) -> Self {
            Self {
                ask_liquidity_used: Ok(value.ask_liquidity_used),
                bid_liquidity_used: Ok(value.bid_liquidity_used),
                timestamp: Ok(value.timestamp),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct ListAccountsResponse {
        accounts: Result<Vec<super::AccountProperties>, String>,
    }

    impl Default for ListAccountsResponse {
        fn default() -> Self {
            Self {
                accounts: Ok(Default::default()),
            }
        }
    }

    impl ListAccountsResponse {
        pub fn accounts<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::AccountProperties>>,
            T::Error: std::fmt::Display,
        {
            self.accounts = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for accounts: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<ListAccountsResponse> for super::ListAccountsResponse {
        type Error = super::error::ConversionError;
        fn try_from(value: ListAccountsResponse) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                accounts: value.accounts?,
            })
        }
    }

    impl From<super::ListAccountsResponse> for ListAccountsResponse {
        fn from(value: super::ListAccountsResponse) -> Self {
            Self {
                accounts: Ok(value.accounts),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct ListOpenPositionsResponse {
        last_transaction_id: Result<Option<String>, String>,
        positions: Result<Vec<super::Position>, String>,
    }

    impl Default for ListOpenPositionsResponse {
        fn default() -> Self {
            Self {
                last_transaction_id: Ok(Default::default()),
                positions: Ok(Default::default()),
            }
        }
    }

    impl ListOpenPositionsResponse {
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn positions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Position>>,
            T::Error: std::fmt::Display,
        {
            self.positions = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for positions: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<ListOpenPositionsResponse> for super::ListOpenPositionsResponse {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ListOpenPositionsResponse,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                last_transaction_id: value.last_transaction_id?,
                positions: value.positions?,
            })
        }
    }

    impl From<super::ListOpenPositionsResponse> for ListOpenPositionsResponse {
        fn from(value: super::ListOpenPositionsResponse) -> Self {
            Self {
                last_transaction_id: Ok(value.last_transaction_id),
                positions: Ok(value.positions),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct ListOpenTradesResponse {
        last_transaction_id: Result<Option<String>, String>,
        trades: Result<Vec<super::Trade>, String>,
    }

    impl Default for ListOpenTradesResponse {
        fn default() -> Self {
            Self {
                last_transaction_id: Ok(Default::default()),
                trades: Ok(Default::default()),
            }
        }
    }

    impl ListOpenTradesResponse {
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn trades<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Trade>>,
            T::Error: std::fmt::Display,
        {
            self.trades = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trades: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<ListOpenTradesResponse> for super::ListOpenTradesResponse {
        type Error = super::error::ConversionError;
        fn try_from(value: ListOpenTradesResponse) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                last_transaction_id: value.last_transaction_id?,
                trades: value.trades?,
            })
        }
    }

    impl From<super::ListOpenTradesResponse> for ListOpenTradesResponse {
        fn from(value: super::ListOpenTradesResponse) -> Self {
            Self {
                last_transaction_id: Ok(value.last_transaction_id),
                trades: Ok(value.trades),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct ListOrdersResponse {
        last_transaction_id: Result<Option<String>, String>,
        orders: Result<Vec<super::Order>, String>,
    }

    impl Default for ListOrdersResponse {
        fn default() -> Self {
            Self {
                last_transaction_id: Ok(Default::default()),
                orders: Ok(Default::default()),
            }
        }
    }

    impl ListOrdersResponse {
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn orders<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Order>>,
            T::Error: std::fmt::Display,
        {
            self.orders = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for orders: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<ListOrdersResponse> for super::ListOrdersResponse {
        type Error = super::error::ConversionError;
        fn try_from(value: ListOrdersResponse) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                last_transaction_id: value.last_transaction_id?,
                orders: value.orders?,
            })
        }
    }

    impl From<super::ListOrdersResponse> for ListOrdersResponse {
        fn from(value: super::ListOrdersResponse) -> Self {
            Self {
                last_transaction_id: Ok(value.last_transaction_id),
                orders: Ok(value.orders),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct ListPendingOrdersResponse {
        last_transaction_id: Result<Option<String>, String>,
        orders: Result<Vec<super::Order>, String>,
    }

    impl Default for ListPendingOrdersResponse {
        fn default() -> Self {
            Self {
                last_transaction_id: Ok(Default::default()),
                orders: Ok(Default::default()),
            }
        }
    }

    impl ListPendingOrdersResponse {
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn orders<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Order>>,
            T::Error: std::fmt::Display,
        {
            self.orders = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for orders: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<ListPendingOrdersResponse> for super::ListPendingOrdersResponse {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ListPendingOrdersResponse,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                last_transaction_id: value.last_transaction_id?,
                orders: value.orders?,
            })
        }
    }

    impl From<super::ListPendingOrdersResponse> for ListPendingOrdersResponse {
        fn from(value: super::ListPendingOrdersResponse) -> Self {
            Self {
                last_transaction_id: Ok(value.last_transaction_id),
                orders: Ok(value.orders),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct ListPositionsResponse {
        last_transaction_id: Result<Option<String>, String>,
        positions: Result<Vec<super::Position>, String>,
    }

    impl Default for ListPositionsResponse {
        fn default() -> Self {
            Self {
                last_transaction_id: Ok(Default::default()),
                positions: Ok(Default::default()),
            }
        }
    }

    impl ListPositionsResponse {
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn positions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Position>>,
            T::Error: std::fmt::Display,
        {
            self.positions = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for positions: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<ListPositionsResponse> for super::ListPositionsResponse {
        type Error = super::error::ConversionError;
        fn try_from(value: ListPositionsResponse) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                last_transaction_id: value.last_transaction_id?,
                positions: value.positions?,
            })
        }
    }

    impl From<super::ListPositionsResponse> for ListPositionsResponse {
        fn from(value: super::ListPositionsResponse) -> Self {
            Self {
                last_transaction_id: Ok(value.last_transaction_id),
                positions: Ok(value.positions),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct ListTradesResponse {
        last_transaction_id: Result<Option<String>, String>,
        trades: Result<Vec<super::Trade>, String>,
    }

    impl Default for ListTradesResponse {
        fn default() -> Self {
            Self {
                last_transaction_id: Ok(Default::default()),
                trades: Ok(Default::default()),
            }
        }
    }

    impl ListTradesResponse {
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn trades<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::Trade>>,
            T::Error: std::fmt::Display,
        {
            self.trades = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trades: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<ListTradesResponse> for super::ListTradesResponse {
        type Error = super::error::ConversionError;
        fn try_from(value: ListTradesResponse) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                last_transaction_id: value.last_transaction_id?,
                trades: value.trades?,
            })
        }
    }

    impl From<super::ListTradesResponse> for ListTradesResponse {
        fn from(value: super::ListTradesResponse) -> Self {
            Self {
                last_transaction_id: Ok(value.last_transaction_id),
                trades: Ok(value.trades),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct ListTransactionsResponse {
        count: Result<Option<i64>, String>,
        from: Result<Option<String>, String>,
        last_transaction_id: Result<Option<String>, String>,
        page_size: Result<Option<i64>, String>,
        pages: Result<Vec<String>, String>,
        to: Result<Option<String>, String>,
        type_: Result<Vec<super::ListTransactionsResponseTypeItem>, String>,
    }

    impl Default for ListTransactionsResponse {
        fn default() -> Self {
            Self {
                count: Ok(Default::default()),
                from: Ok(Default::default()),
                last_transaction_id: Ok(Default::default()),
                page_size: Ok(Default::default()),
                pages: Ok(Default::default()),
                to: Ok(Default::default()),
                type_: Ok(Default::default()),
            }
        }
    }

    impl ListTransactionsResponse {
        pub fn count<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.count = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for count: {}", e));
            self
        }
        pub fn from<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.from = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for from: {}", e));
            self
        }
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn page_size<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.page_size = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for page_size: {}", e));
            self
        }
        pub fn pages<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self.pages = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for pages: {}", e));
            self
        }
        pub fn to<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.to = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for to: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::ListTransactionsResponseTypeItem>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<ListTransactionsResponse> for super::ListTransactionsResponse {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ListTransactionsResponse,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                count: value.count?,
                from: value.from?,
                last_transaction_id: value.last_transaction_id?,
                page_size: value.page_size?,
                pages: value.pages?,
                to: value.to?,
                type_: value.type_?,
            })
        }
    }

    impl From<super::ListTransactionsResponse> for ListTransactionsResponse {
        fn from(value: super::ListTransactionsResponse) -> Self {
            Self {
                count: Ok(value.count),
                from: Ok(value.from),
                last_transaction_id: Ok(value.last_transaction_id),
                page_size: Ok(value.page_size),
                pages: Ok(value.pages),
                to: Ok(value.to),
                type_: Ok(value.type_),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct MarginCallEnterTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        request_id: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
        type_: Result<Option<super::MarginCallEnterTransactionType>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for MarginCallEnterTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                id: Ok(Default::default()),
                request_id: Ok(Default::default()),
                time: Ok(Default::default()),
                type_: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl MarginCallEnterTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarginCallEnterTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<MarginCallEnterTransaction> for super::MarginCallEnterTransaction {
        type Error = super::error::ConversionError;
        fn try_from(
            value: MarginCallEnterTransaction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                id: value.id?,
                request_id: value.request_id?,
                time: value.time?,
                type_: value.type_?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::MarginCallEnterTransaction> for MarginCallEnterTransaction {
        fn from(value: super::MarginCallEnterTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                id: Ok(value.id),
                request_id: Ok(value.request_id),
                time: Ok(value.time),
                type_: Ok(value.type_),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct MarginCallExitTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        request_id: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
        type_: Result<Option<super::MarginCallExitTransactionType>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for MarginCallExitTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                id: Ok(Default::default()),
                request_id: Ok(Default::default()),
                time: Ok(Default::default()),
                type_: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl MarginCallExitTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarginCallExitTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<MarginCallExitTransaction> for super::MarginCallExitTransaction {
        type Error = super::error::ConversionError;
        fn try_from(
            value: MarginCallExitTransaction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                id: value.id?,
                request_id: value.request_id?,
                time: value.time?,
                type_: value.type_?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::MarginCallExitTransaction> for MarginCallExitTransaction {
        fn from(value: super::MarginCallExitTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                id: Ok(value.id),
                request_id: Ok(value.request_id),
                time: Ok(value.time),
                type_: Ok(value.type_),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct MarginCallExtendTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        extension_number: Result<Option<i64>, String>,
        id: Result<Option<String>, String>,
        request_id: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
        type_: Result<Option<super::MarginCallExtendTransactionType>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for MarginCallExtendTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                extension_number: Ok(Default::default()),
                id: Ok(Default::default()),
                request_id: Ok(Default::default()),
                time: Ok(Default::default()),
                type_: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl MarginCallExtendTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn extension_number<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.extension_number = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for extension_number: {}",
                    e
                )
            });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarginCallExtendTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<MarginCallExtendTransaction> for super::MarginCallExtendTransaction {
        type Error = super::error::ConversionError;
        fn try_from(
            value: MarginCallExtendTransaction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                extension_number: value.extension_number?,
                id: value.id?,
                request_id: value.request_id?,
                time: value.time?,
                type_: value.type_?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::MarginCallExtendTransaction> for MarginCallExtendTransaction {
        fn from(value: super::MarginCallExtendTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                extension_number: Ok(value.extension_number),
                id: Ok(value.id),
                request_id: Ok(value.request_id),
                time: Ok(value.time),
                type_: Ok(value.type_),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct MarketIfTouchedOrder {
        cancelled_time: Result<Option<String>, String>,
        cancelling_transaction_id: Result<Option<String>, String>,
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        create_time: Result<Option<String>, String>,
        filled_time: Result<Option<String>, String>,
        filling_transaction_id: Result<Option<String>, String>,
        gtd_time: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        initial_market_price: Result<Option<String>, String>,
        instrument: Result<Option<String>, String>,
        position_fill: Result<Option<super::MarketIfTouchedOrderPositionFill>, String>,
        price: Result<Option<String>, String>,
        price_bound: Result<Option<String>, String>,
        replaced_by_order_id: Result<Option<String>, String>,
        replaces_order_id: Result<Option<String>, String>,
        state: Result<Option<super::MarketIfTouchedOrderState>, String>,
        stop_loss_on_fill: Result<Option<super::StopLossDetails>, String>,
        take_profit_on_fill: Result<Option<super::TakeProfitDetails>, String>,
        time_in_force: Result<Option<super::MarketIfTouchedOrderTimeInForce>, String>,
        trade_client_extensions: Result<Option<super::ClientExtensions>, String>,
        trade_closed_i_ds: Result<Vec<String>, String>,
        trade_opened_id: Result<Option<String>, String>,
        trade_reduced_id: Result<Option<String>, String>,
        trailing_stop_loss_on_fill: Result<Option<super::TrailingStopLossDetails>, String>,
        trigger_condition: Result<Option<super::MarketIfTouchedOrderTriggerCondition>, String>,
        type_: Result<Option<super::MarketIfTouchedOrderType>, String>,
        units: Result<Option<String>, String>,
    }

    impl Default for MarketIfTouchedOrder {
        fn default() -> Self {
            Self {
                cancelled_time: Ok(Default::default()),
                cancelling_transaction_id: Ok(Default::default()),
                client_extensions: Ok(Default::default()),
                create_time: Ok(Default::default()),
                filled_time: Ok(Default::default()),
                filling_transaction_id: Ok(Default::default()),
                gtd_time: Ok(Default::default()),
                id: Ok(Default::default()),
                initial_market_price: Ok(Default::default()),
                instrument: Ok(Default::default()),
                position_fill: Ok(Default::default()),
                price: Ok(Default::default()),
                price_bound: Ok(Default::default()),
                replaced_by_order_id: Ok(Default::default()),
                replaces_order_id: Ok(Default::default()),
                state: Ok(Default::default()),
                stop_loss_on_fill: Ok(Default::default()),
                take_profit_on_fill: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_client_extensions: Ok(Default::default()),
                trade_closed_i_ds: Ok(Default::default()),
                trade_opened_id: Ok(Default::default()),
                trade_reduced_id: Ok(Default::default()),
                trailing_stop_loss_on_fill: Ok(Default::default()),
                trigger_condition: Ok(Default::default()),
                type_: Ok(Default::default()),
                units: Ok(Default::default()),
            }
        }
    }

    impl MarketIfTouchedOrder {
        pub fn cancelled_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.cancelled_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for cancelled_time: {}", e));
            self
        }
        pub fn cancelling_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.cancelling_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for cancelling_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn create_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.create_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for create_time: {}", e));
            self
        }
        pub fn filled_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.filled_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for filled_time: {}", e));
            self
        }
        pub fn filling_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.filling_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for filling_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn gtd_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gtd_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for gtd_time: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn initial_market_price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.initial_market_price = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for initial_market_price: {}",
                    e
                )
            });
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn position_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketIfTouchedOrderPositionFill>>,
            T::Error: std::fmt::Display,
        {
            self.position_fill = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for position_fill: {}", e));
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn price_bound<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price_bound = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price_bound: {}", e));
            self
        }
        pub fn replaced_by_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.replaced_by_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for replaced_by_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn replaces_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.replaces_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for replaces_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn state<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketIfTouchedOrderState>>,
            T::Error: std::fmt::Display,
        {
            self.state = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for state: {}", e));
            self
        }
        pub fn stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn take_profit_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitDetails>>,
            T::Error: std::fmt::Display,
        {
            self.take_profit_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for take_profit_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketIfTouchedOrderTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.trade_client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn trade_closed_i_ds<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_closed_i_ds = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_closed_i_ds: {}",
                    e
                )
            });
            self
        }
        pub fn trade_opened_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_opened_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_opened_id: {}", e));
            self
        }
        pub fn trade_reduced_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_reduced_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_reduced_id: {}",
                    e
                )
            });
            self
        }
        pub fn trailing_stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.trailing_stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trailing_stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn trigger_condition<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketIfTouchedOrderTriggerCondition>>,
            T::Error: std::fmt::Display,
        {
            self.trigger_condition = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trigger_condition: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketIfTouchedOrderType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for units: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<MarketIfTouchedOrder> for super::MarketIfTouchedOrder {
        type Error = super::error::ConversionError;
        fn try_from(value: MarketIfTouchedOrder) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                cancelled_time: value.cancelled_time?,
                cancelling_transaction_id: value.cancelling_transaction_id?,
                client_extensions: value.client_extensions?,
                create_time: value.create_time?,
                filled_time: value.filled_time?,
                filling_transaction_id: value.filling_transaction_id?,
                gtd_time: value.gtd_time?,
                id: value.id?,
                initial_market_price: value.initial_market_price?,
                instrument: value.instrument?,
                position_fill: value.position_fill?,
                price: value.price?,
                price_bound: value.price_bound?,
                replaced_by_order_id: value.replaced_by_order_id?,
                replaces_order_id: value.replaces_order_id?,
                state: value.state?,
                stop_loss_on_fill: value.stop_loss_on_fill?,
                take_profit_on_fill: value.take_profit_on_fill?,
                time_in_force: value.time_in_force?,
                trade_client_extensions: value.trade_client_extensions?,
                trade_closed_i_ds: value.trade_closed_i_ds?,
                trade_opened_id: value.trade_opened_id?,
                trade_reduced_id: value.trade_reduced_id?,
                trailing_stop_loss_on_fill: value.trailing_stop_loss_on_fill?,
                trigger_condition: value.trigger_condition?,
                type_: value.type_?,
                units: value.units?,
            })
        }
    }

    impl From<super::MarketIfTouchedOrder> for MarketIfTouchedOrder {
        fn from(value: super::MarketIfTouchedOrder) -> Self {
            Self {
                cancelled_time: Ok(value.cancelled_time),
                cancelling_transaction_id: Ok(value.cancelling_transaction_id),
                client_extensions: Ok(value.client_extensions),
                create_time: Ok(value.create_time),
                filled_time: Ok(value.filled_time),
                filling_transaction_id: Ok(value.filling_transaction_id),
                gtd_time: Ok(value.gtd_time),
                id: Ok(value.id),
                initial_market_price: Ok(value.initial_market_price),
                instrument: Ok(value.instrument),
                position_fill: Ok(value.position_fill),
                price: Ok(value.price),
                price_bound: Ok(value.price_bound),
                replaced_by_order_id: Ok(value.replaced_by_order_id),
                replaces_order_id: Ok(value.replaces_order_id),
                state: Ok(value.state),
                stop_loss_on_fill: Ok(value.stop_loss_on_fill),
                take_profit_on_fill: Ok(value.take_profit_on_fill),
                time_in_force: Ok(value.time_in_force),
                trade_client_extensions: Ok(value.trade_client_extensions),
                trade_closed_i_ds: Ok(value.trade_closed_i_ds),
                trade_opened_id: Ok(value.trade_opened_id),
                trade_reduced_id: Ok(value.trade_reduced_id),
                trailing_stop_loss_on_fill: Ok(value.trailing_stop_loss_on_fill),
                trigger_condition: Ok(value.trigger_condition),
                type_: Ok(value.type_),
                units: Ok(value.units),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct MarketIfTouchedOrderRejectTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        gtd_time: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        instrument: Result<Option<String>, String>,
        intended_replaces_order_id: Result<Option<String>, String>,
        position_fill:
            Result<Option<super::MarketIfTouchedOrderRejectTransactionPositionFill>, String>,
        price: Result<Option<String>, String>,
        price_bound: Result<Option<String>, String>,
        reason: Result<Option<super::MarketIfTouchedOrderRejectTransactionReason>, String>,
        reject_reason:
            Result<Option<super::MarketIfTouchedOrderRejectTransactionRejectReason>, String>,
        request_id: Result<Option<String>, String>,
        stop_loss_on_fill: Result<Option<super::StopLossDetails>, String>,
        take_profit_on_fill: Result<Option<super::TakeProfitDetails>, String>,
        time: Result<Option<String>, String>,
        time_in_force:
            Result<Option<super::MarketIfTouchedOrderRejectTransactionTimeInForce>, String>,
        trade_client_extensions: Result<Option<super::ClientExtensions>, String>,
        trailing_stop_loss_on_fill: Result<Option<super::TrailingStopLossDetails>, String>,
        trigger_condition:
            Result<Option<super::MarketIfTouchedOrderRejectTransactionTriggerCondition>, String>,
        type_: Result<Option<super::MarketIfTouchedOrderRejectTransactionType>, String>,
        units: Result<Option<String>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for MarketIfTouchedOrderRejectTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                client_extensions: Ok(Default::default()),
                gtd_time: Ok(Default::default()),
                id: Ok(Default::default()),
                instrument: Ok(Default::default()),
                intended_replaces_order_id: Ok(Default::default()),
                position_fill: Ok(Default::default()),
                price: Ok(Default::default()),
                price_bound: Ok(Default::default()),
                reason: Ok(Default::default()),
                reject_reason: Ok(Default::default()),
                request_id: Ok(Default::default()),
                stop_loss_on_fill: Ok(Default::default()),
                take_profit_on_fill: Ok(Default::default()),
                time: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_client_extensions: Ok(Default::default()),
                trailing_stop_loss_on_fill: Ok(Default::default()),
                trigger_condition: Ok(Default::default()),
                type_: Ok(Default::default()),
                units: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl MarketIfTouchedOrderRejectTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn gtd_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gtd_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for gtd_time: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn intended_replaces_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.intended_replaces_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for intended_replaces_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn position_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::MarketIfTouchedOrderRejectTransactionPositionFill>,
            >,
            T::Error: std::fmt::Display,
        {
            self.position_fill = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for position_fill: {}", e));
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn price_bound<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price_bound = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price_bound: {}", e));
            self
        }
        pub fn reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketIfTouchedOrderRejectTransactionReason>>,
            T::Error: std::fmt::Display,
        {
            self.reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reason: {}", e));
            self
        }
        pub fn reject_reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::MarketIfTouchedOrderRejectTransactionRejectReason>,
            >,
            T::Error: std::fmt::Display,
        {
            self.reject_reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reject_reason: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn take_profit_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitDetails>>,
            T::Error: std::fmt::Display,
        {
            self.take_profit_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for take_profit_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::MarketIfTouchedOrderRejectTransactionTimeInForce>,
            >,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.trade_client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn trailing_stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.trailing_stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trailing_stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn trigger_condition<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::MarketIfTouchedOrderRejectTransactionTriggerCondition>,
            >,
            T::Error: std::fmt::Display,
        {
            self.trigger_condition = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trigger_condition: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketIfTouchedOrderRejectTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for units: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<MarketIfTouchedOrderRejectTransaction>
        for super::MarketIfTouchedOrderRejectTransaction
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: MarketIfTouchedOrderRejectTransaction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                client_extensions: value.client_extensions?,
                gtd_time: value.gtd_time?,
                id: value.id?,
                instrument: value.instrument?,
                intended_replaces_order_id: value.intended_replaces_order_id?,
                position_fill: value.position_fill?,
                price: value.price?,
                price_bound: value.price_bound?,
                reason: value.reason?,
                reject_reason: value.reject_reason?,
                request_id: value.request_id?,
                stop_loss_on_fill: value.stop_loss_on_fill?,
                take_profit_on_fill: value.take_profit_on_fill?,
                time: value.time?,
                time_in_force: value.time_in_force?,
                trade_client_extensions: value.trade_client_extensions?,
                trailing_stop_loss_on_fill: value.trailing_stop_loss_on_fill?,
                trigger_condition: value.trigger_condition?,
                type_: value.type_?,
                units: value.units?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::MarketIfTouchedOrderRejectTransaction> for MarketIfTouchedOrderRejectTransaction {
        fn from(value: super::MarketIfTouchedOrderRejectTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                client_extensions: Ok(value.client_extensions),
                gtd_time: Ok(value.gtd_time),
                id: Ok(value.id),
                instrument: Ok(value.instrument),
                intended_replaces_order_id: Ok(value.intended_replaces_order_id),
                position_fill: Ok(value.position_fill),
                price: Ok(value.price),
                price_bound: Ok(value.price_bound),
                reason: Ok(value.reason),
                reject_reason: Ok(value.reject_reason),
                request_id: Ok(value.request_id),
                stop_loss_on_fill: Ok(value.stop_loss_on_fill),
                take_profit_on_fill: Ok(value.take_profit_on_fill),
                time: Ok(value.time),
                time_in_force: Ok(value.time_in_force),
                trade_client_extensions: Ok(value.trade_client_extensions),
                trailing_stop_loss_on_fill: Ok(value.trailing_stop_loss_on_fill),
                trigger_condition: Ok(value.trigger_condition),
                type_: Ok(value.type_),
                units: Ok(value.units),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct MarketIfTouchedOrderRequest {
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        gtd_time: Result<Option<String>, String>,
        instrument: Result<Option<String>, String>,
        position_fill: Result<Option<super::MarketIfTouchedOrderRequestPositionFill>, String>,
        price: Result<Option<String>, String>,
        price_bound: Result<Option<String>, String>,
        stop_loss_on_fill: Result<Option<super::StopLossDetails>, String>,
        take_profit_on_fill: Result<Option<super::TakeProfitDetails>, String>,
        time_in_force: Result<Option<super::MarketIfTouchedOrderRequestTimeInForce>, String>,
        trade_client_extensions: Result<Option<super::ClientExtensions>, String>,
        trailing_stop_loss_on_fill: Result<Option<super::TrailingStopLossDetails>, String>,
        trigger_condition:
            Result<Option<super::MarketIfTouchedOrderRequestTriggerCondition>, String>,
        type_: Result<Option<super::MarketIfTouchedOrderRequestType>, String>,
        units: Result<Option<String>, String>,
    }

    impl Default for MarketIfTouchedOrderRequest {
        fn default() -> Self {
            Self {
                client_extensions: Ok(Default::default()),
                gtd_time: Ok(Default::default()),
                instrument: Ok(Default::default()),
                position_fill: Ok(Default::default()),
                price: Ok(Default::default()),
                price_bound: Ok(Default::default()),
                stop_loss_on_fill: Ok(Default::default()),
                take_profit_on_fill: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_client_extensions: Ok(Default::default()),
                trailing_stop_loss_on_fill: Ok(Default::default()),
                trigger_condition: Ok(Default::default()),
                type_: Ok(Default::default()),
                units: Ok(Default::default()),
            }
        }
    }

    impl MarketIfTouchedOrderRequest {
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn gtd_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gtd_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for gtd_time: {}", e));
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn position_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketIfTouchedOrderRequestPositionFill>>,
            T::Error: std::fmt::Display,
        {
            self.position_fill = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for position_fill: {}", e));
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn price_bound<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price_bound = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price_bound: {}", e));
            self
        }
        pub fn stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn take_profit_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitDetails>>,
            T::Error: std::fmt::Display,
        {
            self.take_profit_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for take_profit_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketIfTouchedOrderRequestTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.trade_client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn trailing_stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.trailing_stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trailing_stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn trigger_condition<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketIfTouchedOrderRequestTriggerCondition>>,
            T::Error: std::fmt::Display,
        {
            self.trigger_condition = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trigger_condition: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketIfTouchedOrderRequestType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for units: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<MarketIfTouchedOrderRequest> for super::MarketIfTouchedOrderRequest {
        type Error = super::error::ConversionError;
        fn try_from(
            value: MarketIfTouchedOrderRequest,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                client_extensions: value.client_extensions?,
                gtd_time: value.gtd_time?,
                instrument: value.instrument?,
                position_fill: value.position_fill?,
                price: value.price?,
                price_bound: value.price_bound?,
                stop_loss_on_fill: value.stop_loss_on_fill?,
                take_profit_on_fill: value.take_profit_on_fill?,
                time_in_force: value.time_in_force?,
                trade_client_extensions: value.trade_client_extensions?,
                trailing_stop_loss_on_fill: value.trailing_stop_loss_on_fill?,
                trigger_condition: value.trigger_condition?,
                type_: value.type_?,
                units: value.units?,
            })
        }
    }

    impl From<super::MarketIfTouchedOrderRequest> for MarketIfTouchedOrderRequest {
        fn from(value: super::MarketIfTouchedOrderRequest) -> Self {
            Self {
                client_extensions: Ok(value.client_extensions),
                gtd_time: Ok(value.gtd_time),
                instrument: Ok(value.instrument),
                position_fill: Ok(value.position_fill),
                price: Ok(value.price),
                price_bound: Ok(value.price_bound),
                stop_loss_on_fill: Ok(value.stop_loss_on_fill),
                take_profit_on_fill: Ok(value.take_profit_on_fill),
                time_in_force: Ok(value.time_in_force),
                trade_client_extensions: Ok(value.trade_client_extensions),
                trailing_stop_loss_on_fill: Ok(value.trailing_stop_loss_on_fill),
                trigger_condition: Ok(value.trigger_condition),
                type_: Ok(value.type_),
                units: Ok(value.units),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct MarketIfTouchedOrderTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        cancelling_transaction_id: Result<Option<String>, String>,
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        gtd_time: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        instrument: Result<Option<String>, String>,
        position_fill: Result<Option<super::MarketIfTouchedOrderTransactionPositionFill>, String>,
        price: Result<Option<String>, String>,
        price_bound: Result<Option<String>, String>,
        reason: Result<Option<super::MarketIfTouchedOrderTransactionReason>, String>,
        replaces_order_id: Result<Option<String>, String>,
        request_id: Result<Option<String>, String>,
        stop_loss_on_fill: Result<Option<super::StopLossDetails>, String>,
        take_profit_on_fill: Result<Option<super::TakeProfitDetails>, String>,
        time: Result<Option<String>, String>,
        time_in_force: Result<Option<super::MarketIfTouchedOrderTransactionTimeInForce>, String>,
        trade_client_extensions: Result<Option<super::ClientExtensions>, String>,
        trailing_stop_loss_on_fill: Result<Option<super::TrailingStopLossDetails>, String>,
        trigger_condition:
            Result<Option<super::MarketIfTouchedOrderTransactionTriggerCondition>, String>,
        type_: Result<Option<super::MarketIfTouchedOrderTransactionType>, String>,
        units: Result<Option<String>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for MarketIfTouchedOrderTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                cancelling_transaction_id: Ok(Default::default()),
                client_extensions: Ok(Default::default()),
                gtd_time: Ok(Default::default()),
                id: Ok(Default::default()),
                instrument: Ok(Default::default()),
                position_fill: Ok(Default::default()),
                price: Ok(Default::default()),
                price_bound: Ok(Default::default()),
                reason: Ok(Default::default()),
                replaces_order_id: Ok(Default::default()),
                request_id: Ok(Default::default()),
                stop_loss_on_fill: Ok(Default::default()),
                take_profit_on_fill: Ok(Default::default()),
                time: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_client_extensions: Ok(Default::default()),
                trailing_stop_loss_on_fill: Ok(Default::default()),
                trigger_condition: Ok(Default::default()),
                type_: Ok(Default::default()),
                units: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl MarketIfTouchedOrderTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn cancelling_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.cancelling_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for cancelling_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn gtd_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gtd_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for gtd_time: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn position_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketIfTouchedOrderTransactionPositionFill>>,
            T::Error: std::fmt::Display,
        {
            self.position_fill = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for position_fill: {}", e));
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn price_bound<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price_bound = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price_bound: {}", e));
            self
        }
        pub fn reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketIfTouchedOrderTransactionReason>>,
            T::Error: std::fmt::Display,
        {
            self.reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reason: {}", e));
            self
        }
        pub fn replaces_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.replaces_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for replaces_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn take_profit_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitDetails>>,
            T::Error: std::fmt::Display,
        {
            self.take_profit_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for take_profit_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketIfTouchedOrderTransactionTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.trade_client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn trailing_stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.trailing_stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trailing_stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn trigger_condition<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::MarketIfTouchedOrderTransactionTriggerCondition>,
            >,
            T::Error: std::fmt::Display,
        {
            self.trigger_condition = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trigger_condition: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketIfTouchedOrderTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for units: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<MarketIfTouchedOrderTransaction>
        for super::MarketIfTouchedOrderTransaction
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: MarketIfTouchedOrderTransaction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                cancelling_transaction_id: value.cancelling_transaction_id?,
                client_extensions: value.client_extensions?,
                gtd_time: value.gtd_time?,
                id: value.id?,
                instrument: value.instrument?,
                position_fill: value.position_fill?,
                price: value.price?,
                price_bound: value.price_bound?,
                reason: value.reason?,
                replaces_order_id: value.replaces_order_id?,
                request_id: value.request_id?,
                stop_loss_on_fill: value.stop_loss_on_fill?,
                take_profit_on_fill: value.take_profit_on_fill?,
                time: value.time?,
                time_in_force: value.time_in_force?,
                trade_client_extensions: value.trade_client_extensions?,
                trailing_stop_loss_on_fill: value.trailing_stop_loss_on_fill?,
                trigger_condition: value.trigger_condition?,
                type_: value.type_?,
                units: value.units?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::MarketIfTouchedOrderTransaction> for MarketIfTouchedOrderTransaction {
        fn from(value: super::MarketIfTouchedOrderTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                cancelling_transaction_id: Ok(value.cancelling_transaction_id),
                client_extensions: Ok(value.client_extensions),
                gtd_time: Ok(value.gtd_time),
                id: Ok(value.id),
                instrument: Ok(value.instrument),
                position_fill: Ok(value.position_fill),
                price: Ok(value.price),
                price_bound: Ok(value.price_bound),
                reason: Ok(value.reason),
                replaces_order_id: Ok(value.replaces_order_id),
                request_id: Ok(value.request_id),
                stop_loss_on_fill: Ok(value.stop_loss_on_fill),
                take_profit_on_fill: Ok(value.take_profit_on_fill),
                time: Ok(value.time),
                time_in_force: Ok(value.time_in_force),
                trade_client_extensions: Ok(value.trade_client_extensions),
                trailing_stop_loss_on_fill: Ok(value.trailing_stop_loss_on_fill),
                trigger_condition: Ok(value.trigger_condition),
                type_: Ok(value.type_),
                units: Ok(value.units),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct MarketOrder {
        cancelled_time: Result<Option<String>, String>,
        cancelling_transaction_id: Result<Option<String>, String>,
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        create_time: Result<Option<String>, String>,
        delayed_trade_close: Result<Option<super::MarketOrderDelayedTradeClose>, String>,
        filled_time: Result<Option<String>, String>,
        filling_transaction_id: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        instrument: Result<Option<String>, String>,
        long_position_closeout: Result<Option<super::MarketOrderPositionCloseout>, String>,
        margin_closeout: Result<Option<super::MarketOrderMarginCloseout>, String>,
        position_fill: Result<Option<super::MarketOrderPositionFill>, String>,
        price_bound: Result<Option<String>, String>,
        short_position_closeout: Result<Option<super::MarketOrderPositionCloseout>, String>,
        state: Result<Option<super::MarketOrderState>, String>,
        stop_loss_on_fill: Result<Option<super::StopLossDetails>, String>,
        take_profit_on_fill: Result<Option<super::TakeProfitDetails>, String>,
        time_in_force: Result<Option<super::MarketOrderTimeInForce>, String>,
        trade_client_extensions: Result<Option<super::ClientExtensions>, String>,
        trade_close: Result<Option<super::MarketOrderTradeClose>, String>,
        trade_closed_i_ds: Result<Vec<String>, String>,
        trade_opened_id: Result<Option<String>, String>,
        trade_reduced_id: Result<Option<String>, String>,
        trailing_stop_loss_on_fill: Result<Option<super::TrailingStopLossDetails>, String>,
        type_: Result<Option<super::MarketOrderType>, String>,
        units: Result<Option<String>, String>,
    }

    impl Default for MarketOrder {
        fn default() -> Self {
            Self {
                cancelled_time: Ok(Default::default()),
                cancelling_transaction_id: Ok(Default::default()),
                client_extensions: Ok(Default::default()),
                create_time: Ok(Default::default()),
                delayed_trade_close: Ok(Default::default()),
                filled_time: Ok(Default::default()),
                filling_transaction_id: Ok(Default::default()),
                id: Ok(Default::default()),
                instrument: Ok(Default::default()),
                long_position_closeout: Ok(Default::default()),
                margin_closeout: Ok(Default::default()),
                position_fill: Ok(Default::default()),
                price_bound: Ok(Default::default()),
                short_position_closeout: Ok(Default::default()),
                state: Ok(Default::default()),
                stop_loss_on_fill: Ok(Default::default()),
                take_profit_on_fill: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_client_extensions: Ok(Default::default()),
                trade_close: Ok(Default::default()),
                trade_closed_i_ds: Ok(Default::default()),
                trade_opened_id: Ok(Default::default()),
                trade_reduced_id: Ok(Default::default()),
                trailing_stop_loss_on_fill: Ok(Default::default()),
                type_: Ok(Default::default()),
                units: Ok(Default::default()),
            }
        }
    }

    impl MarketOrder {
        pub fn cancelled_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.cancelled_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for cancelled_time: {}", e));
            self
        }
        pub fn cancelling_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.cancelling_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for cancelling_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn create_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.create_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for create_time: {}", e));
            self
        }
        pub fn delayed_trade_close<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderDelayedTradeClose>>,
            T::Error: std::fmt::Display,
        {
            self.delayed_trade_close = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for delayed_trade_close: {}",
                    e
                )
            });
            self
        }
        pub fn filled_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.filled_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for filled_time: {}", e));
            self
        }
        pub fn filling_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.filling_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for filling_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn long_position_closeout<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderPositionCloseout>>,
            T::Error: std::fmt::Display,
        {
            self.long_position_closeout = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for long_position_closeout: {}",
                    e
                )
            });
            self
        }
        pub fn margin_closeout<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderMarginCloseout>>,
            T::Error: std::fmt::Display,
        {
            self.margin_closeout = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for margin_closeout: {}", e));
            self
        }
        pub fn position_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderPositionFill>>,
            T::Error: std::fmt::Display,
        {
            self.position_fill = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for position_fill: {}", e));
            self
        }
        pub fn price_bound<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price_bound = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price_bound: {}", e));
            self
        }
        pub fn short_position_closeout<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderPositionCloseout>>,
            T::Error: std::fmt::Display,
        {
            self.short_position_closeout = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for short_position_closeout: {}",
                    e
                )
            });
            self
        }
        pub fn state<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderState>>,
            T::Error: std::fmt::Display,
        {
            self.state = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for state: {}", e));
            self
        }
        pub fn stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn take_profit_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitDetails>>,
            T::Error: std::fmt::Display,
        {
            self.take_profit_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for take_profit_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.trade_client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn trade_close<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderTradeClose>>,
            T::Error: std::fmt::Display,
        {
            self.trade_close = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_close: {}", e));
            self
        }
        pub fn trade_closed_i_ds<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_closed_i_ds = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_closed_i_ds: {}",
                    e
                )
            });
            self
        }
        pub fn trade_opened_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_opened_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_opened_id: {}", e));
            self
        }
        pub fn trade_reduced_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_reduced_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_reduced_id: {}",
                    e
                )
            });
            self
        }
        pub fn trailing_stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.trailing_stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trailing_stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for units: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<MarketOrder> for super::MarketOrder {
        type Error = super::error::ConversionError;
        fn try_from(value: MarketOrder) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                cancelled_time: value.cancelled_time?,
                cancelling_transaction_id: value.cancelling_transaction_id?,
                client_extensions: value.client_extensions?,
                create_time: value.create_time?,
                delayed_trade_close: value.delayed_trade_close?,
                filled_time: value.filled_time?,
                filling_transaction_id: value.filling_transaction_id?,
                id: value.id?,
                instrument: value.instrument?,
                long_position_closeout: value.long_position_closeout?,
                margin_closeout: value.margin_closeout?,
                position_fill: value.position_fill?,
                price_bound: value.price_bound?,
                short_position_closeout: value.short_position_closeout?,
                state: value.state?,
                stop_loss_on_fill: value.stop_loss_on_fill?,
                take_profit_on_fill: value.take_profit_on_fill?,
                time_in_force: value.time_in_force?,
                trade_client_extensions: value.trade_client_extensions?,
                trade_close: value.trade_close?,
                trade_closed_i_ds: value.trade_closed_i_ds?,
                trade_opened_id: value.trade_opened_id?,
                trade_reduced_id: value.trade_reduced_id?,
                trailing_stop_loss_on_fill: value.trailing_stop_loss_on_fill?,
                type_: value.type_?,
                units: value.units?,
            })
        }
    }

    impl From<super::MarketOrder> for MarketOrder {
        fn from(value: super::MarketOrder) -> Self {
            Self {
                cancelled_time: Ok(value.cancelled_time),
                cancelling_transaction_id: Ok(value.cancelling_transaction_id),
                client_extensions: Ok(value.client_extensions),
                create_time: Ok(value.create_time),
                delayed_trade_close: Ok(value.delayed_trade_close),
                filled_time: Ok(value.filled_time),
                filling_transaction_id: Ok(value.filling_transaction_id),
                id: Ok(value.id),
                instrument: Ok(value.instrument),
                long_position_closeout: Ok(value.long_position_closeout),
                margin_closeout: Ok(value.margin_closeout),
                position_fill: Ok(value.position_fill),
                price_bound: Ok(value.price_bound),
                short_position_closeout: Ok(value.short_position_closeout),
                state: Ok(value.state),
                stop_loss_on_fill: Ok(value.stop_loss_on_fill),
                take_profit_on_fill: Ok(value.take_profit_on_fill),
                time_in_force: Ok(value.time_in_force),
                trade_client_extensions: Ok(value.trade_client_extensions),
                trade_close: Ok(value.trade_close),
                trade_closed_i_ds: Ok(value.trade_closed_i_ds),
                trade_opened_id: Ok(value.trade_opened_id),
                trade_reduced_id: Ok(value.trade_reduced_id),
                trailing_stop_loss_on_fill: Ok(value.trailing_stop_loss_on_fill),
                type_: Ok(value.type_),
                units: Ok(value.units),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct MarketOrderDelayedTradeClose {
        client_trade_id: Result<Option<String>, String>,
        source_transaction_id: Result<Option<String>, String>,
        trade_id: Result<Option<String>, String>,
    }

    impl Default for MarketOrderDelayedTradeClose {
        fn default() -> Self {
            Self {
                client_trade_id: Ok(Default::default()),
                source_transaction_id: Ok(Default::default()),
                trade_id: Ok(Default::default()),
            }
        }
    }

    impl MarketOrderDelayedTradeClose {
        pub fn client_trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.client_trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for client_trade_id: {}", e));
            self
        }
        pub fn source_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.source_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for source_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<MarketOrderDelayedTradeClose> for super::MarketOrderDelayedTradeClose {
        type Error = super::error::ConversionError;
        fn try_from(
            value: MarketOrderDelayedTradeClose,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                client_trade_id: value.client_trade_id?,
                source_transaction_id: value.source_transaction_id?,
                trade_id: value.trade_id?,
            })
        }
    }

    impl From<super::MarketOrderDelayedTradeClose> for MarketOrderDelayedTradeClose {
        fn from(value: super::MarketOrderDelayedTradeClose) -> Self {
            Self {
                client_trade_id: Ok(value.client_trade_id),
                source_transaction_id: Ok(value.source_transaction_id),
                trade_id: Ok(value.trade_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct MarketOrderMarginCloseout {
        reason: Result<Option<super::MarketOrderMarginCloseoutReason>, String>,
    }

    impl Default for MarketOrderMarginCloseout {
        fn default() -> Self {
            Self {
                reason: Ok(Default::default()),
            }
        }
    }

    impl MarketOrderMarginCloseout {
        pub fn reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderMarginCloseoutReason>>,
            T::Error: std::fmt::Display,
        {
            self.reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reason: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<MarketOrderMarginCloseout> for super::MarketOrderMarginCloseout {
        type Error = super::error::ConversionError;
        fn try_from(
            value: MarketOrderMarginCloseout,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                reason: value.reason?,
            })
        }
    }

    impl From<super::MarketOrderMarginCloseout> for MarketOrderMarginCloseout {
        fn from(value: super::MarketOrderMarginCloseout) -> Self {
            Self {
                reason: Ok(value.reason),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct MarketOrderPositionCloseout {
        instrument: Result<Option<String>, String>,
        units: Result<Option<String>, String>,
    }

    impl Default for MarketOrderPositionCloseout {
        fn default() -> Self {
            Self {
                instrument: Ok(Default::default()),
                units: Ok(Default::default()),
            }
        }
    }

    impl MarketOrderPositionCloseout {
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for units: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<MarketOrderPositionCloseout> for super::MarketOrderPositionCloseout {
        type Error = super::error::ConversionError;
        fn try_from(
            value: MarketOrderPositionCloseout,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                instrument: value.instrument?,
                units: value.units?,
            })
        }
    }

    impl From<super::MarketOrderPositionCloseout> for MarketOrderPositionCloseout {
        fn from(value: super::MarketOrderPositionCloseout) -> Self {
            Self {
                instrument: Ok(value.instrument),
                units: Ok(value.units),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct MarketOrderRejectTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        delayed_trade_close: Result<Option<super::MarketOrderDelayedTradeClose>, String>,
        id: Result<Option<String>, String>,
        instrument: Result<Option<String>, String>,
        long_position_closeout: Result<Option<super::MarketOrderPositionCloseout>, String>,
        margin_closeout: Result<Option<super::MarketOrderMarginCloseout>, String>,
        position_fill: Result<Option<super::MarketOrderRejectTransactionPositionFill>, String>,
        price_bound: Result<Option<String>, String>,
        reason: Result<Option<super::MarketOrderRejectTransactionReason>, String>,
        reject_reason: Result<Option<super::MarketOrderRejectTransactionRejectReason>, String>,
        request_id: Result<Option<String>, String>,
        short_position_closeout: Result<Option<super::MarketOrderPositionCloseout>, String>,
        stop_loss_on_fill: Result<Option<super::StopLossDetails>, String>,
        take_profit_on_fill: Result<Option<super::TakeProfitDetails>, String>,
        time: Result<Option<String>, String>,
        time_in_force: Result<Option<super::MarketOrderRejectTransactionTimeInForce>, String>,
        trade_client_extensions: Result<Option<super::ClientExtensions>, String>,
        trade_close: Result<Option<super::MarketOrderTradeClose>, String>,
        trailing_stop_loss_on_fill: Result<Option<super::TrailingStopLossDetails>, String>,
        type_: Result<Option<super::MarketOrderRejectTransactionType>, String>,
        units: Result<Option<String>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for MarketOrderRejectTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                client_extensions: Ok(Default::default()),
                delayed_trade_close: Ok(Default::default()),
                id: Ok(Default::default()),
                instrument: Ok(Default::default()),
                long_position_closeout: Ok(Default::default()),
                margin_closeout: Ok(Default::default()),
                position_fill: Ok(Default::default()),
                price_bound: Ok(Default::default()),
                reason: Ok(Default::default()),
                reject_reason: Ok(Default::default()),
                request_id: Ok(Default::default()),
                short_position_closeout: Ok(Default::default()),
                stop_loss_on_fill: Ok(Default::default()),
                take_profit_on_fill: Ok(Default::default()),
                time: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_client_extensions: Ok(Default::default()),
                trade_close: Ok(Default::default()),
                trailing_stop_loss_on_fill: Ok(Default::default()),
                type_: Ok(Default::default()),
                units: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl MarketOrderRejectTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn delayed_trade_close<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderDelayedTradeClose>>,
            T::Error: std::fmt::Display,
        {
            self.delayed_trade_close = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for delayed_trade_close: {}",
                    e
                )
            });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn long_position_closeout<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderPositionCloseout>>,
            T::Error: std::fmt::Display,
        {
            self.long_position_closeout = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for long_position_closeout: {}",
                    e
                )
            });
            self
        }
        pub fn margin_closeout<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderMarginCloseout>>,
            T::Error: std::fmt::Display,
        {
            self.margin_closeout = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for margin_closeout: {}", e));
            self
        }
        pub fn position_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderRejectTransactionPositionFill>>,
            T::Error: std::fmt::Display,
        {
            self.position_fill = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for position_fill: {}", e));
            self
        }
        pub fn price_bound<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price_bound = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price_bound: {}", e));
            self
        }
        pub fn reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderRejectTransactionReason>>,
            T::Error: std::fmt::Display,
        {
            self.reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reason: {}", e));
            self
        }
        pub fn reject_reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderRejectTransactionRejectReason>>,
            T::Error: std::fmt::Display,
        {
            self.reject_reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reject_reason: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn short_position_closeout<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderPositionCloseout>>,
            T::Error: std::fmt::Display,
        {
            self.short_position_closeout = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for short_position_closeout: {}",
                    e
                )
            });
            self
        }
        pub fn stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn take_profit_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitDetails>>,
            T::Error: std::fmt::Display,
        {
            self.take_profit_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for take_profit_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderRejectTransactionTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.trade_client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn trade_close<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderTradeClose>>,
            T::Error: std::fmt::Display,
        {
            self.trade_close = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_close: {}", e));
            self
        }
        pub fn trailing_stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.trailing_stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trailing_stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderRejectTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for units: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<MarketOrderRejectTransaction> for super::MarketOrderRejectTransaction {
        type Error = super::error::ConversionError;
        fn try_from(
            value: MarketOrderRejectTransaction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                client_extensions: value.client_extensions?,
                delayed_trade_close: value.delayed_trade_close?,
                id: value.id?,
                instrument: value.instrument?,
                long_position_closeout: value.long_position_closeout?,
                margin_closeout: value.margin_closeout?,
                position_fill: value.position_fill?,
                price_bound: value.price_bound?,
                reason: value.reason?,
                reject_reason: value.reject_reason?,
                request_id: value.request_id?,
                short_position_closeout: value.short_position_closeout?,
                stop_loss_on_fill: value.stop_loss_on_fill?,
                take_profit_on_fill: value.take_profit_on_fill?,
                time: value.time?,
                time_in_force: value.time_in_force?,
                trade_client_extensions: value.trade_client_extensions?,
                trade_close: value.trade_close?,
                trailing_stop_loss_on_fill: value.trailing_stop_loss_on_fill?,
                type_: value.type_?,
                units: value.units?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::MarketOrderRejectTransaction> for MarketOrderRejectTransaction {
        fn from(value: super::MarketOrderRejectTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                client_extensions: Ok(value.client_extensions),
                delayed_trade_close: Ok(value.delayed_trade_close),
                id: Ok(value.id),
                instrument: Ok(value.instrument),
                long_position_closeout: Ok(value.long_position_closeout),
                margin_closeout: Ok(value.margin_closeout),
                position_fill: Ok(value.position_fill),
                price_bound: Ok(value.price_bound),
                reason: Ok(value.reason),
                reject_reason: Ok(value.reject_reason),
                request_id: Ok(value.request_id),
                short_position_closeout: Ok(value.short_position_closeout),
                stop_loss_on_fill: Ok(value.stop_loss_on_fill),
                take_profit_on_fill: Ok(value.take_profit_on_fill),
                time: Ok(value.time),
                time_in_force: Ok(value.time_in_force),
                trade_client_extensions: Ok(value.trade_client_extensions),
                trade_close: Ok(value.trade_close),
                trailing_stop_loss_on_fill: Ok(value.trailing_stop_loss_on_fill),
                type_: Ok(value.type_),
                units: Ok(value.units),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct MarketOrderRequest {
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        instrument: Result<Option<String>, String>,
        position_fill: Result<Option<super::MarketOrderRequestPositionFill>, String>,
        price_bound: Result<Option<String>, String>,
        stop_loss_on_fill: Result<Option<super::StopLossDetails>, String>,
        take_profit_on_fill: Result<Option<super::TakeProfitDetails>, String>,
        time_in_force: Result<Option<super::MarketOrderRequestTimeInForce>, String>,
        trade_client_extensions: Result<Option<super::ClientExtensions>, String>,
        trailing_stop_loss_on_fill: Result<Option<super::TrailingStopLossDetails>, String>,
        type_: Result<Option<super::MarketOrderRequestType>, String>,
        units: Result<Option<String>, String>,
    }

    impl Default for MarketOrderRequest {
        fn default() -> Self {
            Self {
                client_extensions: Ok(Default::default()),
                instrument: Ok(Default::default()),
                position_fill: Ok(Default::default()),
                price_bound: Ok(Default::default()),
                stop_loss_on_fill: Ok(Default::default()),
                take_profit_on_fill: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_client_extensions: Ok(Default::default()),
                trailing_stop_loss_on_fill: Ok(Default::default()),
                type_: Ok(Default::default()),
                units: Ok(Default::default()),
            }
        }
    }

    impl MarketOrderRequest {
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn position_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderRequestPositionFill>>,
            T::Error: std::fmt::Display,
        {
            self.position_fill = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for position_fill: {}", e));
            self
        }
        pub fn price_bound<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price_bound = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price_bound: {}", e));
            self
        }
        pub fn stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn take_profit_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitDetails>>,
            T::Error: std::fmt::Display,
        {
            self.take_profit_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for take_profit_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderRequestTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.trade_client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn trailing_stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.trailing_stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trailing_stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderRequestType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for units: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<MarketOrderRequest> for super::MarketOrderRequest {
        type Error = super::error::ConversionError;
        fn try_from(value: MarketOrderRequest) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                client_extensions: value.client_extensions?,
                instrument: value.instrument?,
                position_fill: value.position_fill?,
                price_bound: value.price_bound?,
                stop_loss_on_fill: value.stop_loss_on_fill?,
                take_profit_on_fill: value.take_profit_on_fill?,
                time_in_force: value.time_in_force?,
                trade_client_extensions: value.trade_client_extensions?,
                trailing_stop_loss_on_fill: value.trailing_stop_loss_on_fill?,
                type_: value.type_?,
                units: value.units?,
            })
        }
    }

    impl From<super::MarketOrderRequest> for MarketOrderRequest {
        fn from(value: super::MarketOrderRequest) -> Self {
            Self {
                client_extensions: Ok(value.client_extensions),
                instrument: Ok(value.instrument),
                position_fill: Ok(value.position_fill),
                price_bound: Ok(value.price_bound),
                stop_loss_on_fill: Ok(value.stop_loss_on_fill),
                take_profit_on_fill: Ok(value.take_profit_on_fill),
                time_in_force: Ok(value.time_in_force),
                trade_client_extensions: Ok(value.trade_client_extensions),
                trailing_stop_loss_on_fill: Ok(value.trailing_stop_loss_on_fill),
                type_: Ok(value.type_),
                units: Ok(value.units),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct MarketOrderTradeClose {
        client_trade_id: Result<Option<String>, String>,
        trade_id: Result<Option<String>, String>,
        units: Result<Option<String>, String>,
    }

    impl Default for MarketOrderTradeClose {
        fn default() -> Self {
            Self {
                client_trade_id: Ok(Default::default()),
                trade_id: Ok(Default::default()),
                units: Ok(Default::default()),
            }
        }
    }

    impl MarketOrderTradeClose {
        pub fn client_trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.client_trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for client_trade_id: {}", e));
            self
        }
        pub fn trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_id: {}", e));
            self
        }
        pub fn units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for units: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<MarketOrderTradeClose> for super::MarketOrderTradeClose {
        type Error = super::error::ConversionError;
        fn try_from(value: MarketOrderTradeClose) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                client_trade_id: value.client_trade_id?,
                trade_id: value.trade_id?,
                units: value.units?,
            })
        }
    }

    impl From<super::MarketOrderTradeClose> for MarketOrderTradeClose {
        fn from(value: super::MarketOrderTradeClose) -> Self {
            Self {
                client_trade_id: Ok(value.client_trade_id),
                trade_id: Ok(value.trade_id),
                units: Ok(value.units),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct MarketOrderTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        delayed_trade_close: Result<Option<super::MarketOrderDelayedTradeClose>, String>,
        id: Result<Option<String>, String>,
        instrument: Result<Option<String>, String>,
        long_position_closeout: Result<Option<super::MarketOrderPositionCloseout>, String>,
        margin_closeout: Result<Option<super::MarketOrderMarginCloseout>, String>,
        position_fill: Result<Option<super::MarketOrderTransactionPositionFill>, String>,
        price_bound: Result<Option<String>, String>,
        reason: Result<Option<super::MarketOrderTransactionReason>, String>,
        request_id: Result<Option<String>, String>,
        short_position_closeout: Result<Option<super::MarketOrderPositionCloseout>, String>,
        stop_loss_on_fill: Result<Option<super::StopLossDetails>, String>,
        take_profit_on_fill: Result<Option<super::TakeProfitDetails>, String>,
        time: Result<Option<String>, String>,
        time_in_force: Result<Option<super::MarketOrderTransactionTimeInForce>, String>,
        trade_client_extensions: Result<Option<super::ClientExtensions>, String>,
        trade_close: Result<Option<super::MarketOrderTradeClose>, String>,
        trailing_stop_loss_on_fill: Result<Option<super::TrailingStopLossDetails>, String>,
        type_: Result<Option<super::MarketOrderTransactionType>, String>,
        units: Result<Option<String>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for MarketOrderTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                client_extensions: Ok(Default::default()),
                delayed_trade_close: Ok(Default::default()),
                id: Ok(Default::default()),
                instrument: Ok(Default::default()),
                long_position_closeout: Ok(Default::default()),
                margin_closeout: Ok(Default::default()),
                position_fill: Ok(Default::default()),
                price_bound: Ok(Default::default()),
                reason: Ok(Default::default()),
                request_id: Ok(Default::default()),
                short_position_closeout: Ok(Default::default()),
                stop_loss_on_fill: Ok(Default::default()),
                take_profit_on_fill: Ok(Default::default()),
                time: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_client_extensions: Ok(Default::default()),
                trade_close: Ok(Default::default()),
                trailing_stop_loss_on_fill: Ok(Default::default()),
                type_: Ok(Default::default()),
                units: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl MarketOrderTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn delayed_trade_close<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderDelayedTradeClose>>,
            T::Error: std::fmt::Display,
        {
            self.delayed_trade_close = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for delayed_trade_close: {}",
                    e
                )
            });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn long_position_closeout<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderPositionCloseout>>,
            T::Error: std::fmt::Display,
        {
            self.long_position_closeout = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for long_position_closeout: {}",
                    e
                )
            });
            self
        }
        pub fn margin_closeout<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderMarginCloseout>>,
            T::Error: std::fmt::Display,
        {
            self.margin_closeout = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for margin_closeout: {}", e));
            self
        }
        pub fn position_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderTransactionPositionFill>>,
            T::Error: std::fmt::Display,
        {
            self.position_fill = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for position_fill: {}", e));
            self
        }
        pub fn price_bound<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price_bound = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price_bound: {}", e));
            self
        }
        pub fn reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderTransactionReason>>,
            T::Error: std::fmt::Display,
        {
            self.reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reason: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn short_position_closeout<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderPositionCloseout>>,
            T::Error: std::fmt::Display,
        {
            self.short_position_closeout = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for short_position_closeout: {}",
                    e
                )
            });
            self
        }
        pub fn stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn take_profit_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitDetails>>,
            T::Error: std::fmt::Display,
        {
            self.take_profit_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for take_profit_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderTransactionTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.trade_client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn trade_close<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderTradeClose>>,
            T::Error: std::fmt::Display,
        {
            self.trade_close = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_close: {}", e));
            self
        }
        pub fn trailing_stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.trailing_stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trailing_stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::MarketOrderTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for units: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<MarketOrderTransaction> for super::MarketOrderTransaction {
        type Error = super::error::ConversionError;
        fn try_from(value: MarketOrderTransaction) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                client_extensions: value.client_extensions?,
                delayed_trade_close: value.delayed_trade_close?,
                id: value.id?,
                instrument: value.instrument?,
                long_position_closeout: value.long_position_closeout?,
                margin_closeout: value.margin_closeout?,
                position_fill: value.position_fill?,
                price_bound: value.price_bound?,
                reason: value.reason?,
                request_id: value.request_id?,
                short_position_closeout: value.short_position_closeout?,
                stop_loss_on_fill: value.stop_loss_on_fill?,
                take_profit_on_fill: value.take_profit_on_fill?,
                time: value.time?,
                time_in_force: value.time_in_force?,
                trade_client_extensions: value.trade_client_extensions?,
                trade_close: value.trade_close?,
                trailing_stop_loss_on_fill: value.trailing_stop_loss_on_fill?,
                type_: value.type_?,
                units: value.units?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::MarketOrderTransaction> for MarketOrderTransaction {
        fn from(value: super::MarketOrderTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                client_extensions: Ok(value.client_extensions),
                delayed_trade_close: Ok(value.delayed_trade_close),
                id: Ok(value.id),
                instrument: Ok(value.instrument),
                long_position_closeout: Ok(value.long_position_closeout),
                margin_closeout: Ok(value.margin_closeout),
                position_fill: Ok(value.position_fill),
                price_bound: Ok(value.price_bound),
                reason: Ok(value.reason),
                request_id: Ok(value.request_id),
                short_position_closeout: Ok(value.short_position_closeout),
                stop_loss_on_fill: Ok(value.stop_loss_on_fill),
                take_profit_on_fill: Ok(value.take_profit_on_fill),
                time: Ok(value.time),
                time_in_force: Ok(value.time_in_force),
                trade_client_extensions: Ok(value.trade_client_extensions),
                trade_close: Ok(value.trade_close),
                trailing_stop_loss_on_fill: Ok(value.trailing_stop_loss_on_fill),
                type_: Ok(value.type_),
                units: Ok(value.units),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct Mt4TransactionHeartbeat {
        time: Result<Option<String>, String>,
        type_: Result<Option<String>, String>,
    }

    impl Default for Mt4TransactionHeartbeat {
        fn default() -> Self {
            Self {
                time: Ok(Default::default()),
                type_: Ok(Default::default()),
            }
        }
    }

    impl Mt4TransactionHeartbeat {
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<Mt4TransactionHeartbeat> for super::Mt4TransactionHeartbeat {
        type Error = super::error::ConversionError;
        fn try_from(value: Mt4TransactionHeartbeat) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                time: value.time?,
                type_: value.type_?,
            })
        }
    }

    impl From<super::Mt4TransactionHeartbeat> for Mt4TransactionHeartbeat {
        fn from(value: super::Mt4TransactionHeartbeat) -> Self {
            Self {
                time: Ok(value.time),
                type_: Ok(value.type_),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct OpenTradeFinancing {
        financing: Result<Option<String>, String>,
        trade_id: Result<Option<String>, String>,
    }

    impl Default for OpenTradeFinancing {
        fn default() -> Self {
            Self {
                financing: Ok(Default::default()),
                trade_id: Ok(Default::default()),
            }
        }
    }

    impl OpenTradeFinancing {
        pub fn financing<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.financing = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for financing: {}", e));
            self
        }
        pub fn trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<OpenTradeFinancing> for super::OpenTradeFinancing {
        type Error = super::error::ConversionError;
        fn try_from(value: OpenTradeFinancing) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                financing: value.financing?,
                trade_id: value.trade_id?,
            })
        }
    }

    impl From<super::OpenTradeFinancing> for OpenTradeFinancing {
        fn from(value: super::OpenTradeFinancing) -> Self {
            Self {
                financing: Ok(value.financing),
                trade_id: Ok(value.trade_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct Order {
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        create_time: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        state: Result<Option<super::OrderState>, String>,
    }

    impl Default for Order {
        fn default() -> Self {
            Self {
                client_extensions: Ok(Default::default()),
                create_time: Ok(Default::default()),
                id: Ok(Default::default()),
                state: Ok(Default::default()),
            }
        }
    }

    impl Order {
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn create_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.create_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for create_time: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn state<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderState>>,
            T::Error: std::fmt::Display,
        {
            self.state = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for state: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<Order> for super::Order {
        type Error = super::error::ConversionError;
        fn try_from(value: Order) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                client_extensions: value.client_extensions?,
                create_time: value.create_time?,
                id: value.id?,
                state: value.state?,
            })
        }
    }

    impl From<super::Order> for Order {
        fn from(value: super::Order) -> Self {
            Self {
                client_extensions: Ok(value.client_extensions),
                create_time: Ok(value.create_time),
                id: Ok(value.id),
                state: Ok(value.state),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct OrderBook {
        bucket_width: Result<Option<String>, String>,
        buckets: Result<Vec<super::OrderBookBucket>, String>,
        instrument: Result<Option<String>, String>,
        price: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
    }

    impl Default for OrderBook {
        fn default() -> Self {
            Self {
                bucket_width: Ok(Default::default()),
                buckets: Ok(Default::default()),
                instrument: Ok(Default::default()),
                price: Ok(Default::default()),
                time: Ok(Default::default()),
            }
        }
    }

    impl OrderBook {
        pub fn bucket_width<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.bucket_width = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for bucket_width: {}", e));
            self
        }
        pub fn buckets<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::OrderBookBucket>>,
            T::Error: std::fmt::Display,
        {
            self.buckets = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for buckets: {}", e));
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<OrderBook> for super::OrderBook {
        type Error = super::error::ConversionError;
        fn try_from(value: OrderBook) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                bucket_width: value.bucket_width?,
                buckets: value.buckets?,
                instrument: value.instrument?,
                price: value.price?,
                time: value.time?,
            })
        }
    }

    impl From<super::OrderBook> for OrderBook {
        fn from(value: super::OrderBook) -> Self {
            Self {
                bucket_width: Ok(value.bucket_width),
                buckets: Ok(value.buckets),
                instrument: Ok(value.instrument),
                price: Ok(value.price),
                time: Ok(value.time),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct OrderBookBucket {
        long_count_percent: Result<Option<String>, String>,
        price: Result<Option<String>, String>,
        short_count_percent: Result<Option<String>, String>,
    }

    impl Default for OrderBookBucket {
        fn default() -> Self {
            Self {
                long_count_percent: Ok(Default::default()),
                price: Ok(Default::default()),
                short_count_percent: Ok(Default::default()),
            }
        }
    }

    impl OrderBookBucket {
        pub fn long_count_percent<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.long_count_percent = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for long_count_percent: {}",
                    e
                )
            });
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn short_count_percent<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.short_count_percent = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for short_count_percent: {}",
                    e
                )
            });
            self
        }
    }

    impl std::convert::TryFrom<OrderBookBucket> for super::OrderBookBucket {
        type Error = super::error::ConversionError;
        fn try_from(value: OrderBookBucket) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                long_count_percent: value.long_count_percent?,
                price: value.price?,
                short_count_percent: value.short_count_percent?,
            })
        }
    }

    impl From<super::OrderBookBucket> for OrderBookBucket {
        fn from(value: super::OrderBookBucket) -> Self {
            Self {
                long_count_percent: Ok(value.long_count_percent),
                price: Ok(value.price),
                short_count_percent: Ok(value.short_count_percent),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct OrderCancelRejectTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        client_order_id: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        order_id: Result<Option<String>, String>,
        reject_reason: Result<Option<super::OrderCancelRejectTransactionRejectReason>, String>,
        request_id: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
        type_: Result<Option<super::OrderCancelRejectTransactionType>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for OrderCancelRejectTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                client_order_id: Ok(Default::default()),
                id: Ok(Default::default()),
                order_id: Ok(Default::default()),
                reject_reason: Ok(Default::default()),
                request_id: Ok(Default::default()),
                time: Ok(Default::default()),
                type_: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl OrderCancelRejectTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn client_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.client_order_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for client_order_id: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.order_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for order_id: {}", e));
            self
        }
        pub fn reject_reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderCancelRejectTransactionRejectReason>>,
            T::Error: std::fmt::Display,
        {
            self.reject_reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reject_reason: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderCancelRejectTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<OrderCancelRejectTransaction> for super::OrderCancelRejectTransaction {
        type Error = super::error::ConversionError;
        fn try_from(
            value: OrderCancelRejectTransaction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                client_order_id: value.client_order_id?,
                id: value.id?,
                order_id: value.order_id?,
                reject_reason: value.reject_reason?,
                request_id: value.request_id?,
                time: value.time?,
                type_: value.type_?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::OrderCancelRejectTransaction> for OrderCancelRejectTransaction {
        fn from(value: super::OrderCancelRejectTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                client_order_id: Ok(value.client_order_id),
                id: Ok(value.id),
                order_id: Ok(value.order_id),
                reject_reason: Ok(value.reject_reason),
                request_id: Ok(value.request_id),
                time: Ok(value.time),
                type_: Ok(value.type_),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct OrderCancelTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        client_order_id: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        order_id: Result<Option<String>, String>,
        reason: Result<Option<super::OrderCancelTransactionReason>, String>,
        replaced_by_order_id: Result<Option<String>, String>,
        request_id: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
        type_: Result<Option<super::OrderCancelTransactionType>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for OrderCancelTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                client_order_id: Ok(Default::default()),
                id: Ok(Default::default()),
                order_id: Ok(Default::default()),
                reason: Ok(Default::default()),
                replaced_by_order_id: Ok(Default::default()),
                request_id: Ok(Default::default()),
                time: Ok(Default::default()),
                type_: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl OrderCancelTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn client_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.client_order_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for client_order_id: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.order_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for order_id: {}", e));
            self
        }
        pub fn reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderCancelTransactionReason>>,
            T::Error: std::fmt::Display,
        {
            self.reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reason: {}", e));
            self
        }
        pub fn replaced_by_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.replaced_by_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for replaced_by_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderCancelTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<OrderCancelTransaction> for super::OrderCancelTransaction {
        type Error = super::error::ConversionError;
        fn try_from(value: OrderCancelTransaction) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                client_order_id: value.client_order_id?,
                id: value.id?,
                order_id: value.order_id?,
                reason: value.reason?,
                replaced_by_order_id: value.replaced_by_order_id?,
                request_id: value.request_id?,
                time: value.time?,
                type_: value.type_?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::OrderCancelTransaction> for OrderCancelTransaction {
        fn from(value: super::OrderCancelTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                client_order_id: Ok(value.client_order_id),
                id: Ok(value.id),
                order_id: Ok(value.order_id),
                reason: Ok(value.reason),
                replaced_by_order_id: Ok(value.replaced_by_order_id),
                request_id: Ok(value.request_id),
                time: Ok(value.time),
                type_: Ok(value.type_),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct OrderClientExtensionsModifyRejectTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        client_extensions_modify: Result<Option<super::ClientExtensions>, String>,
        client_order_id: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        order_id: Result<Option<String>, String>,
        reject_reason:
            Result<Option<super::OrderClientExtensionsModifyRejectTransactionRejectReason>, String>,
        request_id: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
        trade_client_extensions_modify: Result<Option<super::ClientExtensions>, String>,
        type_: Result<Option<super::OrderClientExtensionsModifyRejectTransactionType>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for OrderClientExtensionsModifyRejectTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                client_extensions_modify: Ok(Default::default()),
                client_order_id: Ok(Default::default()),
                id: Ok(Default::default()),
                order_id: Ok(Default::default()),
                reject_reason: Ok(Default::default()),
                request_id: Ok(Default::default()),
                time: Ok(Default::default()),
                trade_client_extensions_modify: Ok(Default::default()),
                type_: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl OrderClientExtensionsModifyRejectTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn client_extensions_modify<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions_modify = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions_modify: {}",
                    e
                )
            });
            self
        }
        pub fn client_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.client_order_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for client_order_id: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.order_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for order_id: {}", e));
            self
        }
        pub fn reject_reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::OrderClientExtensionsModifyRejectTransactionRejectReason>,
            >,
            T::Error: std::fmt::Display,
        {
            self.reject_reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reject_reason: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn trade_client_extensions_modify<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.trade_client_extensions_modify = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_client_extensions_modify: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::OrderClientExtensionsModifyRejectTransactionType>,
            >,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<OrderClientExtensionsModifyRejectTransaction>
        for super::OrderClientExtensionsModifyRejectTransaction
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: OrderClientExtensionsModifyRejectTransaction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                client_extensions_modify: value.client_extensions_modify?,
                client_order_id: value.client_order_id?,
                id: value.id?,
                order_id: value.order_id?,
                reject_reason: value.reject_reason?,
                request_id: value.request_id?,
                time: value.time?,
                trade_client_extensions_modify: value.trade_client_extensions_modify?,
                type_: value.type_?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::OrderClientExtensionsModifyRejectTransaction>
        for OrderClientExtensionsModifyRejectTransaction
    {
        fn from(value: super::OrderClientExtensionsModifyRejectTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                client_extensions_modify: Ok(value.client_extensions_modify),
                client_order_id: Ok(value.client_order_id),
                id: Ok(value.id),
                order_id: Ok(value.order_id),
                reject_reason: Ok(value.reject_reason),
                request_id: Ok(value.request_id),
                time: Ok(value.time),
                trade_client_extensions_modify: Ok(value.trade_client_extensions_modify),
                type_: Ok(value.type_),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct OrderClientExtensionsModifyTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        client_extensions_modify: Result<Option<super::ClientExtensions>, String>,
        client_order_id: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        order_id: Result<Option<String>, String>,
        request_id: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
        trade_client_extensions_modify: Result<Option<super::ClientExtensions>, String>,
        type_: Result<Option<super::OrderClientExtensionsModifyTransactionType>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for OrderClientExtensionsModifyTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                client_extensions_modify: Ok(Default::default()),
                client_order_id: Ok(Default::default()),
                id: Ok(Default::default()),
                order_id: Ok(Default::default()),
                request_id: Ok(Default::default()),
                time: Ok(Default::default()),
                trade_client_extensions_modify: Ok(Default::default()),
                type_: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl OrderClientExtensionsModifyTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn client_extensions_modify<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions_modify = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions_modify: {}",
                    e
                )
            });
            self
        }
        pub fn client_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.client_order_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for client_order_id: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.order_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for order_id: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn trade_client_extensions_modify<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.trade_client_extensions_modify = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_client_extensions_modify: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderClientExtensionsModifyTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<OrderClientExtensionsModifyTransaction>
        for super::OrderClientExtensionsModifyTransaction
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: OrderClientExtensionsModifyTransaction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                client_extensions_modify: value.client_extensions_modify?,
                client_order_id: value.client_order_id?,
                id: value.id?,
                order_id: value.order_id?,
                request_id: value.request_id?,
                time: value.time?,
                trade_client_extensions_modify: value.trade_client_extensions_modify?,
                type_: value.type_?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::OrderClientExtensionsModifyTransaction>
        for OrderClientExtensionsModifyTransaction
    {
        fn from(value: super::OrderClientExtensionsModifyTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                client_extensions_modify: Ok(value.client_extensions_modify),
                client_order_id: Ok(value.client_order_id),
                id: Ok(value.id),
                order_id: Ok(value.order_id),
                request_id: Ok(value.request_id),
                time: Ok(value.time),
                trade_client_extensions_modify: Ok(value.trade_client_extensions_modify),
                type_: Ok(value.type_),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct OrderFillTransaction {
        account_balance: Result<Option<String>, String>,
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        client_order_id: Result<Option<String>, String>,
        commission: Result<Option<String>, String>,
        financing: Result<Option<String>, String>,
        full_price: Result<Option<super::ClientPrice>, String>,
        full_vwap: Result<Option<String>, String>,
        gain_quote_home_conversion_factor: Result<Option<String>, String>,
        guaranteed_execution_fee: Result<Option<String>, String>,
        half_spread_cost: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        instrument: Result<Option<String>, String>,
        loss_quote_home_conversion_factor: Result<Option<String>, String>,
        order_id: Result<Option<String>, String>,
        pl: Result<Option<String>, String>,
        price: Result<Option<String>, String>,
        reason: Result<Option<super::OrderFillTransactionReason>, String>,
        request_id: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
        trade_opened: Result<Option<super::TradeOpen>, String>,
        trade_reduced: Result<Option<super::TradeReduce>, String>,
        trades_closed: Result<Vec<super::TradeReduce>, String>,
        type_: Result<Option<super::OrderFillTransactionType>, String>,
        units: Result<Option<String>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for OrderFillTransaction {
        fn default() -> Self {
            Self {
                account_balance: Ok(Default::default()),
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                client_order_id: Ok(Default::default()),
                commission: Ok(Default::default()),
                financing: Ok(Default::default()),
                full_price: Ok(Default::default()),
                full_vwap: Ok(Default::default()),
                gain_quote_home_conversion_factor: Ok(Default::default()),
                guaranteed_execution_fee: Ok(Default::default()),
                half_spread_cost: Ok(Default::default()),
                id: Ok(Default::default()),
                instrument: Ok(Default::default()),
                loss_quote_home_conversion_factor: Ok(Default::default()),
                order_id: Ok(Default::default()),
                pl: Ok(Default::default()),
                price: Ok(Default::default()),
                reason: Ok(Default::default()),
                request_id: Ok(Default::default()),
                time: Ok(Default::default()),
                trade_opened: Ok(Default::default()),
                trade_reduced: Ok(Default::default()),
                trades_closed: Ok(Default::default()),
                type_: Ok(Default::default()),
                units: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl OrderFillTransaction {
        pub fn account_balance<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_balance = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_balance: {}", e));
            self
        }
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn client_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.client_order_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for client_order_id: {}", e));
            self
        }
        pub fn commission<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.commission = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for commission: {}", e));
            self
        }
        pub fn financing<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.financing = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for financing: {}", e));
            self
        }
        pub fn full_price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientPrice>>,
            T::Error: std::fmt::Display,
        {
            self.full_price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for full_price: {}", e));
            self
        }
        pub fn full_vwap<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.full_vwap = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for full_vwap: {}", e));
            self
        }
        pub fn gain_quote_home_conversion_factor<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gain_quote_home_conversion_factor = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for gain_quote_home_conversion_factor: {}",
                    e
                )
            });
            self
        }
        pub fn guaranteed_execution_fee<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.guaranteed_execution_fee = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for guaranteed_execution_fee: {}",
                    e
                )
            });
            self
        }
        pub fn half_spread_cost<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.half_spread_cost = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for half_spread_cost: {}",
                    e
                )
            });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn loss_quote_home_conversion_factor<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.loss_quote_home_conversion_factor = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for loss_quote_home_conversion_factor: {}",
                    e
                )
            });
            self
        }
        pub fn order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.order_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for order_id: {}", e));
            self
        }
        pub fn pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.pl = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for pl: {}", e));
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderFillTransactionReason>>,
            T::Error: std::fmt::Display,
        {
            self.reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reason: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn trade_opened<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TradeOpen>>,
            T::Error: std::fmt::Display,
        {
            self.trade_opened = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_opened: {}", e));
            self
        }
        pub fn trade_reduced<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TradeReduce>>,
            T::Error: std::fmt::Display,
        {
            self.trade_reduced = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_reduced: {}", e));
            self
        }
        pub fn trades_closed<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::TradeReduce>>,
            T::Error: std::fmt::Display,
        {
            self.trades_closed = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trades_closed: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderFillTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for units: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<OrderFillTransaction> for super::OrderFillTransaction {
        type Error = super::error::ConversionError;
        fn try_from(value: OrderFillTransaction) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_balance: value.account_balance?,
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                client_order_id: value.client_order_id?,
                commission: value.commission?,
                financing: value.financing?,
                full_price: value.full_price?,
                full_vwap: value.full_vwap?,
                gain_quote_home_conversion_factor: value.gain_quote_home_conversion_factor?,
                guaranteed_execution_fee: value.guaranteed_execution_fee?,
                half_spread_cost: value.half_spread_cost?,
                id: value.id?,
                instrument: value.instrument?,
                loss_quote_home_conversion_factor: value.loss_quote_home_conversion_factor?,
                order_id: value.order_id?,
                pl: value.pl?,
                price: value.price?,
                reason: value.reason?,
                request_id: value.request_id?,
                time: value.time?,
                trade_opened: value.trade_opened?,
                trade_reduced: value.trade_reduced?,
                trades_closed: value.trades_closed?,
                type_: value.type_?,
                units: value.units?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::OrderFillTransaction> for OrderFillTransaction {
        fn from(value: super::OrderFillTransaction) -> Self {
            Self {
                account_balance: Ok(value.account_balance),
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                client_order_id: Ok(value.client_order_id),
                commission: Ok(value.commission),
                financing: Ok(value.financing),
                full_price: Ok(value.full_price),
                full_vwap: Ok(value.full_vwap),
                gain_quote_home_conversion_factor: Ok(value.gain_quote_home_conversion_factor),
                guaranteed_execution_fee: Ok(value.guaranteed_execution_fee),
                half_spread_cost: Ok(value.half_spread_cost),
                id: Ok(value.id),
                instrument: Ok(value.instrument),
                loss_quote_home_conversion_factor: Ok(value.loss_quote_home_conversion_factor),
                order_id: Ok(value.order_id),
                pl: Ok(value.pl),
                price: Ok(value.price),
                reason: Ok(value.reason),
                request_id: Ok(value.request_id),
                time: Ok(value.time),
                trade_opened: Ok(value.trade_opened),
                trade_reduced: Ok(value.trade_reduced),
                trades_closed: Ok(value.trades_closed),
                type_: Ok(value.type_),
                units: Ok(value.units),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct OrderIdentifier {
        client_order_id: Result<Option<String>, String>,
        order_id: Result<Option<String>, String>,
    }

    impl Default for OrderIdentifier {
        fn default() -> Self {
            Self {
                client_order_id: Ok(Default::default()),
                order_id: Ok(Default::default()),
            }
        }
    }

    impl OrderIdentifier {
        pub fn client_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.client_order_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for client_order_id: {}", e));
            self
        }
        pub fn order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.order_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for order_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<OrderIdentifier> for super::OrderIdentifier {
        type Error = super::error::ConversionError;
        fn try_from(value: OrderIdentifier) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                client_order_id: value.client_order_id?,
                order_id: value.order_id?,
            })
        }
    }

    impl From<super::OrderIdentifier> for OrderIdentifier {
        fn from(value: super::OrderIdentifier) -> Self {
            Self {
                client_order_id: Ok(value.client_order_id),
                order_id: Ok(value.order_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct Position {
        commission: Result<Option<String>, String>,
        financing: Result<Option<String>, String>,
        guaranteed_execution_fees: Result<Option<String>, String>,
        instrument: Result<Option<String>, String>,
        long: Result<Option<super::PositionSide>, String>,
        margin_used: Result<Option<String>, String>,
        pl: Result<Option<String>, String>,
        resettable_pl: Result<Option<String>, String>,
        short: Result<Option<super::PositionSide>, String>,
        unrealized_pl: Result<Option<String>, String>,
    }

    impl Default for Position {
        fn default() -> Self {
            Self {
                commission: Ok(Default::default()),
                financing: Ok(Default::default()),
                guaranteed_execution_fees: Ok(Default::default()),
                instrument: Ok(Default::default()),
                long: Ok(Default::default()),
                margin_used: Ok(Default::default()),
                pl: Ok(Default::default()),
                resettable_pl: Ok(Default::default()),
                short: Ok(Default::default()),
                unrealized_pl: Ok(Default::default()),
            }
        }
    }

    impl Position {
        pub fn commission<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.commission = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for commission: {}", e));
            self
        }
        pub fn financing<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.financing = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for financing: {}", e));
            self
        }
        pub fn guaranteed_execution_fees<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.guaranteed_execution_fees = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for guaranteed_execution_fees: {}",
                    e
                )
            });
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn long<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::PositionSide>>,
            T::Error: std::fmt::Display,
        {
            self.long = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for long: {}", e));
            self
        }
        pub fn margin_used<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_used = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for margin_used: {}", e));
            self
        }
        pub fn pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.pl = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for pl: {}", e));
            self
        }
        pub fn resettable_pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.resettable_pl = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for resettable_pl: {}", e));
            self
        }
        pub fn short<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::PositionSide>>,
            T::Error: std::fmt::Display,
        {
            self.short = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for short: {}", e));
            self
        }
        pub fn unrealized_pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.unrealized_pl = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for unrealized_pl: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<Position> for super::Position {
        type Error = super::error::ConversionError;
        fn try_from(value: Position) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                commission: value.commission?,
                financing: value.financing?,
                guaranteed_execution_fees: value.guaranteed_execution_fees?,
                instrument: value.instrument?,
                long: value.long?,
                margin_used: value.margin_used?,
                pl: value.pl?,
                resettable_pl: value.resettable_pl?,
                short: value.short?,
                unrealized_pl: value.unrealized_pl?,
            })
        }
    }

    impl From<super::Position> for Position {
        fn from(value: super::Position) -> Self {
            Self {
                commission: Ok(value.commission),
                financing: Ok(value.financing),
                guaranteed_execution_fees: Ok(value.guaranteed_execution_fees),
                instrument: Ok(value.instrument),
                long: Ok(value.long),
                margin_used: Ok(value.margin_used),
                pl: Ok(value.pl),
                resettable_pl: Ok(value.resettable_pl),
                short: Ok(value.short),
                unrealized_pl: Ok(value.unrealized_pl),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct PositionBook {
        bucket_width: Result<Option<String>, String>,
        buckets: Result<Vec<super::PositionBookBucket>, String>,
        instrument: Result<Option<String>, String>,
        price: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
    }

    impl Default for PositionBook {
        fn default() -> Self {
            Self {
                bucket_width: Ok(Default::default()),
                buckets: Ok(Default::default()),
                instrument: Ok(Default::default()),
                price: Ok(Default::default()),
                time: Ok(Default::default()),
            }
        }
    }

    impl PositionBook {
        pub fn bucket_width<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.bucket_width = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for bucket_width: {}", e));
            self
        }
        pub fn buckets<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::PositionBookBucket>>,
            T::Error: std::fmt::Display,
        {
            self.buckets = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for buckets: {}", e));
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<PositionBook> for super::PositionBook {
        type Error = super::error::ConversionError;
        fn try_from(value: PositionBook) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                bucket_width: value.bucket_width?,
                buckets: value.buckets?,
                instrument: value.instrument?,
                price: value.price?,
                time: value.time?,
            })
        }
    }

    impl From<super::PositionBook> for PositionBook {
        fn from(value: super::PositionBook) -> Self {
            Self {
                bucket_width: Ok(value.bucket_width),
                buckets: Ok(value.buckets),
                instrument: Ok(value.instrument),
                price: Ok(value.price),
                time: Ok(value.time),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct PositionBookBucket {
        long_count_percent: Result<Option<String>, String>,
        price: Result<Option<String>, String>,
        short_count_percent: Result<Option<String>, String>,
    }

    impl Default for PositionBookBucket {
        fn default() -> Self {
            Self {
                long_count_percent: Ok(Default::default()),
                price: Ok(Default::default()),
                short_count_percent: Ok(Default::default()),
            }
        }
    }

    impl PositionBookBucket {
        pub fn long_count_percent<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.long_count_percent = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for long_count_percent: {}",
                    e
                )
            });
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn short_count_percent<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.short_count_percent = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for short_count_percent: {}",
                    e
                )
            });
            self
        }
    }

    impl std::convert::TryFrom<PositionBookBucket> for super::PositionBookBucket {
        type Error = super::error::ConversionError;
        fn try_from(value: PositionBookBucket) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                long_count_percent: value.long_count_percent?,
                price: value.price?,
                short_count_percent: value.short_count_percent?,
            })
        }
    }

    impl From<super::PositionBookBucket> for PositionBookBucket {
        fn from(value: super::PositionBookBucket) -> Self {
            Self {
                long_count_percent: Ok(value.long_count_percent),
                price: Ok(value.price),
                short_count_percent: Ok(value.short_count_percent),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct PositionFinancing {
        financing: Result<Option<String>, String>,
        instrument: Result<Option<String>, String>,
        open_trade_financings: Result<Vec<super::OpenTradeFinancing>, String>,
    }

    impl Default for PositionFinancing {
        fn default() -> Self {
            Self {
                financing: Ok(Default::default()),
                instrument: Ok(Default::default()),
                open_trade_financings: Ok(Default::default()),
            }
        }
    }

    impl PositionFinancing {
        pub fn financing<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.financing = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for financing: {}", e));
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn open_trade_financings<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::OpenTradeFinancing>>,
            T::Error: std::fmt::Display,
        {
            self.open_trade_financings = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for open_trade_financings: {}",
                    e
                )
            });
            self
        }
    }

    impl std::convert::TryFrom<PositionFinancing> for super::PositionFinancing {
        type Error = super::error::ConversionError;
        fn try_from(value: PositionFinancing) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                financing: value.financing?,
                instrument: value.instrument?,
                open_trade_financings: value.open_trade_financings?,
            })
        }
    }

    impl From<super::PositionFinancing> for PositionFinancing {
        fn from(value: super::PositionFinancing) -> Self {
            Self {
                financing: Ok(value.financing),
                instrument: Ok(value.instrument),
                open_trade_financings: Ok(value.open_trade_financings),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct PositionSide {
        average_price: Result<Option<String>, String>,
        financing: Result<Option<String>, String>,
        guaranteed_execution_fees: Result<Option<String>, String>,
        pl: Result<Option<String>, String>,
        resettable_pl: Result<Option<String>, String>,
        trade_i_ds: Result<Vec<String>, String>,
        units: Result<Option<String>, String>,
        unrealized_pl: Result<Option<String>, String>,
    }

    impl Default for PositionSide {
        fn default() -> Self {
            Self {
                average_price: Ok(Default::default()),
                financing: Ok(Default::default()),
                guaranteed_execution_fees: Ok(Default::default()),
                pl: Ok(Default::default()),
                resettable_pl: Ok(Default::default()),
                trade_i_ds: Ok(Default::default()),
                units: Ok(Default::default()),
                unrealized_pl: Ok(Default::default()),
            }
        }
    }

    impl PositionSide {
        pub fn average_price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.average_price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for average_price: {}", e));
            self
        }
        pub fn financing<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.financing = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for financing: {}", e));
            self
        }
        pub fn guaranteed_execution_fees<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.guaranteed_execution_fees = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for guaranteed_execution_fees: {}",
                    e
                )
            });
            self
        }
        pub fn pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.pl = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for pl: {}", e));
            self
        }
        pub fn resettable_pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.resettable_pl = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for resettable_pl: {}", e));
            self
        }
        pub fn trade_i_ds<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_i_ds = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_i_ds: {}", e));
            self
        }
        pub fn units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for units: {}", e));
            self
        }
        pub fn unrealized_pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.unrealized_pl = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for unrealized_pl: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<PositionSide> for super::PositionSide {
        type Error = super::error::ConversionError;
        fn try_from(value: PositionSide) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                average_price: value.average_price?,
                financing: value.financing?,
                guaranteed_execution_fees: value.guaranteed_execution_fees?,
                pl: value.pl?,
                resettable_pl: value.resettable_pl?,
                trade_i_ds: value.trade_i_ds?,
                units: value.units?,
                unrealized_pl: value.unrealized_pl?,
            })
        }
    }

    impl From<super::PositionSide> for PositionSide {
        fn from(value: super::PositionSide) -> Self {
            Self {
                average_price: Ok(value.average_price),
                financing: Ok(value.financing),
                guaranteed_execution_fees: Ok(value.guaranteed_execution_fees),
                pl: Ok(value.pl),
                resettable_pl: Ok(value.resettable_pl),
                trade_i_ds: Ok(value.trade_i_ds),
                units: Ok(value.units),
                unrealized_pl: Ok(value.unrealized_pl),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct Price {
        asks: Result<Vec<super::PriceBucket>, String>,
        base_ask: Result<Option<String>, String>,
        base_bid: Result<Option<String>, String>,
        bids: Result<Vec<super::PriceBucket>, String>,
        closeout_ask: Result<Option<String>, String>,
        closeout_bid: Result<Option<String>, String>,
        instrument: Result<Option<String>, String>,
        timestamp: Result<Option<String>, String>,
        tradeable: Result<Option<bool>, String>,
    }

    impl Default for Price {
        fn default() -> Self {
            Self {
                asks: Ok(Default::default()),
                base_ask: Ok(Default::default()),
                base_bid: Ok(Default::default()),
                bids: Ok(Default::default()),
                closeout_ask: Ok(Default::default()),
                closeout_bid: Ok(Default::default()),
                instrument: Ok(Default::default()),
                timestamp: Ok(Default::default()),
                tradeable: Ok(Default::default()),
            }
        }
    }

    impl Price {
        pub fn asks<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::PriceBucket>>,
            T::Error: std::fmt::Display,
        {
            self.asks = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for asks: {}", e));
            self
        }
        pub fn base_ask<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.base_ask = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for base_ask: {}", e));
            self
        }
        pub fn base_bid<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.base_bid = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for base_bid: {}", e));
            self
        }
        pub fn bids<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<super::PriceBucket>>,
            T::Error: std::fmt::Display,
        {
            self.bids = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for bids: {}", e));
            self
        }
        pub fn closeout_ask<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.closeout_ask = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for closeout_ask: {}", e));
            self
        }
        pub fn closeout_bid<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.closeout_bid = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for closeout_bid: {}", e));
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn timestamp<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.timestamp = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for timestamp: {}", e));
            self
        }
        pub fn tradeable<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<bool>>,
            T::Error: std::fmt::Display,
        {
            self.tradeable = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for tradeable: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<Price> for super::Price {
        type Error = super::error::ConversionError;
        fn try_from(value: Price) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                asks: value.asks?,
                base_ask: value.base_ask?,
                base_bid: value.base_bid?,
                bids: value.bids?,
                closeout_ask: value.closeout_ask?,
                closeout_bid: value.closeout_bid?,
                instrument: value.instrument?,
                timestamp: value.timestamp?,
                tradeable: value.tradeable?,
            })
        }
    }

    impl From<super::Price> for Price {
        fn from(value: super::Price) -> Self {
            Self {
                asks: Ok(value.asks),
                base_ask: Ok(value.base_ask),
                base_bid: Ok(value.base_bid),
                bids: Ok(value.bids),
                closeout_ask: Ok(value.closeout_ask),
                closeout_bid: Ok(value.closeout_bid),
                instrument: Ok(value.instrument),
                timestamp: Ok(value.timestamp),
                tradeable: Ok(value.tradeable),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct PriceBucket {
        liquidity: Result<Option<i64>, String>,
        price: Result<Option<String>, String>,
    }

    impl Default for PriceBucket {
        fn default() -> Self {
            Self {
                liquidity: Ok(Default::default()),
                price: Ok(Default::default()),
            }
        }
    }

    impl PriceBucket {
        pub fn liquidity<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.liquidity = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for liquidity: {}", e));
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<PriceBucket> for super::PriceBucket {
        type Error = super::error::ConversionError;
        fn try_from(value: PriceBucket) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                liquidity: value.liquidity?,
                price: value.price?,
            })
        }
    }

    impl From<super::PriceBucket> for PriceBucket {
        fn from(value: super::PriceBucket) -> Self {
            Self {
                liquidity: Ok(value.liquidity),
                price: Ok(value.price),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct PricingHeartbeat {
        time: Result<Option<String>, String>,
        type_: Result<Option<String>, String>,
    }

    impl Default for PricingHeartbeat {
        fn default() -> Self {
            Self {
                time: Ok(Default::default()),
                type_: Ok(Default::default()),
            }
        }
    }

    impl PricingHeartbeat {
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<PricingHeartbeat> for super::PricingHeartbeat {
        type Error = super::error::ConversionError;
        fn try_from(value: PricingHeartbeat) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                time: value.time?,
                type_: value.type_?,
            })
        }
    }

    impl From<super::PricingHeartbeat> for PricingHeartbeat {
        fn from(value: super::PricingHeartbeat) -> Self {
            Self {
                time: Ok(value.time),
                type_: Ok(value.type_),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct QuoteHomeConversionFactors {
        negative_units: Result<Option<String>, String>,
        positive_units: Result<Option<String>, String>,
    }

    impl Default for QuoteHomeConversionFactors {
        fn default() -> Self {
            Self {
                negative_units: Ok(Default::default()),
                positive_units: Ok(Default::default()),
            }
        }
    }

    impl QuoteHomeConversionFactors {
        pub fn negative_units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.negative_units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for negative_units: {}", e));
            self
        }
        pub fn positive_units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.positive_units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for positive_units: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<QuoteHomeConversionFactors> for super::QuoteHomeConversionFactors {
        type Error = super::error::ConversionError;
        fn try_from(
            value: QuoteHomeConversionFactors,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                negative_units: value.negative_units?,
                positive_units: value.positive_units?,
            })
        }
    }

    impl From<super::QuoteHomeConversionFactors> for QuoteHomeConversionFactors {
        fn from(value: super::QuoteHomeConversionFactors) -> Self {
            Self {
                negative_units: Ok(value.negative_units),
                positive_units: Ok(value.positive_units),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct ReopenTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        request_id: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
        type_: Result<Option<super::ReopenTransactionType>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for ReopenTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                id: Ok(Default::default()),
                request_id: Ok(Default::default()),
                time: Ok(Default::default()),
                type_: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl ReopenTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ReopenTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<ReopenTransaction> for super::ReopenTransaction {
        type Error = super::error::ConversionError;
        fn try_from(value: ReopenTransaction) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                id: value.id?,
                request_id: value.request_id?,
                time: value.time?,
                type_: value.type_?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::ReopenTransaction> for ReopenTransaction {
        fn from(value: super::ReopenTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                id: Ok(value.id),
                request_id: Ok(value.request_id),
                time: Ok(value.time),
                type_: Ok(value.type_),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct ReplaceOrderBody {
        order: Result<Option<super::OrderRequest>, String>,
    }

    impl Default for ReplaceOrderBody {
        fn default() -> Self {
            Self {
                order: Ok(Default::default()),
            }
        }
    }

    impl ReplaceOrderBody {
        pub fn order<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderRequest>>,
            T::Error: std::fmt::Display,
        {
            self.order = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for order: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<ReplaceOrderBody> for super::ReplaceOrderBody {
        type Error = super::error::ConversionError;
        fn try_from(value: ReplaceOrderBody) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                order: value.order?,
            })
        }
    }

    impl From<super::ReplaceOrderBody> for ReplaceOrderBody {
        fn from(value: super::ReplaceOrderBody) -> Self {
            Self {
                order: Ok(value.order),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct ReplaceOrderResponse {
        last_transaction_id: Result<Option<String>, String>,
        order_cancel_transaction: Result<Option<super::OrderCancelTransaction>, String>,
        order_create_transaction: Result<Option<super::Transaction>, String>,
        order_fill_transaction: Result<Option<super::OrderFillTransaction>, String>,
        order_reissue_reject_transaction: Result<Option<super::Transaction>, String>,
        order_reissue_transaction: Result<Option<super::Transaction>, String>,
        related_transaction_i_ds: Result<Vec<String>, String>,
        replacing_order_cancel_transaction: Result<Option<super::OrderCancelTransaction>, String>,
    }

    impl Default for ReplaceOrderResponse {
        fn default() -> Self {
            Self {
                last_transaction_id: Ok(Default::default()),
                order_cancel_transaction: Ok(Default::default()),
                order_create_transaction: Ok(Default::default()),
                order_fill_transaction: Ok(Default::default()),
                order_reissue_reject_transaction: Ok(Default::default()),
                order_reissue_transaction: Ok(Default::default()),
                related_transaction_i_ds: Ok(Default::default()),
                replacing_order_cancel_transaction: Ok(Default::default()),
            }
        }
    }

    impl ReplaceOrderResponse {
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn order_cancel_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderCancelTransaction>>,
            T::Error: std::fmt::Display,
        {
            self.order_cancel_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for order_cancel_transaction: {}",
                    e
                )
            });
            self
        }
        pub fn order_create_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::Transaction>>,
            T::Error: std::fmt::Display,
        {
            self.order_create_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for order_create_transaction: {}",
                    e
                )
            });
            self
        }
        pub fn order_fill_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderFillTransaction>>,
            T::Error: std::fmt::Display,
        {
            self.order_fill_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for order_fill_transaction: {}",
                    e
                )
            });
            self
        }
        pub fn order_reissue_reject_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::Transaction>>,
            T::Error: std::fmt::Display,
        {
            self.order_reissue_reject_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for order_reissue_reject_transaction: {}",
                    e
                )
            });
            self
        }
        pub fn order_reissue_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::Transaction>>,
            T::Error: std::fmt::Display,
        {
            self.order_reissue_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for order_reissue_transaction: {}",
                    e
                )
            });
            self
        }
        pub fn related_transaction_i_ds<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self.related_transaction_i_ds = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for related_transaction_i_ds: {}",
                    e
                )
            });
            self
        }
        pub fn replacing_order_cancel_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderCancelTransaction>>,
            T::Error: std::fmt::Display,
        {
            self.replacing_order_cancel_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for replacing_order_cancel_transaction: {}",
                    e
                )
            });
            self
        }
    }

    impl std::convert::TryFrom<ReplaceOrderResponse> for super::ReplaceOrderResponse {
        type Error = super::error::ConversionError;
        fn try_from(value: ReplaceOrderResponse) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                last_transaction_id: value.last_transaction_id?,
                order_cancel_transaction: value.order_cancel_transaction?,
                order_create_transaction: value.order_create_transaction?,
                order_fill_transaction: value.order_fill_transaction?,
                order_reissue_reject_transaction: value.order_reissue_reject_transaction?,
                order_reissue_transaction: value.order_reissue_transaction?,
                related_transaction_i_ds: value.related_transaction_i_ds?,
                replacing_order_cancel_transaction: value.replacing_order_cancel_transaction?,
            })
        }
    }

    impl From<super::ReplaceOrderResponse> for ReplaceOrderResponse {
        fn from(value: super::ReplaceOrderResponse) -> Self {
            Self {
                last_transaction_id: Ok(value.last_transaction_id),
                order_cancel_transaction: Ok(value.order_cancel_transaction),
                order_create_transaction: Ok(value.order_create_transaction),
                order_fill_transaction: Ok(value.order_fill_transaction),
                order_reissue_reject_transaction: Ok(value.order_reissue_reject_transaction),
                order_reissue_transaction: Ok(value.order_reissue_transaction),
                related_transaction_i_ds: Ok(value.related_transaction_i_ds),
                replacing_order_cancel_transaction: Ok(value.replacing_order_cancel_transaction),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct ResetResettablePlTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        request_id: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
        type_: Result<Option<super::ResetResettablePlTransactionType>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for ResetResettablePlTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                id: Ok(Default::default()),
                request_id: Ok(Default::default()),
                time: Ok(Default::default()),
                type_: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl ResetResettablePlTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ResetResettablePlTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<ResetResettablePlTransaction> for super::ResetResettablePlTransaction {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ResetResettablePlTransaction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                id: value.id?,
                request_id: value.request_id?,
                time: value.time?,
                type_: value.type_?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::ResetResettablePlTransaction> for ResetResettablePlTransaction {
        fn from(value: super::ResetResettablePlTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                id: Ok(value.id),
                request_id: Ok(value.request_id),
                time: Ok(value.time),
                type_: Ok(value.type_),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct SetOrderClientExtensionsBody {
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        trade_client_extensions: Result<Option<super::ClientExtensions>, String>,
    }

    impl Default for SetOrderClientExtensionsBody {
        fn default() -> Self {
            Self {
                client_extensions: Ok(Default::default()),
                trade_client_extensions: Ok(Default::default()),
            }
        }
    }

    impl SetOrderClientExtensionsBody {
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn trade_client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.trade_client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_client_extensions: {}",
                    e
                )
            });
            self
        }
    }

    impl std::convert::TryFrom<SetOrderClientExtensionsBody> for super::SetOrderClientExtensionsBody {
        type Error = super::error::ConversionError;
        fn try_from(
            value: SetOrderClientExtensionsBody,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                client_extensions: value.client_extensions?,
                trade_client_extensions: value.trade_client_extensions?,
            })
        }
    }

    impl From<super::SetOrderClientExtensionsBody> for SetOrderClientExtensionsBody {
        fn from(value: super::SetOrderClientExtensionsBody) -> Self {
            Self {
                client_extensions: Ok(value.client_extensions),
                trade_client_extensions: Ok(value.trade_client_extensions),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct SetOrderClientExtensionsResponse {
        last_transaction_id: Result<Option<String>, String>,
        order_client_extensions_modify_transaction:
            Result<Option<super::OrderClientExtensionsModifyTransaction>, String>,
        related_transaction_i_ds: Result<Vec<String>, String>,
    }

    impl Default for SetOrderClientExtensionsResponse {
        fn default() -> Self {
            Self {
                last_transaction_id: Ok(Default::default()),
                order_client_extensions_modify_transaction: Ok(Default::default()),
                related_transaction_i_ds: Ok(Default::default()),
            }
        }
    }

    impl SetOrderClientExtensionsResponse {
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn order_client_extensions_modify_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderClientExtensionsModifyTransaction>>,
            T::Error: std::fmt::Display,
        {
            self . order_client_extensions_modify_transaction = value . try_into () . map_err (| e | format ! ("error converting supplied value for order_client_extensions_modify_transaction: {}" , e)) ;
            self
        }
        pub fn related_transaction_i_ds<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self.related_transaction_i_ds = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for related_transaction_i_ds: {}",
                    e
                )
            });
            self
        }
    }

    impl std::convert::TryFrom<SetOrderClientExtensionsResponse>
        for super::SetOrderClientExtensionsResponse
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: SetOrderClientExtensionsResponse,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                last_transaction_id: value.last_transaction_id?,
                order_client_extensions_modify_transaction: value
                    .order_client_extensions_modify_transaction?,
                related_transaction_i_ds: value.related_transaction_i_ds?,
            })
        }
    }

    impl From<super::SetOrderClientExtensionsResponse> for SetOrderClientExtensionsResponse {
        fn from(value: super::SetOrderClientExtensionsResponse) -> Self {
            Self {
                last_transaction_id: Ok(value.last_transaction_id),
                order_client_extensions_modify_transaction: Ok(
                    value.order_client_extensions_modify_transaction
                ),
                related_transaction_i_ds: Ok(value.related_transaction_i_ds),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct SetTradeClientExtensionsBody {
        client_extensions: Result<Option<super::ClientExtensions>, String>,
    }

    impl Default for SetTradeClientExtensionsBody {
        fn default() -> Self {
            Self {
                client_extensions: Ok(Default::default()),
            }
        }
    }

    impl SetTradeClientExtensionsBody {
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
    }

    impl std::convert::TryFrom<SetTradeClientExtensionsBody> for super::SetTradeClientExtensionsBody {
        type Error = super::error::ConversionError;
        fn try_from(
            value: SetTradeClientExtensionsBody,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                client_extensions: value.client_extensions?,
            })
        }
    }

    impl From<super::SetTradeClientExtensionsBody> for SetTradeClientExtensionsBody {
        fn from(value: super::SetTradeClientExtensionsBody) -> Self {
            Self {
                client_extensions: Ok(value.client_extensions),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct SetTradeClientExtensionsResponse {
        last_transaction_id: Result<Option<String>, String>,
        related_transaction_i_ds: Result<Vec<String>, String>,
        trade_client_extensions_modify_transaction:
            Result<Option<super::TradeClientExtensionsModifyTransaction>, String>,
    }

    impl Default for SetTradeClientExtensionsResponse {
        fn default() -> Self {
            Self {
                last_transaction_id: Ok(Default::default()),
                related_transaction_i_ds: Ok(Default::default()),
                trade_client_extensions_modify_transaction: Ok(Default::default()),
            }
        }
    }

    impl SetTradeClientExtensionsResponse {
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn related_transaction_i_ds<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self.related_transaction_i_ds = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for related_transaction_i_ds: {}",
                    e
                )
            });
            self
        }
        pub fn trade_client_extensions_modify_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TradeClientExtensionsModifyTransaction>>,
            T::Error: std::fmt::Display,
        {
            self . trade_client_extensions_modify_transaction = value . try_into () . map_err (| e | format ! ("error converting supplied value for trade_client_extensions_modify_transaction: {}" , e)) ;
            self
        }
    }

    impl std::convert::TryFrom<SetTradeClientExtensionsResponse>
        for super::SetTradeClientExtensionsResponse
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: SetTradeClientExtensionsResponse,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                last_transaction_id: value.last_transaction_id?,
                related_transaction_i_ds: value.related_transaction_i_ds?,
                trade_client_extensions_modify_transaction: value
                    .trade_client_extensions_modify_transaction?,
            })
        }
    }

    impl From<super::SetTradeClientExtensionsResponse> for SetTradeClientExtensionsResponse {
        fn from(value: super::SetTradeClientExtensionsResponse) -> Self {
            Self {
                last_transaction_id: Ok(value.last_transaction_id),
                related_transaction_i_ds: Ok(value.related_transaction_i_ds),
                trade_client_extensions_modify_transaction: Ok(
                    value.trade_client_extensions_modify_transaction
                ),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct SetTradeDependentOrdersBody {
        stop_loss: Result<Option<super::StopLossDetails>, String>,
        take_profit: Result<Option<super::TakeProfitDetails>, String>,
        trailing_stop_loss: Result<Option<super::TrailingStopLossDetails>, String>,
    }

    impl Default for SetTradeDependentOrdersBody {
        fn default() -> Self {
            Self {
                stop_loss: Ok(Default::default()),
                take_profit: Ok(Default::default()),
                trailing_stop_loss: Ok(Default::default()),
            }
        }
    }

    impl SetTradeDependentOrdersBody {
        pub fn stop_loss<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.stop_loss = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for stop_loss: {}", e));
            self
        }
        pub fn take_profit<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitDetails>>,
            T::Error: std::fmt::Display,
        {
            self.take_profit = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for take_profit: {}", e));
            self
        }
        pub fn trailing_stop_loss<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.trailing_stop_loss = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trailing_stop_loss: {}",
                    e
                )
            });
            self
        }
    }

    impl std::convert::TryFrom<SetTradeDependentOrdersBody> for super::SetTradeDependentOrdersBody {
        type Error = super::error::ConversionError;
        fn try_from(
            value: SetTradeDependentOrdersBody,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                stop_loss: value.stop_loss?,
                take_profit: value.take_profit?,
                trailing_stop_loss: value.trailing_stop_loss?,
            })
        }
    }

    impl From<super::SetTradeDependentOrdersBody> for SetTradeDependentOrdersBody {
        fn from(value: super::SetTradeDependentOrdersBody) -> Self {
            Self {
                stop_loss: Ok(value.stop_loss),
                take_profit: Ok(value.take_profit),
                trailing_stop_loss: Ok(value.trailing_stop_loss),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct SetTradeDependentOrdersResponse {
        last_transaction_id: Result<Option<String>, String>,
        related_transaction_i_ds: Result<Vec<String>, String>,
        stop_loss_order_cancel_transaction: Result<Option<super::OrderCancelTransaction>, String>,
        stop_loss_order_created_cancel_transaction:
            Result<Option<super::OrderCancelTransaction>, String>,
        stop_loss_order_fill_transaction: Result<Option<super::OrderFillTransaction>, String>,
        stop_loss_order_transaction: Result<Option<super::StopLossOrderTransaction>, String>,
        take_profit_order_cancel_transaction: Result<Option<super::OrderCancelTransaction>, String>,
        take_profit_order_created_cancel_transaction:
            Result<Option<super::OrderCancelTransaction>, String>,
        take_profit_order_fill_transaction: Result<Option<super::OrderFillTransaction>, String>,
        take_profit_order_transaction: Result<Option<super::TakeProfitOrderTransaction>, String>,
        trailing_stop_loss_order_cancel_transaction:
            Result<Option<super::OrderCancelTransaction>, String>,
        trailing_stop_loss_order_transaction:
            Result<Option<super::TrailingStopLossOrderTransaction>, String>,
    }

    impl Default for SetTradeDependentOrdersResponse {
        fn default() -> Self {
            Self {
                last_transaction_id: Ok(Default::default()),
                related_transaction_i_ds: Ok(Default::default()),
                stop_loss_order_cancel_transaction: Ok(Default::default()),
                stop_loss_order_created_cancel_transaction: Ok(Default::default()),
                stop_loss_order_fill_transaction: Ok(Default::default()),
                stop_loss_order_transaction: Ok(Default::default()),
                take_profit_order_cancel_transaction: Ok(Default::default()),
                take_profit_order_created_cancel_transaction: Ok(Default::default()),
                take_profit_order_fill_transaction: Ok(Default::default()),
                take_profit_order_transaction: Ok(Default::default()),
                trailing_stop_loss_order_cancel_transaction: Ok(Default::default()),
                trailing_stop_loss_order_transaction: Ok(Default::default()),
            }
        }
    }

    impl SetTradeDependentOrdersResponse {
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn related_transaction_i_ds<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self.related_transaction_i_ds = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for related_transaction_i_ds: {}",
                    e
                )
            });
            self
        }
        pub fn stop_loss_order_cancel_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderCancelTransaction>>,
            T::Error: std::fmt::Display,
        {
            self.stop_loss_order_cancel_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for stop_loss_order_cancel_transaction: {}",
                    e
                )
            });
            self
        }
        pub fn stop_loss_order_created_cancel_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderCancelTransaction>>,
            T::Error: std::fmt::Display,
        {
            self . stop_loss_order_created_cancel_transaction = value . try_into () . map_err (| e | format ! ("error converting supplied value for stop_loss_order_created_cancel_transaction: {}" , e)) ;
            self
        }
        pub fn stop_loss_order_fill_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderFillTransaction>>,
            T::Error: std::fmt::Display,
        {
            self.stop_loss_order_fill_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for stop_loss_order_fill_transaction: {}",
                    e
                )
            });
            self
        }
        pub fn stop_loss_order_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossOrderTransaction>>,
            T::Error: std::fmt::Display,
        {
            self.stop_loss_order_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for stop_loss_order_transaction: {}",
                    e
                )
            });
            self
        }
        pub fn take_profit_order_cancel_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderCancelTransaction>>,
            T::Error: std::fmt::Display,
        {
            self.take_profit_order_cancel_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for take_profit_order_cancel_transaction: {}",
                    e
                )
            });
            self
        }
        pub fn take_profit_order_created_cancel_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderCancelTransaction>>,
            T::Error: std::fmt::Display,
        {
            self . take_profit_order_created_cancel_transaction = value . try_into () . map_err (| e | format ! ("error converting supplied value for take_profit_order_created_cancel_transaction: {}" , e)) ;
            self
        }
        pub fn take_profit_order_fill_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderFillTransaction>>,
            T::Error: std::fmt::Display,
        {
            self.take_profit_order_fill_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for take_profit_order_fill_transaction: {}",
                    e
                )
            });
            self
        }
        pub fn take_profit_order_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitOrderTransaction>>,
            T::Error: std::fmt::Display,
        {
            self.take_profit_order_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for take_profit_order_transaction: {}",
                    e
                )
            });
            self
        }
        pub fn trailing_stop_loss_order_cancel_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::OrderCancelTransaction>>,
            T::Error: std::fmt::Display,
        {
            self . trailing_stop_loss_order_cancel_transaction = value . try_into () . map_err (| e | format ! ("error converting supplied value for trailing_stop_loss_order_cancel_transaction: {}" , e)) ;
            self
        }
        pub fn trailing_stop_loss_order_transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossOrderTransaction>>,
            T::Error: std::fmt::Display,
        {
            self.trailing_stop_loss_order_transaction = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trailing_stop_loss_order_transaction: {}",
                    e
                )
            });
            self
        }
    }

    impl std::convert::TryFrom<SetTradeDependentOrdersResponse>
        for super::SetTradeDependentOrdersResponse
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: SetTradeDependentOrdersResponse,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                last_transaction_id: value.last_transaction_id?,
                related_transaction_i_ds: value.related_transaction_i_ds?,
                stop_loss_order_cancel_transaction: value.stop_loss_order_cancel_transaction?,
                stop_loss_order_created_cancel_transaction: value
                    .stop_loss_order_created_cancel_transaction?,
                stop_loss_order_fill_transaction: value.stop_loss_order_fill_transaction?,
                stop_loss_order_transaction: value.stop_loss_order_transaction?,
                take_profit_order_cancel_transaction: value.take_profit_order_cancel_transaction?,
                take_profit_order_created_cancel_transaction: value
                    .take_profit_order_created_cancel_transaction?,
                take_profit_order_fill_transaction: value.take_profit_order_fill_transaction?,
                take_profit_order_transaction: value.take_profit_order_transaction?,
                trailing_stop_loss_order_cancel_transaction: value
                    .trailing_stop_loss_order_cancel_transaction?,
                trailing_stop_loss_order_transaction: value.trailing_stop_loss_order_transaction?,
            })
        }
    }

    impl From<super::SetTradeDependentOrdersResponse> for SetTradeDependentOrdersResponse {
        fn from(value: super::SetTradeDependentOrdersResponse) -> Self {
            Self {
                last_transaction_id: Ok(value.last_transaction_id),
                related_transaction_i_ds: Ok(value.related_transaction_i_ds),
                stop_loss_order_cancel_transaction: Ok(value.stop_loss_order_cancel_transaction),
                stop_loss_order_created_cancel_transaction: Ok(
                    value.stop_loss_order_created_cancel_transaction
                ),
                stop_loss_order_fill_transaction: Ok(value.stop_loss_order_fill_transaction),
                stop_loss_order_transaction: Ok(value.stop_loss_order_transaction),
                take_profit_order_cancel_transaction: Ok(value.take_profit_order_cancel_transaction),
                take_profit_order_created_cancel_transaction: Ok(
                    value.take_profit_order_created_cancel_transaction
                ),
                take_profit_order_fill_transaction: Ok(value.take_profit_order_fill_transaction),
                take_profit_order_transaction: Ok(value.take_profit_order_transaction),
                trailing_stop_loss_order_cancel_transaction: Ok(
                    value.trailing_stop_loss_order_cancel_transaction
                ),
                trailing_stop_loss_order_transaction: Ok(value.trailing_stop_loss_order_transaction),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct StopLossDetails {
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        distance: Result<Option<String>, String>,
        gtd_time: Result<Option<String>, String>,
        guaranteed: Result<Option<bool>, String>,
        price: Result<Option<String>, String>,
        time_in_force: Result<Option<super::StopLossDetailsTimeInForce>, String>,
    }

    impl Default for StopLossDetails {
        fn default() -> Self {
            Self {
                client_extensions: Ok(Default::default()),
                distance: Ok(Default::default()),
                gtd_time: Ok(Default::default()),
                guaranteed: Ok(Default::default()),
                price: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
            }
        }
    }

    impl StopLossDetails {
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn distance<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.distance = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for distance: {}", e));
            self
        }
        pub fn gtd_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gtd_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for gtd_time: {}", e));
            self
        }
        pub fn guaranteed<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<bool>>,
            T::Error: std::fmt::Display,
        {
            self.guaranteed = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for guaranteed: {}", e));
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossDetailsTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<StopLossDetails> for super::StopLossDetails {
        type Error = super::error::ConversionError;
        fn try_from(value: StopLossDetails) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                client_extensions: value.client_extensions?,
                distance: value.distance?,
                gtd_time: value.gtd_time?,
                guaranteed: value.guaranteed?,
                price: value.price?,
                time_in_force: value.time_in_force?,
            })
        }
    }

    impl From<super::StopLossDetails> for StopLossDetails {
        fn from(value: super::StopLossDetails) -> Self {
            Self {
                client_extensions: Ok(value.client_extensions),
                distance: Ok(value.distance),
                gtd_time: Ok(value.gtd_time),
                guaranteed: Ok(value.guaranteed),
                price: Ok(value.price),
                time_in_force: Ok(value.time_in_force),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct StopLossOrder {
        cancelled_time: Result<Option<String>, String>,
        cancelling_transaction_id: Result<Option<String>, String>,
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        client_trade_id: Result<Option<String>, String>,
        create_time: Result<Option<String>, String>,
        distance: Result<Option<String>, String>,
        filled_time: Result<Option<String>, String>,
        filling_transaction_id: Result<Option<String>, String>,
        gtd_time: Result<Option<String>, String>,
        guaranteed: Result<Option<bool>, String>,
        guaranteed_execution_premium: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        price: Result<Option<String>, String>,
        replaced_by_order_id: Result<Option<String>, String>,
        replaces_order_id: Result<Option<String>, String>,
        state: Result<Option<super::StopLossOrderState>, String>,
        time_in_force: Result<Option<super::StopLossOrderTimeInForce>, String>,
        trade_closed_i_ds: Result<Vec<String>, String>,
        trade_id: Result<Option<String>, String>,
        trade_opened_id: Result<Option<String>, String>,
        trade_reduced_id: Result<Option<String>, String>,
        trigger_condition: Result<Option<super::StopLossOrderTriggerCondition>, String>,
        type_: Result<Option<super::StopLossOrderType>, String>,
    }

    impl Default for StopLossOrder {
        fn default() -> Self {
            Self {
                cancelled_time: Ok(Default::default()),
                cancelling_transaction_id: Ok(Default::default()),
                client_extensions: Ok(Default::default()),
                client_trade_id: Ok(Default::default()),
                create_time: Ok(Default::default()),
                distance: Ok(Default::default()),
                filled_time: Ok(Default::default()),
                filling_transaction_id: Ok(Default::default()),
                gtd_time: Ok(Default::default()),
                guaranteed: Ok(Default::default()),
                guaranteed_execution_premium: Ok(Default::default()),
                id: Ok(Default::default()),
                price: Ok(Default::default()),
                replaced_by_order_id: Ok(Default::default()),
                replaces_order_id: Ok(Default::default()),
                state: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_closed_i_ds: Ok(Default::default()),
                trade_id: Ok(Default::default()),
                trade_opened_id: Ok(Default::default()),
                trade_reduced_id: Ok(Default::default()),
                trigger_condition: Ok(Default::default()),
                type_: Ok(Default::default()),
            }
        }
    }

    impl StopLossOrder {
        pub fn cancelled_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.cancelled_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for cancelled_time: {}", e));
            self
        }
        pub fn cancelling_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.cancelling_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for cancelling_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn client_trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.client_trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for client_trade_id: {}", e));
            self
        }
        pub fn create_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.create_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for create_time: {}", e));
            self
        }
        pub fn distance<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.distance = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for distance: {}", e));
            self
        }
        pub fn filled_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.filled_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for filled_time: {}", e));
            self
        }
        pub fn filling_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.filling_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for filling_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn gtd_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gtd_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for gtd_time: {}", e));
            self
        }
        pub fn guaranteed<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<bool>>,
            T::Error: std::fmt::Display,
        {
            self.guaranteed = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for guaranteed: {}", e));
            self
        }
        pub fn guaranteed_execution_premium<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.guaranteed_execution_premium = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for guaranteed_execution_premium: {}",
                    e
                )
            });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn replaced_by_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.replaced_by_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for replaced_by_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn replaces_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.replaces_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for replaces_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn state<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossOrderState>>,
            T::Error: std::fmt::Display,
        {
            self.state = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for state: {}", e));
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossOrderTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_closed_i_ds<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_closed_i_ds = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_closed_i_ds: {}",
                    e
                )
            });
            self
        }
        pub fn trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_id: {}", e));
            self
        }
        pub fn trade_opened_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_opened_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_opened_id: {}", e));
            self
        }
        pub fn trade_reduced_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_reduced_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_reduced_id: {}",
                    e
                )
            });
            self
        }
        pub fn trigger_condition<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossOrderTriggerCondition>>,
            T::Error: std::fmt::Display,
        {
            self.trigger_condition = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trigger_condition: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossOrderType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<StopLossOrder> for super::StopLossOrder {
        type Error = super::error::ConversionError;
        fn try_from(value: StopLossOrder) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                cancelled_time: value.cancelled_time?,
                cancelling_transaction_id: value.cancelling_transaction_id?,
                client_extensions: value.client_extensions?,
                client_trade_id: value.client_trade_id?,
                create_time: value.create_time?,
                distance: value.distance?,
                filled_time: value.filled_time?,
                filling_transaction_id: value.filling_transaction_id?,
                gtd_time: value.gtd_time?,
                guaranteed: value.guaranteed?,
                guaranteed_execution_premium: value.guaranteed_execution_premium?,
                id: value.id?,
                price: value.price?,
                replaced_by_order_id: value.replaced_by_order_id?,
                replaces_order_id: value.replaces_order_id?,
                state: value.state?,
                time_in_force: value.time_in_force?,
                trade_closed_i_ds: value.trade_closed_i_ds?,
                trade_id: value.trade_id?,
                trade_opened_id: value.trade_opened_id?,
                trade_reduced_id: value.trade_reduced_id?,
                trigger_condition: value.trigger_condition?,
                type_: value.type_?,
            })
        }
    }

    impl From<super::StopLossOrder> for StopLossOrder {
        fn from(value: super::StopLossOrder) -> Self {
            Self {
                cancelled_time: Ok(value.cancelled_time),
                cancelling_transaction_id: Ok(value.cancelling_transaction_id),
                client_extensions: Ok(value.client_extensions),
                client_trade_id: Ok(value.client_trade_id),
                create_time: Ok(value.create_time),
                distance: Ok(value.distance),
                filled_time: Ok(value.filled_time),
                filling_transaction_id: Ok(value.filling_transaction_id),
                gtd_time: Ok(value.gtd_time),
                guaranteed: Ok(value.guaranteed),
                guaranteed_execution_premium: Ok(value.guaranteed_execution_premium),
                id: Ok(value.id),
                price: Ok(value.price),
                replaced_by_order_id: Ok(value.replaced_by_order_id),
                replaces_order_id: Ok(value.replaces_order_id),
                state: Ok(value.state),
                time_in_force: Ok(value.time_in_force),
                trade_closed_i_ds: Ok(value.trade_closed_i_ds),
                trade_id: Ok(value.trade_id),
                trade_opened_id: Ok(value.trade_opened_id),
                trade_reduced_id: Ok(value.trade_reduced_id),
                trigger_condition: Ok(value.trigger_condition),
                type_: Ok(value.type_),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct StopLossOrderRejectTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        client_trade_id: Result<Option<String>, String>,
        distance: Result<Option<String>, String>,
        gtd_time: Result<Option<String>, String>,
        guaranteed: Result<Option<bool>, String>,
        id: Result<Option<String>, String>,
        intended_replaces_order_id: Result<Option<String>, String>,
        order_fill_transaction_id: Result<Option<String>, String>,
        price: Result<Option<String>, String>,
        reason: Result<Option<super::StopLossOrderRejectTransactionReason>, String>,
        reject_reason: Result<Option<super::StopLossOrderRejectTransactionRejectReason>, String>,
        request_id: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
        time_in_force: Result<Option<super::StopLossOrderRejectTransactionTimeInForce>, String>,
        trade_id: Result<Option<String>, String>,
        trigger_condition:
            Result<Option<super::StopLossOrderRejectTransactionTriggerCondition>, String>,
        type_: Result<Option<super::StopLossOrderRejectTransactionType>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for StopLossOrderRejectTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                client_extensions: Ok(Default::default()),
                client_trade_id: Ok(Default::default()),
                distance: Ok(Default::default()),
                gtd_time: Ok(Default::default()),
                guaranteed: Ok(Default::default()),
                id: Ok(Default::default()),
                intended_replaces_order_id: Ok(Default::default()),
                order_fill_transaction_id: Ok(Default::default()),
                price: Ok(Default::default()),
                reason: Ok(Default::default()),
                reject_reason: Ok(Default::default()),
                request_id: Ok(Default::default()),
                time: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_id: Ok(Default::default()),
                trigger_condition: Ok(Default::default()),
                type_: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl StopLossOrderRejectTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn client_trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.client_trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for client_trade_id: {}", e));
            self
        }
        pub fn distance<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.distance = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for distance: {}", e));
            self
        }
        pub fn gtd_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gtd_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for gtd_time: {}", e));
            self
        }
        pub fn guaranteed<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<bool>>,
            T::Error: std::fmt::Display,
        {
            self.guaranteed = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for guaranteed: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn intended_replaces_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.intended_replaces_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for intended_replaces_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn order_fill_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.order_fill_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for order_fill_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossOrderRejectTransactionReason>>,
            T::Error: std::fmt::Display,
        {
            self.reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reason: {}", e));
            self
        }
        pub fn reject_reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossOrderRejectTransactionRejectReason>>,
            T::Error: std::fmt::Display,
        {
            self.reject_reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reject_reason: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossOrderRejectTransactionTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_id: {}", e));
            self
        }
        pub fn trigger_condition<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossOrderRejectTransactionTriggerCondition>>,
            T::Error: std::fmt::Display,
        {
            self.trigger_condition = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trigger_condition: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossOrderRejectTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<StopLossOrderRejectTransaction>
        for super::StopLossOrderRejectTransaction
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: StopLossOrderRejectTransaction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                client_extensions: value.client_extensions?,
                client_trade_id: value.client_trade_id?,
                distance: value.distance?,
                gtd_time: value.gtd_time?,
                guaranteed: value.guaranteed?,
                id: value.id?,
                intended_replaces_order_id: value.intended_replaces_order_id?,
                order_fill_transaction_id: value.order_fill_transaction_id?,
                price: value.price?,
                reason: value.reason?,
                reject_reason: value.reject_reason?,
                request_id: value.request_id?,
                time: value.time?,
                time_in_force: value.time_in_force?,
                trade_id: value.trade_id?,
                trigger_condition: value.trigger_condition?,
                type_: value.type_?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::StopLossOrderRejectTransaction> for StopLossOrderRejectTransaction {
        fn from(value: super::StopLossOrderRejectTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                client_extensions: Ok(value.client_extensions),
                client_trade_id: Ok(value.client_trade_id),
                distance: Ok(value.distance),
                gtd_time: Ok(value.gtd_time),
                guaranteed: Ok(value.guaranteed),
                id: Ok(value.id),
                intended_replaces_order_id: Ok(value.intended_replaces_order_id),
                order_fill_transaction_id: Ok(value.order_fill_transaction_id),
                price: Ok(value.price),
                reason: Ok(value.reason),
                reject_reason: Ok(value.reject_reason),
                request_id: Ok(value.request_id),
                time: Ok(value.time),
                time_in_force: Ok(value.time_in_force),
                trade_id: Ok(value.trade_id),
                trigger_condition: Ok(value.trigger_condition),
                type_: Ok(value.type_),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct StopLossOrderRequest {
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        client_trade_id: Result<Option<String>, String>,
        distance: Result<Option<String>, String>,
        gtd_time: Result<Option<String>, String>,
        guaranteed: Result<Option<bool>, String>,
        price: Result<Option<String>, String>,
        time_in_force: Result<Option<super::StopLossOrderRequestTimeInForce>, String>,
        trade_id: Result<Option<String>, String>,
        trigger_condition: Result<Option<super::StopLossOrderRequestTriggerCondition>, String>,
        type_: Result<Option<super::StopLossOrderRequestType>, String>,
    }

    impl Default for StopLossOrderRequest {
        fn default() -> Self {
            Self {
                client_extensions: Ok(Default::default()),
                client_trade_id: Ok(Default::default()),
                distance: Ok(Default::default()),
                gtd_time: Ok(Default::default()),
                guaranteed: Ok(Default::default()),
                price: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_id: Ok(Default::default()),
                trigger_condition: Ok(Default::default()),
                type_: Ok(Default::default()),
            }
        }
    }

    impl StopLossOrderRequest {
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn client_trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.client_trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for client_trade_id: {}", e));
            self
        }
        pub fn distance<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.distance = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for distance: {}", e));
            self
        }
        pub fn gtd_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gtd_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for gtd_time: {}", e));
            self
        }
        pub fn guaranteed<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<bool>>,
            T::Error: std::fmt::Display,
        {
            self.guaranteed = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for guaranteed: {}", e));
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossOrderRequestTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_id: {}", e));
            self
        }
        pub fn trigger_condition<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossOrderRequestTriggerCondition>>,
            T::Error: std::fmt::Display,
        {
            self.trigger_condition = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trigger_condition: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossOrderRequestType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<StopLossOrderRequest> for super::StopLossOrderRequest {
        type Error = super::error::ConversionError;
        fn try_from(value: StopLossOrderRequest) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                client_extensions: value.client_extensions?,
                client_trade_id: value.client_trade_id?,
                distance: value.distance?,
                gtd_time: value.gtd_time?,
                guaranteed: value.guaranteed?,
                price: value.price?,
                time_in_force: value.time_in_force?,
                trade_id: value.trade_id?,
                trigger_condition: value.trigger_condition?,
                type_: value.type_?,
            })
        }
    }

    impl From<super::StopLossOrderRequest> for StopLossOrderRequest {
        fn from(value: super::StopLossOrderRequest) -> Self {
            Self {
                client_extensions: Ok(value.client_extensions),
                client_trade_id: Ok(value.client_trade_id),
                distance: Ok(value.distance),
                gtd_time: Ok(value.gtd_time),
                guaranteed: Ok(value.guaranteed),
                price: Ok(value.price),
                time_in_force: Ok(value.time_in_force),
                trade_id: Ok(value.trade_id),
                trigger_condition: Ok(value.trigger_condition),
                type_: Ok(value.type_),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct StopLossOrderTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        cancelling_transaction_id: Result<Option<String>, String>,
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        client_trade_id: Result<Option<String>, String>,
        distance: Result<Option<String>, String>,
        gtd_time: Result<Option<String>, String>,
        guaranteed: Result<Option<bool>, String>,
        guaranteed_execution_premium: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        order_fill_transaction_id: Result<Option<String>, String>,
        price: Result<Option<String>, String>,
        reason: Result<Option<super::StopLossOrderTransactionReason>, String>,
        replaces_order_id: Result<Option<String>, String>,
        request_id: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
        time_in_force: Result<Option<super::StopLossOrderTransactionTimeInForce>, String>,
        trade_id: Result<Option<String>, String>,
        trigger_condition: Result<Option<super::StopLossOrderTransactionTriggerCondition>, String>,
        type_: Result<Option<super::StopLossOrderTransactionType>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for StopLossOrderTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                cancelling_transaction_id: Ok(Default::default()),
                client_extensions: Ok(Default::default()),
                client_trade_id: Ok(Default::default()),
                distance: Ok(Default::default()),
                gtd_time: Ok(Default::default()),
                guaranteed: Ok(Default::default()),
                guaranteed_execution_premium: Ok(Default::default()),
                id: Ok(Default::default()),
                order_fill_transaction_id: Ok(Default::default()),
                price: Ok(Default::default()),
                reason: Ok(Default::default()),
                replaces_order_id: Ok(Default::default()),
                request_id: Ok(Default::default()),
                time: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_id: Ok(Default::default()),
                trigger_condition: Ok(Default::default()),
                type_: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl StopLossOrderTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn cancelling_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.cancelling_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for cancelling_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn client_trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.client_trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for client_trade_id: {}", e));
            self
        }
        pub fn distance<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.distance = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for distance: {}", e));
            self
        }
        pub fn gtd_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gtd_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for gtd_time: {}", e));
            self
        }
        pub fn guaranteed<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<bool>>,
            T::Error: std::fmt::Display,
        {
            self.guaranteed = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for guaranteed: {}", e));
            self
        }
        pub fn guaranteed_execution_premium<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.guaranteed_execution_premium = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for guaranteed_execution_premium: {}",
                    e
                )
            });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn order_fill_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.order_fill_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for order_fill_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossOrderTransactionReason>>,
            T::Error: std::fmt::Display,
        {
            self.reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reason: {}", e));
            self
        }
        pub fn replaces_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.replaces_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for replaces_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossOrderTransactionTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_id: {}", e));
            self
        }
        pub fn trigger_condition<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossOrderTransactionTriggerCondition>>,
            T::Error: std::fmt::Display,
        {
            self.trigger_condition = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trigger_condition: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossOrderTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<StopLossOrderTransaction> for super::StopLossOrderTransaction {
        type Error = super::error::ConversionError;
        fn try_from(
            value: StopLossOrderTransaction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                cancelling_transaction_id: value.cancelling_transaction_id?,
                client_extensions: value.client_extensions?,
                client_trade_id: value.client_trade_id?,
                distance: value.distance?,
                gtd_time: value.gtd_time?,
                guaranteed: value.guaranteed?,
                guaranteed_execution_premium: value.guaranteed_execution_premium?,
                id: value.id?,
                order_fill_transaction_id: value.order_fill_transaction_id?,
                price: value.price?,
                reason: value.reason?,
                replaces_order_id: value.replaces_order_id?,
                request_id: value.request_id?,
                time: value.time?,
                time_in_force: value.time_in_force?,
                trade_id: value.trade_id?,
                trigger_condition: value.trigger_condition?,
                type_: value.type_?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::StopLossOrderTransaction> for StopLossOrderTransaction {
        fn from(value: super::StopLossOrderTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                cancelling_transaction_id: Ok(value.cancelling_transaction_id),
                client_extensions: Ok(value.client_extensions),
                client_trade_id: Ok(value.client_trade_id),
                distance: Ok(value.distance),
                gtd_time: Ok(value.gtd_time),
                guaranteed: Ok(value.guaranteed),
                guaranteed_execution_premium: Ok(value.guaranteed_execution_premium),
                id: Ok(value.id),
                order_fill_transaction_id: Ok(value.order_fill_transaction_id),
                price: Ok(value.price),
                reason: Ok(value.reason),
                replaces_order_id: Ok(value.replaces_order_id),
                request_id: Ok(value.request_id),
                time: Ok(value.time),
                time_in_force: Ok(value.time_in_force),
                trade_id: Ok(value.trade_id),
                trigger_condition: Ok(value.trigger_condition),
                type_: Ok(value.type_),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct StopOrder {
        cancelled_time: Result<Option<String>, String>,
        cancelling_transaction_id: Result<Option<String>, String>,
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        create_time: Result<Option<String>, String>,
        filled_time: Result<Option<String>, String>,
        filling_transaction_id: Result<Option<String>, String>,
        gtd_time: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        instrument: Result<Option<String>, String>,
        position_fill: Result<Option<super::StopOrderPositionFill>, String>,
        price: Result<Option<String>, String>,
        price_bound: Result<Option<String>, String>,
        replaced_by_order_id: Result<Option<String>, String>,
        replaces_order_id: Result<Option<String>, String>,
        state: Result<Option<super::StopOrderState>, String>,
        stop_loss_on_fill: Result<Option<super::StopLossDetails>, String>,
        take_profit_on_fill: Result<Option<super::TakeProfitDetails>, String>,
        time_in_force: Result<Option<super::StopOrderTimeInForce>, String>,
        trade_client_extensions: Result<Option<super::ClientExtensions>, String>,
        trade_closed_i_ds: Result<Vec<String>, String>,
        trade_opened_id: Result<Option<String>, String>,
        trade_reduced_id: Result<Option<String>, String>,
        trailing_stop_loss_on_fill: Result<Option<super::TrailingStopLossDetails>, String>,
        trigger_condition: Result<Option<super::StopOrderTriggerCondition>, String>,
        type_: Result<Option<super::StopOrderType>, String>,
        units: Result<Option<String>, String>,
    }

    impl Default for StopOrder {
        fn default() -> Self {
            Self {
                cancelled_time: Ok(Default::default()),
                cancelling_transaction_id: Ok(Default::default()),
                client_extensions: Ok(Default::default()),
                create_time: Ok(Default::default()),
                filled_time: Ok(Default::default()),
                filling_transaction_id: Ok(Default::default()),
                gtd_time: Ok(Default::default()),
                id: Ok(Default::default()),
                instrument: Ok(Default::default()),
                position_fill: Ok(Default::default()),
                price: Ok(Default::default()),
                price_bound: Ok(Default::default()),
                replaced_by_order_id: Ok(Default::default()),
                replaces_order_id: Ok(Default::default()),
                state: Ok(Default::default()),
                stop_loss_on_fill: Ok(Default::default()),
                take_profit_on_fill: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_client_extensions: Ok(Default::default()),
                trade_closed_i_ds: Ok(Default::default()),
                trade_opened_id: Ok(Default::default()),
                trade_reduced_id: Ok(Default::default()),
                trailing_stop_loss_on_fill: Ok(Default::default()),
                trigger_condition: Ok(Default::default()),
                type_: Ok(Default::default()),
                units: Ok(Default::default()),
            }
        }
    }

    impl StopOrder {
        pub fn cancelled_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.cancelled_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for cancelled_time: {}", e));
            self
        }
        pub fn cancelling_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.cancelling_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for cancelling_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn create_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.create_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for create_time: {}", e));
            self
        }
        pub fn filled_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.filled_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for filled_time: {}", e));
            self
        }
        pub fn filling_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.filling_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for filling_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn gtd_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gtd_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for gtd_time: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn position_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopOrderPositionFill>>,
            T::Error: std::fmt::Display,
        {
            self.position_fill = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for position_fill: {}", e));
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn price_bound<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price_bound = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price_bound: {}", e));
            self
        }
        pub fn replaced_by_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.replaced_by_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for replaced_by_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn replaces_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.replaces_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for replaces_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn state<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopOrderState>>,
            T::Error: std::fmt::Display,
        {
            self.state = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for state: {}", e));
            self
        }
        pub fn stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn take_profit_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitDetails>>,
            T::Error: std::fmt::Display,
        {
            self.take_profit_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for take_profit_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopOrderTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.trade_client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn trade_closed_i_ds<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_closed_i_ds = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_closed_i_ds: {}",
                    e
                )
            });
            self
        }
        pub fn trade_opened_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_opened_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_opened_id: {}", e));
            self
        }
        pub fn trade_reduced_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_reduced_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_reduced_id: {}",
                    e
                )
            });
            self
        }
        pub fn trailing_stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.trailing_stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trailing_stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn trigger_condition<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopOrderTriggerCondition>>,
            T::Error: std::fmt::Display,
        {
            self.trigger_condition = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trigger_condition: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopOrderType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for units: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<StopOrder> for super::StopOrder {
        type Error = super::error::ConversionError;
        fn try_from(value: StopOrder) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                cancelled_time: value.cancelled_time?,
                cancelling_transaction_id: value.cancelling_transaction_id?,
                client_extensions: value.client_extensions?,
                create_time: value.create_time?,
                filled_time: value.filled_time?,
                filling_transaction_id: value.filling_transaction_id?,
                gtd_time: value.gtd_time?,
                id: value.id?,
                instrument: value.instrument?,
                position_fill: value.position_fill?,
                price: value.price?,
                price_bound: value.price_bound?,
                replaced_by_order_id: value.replaced_by_order_id?,
                replaces_order_id: value.replaces_order_id?,
                state: value.state?,
                stop_loss_on_fill: value.stop_loss_on_fill?,
                take_profit_on_fill: value.take_profit_on_fill?,
                time_in_force: value.time_in_force?,
                trade_client_extensions: value.trade_client_extensions?,
                trade_closed_i_ds: value.trade_closed_i_ds?,
                trade_opened_id: value.trade_opened_id?,
                trade_reduced_id: value.trade_reduced_id?,
                trailing_stop_loss_on_fill: value.trailing_stop_loss_on_fill?,
                trigger_condition: value.trigger_condition?,
                type_: value.type_?,
                units: value.units?,
            })
        }
    }

    impl From<super::StopOrder> for StopOrder {
        fn from(value: super::StopOrder) -> Self {
            Self {
                cancelled_time: Ok(value.cancelled_time),
                cancelling_transaction_id: Ok(value.cancelling_transaction_id),
                client_extensions: Ok(value.client_extensions),
                create_time: Ok(value.create_time),
                filled_time: Ok(value.filled_time),
                filling_transaction_id: Ok(value.filling_transaction_id),
                gtd_time: Ok(value.gtd_time),
                id: Ok(value.id),
                instrument: Ok(value.instrument),
                position_fill: Ok(value.position_fill),
                price: Ok(value.price),
                price_bound: Ok(value.price_bound),
                replaced_by_order_id: Ok(value.replaced_by_order_id),
                replaces_order_id: Ok(value.replaces_order_id),
                state: Ok(value.state),
                stop_loss_on_fill: Ok(value.stop_loss_on_fill),
                take_profit_on_fill: Ok(value.take_profit_on_fill),
                time_in_force: Ok(value.time_in_force),
                trade_client_extensions: Ok(value.trade_client_extensions),
                trade_closed_i_ds: Ok(value.trade_closed_i_ds),
                trade_opened_id: Ok(value.trade_opened_id),
                trade_reduced_id: Ok(value.trade_reduced_id),
                trailing_stop_loss_on_fill: Ok(value.trailing_stop_loss_on_fill),
                trigger_condition: Ok(value.trigger_condition),
                type_: Ok(value.type_),
                units: Ok(value.units),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct StopOrderRejectTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        gtd_time: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        instrument: Result<Option<String>, String>,
        intended_replaces_order_id: Result<Option<String>, String>,
        position_fill: Result<Option<super::StopOrderRejectTransactionPositionFill>, String>,
        price: Result<Option<String>, String>,
        price_bound: Result<Option<String>, String>,
        reason: Result<Option<super::StopOrderRejectTransactionReason>, String>,
        reject_reason: Result<Option<super::StopOrderRejectTransactionRejectReason>, String>,
        request_id: Result<Option<String>, String>,
        stop_loss_on_fill: Result<Option<super::StopLossDetails>, String>,
        take_profit_on_fill: Result<Option<super::TakeProfitDetails>, String>,
        time: Result<Option<String>, String>,
        time_in_force: Result<Option<super::StopOrderRejectTransactionTimeInForce>, String>,
        trade_client_extensions: Result<Option<super::ClientExtensions>, String>,
        trailing_stop_loss_on_fill: Result<Option<super::TrailingStopLossDetails>, String>,
        trigger_condition:
            Result<Option<super::StopOrderRejectTransactionTriggerCondition>, String>,
        type_: Result<Option<super::StopOrderRejectTransactionType>, String>,
        units: Result<Option<String>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for StopOrderRejectTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                client_extensions: Ok(Default::default()),
                gtd_time: Ok(Default::default()),
                id: Ok(Default::default()),
                instrument: Ok(Default::default()),
                intended_replaces_order_id: Ok(Default::default()),
                position_fill: Ok(Default::default()),
                price: Ok(Default::default()),
                price_bound: Ok(Default::default()),
                reason: Ok(Default::default()),
                reject_reason: Ok(Default::default()),
                request_id: Ok(Default::default()),
                stop_loss_on_fill: Ok(Default::default()),
                take_profit_on_fill: Ok(Default::default()),
                time: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_client_extensions: Ok(Default::default()),
                trailing_stop_loss_on_fill: Ok(Default::default()),
                trigger_condition: Ok(Default::default()),
                type_: Ok(Default::default()),
                units: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl StopOrderRejectTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn gtd_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gtd_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for gtd_time: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn intended_replaces_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.intended_replaces_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for intended_replaces_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn position_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopOrderRejectTransactionPositionFill>>,
            T::Error: std::fmt::Display,
        {
            self.position_fill = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for position_fill: {}", e));
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn price_bound<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price_bound = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price_bound: {}", e));
            self
        }
        pub fn reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopOrderRejectTransactionReason>>,
            T::Error: std::fmt::Display,
        {
            self.reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reason: {}", e));
            self
        }
        pub fn reject_reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopOrderRejectTransactionRejectReason>>,
            T::Error: std::fmt::Display,
        {
            self.reject_reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reject_reason: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn take_profit_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitDetails>>,
            T::Error: std::fmt::Display,
        {
            self.take_profit_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for take_profit_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopOrderRejectTransactionTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.trade_client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn trailing_stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.trailing_stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trailing_stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn trigger_condition<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopOrderRejectTransactionTriggerCondition>>,
            T::Error: std::fmt::Display,
        {
            self.trigger_condition = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trigger_condition: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopOrderRejectTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for units: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<StopOrderRejectTransaction> for super::StopOrderRejectTransaction {
        type Error = super::error::ConversionError;
        fn try_from(
            value: StopOrderRejectTransaction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                client_extensions: value.client_extensions?,
                gtd_time: value.gtd_time?,
                id: value.id?,
                instrument: value.instrument?,
                intended_replaces_order_id: value.intended_replaces_order_id?,
                position_fill: value.position_fill?,
                price: value.price?,
                price_bound: value.price_bound?,
                reason: value.reason?,
                reject_reason: value.reject_reason?,
                request_id: value.request_id?,
                stop_loss_on_fill: value.stop_loss_on_fill?,
                take_profit_on_fill: value.take_profit_on_fill?,
                time: value.time?,
                time_in_force: value.time_in_force?,
                trade_client_extensions: value.trade_client_extensions?,
                trailing_stop_loss_on_fill: value.trailing_stop_loss_on_fill?,
                trigger_condition: value.trigger_condition?,
                type_: value.type_?,
                units: value.units?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::StopOrderRejectTransaction> for StopOrderRejectTransaction {
        fn from(value: super::StopOrderRejectTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                client_extensions: Ok(value.client_extensions),
                gtd_time: Ok(value.gtd_time),
                id: Ok(value.id),
                instrument: Ok(value.instrument),
                intended_replaces_order_id: Ok(value.intended_replaces_order_id),
                position_fill: Ok(value.position_fill),
                price: Ok(value.price),
                price_bound: Ok(value.price_bound),
                reason: Ok(value.reason),
                reject_reason: Ok(value.reject_reason),
                request_id: Ok(value.request_id),
                stop_loss_on_fill: Ok(value.stop_loss_on_fill),
                take_profit_on_fill: Ok(value.take_profit_on_fill),
                time: Ok(value.time),
                time_in_force: Ok(value.time_in_force),
                trade_client_extensions: Ok(value.trade_client_extensions),
                trailing_stop_loss_on_fill: Ok(value.trailing_stop_loss_on_fill),
                trigger_condition: Ok(value.trigger_condition),
                type_: Ok(value.type_),
                units: Ok(value.units),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct StopOrderRequest {
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        gtd_time: Result<Option<String>, String>,
        instrument: Result<Option<String>, String>,
        position_fill: Result<Option<super::StopOrderRequestPositionFill>, String>,
        price: Result<Option<String>, String>,
        price_bound: Result<Option<String>, String>,
        stop_loss_on_fill: Result<Option<super::StopLossDetails>, String>,
        take_profit_on_fill: Result<Option<super::TakeProfitDetails>, String>,
        time_in_force: Result<Option<super::StopOrderRequestTimeInForce>, String>,
        trade_client_extensions: Result<Option<super::ClientExtensions>, String>,
        trailing_stop_loss_on_fill: Result<Option<super::TrailingStopLossDetails>, String>,
        trigger_condition: Result<Option<super::StopOrderRequestTriggerCondition>, String>,
        type_: Result<Option<super::StopOrderRequestType>, String>,
        units: Result<Option<String>, String>,
    }

    impl Default for StopOrderRequest {
        fn default() -> Self {
            Self {
                client_extensions: Ok(Default::default()),
                gtd_time: Ok(Default::default()),
                instrument: Ok(Default::default()),
                position_fill: Ok(Default::default()),
                price: Ok(Default::default()),
                price_bound: Ok(Default::default()),
                stop_loss_on_fill: Ok(Default::default()),
                take_profit_on_fill: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_client_extensions: Ok(Default::default()),
                trailing_stop_loss_on_fill: Ok(Default::default()),
                trigger_condition: Ok(Default::default()),
                type_: Ok(Default::default()),
                units: Ok(Default::default()),
            }
        }
    }

    impl StopOrderRequest {
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn gtd_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gtd_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for gtd_time: {}", e));
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn position_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopOrderRequestPositionFill>>,
            T::Error: std::fmt::Display,
        {
            self.position_fill = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for position_fill: {}", e));
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn price_bound<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price_bound = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price_bound: {}", e));
            self
        }
        pub fn stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn take_profit_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitDetails>>,
            T::Error: std::fmt::Display,
        {
            self.take_profit_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for take_profit_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopOrderRequestTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.trade_client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn trailing_stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.trailing_stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trailing_stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn trigger_condition<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopOrderRequestTriggerCondition>>,
            T::Error: std::fmt::Display,
        {
            self.trigger_condition = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trigger_condition: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopOrderRequestType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for units: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<StopOrderRequest> for super::StopOrderRequest {
        type Error = super::error::ConversionError;
        fn try_from(value: StopOrderRequest) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                client_extensions: value.client_extensions?,
                gtd_time: value.gtd_time?,
                instrument: value.instrument?,
                position_fill: value.position_fill?,
                price: value.price?,
                price_bound: value.price_bound?,
                stop_loss_on_fill: value.stop_loss_on_fill?,
                take_profit_on_fill: value.take_profit_on_fill?,
                time_in_force: value.time_in_force?,
                trade_client_extensions: value.trade_client_extensions?,
                trailing_stop_loss_on_fill: value.trailing_stop_loss_on_fill?,
                trigger_condition: value.trigger_condition?,
                type_: value.type_?,
                units: value.units?,
            })
        }
    }

    impl From<super::StopOrderRequest> for StopOrderRequest {
        fn from(value: super::StopOrderRequest) -> Self {
            Self {
                client_extensions: Ok(value.client_extensions),
                gtd_time: Ok(value.gtd_time),
                instrument: Ok(value.instrument),
                position_fill: Ok(value.position_fill),
                price: Ok(value.price),
                price_bound: Ok(value.price_bound),
                stop_loss_on_fill: Ok(value.stop_loss_on_fill),
                take_profit_on_fill: Ok(value.take_profit_on_fill),
                time_in_force: Ok(value.time_in_force),
                trade_client_extensions: Ok(value.trade_client_extensions),
                trailing_stop_loss_on_fill: Ok(value.trailing_stop_loss_on_fill),
                trigger_condition: Ok(value.trigger_condition),
                type_: Ok(value.type_),
                units: Ok(value.units),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct StopOrderTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        cancelling_transaction_id: Result<Option<String>, String>,
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        gtd_time: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        instrument: Result<Option<String>, String>,
        position_fill: Result<Option<super::StopOrderTransactionPositionFill>, String>,
        price: Result<Option<String>, String>,
        price_bound: Result<Option<String>, String>,
        reason: Result<Option<super::StopOrderTransactionReason>, String>,
        replaces_order_id: Result<Option<String>, String>,
        request_id: Result<Option<String>, String>,
        stop_loss_on_fill: Result<Option<super::StopLossDetails>, String>,
        take_profit_on_fill: Result<Option<super::TakeProfitDetails>, String>,
        time: Result<Option<String>, String>,
        time_in_force: Result<Option<super::StopOrderTransactionTimeInForce>, String>,
        trade_client_extensions: Result<Option<super::ClientExtensions>, String>,
        trailing_stop_loss_on_fill: Result<Option<super::TrailingStopLossDetails>, String>,
        trigger_condition: Result<Option<super::StopOrderTransactionTriggerCondition>, String>,
        type_: Result<Option<super::StopOrderTransactionType>, String>,
        units: Result<Option<String>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for StopOrderTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                cancelling_transaction_id: Ok(Default::default()),
                client_extensions: Ok(Default::default()),
                gtd_time: Ok(Default::default()),
                id: Ok(Default::default()),
                instrument: Ok(Default::default()),
                position_fill: Ok(Default::default()),
                price: Ok(Default::default()),
                price_bound: Ok(Default::default()),
                reason: Ok(Default::default()),
                replaces_order_id: Ok(Default::default()),
                request_id: Ok(Default::default()),
                stop_loss_on_fill: Ok(Default::default()),
                take_profit_on_fill: Ok(Default::default()),
                time: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_client_extensions: Ok(Default::default()),
                trailing_stop_loss_on_fill: Ok(Default::default()),
                trigger_condition: Ok(Default::default()),
                type_: Ok(Default::default()),
                units: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl StopOrderTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn cancelling_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.cancelling_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for cancelling_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn gtd_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gtd_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for gtd_time: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn position_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopOrderTransactionPositionFill>>,
            T::Error: std::fmt::Display,
        {
            self.position_fill = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for position_fill: {}", e));
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn price_bound<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price_bound = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price_bound: {}", e));
            self
        }
        pub fn reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopOrderTransactionReason>>,
            T::Error: std::fmt::Display,
        {
            self.reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reason: {}", e));
            self
        }
        pub fn replaces_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.replaces_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for replaces_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn take_profit_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitDetails>>,
            T::Error: std::fmt::Display,
        {
            self.take_profit_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for take_profit_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopOrderTransactionTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.trade_client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn trailing_stop_loss_on_fill<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossDetails>>,
            T::Error: std::fmt::Display,
        {
            self.trailing_stop_loss_on_fill = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trailing_stop_loss_on_fill: {}",
                    e
                )
            });
            self
        }
        pub fn trigger_condition<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopOrderTransactionTriggerCondition>>,
            T::Error: std::fmt::Display,
        {
            self.trigger_condition = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trigger_condition: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopOrderTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for units: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<StopOrderTransaction> for super::StopOrderTransaction {
        type Error = super::error::ConversionError;
        fn try_from(value: StopOrderTransaction) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                cancelling_transaction_id: value.cancelling_transaction_id?,
                client_extensions: value.client_extensions?,
                gtd_time: value.gtd_time?,
                id: value.id?,
                instrument: value.instrument?,
                position_fill: value.position_fill?,
                price: value.price?,
                price_bound: value.price_bound?,
                reason: value.reason?,
                replaces_order_id: value.replaces_order_id?,
                request_id: value.request_id?,
                stop_loss_on_fill: value.stop_loss_on_fill?,
                take_profit_on_fill: value.take_profit_on_fill?,
                time: value.time?,
                time_in_force: value.time_in_force?,
                trade_client_extensions: value.trade_client_extensions?,
                trailing_stop_loss_on_fill: value.trailing_stop_loss_on_fill?,
                trigger_condition: value.trigger_condition?,
                type_: value.type_?,
                units: value.units?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::StopOrderTransaction> for StopOrderTransaction {
        fn from(value: super::StopOrderTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                cancelling_transaction_id: Ok(value.cancelling_transaction_id),
                client_extensions: Ok(value.client_extensions),
                gtd_time: Ok(value.gtd_time),
                id: Ok(value.id),
                instrument: Ok(value.instrument),
                position_fill: Ok(value.position_fill),
                price: Ok(value.price),
                price_bound: Ok(value.price_bound),
                reason: Ok(value.reason),
                replaces_order_id: Ok(value.replaces_order_id),
                request_id: Ok(value.request_id),
                stop_loss_on_fill: Ok(value.stop_loss_on_fill),
                take_profit_on_fill: Ok(value.take_profit_on_fill),
                time: Ok(value.time),
                time_in_force: Ok(value.time_in_force),
                trade_client_extensions: Ok(value.trade_client_extensions),
                trailing_stop_loss_on_fill: Ok(value.trailing_stop_loss_on_fill),
                trigger_condition: Ok(value.trigger_condition),
                type_: Ok(value.type_),
                units: Ok(value.units),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct StreamPricingResponse {
        heartbeat: Result<Option<super::PricingHeartbeat>, String>,
        price: Result<Option<super::ClientPrice>, String>,
    }

    impl Default for StreamPricingResponse {
        fn default() -> Self {
            Self {
                heartbeat: Ok(Default::default()),
                price: Ok(Default::default()),
            }
        }
    }

    impl StreamPricingResponse {
        pub fn heartbeat<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::PricingHeartbeat>>,
            T::Error: std::fmt::Display,
        {
            self.heartbeat = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for heartbeat: {}", e));
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientPrice>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<StreamPricingResponse> for super::StreamPricingResponse {
        type Error = super::error::ConversionError;
        fn try_from(value: StreamPricingResponse) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                heartbeat: value.heartbeat?,
                price: value.price?,
            })
        }
    }

    impl From<super::StreamPricingResponse> for StreamPricingResponse {
        fn from(value: super::StreamPricingResponse) -> Self {
            Self {
                heartbeat: Ok(value.heartbeat),
                price: Ok(value.price),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct StreamTransactionsResponse {
        heartbeat: Result<Option<super::TransactionHeartbeat>, String>,
        transaction: Result<Option<super::Transaction>, String>,
    }

    impl Default for StreamTransactionsResponse {
        fn default() -> Self {
            Self {
                heartbeat: Ok(Default::default()),
                transaction: Ok(Default::default()),
            }
        }
    }

    impl StreamTransactionsResponse {
        pub fn heartbeat<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TransactionHeartbeat>>,
            T::Error: std::fmt::Display,
        {
            self.heartbeat = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for heartbeat: {}", e));
            self
        }
        pub fn transaction<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::Transaction>>,
            T::Error: std::fmt::Display,
        {
            self.transaction = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for transaction: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<StreamTransactionsResponse> for super::StreamTransactionsResponse {
        type Error = super::error::ConversionError;
        fn try_from(
            value: StreamTransactionsResponse,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                heartbeat: value.heartbeat?,
                transaction: value.transaction?,
            })
        }
    }

    impl From<super::StreamTransactionsResponse> for StreamTransactionsResponse {
        fn from(value: super::StreamTransactionsResponse) -> Self {
            Self {
                heartbeat: Ok(value.heartbeat),
                transaction: Ok(value.transaction),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct TakeProfitDetails {
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        gtd_time: Result<Option<String>, String>,
        price: Result<Option<String>, String>,
        time_in_force: Result<Option<super::TakeProfitDetailsTimeInForce>, String>,
    }

    impl Default for TakeProfitDetails {
        fn default() -> Self {
            Self {
                client_extensions: Ok(Default::default()),
                gtd_time: Ok(Default::default()),
                price: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
            }
        }
    }

    impl TakeProfitDetails {
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn gtd_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gtd_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for gtd_time: {}", e));
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitDetailsTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<TakeProfitDetails> for super::TakeProfitDetails {
        type Error = super::error::ConversionError;
        fn try_from(value: TakeProfitDetails) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                client_extensions: value.client_extensions?,
                gtd_time: value.gtd_time?,
                price: value.price?,
                time_in_force: value.time_in_force?,
            })
        }
    }

    impl From<super::TakeProfitDetails> for TakeProfitDetails {
        fn from(value: super::TakeProfitDetails) -> Self {
            Self {
                client_extensions: Ok(value.client_extensions),
                gtd_time: Ok(value.gtd_time),
                price: Ok(value.price),
                time_in_force: Ok(value.time_in_force),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct TakeProfitOrder {
        cancelled_time: Result<Option<String>, String>,
        cancelling_transaction_id: Result<Option<String>, String>,
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        client_trade_id: Result<Option<String>, String>,
        create_time: Result<Option<String>, String>,
        filled_time: Result<Option<String>, String>,
        filling_transaction_id: Result<Option<String>, String>,
        gtd_time: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        price: Result<Option<String>, String>,
        replaced_by_order_id: Result<Option<String>, String>,
        replaces_order_id: Result<Option<String>, String>,
        state: Result<Option<super::TakeProfitOrderState>, String>,
        time_in_force: Result<Option<super::TakeProfitOrderTimeInForce>, String>,
        trade_closed_i_ds: Result<Vec<String>, String>,
        trade_id: Result<Option<String>, String>,
        trade_opened_id: Result<Option<String>, String>,
        trade_reduced_id: Result<Option<String>, String>,
        trigger_condition: Result<Option<super::TakeProfitOrderTriggerCondition>, String>,
        type_: Result<Option<super::TakeProfitOrderType>, String>,
    }

    impl Default for TakeProfitOrder {
        fn default() -> Self {
            Self {
                cancelled_time: Ok(Default::default()),
                cancelling_transaction_id: Ok(Default::default()),
                client_extensions: Ok(Default::default()),
                client_trade_id: Ok(Default::default()),
                create_time: Ok(Default::default()),
                filled_time: Ok(Default::default()),
                filling_transaction_id: Ok(Default::default()),
                gtd_time: Ok(Default::default()),
                id: Ok(Default::default()),
                price: Ok(Default::default()),
                replaced_by_order_id: Ok(Default::default()),
                replaces_order_id: Ok(Default::default()),
                state: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_closed_i_ds: Ok(Default::default()),
                trade_id: Ok(Default::default()),
                trade_opened_id: Ok(Default::default()),
                trade_reduced_id: Ok(Default::default()),
                trigger_condition: Ok(Default::default()),
                type_: Ok(Default::default()),
            }
        }
    }

    impl TakeProfitOrder {
        pub fn cancelled_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.cancelled_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for cancelled_time: {}", e));
            self
        }
        pub fn cancelling_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.cancelling_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for cancelling_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn client_trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.client_trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for client_trade_id: {}", e));
            self
        }
        pub fn create_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.create_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for create_time: {}", e));
            self
        }
        pub fn filled_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.filled_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for filled_time: {}", e));
            self
        }
        pub fn filling_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.filling_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for filling_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn gtd_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gtd_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for gtd_time: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn replaced_by_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.replaced_by_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for replaced_by_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn replaces_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.replaces_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for replaces_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn state<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitOrderState>>,
            T::Error: std::fmt::Display,
        {
            self.state = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for state: {}", e));
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitOrderTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_closed_i_ds<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_closed_i_ds = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_closed_i_ds: {}",
                    e
                )
            });
            self
        }
        pub fn trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_id: {}", e));
            self
        }
        pub fn trade_opened_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_opened_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_opened_id: {}", e));
            self
        }
        pub fn trade_reduced_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_reduced_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_reduced_id: {}",
                    e
                )
            });
            self
        }
        pub fn trigger_condition<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitOrderTriggerCondition>>,
            T::Error: std::fmt::Display,
        {
            self.trigger_condition = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trigger_condition: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitOrderType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<TakeProfitOrder> for super::TakeProfitOrder {
        type Error = super::error::ConversionError;
        fn try_from(value: TakeProfitOrder) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                cancelled_time: value.cancelled_time?,
                cancelling_transaction_id: value.cancelling_transaction_id?,
                client_extensions: value.client_extensions?,
                client_trade_id: value.client_trade_id?,
                create_time: value.create_time?,
                filled_time: value.filled_time?,
                filling_transaction_id: value.filling_transaction_id?,
                gtd_time: value.gtd_time?,
                id: value.id?,
                price: value.price?,
                replaced_by_order_id: value.replaced_by_order_id?,
                replaces_order_id: value.replaces_order_id?,
                state: value.state?,
                time_in_force: value.time_in_force?,
                trade_closed_i_ds: value.trade_closed_i_ds?,
                trade_id: value.trade_id?,
                trade_opened_id: value.trade_opened_id?,
                trade_reduced_id: value.trade_reduced_id?,
                trigger_condition: value.trigger_condition?,
                type_: value.type_?,
            })
        }
    }

    impl From<super::TakeProfitOrder> for TakeProfitOrder {
        fn from(value: super::TakeProfitOrder) -> Self {
            Self {
                cancelled_time: Ok(value.cancelled_time),
                cancelling_transaction_id: Ok(value.cancelling_transaction_id),
                client_extensions: Ok(value.client_extensions),
                client_trade_id: Ok(value.client_trade_id),
                create_time: Ok(value.create_time),
                filled_time: Ok(value.filled_time),
                filling_transaction_id: Ok(value.filling_transaction_id),
                gtd_time: Ok(value.gtd_time),
                id: Ok(value.id),
                price: Ok(value.price),
                replaced_by_order_id: Ok(value.replaced_by_order_id),
                replaces_order_id: Ok(value.replaces_order_id),
                state: Ok(value.state),
                time_in_force: Ok(value.time_in_force),
                trade_closed_i_ds: Ok(value.trade_closed_i_ds),
                trade_id: Ok(value.trade_id),
                trade_opened_id: Ok(value.trade_opened_id),
                trade_reduced_id: Ok(value.trade_reduced_id),
                trigger_condition: Ok(value.trigger_condition),
                type_: Ok(value.type_),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct TakeProfitOrderRejectTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        client_trade_id: Result<Option<String>, String>,
        gtd_time: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        intended_replaces_order_id: Result<Option<String>, String>,
        order_fill_transaction_id: Result<Option<String>, String>,
        price: Result<Option<String>, String>,
        reason: Result<Option<super::TakeProfitOrderRejectTransactionReason>, String>,
        reject_reason: Result<Option<super::TakeProfitOrderRejectTransactionRejectReason>, String>,
        request_id: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
        time_in_force: Result<Option<super::TakeProfitOrderRejectTransactionTimeInForce>, String>,
        trade_id: Result<Option<String>, String>,
        trigger_condition:
            Result<Option<super::TakeProfitOrderRejectTransactionTriggerCondition>, String>,
        type_: Result<Option<super::TakeProfitOrderRejectTransactionType>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for TakeProfitOrderRejectTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                client_extensions: Ok(Default::default()),
                client_trade_id: Ok(Default::default()),
                gtd_time: Ok(Default::default()),
                id: Ok(Default::default()),
                intended_replaces_order_id: Ok(Default::default()),
                order_fill_transaction_id: Ok(Default::default()),
                price: Ok(Default::default()),
                reason: Ok(Default::default()),
                reject_reason: Ok(Default::default()),
                request_id: Ok(Default::default()),
                time: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_id: Ok(Default::default()),
                trigger_condition: Ok(Default::default()),
                type_: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl TakeProfitOrderRejectTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn client_trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.client_trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for client_trade_id: {}", e));
            self
        }
        pub fn gtd_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gtd_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for gtd_time: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn intended_replaces_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.intended_replaces_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for intended_replaces_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn order_fill_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.order_fill_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for order_fill_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitOrderRejectTransactionReason>>,
            T::Error: std::fmt::Display,
        {
            self.reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reason: {}", e));
            self
        }
        pub fn reject_reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitOrderRejectTransactionRejectReason>>,
            T::Error: std::fmt::Display,
        {
            self.reject_reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reject_reason: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitOrderRejectTransactionTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_id: {}", e));
            self
        }
        pub fn trigger_condition<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::TakeProfitOrderRejectTransactionTriggerCondition>,
            >,
            T::Error: std::fmt::Display,
        {
            self.trigger_condition = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trigger_condition: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitOrderRejectTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<TakeProfitOrderRejectTransaction>
        for super::TakeProfitOrderRejectTransaction
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: TakeProfitOrderRejectTransaction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                client_extensions: value.client_extensions?,
                client_trade_id: value.client_trade_id?,
                gtd_time: value.gtd_time?,
                id: value.id?,
                intended_replaces_order_id: value.intended_replaces_order_id?,
                order_fill_transaction_id: value.order_fill_transaction_id?,
                price: value.price?,
                reason: value.reason?,
                reject_reason: value.reject_reason?,
                request_id: value.request_id?,
                time: value.time?,
                time_in_force: value.time_in_force?,
                trade_id: value.trade_id?,
                trigger_condition: value.trigger_condition?,
                type_: value.type_?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::TakeProfitOrderRejectTransaction> for TakeProfitOrderRejectTransaction {
        fn from(value: super::TakeProfitOrderRejectTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                client_extensions: Ok(value.client_extensions),
                client_trade_id: Ok(value.client_trade_id),
                gtd_time: Ok(value.gtd_time),
                id: Ok(value.id),
                intended_replaces_order_id: Ok(value.intended_replaces_order_id),
                order_fill_transaction_id: Ok(value.order_fill_transaction_id),
                price: Ok(value.price),
                reason: Ok(value.reason),
                reject_reason: Ok(value.reject_reason),
                request_id: Ok(value.request_id),
                time: Ok(value.time),
                time_in_force: Ok(value.time_in_force),
                trade_id: Ok(value.trade_id),
                trigger_condition: Ok(value.trigger_condition),
                type_: Ok(value.type_),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct TakeProfitOrderRequest {
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        client_trade_id: Result<Option<String>, String>,
        gtd_time: Result<Option<String>, String>,
        price: Result<Option<String>, String>,
        time_in_force: Result<Option<super::TakeProfitOrderRequestTimeInForce>, String>,
        trade_id: Result<Option<String>, String>,
        trigger_condition: Result<Option<super::TakeProfitOrderRequestTriggerCondition>, String>,
        type_: Result<Option<super::TakeProfitOrderRequestType>, String>,
    }

    impl Default for TakeProfitOrderRequest {
        fn default() -> Self {
            Self {
                client_extensions: Ok(Default::default()),
                client_trade_id: Ok(Default::default()),
                gtd_time: Ok(Default::default()),
                price: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_id: Ok(Default::default()),
                trigger_condition: Ok(Default::default()),
                type_: Ok(Default::default()),
            }
        }
    }

    impl TakeProfitOrderRequest {
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn client_trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.client_trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for client_trade_id: {}", e));
            self
        }
        pub fn gtd_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gtd_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for gtd_time: {}", e));
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitOrderRequestTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_id: {}", e));
            self
        }
        pub fn trigger_condition<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitOrderRequestTriggerCondition>>,
            T::Error: std::fmt::Display,
        {
            self.trigger_condition = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trigger_condition: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitOrderRequestType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<TakeProfitOrderRequest> for super::TakeProfitOrderRequest {
        type Error = super::error::ConversionError;
        fn try_from(value: TakeProfitOrderRequest) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                client_extensions: value.client_extensions?,
                client_trade_id: value.client_trade_id?,
                gtd_time: value.gtd_time?,
                price: value.price?,
                time_in_force: value.time_in_force?,
                trade_id: value.trade_id?,
                trigger_condition: value.trigger_condition?,
                type_: value.type_?,
            })
        }
    }

    impl From<super::TakeProfitOrderRequest> for TakeProfitOrderRequest {
        fn from(value: super::TakeProfitOrderRequest) -> Self {
            Self {
                client_extensions: Ok(value.client_extensions),
                client_trade_id: Ok(value.client_trade_id),
                gtd_time: Ok(value.gtd_time),
                price: Ok(value.price),
                time_in_force: Ok(value.time_in_force),
                trade_id: Ok(value.trade_id),
                trigger_condition: Ok(value.trigger_condition),
                type_: Ok(value.type_),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct TakeProfitOrderTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        cancelling_transaction_id: Result<Option<String>, String>,
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        client_trade_id: Result<Option<String>, String>,
        gtd_time: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        order_fill_transaction_id: Result<Option<String>, String>,
        price: Result<Option<String>, String>,
        reason: Result<Option<super::TakeProfitOrderTransactionReason>, String>,
        replaces_order_id: Result<Option<String>, String>,
        request_id: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
        time_in_force: Result<Option<super::TakeProfitOrderTransactionTimeInForce>, String>,
        trade_id: Result<Option<String>, String>,
        trigger_condition:
            Result<Option<super::TakeProfitOrderTransactionTriggerCondition>, String>,
        type_: Result<Option<super::TakeProfitOrderTransactionType>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for TakeProfitOrderTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                cancelling_transaction_id: Ok(Default::default()),
                client_extensions: Ok(Default::default()),
                client_trade_id: Ok(Default::default()),
                gtd_time: Ok(Default::default()),
                id: Ok(Default::default()),
                order_fill_transaction_id: Ok(Default::default()),
                price: Ok(Default::default()),
                reason: Ok(Default::default()),
                replaces_order_id: Ok(Default::default()),
                request_id: Ok(Default::default()),
                time: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_id: Ok(Default::default()),
                trigger_condition: Ok(Default::default()),
                type_: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl TakeProfitOrderTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn cancelling_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.cancelling_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for cancelling_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn client_trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.client_trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for client_trade_id: {}", e));
            self
        }
        pub fn gtd_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gtd_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for gtd_time: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn order_fill_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.order_fill_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for order_fill_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitOrderTransactionReason>>,
            T::Error: std::fmt::Display,
        {
            self.reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reason: {}", e));
            self
        }
        pub fn replaces_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.replaces_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for replaces_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitOrderTransactionTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_id: {}", e));
            self
        }
        pub fn trigger_condition<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitOrderTransactionTriggerCondition>>,
            T::Error: std::fmt::Display,
        {
            self.trigger_condition = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trigger_condition: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitOrderTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<TakeProfitOrderTransaction> for super::TakeProfitOrderTransaction {
        type Error = super::error::ConversionError;
        fn try_from(
            value: TakeProfitOrderTransaction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                cancelling_transaction_id: value.cancelling_transaction_id?,
                client_extensions: value.client_extensions?,
                client_trade_id: value.client_trade_id?,
                gtd_time: value.gtd_time?,
                id: value.id?,
                order_fill_transaction_id: value.order_fill_transaction_id?,
                price: value.price?,
                reason: value.reason?,
                replaces_order_id: value.replaces_order_id?,
                request_id: value.request_id?,
                time: value.time?,
                time_in_force: value.time_in_force?,
                trade_id: value.trade_id?,
                trigger_condition: value.trigger_condition?,
                type_: value.type_?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::TakeProfitOrderTransaction> for TakeProfitOrderTransaction {
        fn from(value: super::TakeProfitOrderTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                cancelling_transaction_id: Ok(value.cancelling_transaction_id),
                client_extensions: Ok(value.client_extensions),
                client_trade_id: Ok(value.client_trade_id),
                gtd_time: Ok(value.gtd_time),
                id: Ok(value.id),
                order_fill_transaction_id: Ok(value.order_fill_transaction_id),
                price: Ok(value.price),
                reason: Ok(value.reason),
                replaces_order_id: Ok(value.replaces_order_id),
                request_id: Ok(value.request_id),
                time: Ok(value.time),
                time_in_force: Ok(value.time_in_force),
                trade_id: Ok(value.trade_id),
                trigger_condition: Ok(value.trigger_condition),
                type_: Ok(value.type_),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct Trade {
        average_close_price: Result<Option<String>, String>,
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        close_time: Result<Option<String>, String>,
        closing_transaction_i_ds: Result<Vec<String>, String>,
        current_units: Result<Option<String>, String>,
        financing: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        initial_margin_required: Result<Option<String>, String>,
        initial_units: Result<Option<String>, String>,
        instrument: Result<Option<String>, String>,
        margin_used: Result<Option<String>, String>,
        open_time: Result<Option<String>, String>,
        price: Result<Option<String>, String>,
        realized_pl: Result<Option<String>, String>,
        state: Result<Option<super::TradeState>, String>,
        stop_loss_order: Result<Option<super::StopLossOrder>, String>,
        take_profit_order: Result<Option<super::TakeProfitOrder>, String>,
        trailing_stop_loss_order: Result<Option<super::TrailingStopLossOrder>, String>,
        unrealized_pl: Result<Option<String>, String>,
    }

    impl Default for Trade {
        fn default() -> Self {
            Self {
                average_close_price: Ok(Default::default()),
                client_extensions: Ok(Default::default()),
                close_time: Ok(Default::default()),
                closing_transaction_i_ds: Ok(Default::default()),
                current_units: Ok(Default::default()),
                financing: Ok(Default::default()),
                id: Ok(Default::default()),
                initial_margin_required: Ok(Default::default()),
                initial_units: Ok(Default::default()),
                instrument: Ok(Default::default()),
                margin_used: Ok(Default::default()),
                open_time: Ok(Default::default()),
                price: Ok(Default::default()),
                realized_pl: Ok(Default::default()),
                state: Ok(Default::default()),
                stop_loss_order: Ok(Default::default()),
                take_profit_order: Ok(Default::default()),
                trailing_stop_loss_order: Ok(Default::default()),
                unrealized_pl: Ok(Default::default()),
            }
        }
    }

    impl Trade {
        pub fn average_close_price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.average_close_price = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for average_close_price: {}",
                    e
                )
            });
            self
        }
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn close_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.close_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for close_time: {}", e));
            self
        }
        pub fn closing_transaction_i_ds<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self.closing_transaction_i_ds = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for closing_transaction_i_ds: {}",
                    e
                )
            });
            self
        }
        pub fn current_units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.current_units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for current_units: {}", e));
            self
        }
        pub fn financing<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.financing = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for financing: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn initial_margin_required<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.initial_margin_required = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for initial_margin_required: {}",
                    e
                )
            });
            self
        }
        pub fn initial_units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.initial_units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for initial_units: {}", e));
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn margin_used<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_used = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for margin_used: {}", e));
            self
        }
        pub fn open_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.open_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for open_time: {}", e));
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn realized_pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.realized_pl = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for realized_pl: {}", e));
            self
        }
        pub fn state<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TradeState>>,
            T::Error: std::fmt::Display,
        {
            self.state = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for state: {}", e));
            self
        }
        pub fn stop_loss_order<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::StopLossOrder>>,
            T::Error: std::fmt::Display,
        {
            self.stop_loss_order = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for stop_loss_order: {}", e));
            self
        }
        pub fn take_profit_order<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TakeProfitOrder>>,
            T::Error: std::fmt::Display,
        {
            self.take_profit_order = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for take_profit_order: {}",
                    e
                )
            });
            self
        }
        pub fn trailing_stop_loss_order<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossOrder>>,
            T::Error: std::fmt::Display,
        {
            self.trailing_stop_loss_order = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trailing_stop_loss_order: {}",
                    e
                )
            });
            self
        }
        pub fn unrealized_pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.unrealized_pl = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for unrealized_pl: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<Trade> for super::Trade {
        type Error = super::error::ConversionError;
        fn try_from(value: Trade) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                average_close_price: value.average_close_price?,
                client_extensions: value.client_extensions?,
                close_time: value.close_time?,
                closing_transaction_i_ds: value.closing_transaction_i_ds?,
                current_units: value.current_units?,
                financing: value.financing?,
                id: value.id?,
                initial_margin_required: value.initial_margin_required?,
                initial_units: value.initial_units?,
                instrument: value.instrument?,
                margin_used: value.margin_used?,
                open_time: value.open_time?,
                price: value.price?,
                realized_pl: value.realized_pl?,
                state: value.state?,
                stop_loss_order: value.stop_loss_order?,
                take_profit_order: value.take_profit_order?,
                trailing_stop_loss_order: value.trailing_stop_loss_order?,
                unrealized_pl: value.unrealized_pl?,
            })
        }
    }

    impl From<super::Trade> for Trade {
        fn from(value: super::Trade) -> Self {
            Self {
                average_close_price: Ok(value.average_close_price),
                client_extensions: Ok(value.client_extensions),
                close_time: Ok(value.close_time),
                closing_transaction_i_ds: Ok(value.closing_transaction_i_ds),
                current_units: Ok(value.current_units),
                financing: Ok(value.financing),
                id: Ok(value.id),
                initial_margin_required: Ok(value.initial_margin_required),
                initial_units: Ok(value.initial_units),
                instrument: Ok(value.instrument),
                margin_used: Ok(value.margin_used),
                open_time: Ok(value.open_time),
                price: Ok(value.price),
                realized_pl: Ok(value.realized_pl),
                state: Ok(value.state),
                stop_loss_order: Ok(value.stop_loss_order),
                take_profit_order: Ok(value.take_profit_order),
                trailing_stop_loss_order: Ok(value.trailing_stop_loss_order),
                unrealized_pl: Ok(value.unrealized_pl),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct TradeClientExtensionsModifyRejectTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        client_trade_id: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        reject_reason:
            Result<Option<super::TradeClientExtensionsModifyRejectTransactionRejectReason>, String>,
        request_id: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
        trade_client_extensions_modify: Result<Option<super::ClientExtensions>, String>,
        trade_id: Result<Option<String>, String>,
        type_: Result<Option<super::TradeClientExtensionsModifyRejectTransactionType>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for TradeClientExtensionsModifyRejectTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                client_trade_id: Ok(Default::default()),
                id: Ok(Default::default()),
                reject_reason: Ok(Default::default()),
                request_id: Ok(Default::default()),
                time: Ok(Default::default()),
                trade_client_extensions_modify: Ok(Default::default()),
                trade_id: Ok(Default::default()),
                type_: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl TradeClientExtensionsModifyRejectTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn client_trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.client_trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for client_trade_id: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn reject_reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::TradeClientExtensionsModifyRejectTransactionRejectReason>,
            >,
            T::Error: std::fmt::Display,
        {
            self.reject_reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reject_reason: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn trade_client_extensions_modify<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.trade_client_extensions_modify = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_client_extensions_modify: {}",
                    e
                )
            });
            self
        }
        pub fn trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_id: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::TradeClientExtensionsModifyRejectTransactionType>,
            >,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<TradeClientExtensionsModifyRejectTransaction>
        for super::TradeClientExtensionsModifyRejectTransaction
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: TradeClientExtensionsModifyRejectTransaction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                client_trade_id: value.client_trade_id?,
                id: value.id?,
                reject_reason: value.reject_reason?,
                request_id: value.request_id?,
                time: value.time?,
                trade_client_extensions_modify: value.trade_client_extensions_modify?,
                trade_id: value.trade_id?,
                type_: value.type_?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::TradeClientExtensionsModifyRejectTransaction>
        for TradeClientExtensionsModifyRejectTransaction
    {
        fn from(value: super::TradeClientExtensionsModifyRejectTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                client_trade_id: Ok(value.client_trade_id),
                id: Ok(value.id),
                reject_reason: Ok(value.reject_reason),
                request_id: Ok(value.request_id),
                time: Ok(value.time),
                trade_client_extensions_modify: Ok(value.trade_client_extensions_modify),
                trade_id: Ok(value.trade_id),
                type_: Ok(value.type_),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct TradeClientExtensionsModifyTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        client_trade_id: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        request_id: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
        trade_client_extensions_modify: Result<Option<super::ClientExtensions>, String>,
        trade_id: Result<Option<String>, String>,
        type_: Result<Option<super::TradeClientExtensionsModifyTransactionType>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for TradeClientExtensionsModifyTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                client_trade_id: Ok(Default::default()),
                id: Ok(Default::default()),
                request_id: Ok(Default::default()),
                time: Ok(Default::default()),
                trade_client_extensions_modify: Ok(Default::default()),
                trade_id: Ok(Default::default()),
                type_: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl TradeClientExtensionsModifyTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn client_trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.client_trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for client_trade_id: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn trade_client_extensions_modify<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.trade_client_extensions_modify = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_client_extensions_modify: {}",
                    e
                )
            });
            self
        }
        pub fn trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_id: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TradeClientExtensionsModifyTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<TradeClientExtensionsModifyTransaction>
        for super::TradeClientExtensionsModifyTransaction
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: TradeClientExtensionsModifyTransaction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                client_trade_id: value.client_trade_id?,
                id: value.id?,
                request_id: value.request_id?,
                time: value.time?,
                trade_client_extensions_modify: value.trade_client_extensions_modify?,
                trade_id: value.trade_id?,
                type_: value.type_?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::TradeClientExtensionsModifyTransaction>
        for TradeClientExtensionsModifyTransaction
    {
        fn from(value: super::TradeClientExtensionsModifyTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                client_trade_id: Ok(value.client_trade_id),
                id: Ok(value.id),
                request_id: Ok(value.request_id),
                time: Ok(value.time),
                trade_client_extensions_modify: Ok(value.trade_client_extensions_modify),
                trade_id: Ok(value.trade_id),
                type_: Ok(value.type_),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct TradeOpen {
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        guaranteed_execution_fee: Result<Option<String>, String>,
        half_spread_cost: Result<Option<String>, String>,
        initial_margin_required: Result<Option<String>, String>,
        price: Result<Option<String>, String>,
        trade_id: Result<Option<String>, String>,
        units: Result<Option<String>, String>,
    }

    impl Default for TradeOpen {
        fn default() -> Self {
            Self {
                client_extensions: Ok(Default::default()),
                guaranteed_execution_fee: Ok(Default::default()),
                half_spread_cost: Ok(Default::default()),
                initial_margin_required: Ok(Default::default()),
                price: Ok(Default::default()),
                trade_id: Ok(Default::default()),
                units: Ok(Default::default()),
            }
        }
    }

    impl TradeOpen {
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn guaranteed_execution_fee<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.guaranteed_execution_fee = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for guaranteed_execution_fee: {}",
                    e
                )
            });
            self
        }
        pub fn half_spread_cost<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.half_spread_cost = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for half_spread_cost: {}",
                    e
                )
            });
            self
        }
        pub fn initial_margin_required<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.initial_margin_required = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for initial_margin_required: {}",
                    e
                )
            });
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_id: {}", e));
            self
        }
        pub fn units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for units: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<TradeOpen> for super::TradeOpen {
        type Error = super::error::ConversionError;
        fn try_from(value: TradeOpen) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                client_extensions: value.client_extensions?,
                guaranteed_execution_fee: value.guaranteed_execution_fee?,
                half_spread_cost: value.half_spread_cost?,
                initial_margin_required: value.initial_margin_required?,
                price: value.price?,
                trade_id: value.trade_id?,
                units: value.units?,
            })
        }
    }

    impl From<super::TradeOpen> for TradeOpen {
        fn from(value: super::TradeOpen) -> Self {
            Self {
                client_extensions: Ok(value.client_extensions),
                guaranteed_execution_fee: Ok(value.guaranteed_execution_fee),
                half_spread_cost: Ok(value.half_spread_cost),
                initial_margin_required: Ok(value.initial_margin_required),
                price: Ok(value.price),
                trade_id: Ok(value.trade_id),
                units: Ok(value.units),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct TradeReduce {
        financing: Result<Option<String>, String>,
        guaranteed_execution_fee: Result<Option<String>, String>,
        half_spread_cost: Result<Option<String>, String>,
        price: Result<Option<String>, String>,
        realized_pl: Result<Option<String>, String>,
        trade_id: Result<Option<String>, String>,
        units: Result<Option<String>, String>,
    }

    impl Default for TradeReduce {
        fn default() -> Self {
            Self {
                financing: Ok(Default::default()),
                guaranteed_execution_fee: Ok(Default::default()),
                half_spread_cost: Ok(Default::default()),
                price: Ok(Default::default()),
                realized_pl: Ok(Default::default()),
                trade_id: Ok(Default::default()),
                units: Ok(Default::default()),
            }
        }
    }

    impl TradeReduce {
        pub fn financing<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.financing = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for financing: {}", e));
            self
        }
        pub fn guaranteed_execution_fee<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.guaranteed_execution_fee = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for guaranteed_execution_fee: {}",
                    e
                )
            });
            self
        }
        pub fn half_spread_cost<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.half_spread_cost = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for half_spread_cost: {}",
                    e
                )
            });
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn realized_pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.realized_pl = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for realized_pl: {}", e));
            self
        }
        pub fn trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_id: {}", e));
            self
        }
        pub fn units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for units: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<TradeReduce> for super::TradeReduce {
        type Error = super::error::ConversionError;
        fn try_from(value: TradeReduce) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                financing: value.financing?,
                guaranteed_execution_fee: value.guaranteed_execution_fee?,
                half_spread_cost: value.half_spread_cost?,
                price: value.price?,
                realized_pl: value.realized_pl?,
                trade_id: value.trade_id?,
                units: value.units?,
            })
        }
    }

    impl From<super::TradeReduce> for TradeReduce {
        fn from(value: super::TradeReduce) -> Self {
            Self {
                financing: Ok(value.financing),
                guaranteed_execution_fee: Ok(value.guaranteed_execution_fee),
                half_spread_cost: Ok(value.half_spread_cost),
                price: Ok(value.price),
                realized_pl: Ok(value.realized_pl),
                trade_id: Ok(value.trade_id),
                units: Ok(value.units),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct TradeSummary {
        average_close_price: Result<Option<String>, String>,
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        close_time: Result<Option<String>, String>,
        closing_transaction_i_ds: Result<Vec<String>, String>,
        current_units: Result<Option<String>, String>,
        financing: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        initial_margin_required: Result<Option<String>, String>,
        initial_units: Result<Option<String>, String>,
        instrument: Result<Option<String>, String>,
        margin_used: Result<Option<String>, String>,
        open_time: Result<Option<String>, String>,
        price: Result<Option<String>, String>,
        realized_pl: Result<Option<String>, String>,
        state: Result<Option<super::TradeSummaryState>, String>,
        stop_loss_order_id: Result<Option<String>, String>,
        take_profit_order_id: Result<Option<String>, String>,
        trailing_stop_loss_order_id: Result<Option<String>, String>,
        unrealized_pl: Result<Option<String>, String>,
    }

    impl Default for TradeSummary {
        fn default() -> Self {
            Self {
                average_close_price: Ok(Default::default()),
                client_extensions: Ok(Default::default()),
                close_time: Ok(Default::default()),
                closing_transaction_i_ds: Ok(Default::default()),
                current_units: Ok(Default::default()),
                financing: Ok(Default::default()),
                id: Ok(Default::default()),
                initial_margin_required: Ok(Default::default()),
                initial_units: Ok(Default::default()),
                instrument: Ok(Default::default()),
                margin_used: Ok(Default::default()),
                open_time: Ok(Default::default()),
                price: Ok(Default::default()),
                realized_pl: Ok(Default::default()),
                state: Ok(Default::default()),
                stop_loss_order_id: Ok(Default::default()),
                take_profit_order_id: Ok(Default::default()),
                trailing_stop_loss_order_id: Ok(Default::default()),
                unrealized_pl: Ok(Default::default()),
            }
        }
    }

    impl TradeSummary {
        pub fn average_close_price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.average_close_price = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for average_close_price: {}",
                    e
                )
            });
            self
        }
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn close_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.close_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for close_time: {}", e));
            self
        }
        pub fn closing_transaction_i_ds<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self.closing_transaction_i_ds = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for closing_transaction_i_ds: {}",
                    e
                )
            });
            self
        }
        pub fn current_units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.current_units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for current_units: {}", e));
            self
        }
        pub fn financing<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.financing = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for financing: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn initial_margin_required<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.initial_margin_required = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for initial_margin_required: {}",
                    e
                )
            });
            self
        }
        pub fn initial_units<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.initial_units = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for initial_units: {}", e));
            self
        }
        pub fn instrument<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.instrument = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instrument: {}", e));
            self
        }
        pub fn margin_used<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.margin_used = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for margin_used: {}", e));
            self
        }
        pub fn open_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.open_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for open_time: {}", e));
            self
        }
        pub fn price<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.price = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for price: {}", e));
            self
        }
        pub fn realized_pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.realized_pl = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for realized_pl: {}", e));
            self
        }
        pub fn state<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TradeSummaryState>>,
            T::Error: std::fmt::Display,
        {
            self.state = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for state: {}", e));
            self
        }
        pub fn stop_loss_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.stop_loss_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for stop_loss_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn take_profit_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.take_profit_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for take_profit_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn trailing_stop_loss_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trailing_stop_loss_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trailing_stop_loss_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn unrealized_pl<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.unrealized_pl = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for unrealized_pl: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<TradeSummary> for super::TradeSummary {
        type Error = super::error::ConversionError;
        fn try_from(value: TradeSummary) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                average_close_price: value.average_close_price?,
                client_extensions: value.client_extensions?,
                close_time: value.close_time?,
                closing_transaction_i_ds: value.closing_transaction_i_ds?,
                current_units: value.current_units?,
                financing: value.financing?,
                id: value.id?,
                initial_margin_required: value.initial_margin_required?,
                initial_units: value.initial_units?,
                instrument: value.instrument?,
                margin_used: value.margin_used?,
                open_time: value.open_time?,
                price: value.price?,
                realized_pl: value.realized_pl?,
                state: value.state?,
                stop_loss_order_id: value.stop_loss_order_id?,
                take_profit_order_id: value.take_profit_order_id?,
                trailing_stop_loss_order_id: value.trailing_stop_loss_order_id?,
                unrealized_pl: value.unrealized_pl?,
            })
        }
    }

    impl From<super::TradeSummary> for TradeSummary {
        fn from(value: super::TradeSummary) -> Self {
            Self {
                average_close_price: Ok(value.average_close_price),
                client_extensions: Ok(value.client_extensions),
                close_time: Ok(value.close_time),
                closing_transaction_i_ds: Ok(value.closing_transaction_i_ds),
                current_units: Ok(value.current_units),
                financing: Ok(value.financing),
                id: Ok(value.id),
                initial_margin_required: Ok(value.initial_margin_required),
                initial_units: Ok(value.initial_units),
                instrument: Ok(value.instrument),
                margin_used: Ok(value.margin_used),
                open_time: Ok(value.open_time),
                price: Ok(value.price),
                realized_pl: Ok(value.realized_pl),
                state: Ok(value.state),
                stop_loss_order_id: Ok(value.stop_loss_order_id),
                take_profit_order_id: Ok(value.take_profit_order_id),
                trailing_stop_loss_order_id: Ok(value.trailing_stop_loss_order_id),
                unrealized_pl: Ok(value.unrealized_pl),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct TrailingStopLossDetails {
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        distance: Result<Option<String>, String>,
        gtd_time: Result<Option<String>, String>,
        time_in_force: Result<Option<super::TrailingStopLossDetailsTimeInForce>, String>,
    }

    impl Default for TrailingStopLossDetails {
        fn default() -> Self {
            Self {
                client_extensions: Ok(Default::default()),
                distance: Ok(Default::default()),
                gtd_time: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
            }
        }
    }

    impl TrailingStopLossDetails {
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn distance<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.distance = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for distance: {}", e));
            self
        }
        pub fn gtd_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gtd_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for gtd_time: {}", e));
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossDetailsTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<TrailingStopLossDetails> for super::TrailingStopLossDetails {
        type Error = super::error::ConversionError;
        fn try_from(value: TrailingStopLossDetails) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                client_extensions: value.client_extensions?,
                distance: value.distance?,
                gtd_time: value.gtd_time?,
                time_in_force: value.time_in_force?,
            })
        }
    }

    impl From<super::TrailingStopLossDetails> for TrailingStopLossDetails {
        fn from(value: super::TrailingStopLossDetails) -> Self {
            Self {
                client_extensions: Ok(value.client_extensions),
                distance: Ok(value.distance),
                gtd_time: Ok(value.gtd_time),
                time_in_force: Ok(value.time_in_force),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct TrailingStopLossOrder {
        cancelled_time: Result<Option<String>, String>,
        cancelling_transaction_id: Result<Option<String>, String>,
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        client_trade_id: Result<Option<String>, String>,
        create_time: Result<Option<String>, String>,
        distance: Result<Option<String>, String>,
        filled_time: Result<Option<String>, String>,
        filling_transaction_id: Result<Option<String>, String>,
        gtd_time: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        replaced_by_order_id: Result<Option<String>, String>,
        replaces_order_id: Result<Option<String>, String>,
        state: Result<Option<super::TrailingStopLossOrderState>, String>,
        time_in_force: Result<Option<super::TrailingStopLossOrderTimeInForce>, String>,
        trade_closed_i_ds: Result<Vec<String>, String>,
        trade_id: Result<Option<String>, String>,
        trade_opened_id: Result<Option<String>, String>,
        trade_reduced_id: Result<Option<String>, String>,
        trailing_stop_value: Result<Option<String>, String>,
        trigger_condition: Result<Option<super::TrailingStopLossOrderTriggerCondition>, String>,
        type_: Result<Option<super::TrailingStopLossOrderType>, String>,
    }

    impl Default for TrailingStopLossOrder {
        fn default() -> Self {
            Self {
                cancelled_time: Ok(Default::default()),
                cancelling_transaction_id: Ok(Default::default()),
                client_extensions: Ok(Default::default()),
                client_trade_id: Ok(Default::default()),
                create_time: Ok(Default::default()),
                distance: Ok(Default::default()),
                filled_time: Ok(Default::default()),
                filling_transaction_id: Ok(Default::default()),
                gtd_time: Ok(Default::default()),
                id: Ok(Default::default()),
                replaced_by_order_id: Ok(Default::default()),
                replaces_order_id: Ok(Default::default()),
                state: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_closed_i_ds: Ok(Default::default()),
                trade_id: Ok(Default::default()),
                trade_opened_id: Ok(Default::default()),
                trade_reduced_id: Ok(Default::default()),
                trailing_stop_value: Ok(Default::default()),
                trigger_condition: Ok(Default::default()),
                type_: Ok(Default::default()),
            }
        }
    }

    impl TrailingStopLossOrder {
        pub fn cancelled_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.cancelled_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for cancelled_time: {}", e));
            self
        }
        pub fn cancelling_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.cancelling_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for cancelling_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn client_trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.client_trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for client_trade_id: {}", e));
            self
        }
        pub fn create_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.create_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for create_time: {}", e));
            self
        }
        pub fn distance<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.distance = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for distance: {}", e));
            self
        }
        pub fn filled_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.filled_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for filled_time: {}", e));
            self
        }
        pub fn filling_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.filling_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for filling_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn gtd_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gtd_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for gtd_time: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn replaced_by_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.replaced_by_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for replaced_by_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn replaces_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.replaces_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for replaces_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn state<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossOrderState>>,
            T::Error: std::fmt::Display,
        {
            self.state = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for state: {}", e));
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossOrderTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_closed_i_ds<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Vec<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_closed_i_ds = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_closed_i_ds: {}",
                    e
                )
            });
            self
        }
        pub fn trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_id: {}", e));
            self
        }
        pub fn trade_opened_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_opened_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_opened_id: {}", e));
            self
        }
        pub fn trade_reduced_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_reduced_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trade_reduced_id: {}",
                    e
                )
            });
            self
        }
        pub fn trailing_stop_value<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trailing_stop_value = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trailing_stop_value: {}",
                    e
                )
            });
            self
        }
        pub fn trigger_condition<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossOrderTriggerCondition>>,
            T::Error: std::fmt::Display,
        {
            self.trigger_condition = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trigger_condition: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossOrderType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<TrailingStopLossOrder> for super::TrailingStopLossOrder {
        type Error = super::error::ConversionError;
        fn try_from(value: TrailingStopLossOrder) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                cancelled_time: value.cancelled_time?,
                cancelling_transaction_id: value.cancelling_transaction_id?,
                client_extensions: value.client_extensions?,
                client_trade_id: value.client_trade_id?,
                create_time: value.create_time?,
                distance: value.distance?,
                filled_time: value.filled_time?,
                filling_transaction_id: value.filling_transaction_id?,
                gtd_time: value.gtd_time?,
                id: value.id?,
                replaced_by_order_id: value.replaced_by_order_id?,
                replaces_order_id: value.replaces_order_id?,
                state: value.state?,
                time_in_force: value.time_in_force?,
                trade_closed_i_ds: value.trade_closed_i_ds?,
                trade_id: value.trade_id?,
                trade_opened_id: value.trade_opened_id?,
                trade_reduced_id: value.trade_reduced_id?,
                trailing_stop_value: value.trailing_stop_value?,
                trigger_condition: value.trigger_condition?,
                type_: value.type_?,
            })
        }
    }

    impl From<super::TrailingStopLossOrder> for TrailingStopLossOrder {
        fn from(value: super::TrailingStopLossOrder) -> Self {
            Self {
                cancelled_time: Ok(value.cancelled_time),
                cancelling_transaction_id: Ok(value.cancelling_transaction_id),
                client_extensions: Ok(value.client_extensions),
                client_trade_id: Ok(value.client_trade_id),
                create_time: Ok(value.create_time),
                distance: Ok(value.distance),
                filled_time: Ok(value.filled_time),
                filling_transaction_id: Ok(value.filling_transaction_id),
                gtd_time: Ok(value.gtd_time),
                id: Ok(value.id),
                replaced_by_order_id: Ok(value.replaced_by_order_id),
                replaces_order_id: Ok(value.replaces_order_id),
                state: Ok(value.state),
                time_in_force: Ok(value.time_in_force),
                trade_closed_i_ds: Ok(value.trade_closed_i_ds),
                trade_id: Ok(value.trade_id),
                trade_opened_id: Ok(value.trade_opened_id),
                trade_reduced_id: Ok(value.trade_reduced_id),
                trailing_stop_value: Ok(value.trailing_stop_value),
                trigger_condition: Ok(value.trigger_condition),
                type_: Ok(value.type_),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct TrailingStopLossOrderRejectTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        client_trade_id: Result<Option<String>, String>,
        distance: Result<Option<String>, String>,
        gtd_time: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        intended_replaces_order_id: Result<Option<String>, String>,
        order_fill_transaction_id: Result<Option<String>, String>,
        reason: Result<Option<super::TrailingStopLossOrderRejectTransactionReason>, String>,
        reject_reason:
            Result<Option<super::TrailingStopLossOrderRejectTransactionRejectReason>, String>,
        request_id: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
        time_in_force:
            Result<Option<super::TrailingStopLossOrderRejectTransactionTimeInForce>, String>,
        trade_id: Result<Option<String>, String>,
        trigger_condition:
            Result<Option<super::TrailingStopLossOrderRejectTransactionTriggerCondition>, String>,
        type_: Result<Option<super::TrailingStopLossOrderRejectTransactionType>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for TrailingStopLossOrderRejectTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                client_extensions: Ok(Default::default()),
                client_trade_id: Ok(Default::default()),
                distance: Ok(Default::default()),
                gtd_time: Ok(Default::default()),
                id: Ok(Default::default()),
                intended_replaces_order_id: Ok(Default::default()),
                order_fill_transaction_id: Ok(Default::default()),
                reason: Ok(Default::default()),
                reject_reason: Ok(Default::default()),
                request_id: Ok(Default::default()),
                time: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_id: Ok(Default::default()),
                trigger_condition: Ok(Default::default()),
                type_: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl TrailingStopLossOrderRejectTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn client_trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.client_trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for client_trade_id: {}", e));
            self
        }
        pub fn distance<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.distance = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for distance: {}", e));
            self
        }
        pub fn gtd_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gtd_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for gtd_time: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn intended_replaces_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.intended_replaces_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for intended_replaces_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn order_fill_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.order_fill_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for order_fill_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossOrderRejectTransactionReason>>,
            T::Error: std::fmt::Display,
        {
            self.reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reason: {}", e));
            self
        }
        pub fn reject_reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::TrailingStopLossOrderRejectTransactionRejectReason>,
            >,
            T::Error: std::fmt::Display,
        {
            self.reject_reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reject_reason: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::TrailingStopLossOrderRejectTransactionTimeInForce>,
            >,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_id: {}", e));
            self
        }
        pub fn trigger_condition<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::TrailingStopLossOrderRejectTransactionTriggerCondition>,
            >,
            T::Error: std::fmt::Display,
        {
            self.trigger_condition = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trigger_condition: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossOrderRejectTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<TrailingStopLossOrderRejectTransaction>
        for super::TrailingStopLossOrderRejectTransaction
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: TrailingStopLossOrderRejectTransaction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                client_extensions: value.client_extensions?,
                client_trade_id: value.client_trade_id?,
                distance: value.distance?,
                gtd_time: value.gtd_time?,
                id: value.id?,
                intended_replaces_order_id: value.intended_replaces_order_id?,
                order_fill_transaction_id: value.order_fill_transaction_id?,
                reason: value.reason?,
                reject_reason: value.reject_reason?,
                request_id: value.request_id?,
                time: value.time?,
                time_in_force: value.time_in_force?,
                trade_id: value.trade_id?,
                trigger_condition: value.trigger_condition?,
                type_: value.type_?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::TrailingStopLossOrderRejectTransaction>
        for TrailingStopLossOrderRejectTransaction
    {
        fn from(value: super::TrailingStopLossOrderRejectTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                client_extensions: Ok(value.client_extensions),
                client_trade_id: Ok(value.client_trade_id),
                distance: Ok(value.distance),
                gtd_time: Ok(value.gtd_time),
                id: Ok(value.id),
                intended_replaces_order_id: Ok(value.intended_replaces_order_id),
                order_fill_transaction_id: Ok(value.order_fill_transaction_id),
                reason: Ok(value.reason),
                reject_reason: Ok(value.reject_reason),
                request_id: Ok(value.request_id),
                time: Ok(value.time),
                time_in_force: Ok(value.time_in_force),
                trade_id: Ok(value.trade_id),
                trigger_condition: Ok(value.trigger_condition),
                type_: Ok(value.type_),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct TrailingStopLossOrderRequest {
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        client_trade_id: Result<Option<String>, String>,
        distance: Result<Option<String>, String>,
        gtd_time: Result<Option<String>, String>,
        time_in_force: Result<Option<super::TrailingStopLossOrderRequestTimeInForce>, String>,
        trade_id: Result<Option<String>, String>,
        trigger_condition:
            Result<Option<super::TrailingStopLossOrderRequestTriggerCondition>, String>,
        type_: Result<Option<super::TrailingStopLossOrderRequestType>, String>,
    }

    impl Default for TrailingStopLossOrderRequest {
        fn default() -> Self {
            Self {
                client_extensions: Ok(Default::default()),
                client_trade_id: Ok(Default::default()),
                distance: Ok(Default::default()),
                gtd_time: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_id: Ok(Default::default()),
                trigger_condition: Ok(Default::default()),
                type_: Ok(Default::default()),
            }
        }
    }

    impl TrailingStopLossOrderRequest {
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn client_trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.client_trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for client_trade_id: {}", e));
            self
        }
        pub fn distance<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.distance = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for distance: {}", e));
            self
        }
        pub fn gtd_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gtd_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for gtd_time: {}", e));
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossOrderRequestTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_id: {}", e));
            self
        }
        pub fn trigger_condition<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossOrderRequestTriggerCondition>>,
            T::Error: std::fmt::Display,
        {
            self.trigger_condition = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trigger_condition: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossOrderRequestType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<TrailingStopLossOrderRequest> for super::TrailingStopLossOrderRequest {
        type Error = super::error::ConversionError;
        fn try_from(
            value: TrailingStopLossOrderRequest,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                client_extensions: value.client_extensions?,
                client_trade_id: value.client_trade_id?,
                distance: value.distance?,
                gtd_time: value.gtd_time?,
                time_in_force: value.time_in_force?,
                trade_id: value.trade_id?,
                trigger_condition: value.trigger_condition?,
                type_: value.type_?,
            })
        }
    }

    impl From<super::TrailingStopLossOrderRequest> for TrailingStopLossOrderRequest {
        fn from(value: super::TrailingStopLossOrderRequest) -> Self {
            Self {
                client_extensions: Ok(value.client_extensions),
                client_trade_id: Ok(value.client_trade_id),
                distance: Ok(value.distance),
                gtd_time: Ok(value.gtd_time),
                time_in_force: Ok(value.time_in_force),
                trade_id: Ok(value.trade_id),
                trigger_condition: Ok(value.trigger_condition),
                type_: Ok(value.type_),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct TrailingStopLossOrderTransaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        cancelling_transaction_id: Result<Option<String>, String>,
        client_extensions: Result<Option<super::ClientExtensions>, String>,
        client_trade_id: Result<Option<String>, String>,
        distance: Result<Option<String>, String>,
        gtd_time: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        order_fill_transaction_id: Result<Option<String>, String>,
        reason: Result<Option<super::TrailingStopLossOrderTransactionReason>, String>,
        replaces_order_id: Result<Option<String>, String>,
        request_id: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
        time_in_force: Result<Option<super::TrailingStopLossOrderTransactionTimeInForce>, String>,
        trade_id: Result<Option<String>, String>,
        trigger_condition:
            Result<Option<super::TrailingStopLossOrderTransactionTriggerCondition>, String>,
        type_: Result<Option<super::TrailingStopLossOrderTransactionType>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for TrailingStopLossOrderTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                cancelling_transaction_id: Ok(Default::default()),
                client_extensions: Ok(Default::default()),
                client_trade_id: Ok(Default::default()),
                distance: Ok(Default::default()),
                gtd_time: Ok(Default::default()),
                id: Ok(Default::default()),
                order_fill_transaction_id: Ok(Default::default()),
                reason: Ok(Default::default()),
                replaces_order_id: Ok(Default::default()),
                request_id: Ok(Default::default()),
                time: Ok(Default::default()),
                time_in_force: Ok(Default::default()),
                trade_id: Ok(Default::default()),
                trigger_condition: Ok(Default::default()),
                type_: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl TrailingStopLossOrderTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn cancelling_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.cancelling_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for cancelling_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn client_extensions<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::ClientExtensions>>,
            T::Error: std::fmt::Display,
        {
            self.client_extensions = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for client_extensions: {}",
                    e
                )
            });
            self
        }
        pub fn client_trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.client_trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for client_trade_id: {}", e));
            self
        }
        pub fn distance<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.distance = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for distance: {}", e));
            self
        }
        pub fn gtd_time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.gtd_time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for gtd_time: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn order_fill_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.order_fill_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for order_fill_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossOrderTransactionReason>>,
            T::Error: std::fmt::Display,
        {
            self.reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reason: {}", e));
            self
        }
        pub fn replaces_order_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.replaces_order_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for replaces_order_id: {}",
                    e
                )
            });
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn time_in_force<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossOrderTransactionTimeInForce>>,
            T::Error: std::fmt::Display,
        {
            self.time_in_force = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time_in_force: {}", e));
            self
        }
        pub fn trade_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.trade_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for trade_id: {}", e));
            self
        }
        pub fn trigger_condition<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<
                Option<super::TrailingStopLossOrderTransactionTriggerCondition>,
            >,
            T::Error: std::fmt::Display,
        {
            self.trigger_condition = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for trigger_condition: {}",
                    e
                )
            });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TrailingStopLossOrderTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<TrailingStopLossOrderTransaction>
        for super::TrailingStopLossOrderTransaction
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: TrailingStopLossOrderTransaction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                cancelling_transaction_id: value.cancelling_transaction_id?,
                client_extensions: value.client_extensions?,
                client_trade_id: value.client_trade_id?,
                distance: value.distance?,
                gtd_time: value.gtd_time?,
                id: value.id?,
                order_fill_transaction_id: value.order_fill_transaction_id?,
                reason: value.reason?,
                replaces_order_id: value.replaces_order_id?,
                request_id: value.request_id?,
                time: value.time?,
                time_in_force: value.time_in_force?,
                trade_id: value.trade_id?,
                trigger_condition: value.trigger_condition?,
                type_: value.type_?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::TrailingStopLossOrderTransaction> for TrailingStopLossOrderTransaction {
        fn from(value: super::TrailingStopLossOrderTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                cancelling_transaction_id: Ok(value.cancelling_transaction_id),
                client_extensions: Ok(value.client_extensions),
                client_trade_id: Ok(value.client_trade_id),
                distance: Ok(value.distance),
                gtd_time: Ok(value.gtd_time),
                id: Ok(value.id),
                order_fill_transaction_id: Ok(value.order_fill_transaction_id),
                reason: Ok(value.reason),
                replaces_order_id: Ok(value.replaces_order_id),
                request_id: Ok(value.request_id),
                time: Ok(value.time),
                time_in_force: Ok(value.time_in_force),
                trade_id: Ok(value.trade_id),
                trigger_condition: Ok(value.trigger_condition),
                type_: Ok(value.type_),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct Transaction {
        account_id: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        id: Result<Option<String>, String>,
        request_id: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for Transaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                id: Ok(Default::default()),
                request_id: Ok(Default::default()),
                time: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl Transaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<Transaction> for super::Transaction {
        type Error = super::error::ConversionError;
        fn try_from(value: Transaction) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                batch_id: value.batch_id?,
                id: value.id?,
                request_id: value.request_id?,
                time: value.time?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::Transaction> for Transaction {
        fn from(value: super::Transaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                batch_id: Ok(value.batch_id),
                id: Ok(value.id),
                request_id: Ok(value.request_id),
                time: Ok(value.time),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct TransactionHeartbeat {
        last_transaction_id: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
        type_: Result<Option<String>, String>,
    }

    impl Default for TransactionHeartbeat {
        fn default() -> Self {
            Self {
                last_transaction_id: Ok(Default::default()),
                time: Ok(Default::default()),
                type_: Ok(Default::default()),
            }
        }
    }

    impl TransactionHeartbeat {
        pub fn last_transaction_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.last_transaction_id = value.try_into().map_err(|e| {
                format!(
                    "error converting supplied value for last_transaction_id: {}",
                    e
                )
            });
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<TransactionHeartbeat> for super::TransactionHeartbeat {
        type Error = super::error::ConversionError;
        fn try_from(value: TransactionHeartbeat) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                last_transaction_id: value.last_transaction_id?,
                time: value.time?,
                type_: value.type_?,
            })
        }
    }

    impl From<super::TransactionHeartbeat> for TransactionHeartbeat {
        fn from(value: super::TransactionHeartbeat) -> Self {
            Self {
                last_transaction_id: Ok(value.last_transaction_id),
                time: Ok(value.time),
                type_: Ok(value.type_),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct TransferFundsRejectTransaction {
        account_id: Result<Option<String>, String>,
        amount: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        comment: Result<Option<String>, String>,
        funding_reason: Result<Option<super::TransferFundsRejectTransactionFundingReason>, String>,
        id: Result<Option<String>, String>,
        reject_reason: Result<Option<super::TransferFundsRejectTransactionRejectReason>, String>,
        request_id: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
        type_: Result<Option<super::TransferFundsRejectTransactionType>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for TransferFundsRejectTransaction {
        fn default() -> Self {
            Self {
                account_id: Ok(Default::default()),
                amount: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                comment: Ok(Default::default()),
                funding_reason: Ok(Default::default()),
                id: Ok(Default::default()),
                reject_reason: Ok(Default::default()),
                request_id: Ok(Default::default()),
                time: Ok(Default::default()),
                type_: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl TransferFundsRejectTransaction {
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn amount<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.amount = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for amount: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.comment = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for comment: {}", e));
            self
        }
        pub fn funding_reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TransferFundsRejectTransactionFundingReason>>,
            T::Error: std::fmt::Display,
        {
            self.funding_reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for funding_reason: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn reject_reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TransferFundsRejectTransactionRejectReason>>,
            T::Error: std::fmt::Display,
        {
            self.reject_reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reject_reason: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TransferFundsRejectTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<TransferFundsRejectTransaction>
        for super::TransferFundsRejectTransaction
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: TransferFundsRejectTransaction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_id: value.account_id?,
                amount: value.amount?,
                batch_id: value.batch_id?,
                comment: value.comment?,
                funding_reason: value.funding_reason?,
                id: value.id?,
                reject_reason: value.reject_reason?,
                request_id: value.request_id?,
                time: value.time?,
                type_: value.type_?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::TransferFundsRejectTransaction> for TransferFundsRejectTransaction {
        fn from(value: super::TransferFundsRejectTransaction) -> Self {
            Self {
                account_id: Ok(value.account_id),
                amount: Ok(value.amount),
                batch_id: Ok(value.batch_id),
                comment: Ok(value.comment),
                funding_reason: Ok(value.funding_reason),
                id: Ok(value.id),
                reject_reason: Ok(value.reject_reason),
                request_id: Ok(value.request_id),
                time: Ok(value.time),
                type_: Ok(value.type_),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct TransferFundsTransaction {
        account_balance: Result<Option<String>, String>,
        account_id: Result<Option<String>, String>,
        amount: Result<Option<String>, String>,
        batch_id: Result<Option<String>, String>,
        comment: Result<Option<String>, String>,
        funding_reason: Result<Option<super::TransferFundsTransactionFundingReason>, String>,
        id: Result<Option<String>, String>,
        request_id: Result<Option<String>, String>,
        time: Result<Option<String>, String>,
        type_: Result<Option<super::TransferFundsTransactionType>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for TransferFundsTransaction {
        fn default() -> Self {
            Self {
                account_balance: Ok(Default::default()),
                account_id: Ok(Default::default()),
                amount: Ok(Default::default()),
                batch_id: Ok(Default::default()),
                comment: Ok(Default::default()),
                funding_reason: Ok(Default::default()),
                id: Ok(Default::default()),
                request_id: Ok(Default::default()),
                time: Ok(Default::default()),
                type_: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl TransferFundsTransaction {
        pub fn account_balance<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_balance = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_balance: {}", e));
            self
        }
        pub fn account_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.account_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for account_id: {}", e));
            self
        }
        pub fn amount<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.amount = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for amount: {}", e));
            self
        }
        pub fn batch_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.batch_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for batch_id: {}", e));
            self
        }
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.comment = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for comment: {}", e));
            self
        }
        pub fn funding_reason<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TransferFundsTransactionFundingReason>>,
            T::Error: std::fmt::Display,
        {
            self.funding_reason = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for funding_reason: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn request_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.request_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request_id: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::TransferFundsTransactionType>>,
            T::Error: std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<TransferFundsTransaction> for super::TransferFundsTransaction {
        type Error = super::error::ConversionError;
        fn try_from(
            value: TransferFundsTransaction,
        ) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                account_balance: value.account_balance?,
                account_id: value.account_id?,
                amount: value.amount?,
                batch_id: value.batch_id?,
                comment: value.comment?,
                funding_reason: value.funding_reason?,
                id: value.id?,
                request_id: value.request_id?,
                time: value.time?,
                type_: value.type_?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::TransferFundsTransaction> for TransferFundsTransaction {
        fn from(value: super::TransferFundsTransaction) -> Self {
            Self {
                account_balance: Ok(value.account_balance),
                account_id: Ok(value.account_id),
                amount: Ok(value.amount),
                batch_id: Ok(value.batch_id),
                comment: Ok(value.comment),
                funding_reason: Ok(value.funding_reason),
                id: Ok(value.id),
                request_id: Ok(value.request_id),
                time: Ok(value.time),
                type_: Ok(value.type_),
                user_id: Ok(value.user_id),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct UnitsAvailable {
        default: Result<Option<super::UnitsAvailableDetails>, String>,
        open_only: Result<Option<super::UnitsAvailableDetails>, String>,
        reduce_first: Result<Option<super::UnitsAvailableDetails>, String>,
        reduce_only: Result<Option<super::UnitsAvailableDetails>, String>,
    }

    impl Default for UnitsAvailable {
        fn default() -> Self {
            Self {
                default: Ok(Default::default()),
                open_only: Ok(Default::default()),
                reduce_first: Ok(Default::default()),
                reduce_only: Ok(Default::default()),
            }
        }
    }

    impl UnitsAvailable {
        pub fn default<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::UnitsAvailableDetails>>,
            T::Error: std::fmt::Display,
        {
            self.default = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for default: {}", e));
            self
        }
        pub fn open_only<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::UnitsAvailableDetails>>,
            T::Error: std::fmt::Display,
        {
            self.open_only = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for open_only: {}", e));
            self
        }
        pub fn reduce_first<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::UnitsAvailableDetails>>,
            T::Error: std::fmt::Display,
        {
            self.reduce_first = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reduce_first: {}", e));
            self
        }
        pub fn reduce_only<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<super::UnitsAvailableDetails>>,
            T::Error: std::fmt::Display,
        {
            self.reduce_only = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for reduce_only: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<UnitsAvailable> for super::UnitsAvailable {
        type Error = super::error::ConversionError;
        fn try_from(value: UnitsAvailable) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                default: value.default?,
                open_only: value.open_only?,
                reduce_first: value.reduce_first?,
                reduce_only: value.reduce_only?,
            })
        }
    }

    impl From<super::UnitsAvailable> for UnitsAvailable {
        fn from(value: super::UnitsAvailable) -> Self {
            Self {
                default: Ok(value.default),
                open_only: Ok(value.open_only),
                reduce_first: Ok(value.reduce_first),
                reduce_only: Ok(value.reduce_only),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct UnitsAvailableDetails {
        long: Result<Option<String>, String>,
        short: Result<Option<String>, String>,
    }

    impl Default for UnitsAvailableDetails {
        fn default() -> Self {
            Self {
                long: Ok(Default::default()),
                short: Ok(Default::default()),
            }
        }
    }

    impl UnitsAvailableDetails {
        pub fn long<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.long = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for long: {}", e));
            self
        }
        pub fn short<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.short = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for short: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<UnitsAvailableDetails> for super::UnitsAvailableDetails {
        type Error = super::error::ConversionError;
        fn try_from(value: UnitsAvailableDetails) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                long: value.long?,
                short: value.short?,
            })
        }
    }

    impl From<super::UnitsAvailableDetails> for UnitsAvailableDetails {
        fn from(value: super::UnitsAvailableDetails) -> Self {
            Self {
                long: Ok(value.long),
                short: Ok(value.short),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct UserInfo {
        country: Result<Option<String>, String>,
        email_address: Result<Option<String>, String>,
        user_id: Result<Option<i64>, String>,
        username: Result<Option<String>, String>,
    }

    impl Default for UserInfo {
        fn default() -> Self {
            Self {
                country: Ok(Default::default()),
                email_address: Ok(Default::default()),
                user_id: Ok(Default::default()),
                username: Ok(Default::default()),
            }
        }
    }

    impl UserInfo {
        pub fn country<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.country = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for country: {}", e));
            self
        }
        pub fn email_address<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.email_address = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for email_address: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
        pub fn username<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.username = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for username: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<UserInfo> for super::UserInfo {
        type Error = super::error::ConversionError;
        fn try_from(value: UserInfo) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                country: value.country?,
                email_address: value.email_address?,
                user_id: value.user_id?,
                username: value.username?,
            })
        }
    }

    impl From<super::UserInfo> for UserInfo {
        fn from(value: super::UserInfo) -> Self {
            Self {
                country: Ok(value.country),
                email_address: Ok(value.email_address),
                user_id: Ok(value.user_id),
                username: Ok(value.username),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct UserInfoExternal {
        country: Result<Option<String>, String>,
        fifo: Result<Option<bool>, String>,
        user_id: Result<Option<i64>, String>,
    }

    impl Default for UserInfoExternal {
        fn default() -> Self {
            Self {
                country: Ok(Default::default()),
                fifo: Ok(Default::default()),
                user_id: Ok(Default::default()),
            }
        }
    }

    impl UserInfoExternal {
        pub fn country<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<String>>,
            T::Error: std::fmt::Display,
        {
            self.country = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for country: {}", e));
            self
        }
        pub fn fifo<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<bool>>,
            T::Error: std::fmt::Display,
        {
            self.fifo = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for fifo: {}", e));
            self
        }
        pub fn user_id<T>(mut self, value: T) -> Self
        where
            T: std::convert::TryInto<Option<i64>>,
            T::Error: std::fmt::Display,
        {
            self.user_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for user_id: {}", e));
            self
        }
    }

    impl std::convert::TryFrom<UserInfoExternal> for super::UserInfoExternal {
        type Error = super::error::ConversionError;
        fn try_from(value: UserInfoExternal) -> Result<Self, super::error::ConversionError> {
            Ok(Self {
                country: value.country?,
                fifo: value.fifo?,
                user_id: value.user_id?,
            })
        }
    }

    impl From<super::UserInfoExternal> for UserInfoExternal {
        fn from(value: super::UserInfoExternal) -> Self {
            Self {
                country: Ok(value.country),
                fifo: Ok(value.fifo),
                user_id: Ok(value.user_id),
            }
        }
    }
}
